mark2: if(j>=n) goto mark3;$/$\sum_{i=0}^{n-2}(n-i)=(n+2)(n-1)/2$次

if(b[j]<b[k]) k=j;$/$\sum_{i=0}^{n-2}(n-i-1)=n(n-1)/2$次

j++;$/$n(n-1)/2$次

goto mark2;$/$n(n-1)/2$次

mark3: x=b[i];$/$n-1$次

b[i]=b[k];$/$n-1$次

b[k]=x;$/$n-1$次

i++;$/$n-1$次

goto mark1;$/$n-1$次

mark4: ;

把分解后的每一条简单语句的执行次数加起来，就得到了它所包含的简单操作的次数。算法 1-3 的时间复杂度为：$f(n)=2n^2+7n-7$从以上分析可以看出，一个算法的时间复杂度的计算是相当繁琐的，特别对于较复杂的算法更是如此。实际上，一般也没有必要精确地计算出算法的时间复杂度，只要大致计算出相应的数量级 (order) 即可。下面接着讨论时间复杂度$f(n)$的数量级表示。

设$f(n)$的一个辅助函数为$g(n)$，定义为当$n$大于等于某一足够大的正整数$n_0$时，存在着两个正的常数 A 和 B（其中 A≤B），使得 A≤$\frac{f(n)}{g(n)}$≤B 均成立，则称$g(n)$是$f(n)$的同数量级函数。把$f(n)$表示成数量级的形式为：$f(n)=O(g(n))$其中，大写字母 O 为英文 order（即数量级）一词的第 1 个字母。这种表示的意思是指$g(n)$同$f(n)$只相差一个常数倍。

例如，在算法 1-1 中，当$n≥1$（即取$n_0$为 1）时，$4≤\frac{4n+4}{n}≤8$均成立，则$g(n)=n$；在算法 1-2 中，当$n≥2$（即取$n_0$为 2）时，$4≤\frac{4n^2+5n+2}{n^2}≤7$均成立，则$g(n)=n^2$；对于算法 1-3，当$n≥3$（即取$n_0$为 3）时，$2≤\frac{2n^2+7n-7}{n^2}≤4$均成立，则$g(n)$也等于$n^2$。由此不难发现，当$f(n)$是$n$的多项式时，$g(n)$则为$f(n)$的最高次幂，它与$f(n)$中的其余项和最高次幂的系数都无关。若把算法 1-1、算法 1-2 和算法 1-3 的时间复杂度分别用数量级的形式表示，则分别为$O(n)$、$O(n^2)$和$O(n^2)$。

算法的时间复杂度采用数量级的形式表示后，将给求一个算法的$f(n)$带来很大方便，这时只需要分析影响一个算法时间复杂度的主要部分即可，不必对每一步都进行详细的分析；同时，对主要部分的分析也可简化，一般只要分析清楚循环体内简单操作的执行次数或递归函数的调用次数即可。例如，对于算法 1-1，只要根据 for 循环中的循环体被执行的次数$n$，就可求出其时间复杂度为$O(n)$；对于算法 1-2，只要弄清楚双重循环内赋值操作的执行次数为$n^2$，就可求出其时间复杂度为$O(n^2)$；对于算法 1-3，只要能够求出内层 for 循

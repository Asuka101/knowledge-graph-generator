if(n==1) cout<<a<<"->"<<c<<endl;
//当多于一个盘子时, 向下递归
else {
    //首先把$n-1$个盘子由值参 a 所表示的柱子搬到由值参 b 所表示
    //的柱子上, 用值参 c 所表示的柱子作为过渡
    Hanoi(n-1,a,c,b);
    //把由值参 a 所表示的柱子上的最后一个盘子搬到由值参 c 所
    //表示的柱子上
    cout<<a<<"->"<<c<<endl;
    //最后把$n-1$个盘子由值参 b 所表示的柱子搬到由值参 c 所表示
    //的柱子上, 用值参 a 所表示的柱子作为过渡
    Hanoi(n-1,b,a,c);
}

采用 Hanoi(3,1,2,3) 去调用该递归函数，则得到的整个递归调用关系，如图 4-9 所示，
它是一棵树结构，每个树叶结点下面的输出是执行 if (n==1) 子句中输出语句的结果，每个
树枝结点下的输出是执行 else 子句中输出语句的结果。其中函数名简记为 H。

图 4-9 执行 Hanoi(3,1,2,3) 时的递归调用关系树

调用上述递归算法时，若实参$n$的值为 1 则算法被执行 1 次，若值为 2 则被执行 3 次，
若为 3 则被执行 7 次，以此类推，总之被执行$2^n-1$次。所以此算法的时间复杂度为$O(2^n)$。
算法在执行时系统需要自动建立工作栈，栈的深度等于对应递归调用关系树的深度（即层
数），该深度等于$n$。所以此算法的空间复杂度为$O(n)$。

若采用 Hanoi(4,1,2,3) 调用上述递归函数，则得到的输出结果如下，其中为了节省篇幅把换行换成了空格。

1→2 1→3 2→3 1→2 3→1 3→2 1→3 2→1 2→3 1→2 3→1 2→3 1→3 2→1 2→3

4.7 队列

4.7.1 队列的定义

队列 (queue) 简称队，它也是一种运算受限的线性表，其限制是仅允许在表的一端进

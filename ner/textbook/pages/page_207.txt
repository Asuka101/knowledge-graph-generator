树由根结点、左子树和右子树所组成，因此，遍历一棵非空二叉树的问题可分解为3个子问题：访问根结点、遍历左子树和遍历右子树。若分别用D、L和R表示上述3个子问题，则有DLR、LDR、LRD、DRL、RDL、RLD等6种次序的遍历方案。其中前3种方案都是先遍历左子树，后遍历右子树，而后3种则相反，都是先遍历右子树，后遍历左子树，由于二者对称，故我们只讨论前3种次序的遍历方案。熟悉了前3种，后3种也就迎刃而解了。

在遍历方案DLR中，因为访问根结点的操作在遍历左、右子树之前，故称之为前序（preorder）遍历或先根遍历。类似地，在LDR方案中，访问根结点的操作在遍历左子树之后和遍历右子树之前，故称之为中序（inorder）遍历或中根遍历；在LRD方案中，访问根结点的操作在遍历左、右子树之后，故称之为后序（postorder）遍历或后根遍历。显然，遍历左、右子树的问题仍然是遍历二叉树的问题，当二叉树为空时递归结束，所以很容易给出这3种遍历的递归算法。

1. 前序遍历算法

void PreOrder(BTreeNode* BT)
{
    if (BT != NULL) {
        cout << BT->data << ' '; //访问根结点
        PreOrder(BT->left);      //前序遍历左子树
        PreOrder(BT->right);     //前序遍历右子树
    }
}

2. 中序遍历算法

void InOrder(BTreeNode* BT)
{
    if (BT != NULL) {
        InOrder(BT->left);       //中序遍历左子树
        cout << BT->data << ' '; //访问根结点
        InOrder(BT->right);      //中序遍历右子树
    }
}

3. 后序遍历算法

void PostOrder(BTreeNode* BT)
{
    if (BT != NULL) {
        PostOrder(BT->left);     //后序遍历左子树
        PostOrder(BT->right);    //后序遍历右子树
        cout << BT->data << ' '; //访问根结点
    }
}

在3种遍历算法中，访问根结点的操作可视具体应用情况而定，这里暂以打印根结点的值代之。当然若结点的值为用户定义的记录类型，则还必须依次输出结点值对象中的每个域的值。

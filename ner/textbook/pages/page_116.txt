item=S.set[i];\nreturn true;\n}\nelse return false;\n}\n\n8. 修改集合中的一个指定元素\n\n此算法与查找算法类似, 需要首先在集合中顺序查找待修改的元素, 即关键字等于$item$关键字的元素, 若找到相应元素则用$item$的完整值修改这个元素, 使它具有$item$的值, 并返回真; 若未找到则无法修改, 返回假表示修改失败。\n\nbool ModifySet(Set& S, const ElemType& item)\n{\n    for(int i=0; i<S.len; i++)\n        if(S.set[i]==item) break;\n    if(i<S.len) {\n        S.set[i]=item;\n        return true;\n    }\n    else return false;\n}\n\n9. 向集合插入一个元素\n\n此算法包含如下5个步骤。\n(1) 顺序查找集合中是否存在值为待插值$item$的元素, 若存在则不能插入, 返回假, 因为集合中不允许存在重复的元素。\n(2) 检查集合空间是否用完, 若是则动态重分配, 增加存储空间。\n(3) 把$item$值插入到表尾 (即最后一个集合元素的后面空位置) 上。\n(4) 集合长度增 1 。\n(5) 返回真表示插入成功。\n对应的算法描述如下。\n\nbool InsertSet(Set& S, ElemType item)   //向集合插入一个元素\n{\n    int i;\n    for(i=0; i<S.len; i++)                  //元素已存在, 返回假表示不用插入\n        if(S.set[i]==item) return false;\n    if(S.len==S.MaxSize) {                 //若集合存储空间用完, 则重新分配较大空间\n        int k=sizeof(ElemType);             //计算每个元素存储空间的长度\n        S.set=(ElemType*)realloc(S.set, 2*S.MaxSize*k);\n        //集合动态存储空间扩展为原来的 2 倍, 原内容不变\n        if(S.set==NULL) {\n            cout<<"动态可分配的存储空间用完,退出运行!"<<endl;\n            exit(1);\n

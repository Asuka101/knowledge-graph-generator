其中, 对于$f_1$中的 105 个原始数据记录, 依次按 10 个一组在数组中排成初始归并段, 并交替写入到$f_2$和$f_3$文件中; 接着把$f_2$和$f_3$中各自第 1 个归并段归并到$f_4$文件中, 把$f_2$和$f_3$中各自第 2 个归并段归并到$f_5$文件中, 把$f_2$和$f_3$中各自第 3 个归并段归并到$f_4$文件中, 以此类推; 再接着把$f_4$和$f_5$中各自第 1 个归并段归并到$f_2$文件中, 把$f_4$和$f_5$中各自第 2 个 归并段归并到$f_3$文件中, 至此$f_2$中含有两个归并段, 其长度依次为 40 和 25,$f_3$中含有一个归并段, 其长度为 40 ; 由于$f_2$和$f_3$中的归并段长度 40 仍小于$f_2$文件的最初长度 55 , 所以仍需要归并, 接着在$f_4$中得到长度为 80 的一个归并段, 在$f_5$中得到长度为 25 的一个不足长度的归并段 (此趟归并长度为 80 ); 再接着要求最后归并到$f_2$和$f_3$中, 此次归并使$f_2$中的归并段长度为 105,$f_3$中的归并段长度为 0 ; 最后再把$f_2$和$f_3$归并到原始数据文件$f_1$中。

\section*{10.7 .2 外排序算法}

设数据文件中每个记录的长度用标识符$b$表示, 文件 A 中当前归并段的记录序号和记录个数分别用 sa 和 ca 表示, 文件 B 中当前归并段的记录序号和记录个数分别用 sb 和 cb 表示, 归并结果被写入文件 R 中, 则实现 A 和 B 中两个对应归并段 (有序子表) 归并到 R 的二路归并算法描述如下。

void FTTwoMerge(fstream &A, fstream &B, fstream &R,

int sa, int ca, int sb, int cb)$\{$//把文件 A 和 B 中对应位置上的两个有序表 (归并段) 归并到文件 R 中 //其中文件 A 中归并段的开始位置和长度分别为 sa 和 ca //文件 B 中归并段的开始位置和长度分别为 sb 和 cb int i,j;

//用 i 和 j 分别指示 A、B 中当前待处理的元素位置

ElemType a1,a2;

i=sa; j=sb;

//分别给 i 和 j 赋初值, 指向各自归并段的开始位置

A.seekg(i*b);

//移动文件 A 中的文件指针, 使之指向 i 位置的记录

B.seekg(j*b);

//移动文件 B 中的文件指针, 使之指向 j 位置的记录

bool ba=true, bb=true;

//当 ba 和 bb 为真时分别读取 A 和 B 中的下一记录

//两个有序归并段中同时存在未归并元素时的处理过程

while(i<sa+ca && j<sb+cb) {

//从文件 A 的归并段中读取一个记录到 a1 中

if(ba) A.read((char*) &a1, b);

//从文件 B 的归并段中读取一个记录到 a2 中

if(bb) B.read((char*) &a2, b);

//将 a1 和 a2 中排序码较小的记录写入到 R 文件中

if(a1.stn<=a2.stn) {

R.write((char*) &a1, b);

i++; ba=true; bb=false;

}

else {

R.write((char*) &a2, b);

j++; bb=true; ba=false;

}

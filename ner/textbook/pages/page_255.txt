parent->rtag=false; //置双亲的右线索标志域为假
parent->right=p; //新结点链接为双亲的右孩子
p->left=parent; //双亲结点成为新结点的前驱
}

利用 InsertThread1 算法建立一棵带线索的二叉搜索树的算法如下。

void CreateThread1(TTreeNode*&HBT, ElemType a[], int n)
//利用数组中的 n 个元素建立带线索的二叉搜索树的算法
{
    HBT=NULL;
    for(int i=0; i<n; i++)
        InsertThread1(HBT, a[i]);
}

\section*{6.4.2 利用线索进行遍历}

以中序线索为例来讨论这个问题。首先讨论一下如何在中序线索二叉树上寻找一个结点 p（即指针 p 所指向的结点）的中序后继结点，它分为如下两种情况。

(1) 若 p 结点的右线索标志域为真，则表明$p->right$为右线索，它直接指向 p 的中序后继结点。

(2) 若 p 的右线索标志域为假，则表明$p->right$指向右孩子结点，p 的中序后继结点必是其右子树中第一个中序遍历到的结点，因此从 p 的右孩子开始，沿左指针链往下查找，直到找到一个没有左孩子（即左线索标志域为 1）的结点为止，该结点是 p 的右子树中“最左下”的结点，它就是 p 的中序后继结点。如图 6-14所示，p 的中序后继结点是$R_k (k \geq 1)$，$R_k$可能是叶子结点，也可能是只含有右子树的单支结点；另外，若$k=1$，则表示 p 的右孩子$R_1$是 p 的中序后继结点。

(a) 二叉树表示

(b) 二叉链表表示

图 6-14 求中继后继结点示意图

根据以上分析，给出在中序线索二叉树上求结点 p 的中序后继的算法如下。

第6章 特殊二叉树特殊二叉树包括二叉搜索树堆哈夫曼树线索二叉树和平衡二叉树等它们都有着不同的应用本章将讨论特殊二叉树的定义结构和运算特点61 二叉搜索树611 二叉搜索树的定义二叉搜索树  又称二叉排序树  它或是一棵空树或者是一棵具有如下特性的非空二叉树1若它的左子树非空则左子树上所有结点的关键字均小于根结点的关键字2若它的右子树非空则右子树上所有结点的关键字均大于若允许具有相同的关键字的结点存在则大于等于根结点的关键字3左右子树本身又各是一棵二叉搜索树在二叉搜索树中当每个结点的元素类型为简单类型时则结点的关键字就是该结点的值当每个结点的元素类型为记录类型时则结点的关键字为该结点的某一个域的值如当元素的类型为整型时则结点的关键字就是该结点的值即整数当元素的类型为学生记录类型时则每个学生的学号即记录中的一个域就是相应结点的关键字在算法描述中以结点的值的比较作为其关键字的比较实际情况可能进行的是关键字域的比较若在语言环境下运行可通过关系操作符的重载使其真正比较的是记录的关键字由二叉搜索树的定义可知在一棵非空的二叉搜索树中其结点的关键字是按照左子树根和右子树有序的所以对它进行中序遍历得到的结点序列必然是一个有序序列如图 61 所示是一棵二叉搜索树树中每个结点的关键字都大于它的左子树中所有结点的关键字而小于它的右子树中所有结点的关键字对此树进行中序遍历得到的结点序列为12 15 18 23 26 30 52 63 74可见此序列是一个有序序列05图 61 二叉搜索树612 二叉搜索树的抽象数据类型二叉搜索树的抽象数据类型中的数据部分是一棵二叉搜索树它可以具有同一般二叉树一样的任何存储结构操作部分除了已经讨论过的对一般二叉树的操作外还具有对二叉搜索树的一些常用操作即搜索查找更新插入和删除元素的操作假定二叉搜索树中的结点类型为 指向二叉搜索树的树根结点的指针为 则对二叉搜索树  的查找更新插入和删除元素的操作声明如下           查找函数  从二叉搜索树  中查找等于给定值  的元素若查找成功则返回 并由  带回该元素的值否则返回 更新函数  从二叉搜索树  中查找等于给定值  的元素若查找成功则用  的值更新该元素并返回 否则返回 插入函数  向二叉搜索树  中插入一个元素 使得插入后仍保持为一棵二叉搜索树删除函数  从二叉搜索树中删除等于给定值  的结点若删除成功则返回 否则返回 61 3 二叉搜索树的运算1 查找根据二叉搜索树的定义查找等于给定值  的元素时若二叉搜索树为空则表明查找失败应返回假否则若  等于当前树根结点的值则表明查找成功应由引用参数  带回根结点的值并返回真若  小于根结点的值则继续在根的左子树中查找若  大于根结点的值则继续在根的右子树中查找这是一个递归查找过程其递归算法描述如下  从二叉搜索树中查找等于给定值  的元素       查找失败返回假               若查找成功则带回元素值并返回真                                            向左子树继续查找                       向右子树继续查找                  由于此递归算法中的递归调用属于末尾递归的调用即递归调用语句是函数体中最后一条可执行语句每次递归调用返回后不执行任何语句又返回到上一层因此原先保存在数据堆栈中的信息都是没有用处的所以为了避免无效花费在进出数据栈操作上的时间和使用数据栈的空间相应的非递归算法如下 1   二叉搜索树查找的非递归算法                                                                从图 61 所示的二叉搜索树中查找关键字为 23 的元素时 首先用 23 同根结点 30 进行比较 因为2330 所以向 30 的左子树继续查找 再用 23 同当前根结点 15 进行比较 因为2315 所以向 15 的右子树继续查找 再用 23 同当前根结点 23 进行比较 因为相等所以由  带回该结点的值并返回真 整个查找过程就此结束若从图 61 中查找关键字为 48 的元素时 其查找过程为 首先用 48 同根结点 30 进行比较 因为4830 所以向 30 的右子树继续查找 再用 48 同当前根结点 52 进行比较 因为4852 所以向 52 的左子树继续查找 此时左子树为空 所以返回假 表明查找失败 整个查找过程就此结束在二叉搜索树上进行查找的过程中 给定值  同树中结点比较的次数最少为一次 即树根结点就是待查的结点 最多为树的深度 所以平均查找次数要小于等于树的深度若二叉搜索树是一棵理想平衡树或接近理想平衡树 则进行查找的时间复杂度为  若退化为一棵单支树最极端和最差的情况则其时间复杂度为对于一般情况 其时间复杂度可大致看作 因此在二叉搜索树上查找比在集合或线性表上进行顺序查找的时间复杂度要好得多 这正是构造二叉搜索树的优势所在二叉搜索树查找的递归算法的空间复杂度平均情况为  最差情况为 非递归算法的空间复杂度为12 更新二叉搜索树的更新算法与查找算法基本相同 区别仅有两点 一是在更新算法中当查找到待更新的元素时 应将  的值赋给该元素 而在查找算法中是将该元素的值赋给  带回 二是在更新算法中参数  可以为变参 即引用参数 也可以为值参 并且在参数说明的前面可以加或不加常量标识符  而在查找算法中参数  只能为变参 并且不能加常量标识符 请同学们编写此更新算法3 插入根据二叉搜索树的定义 向二叉搜索树中插入元素  的过程为 若二叉树为空 则由  元素生成的新结点将作为根结点插入 否则 若  小于根结点 则将新结点插入到根的左子树上 若  大于等于 若不允许具有相同值的结点存在 则对等于情况应作单独处理根结点则将新结点插入到根的右子树上显然插入过程是递归的对应的递归算法描述如下                     把按照  元素生成的新结点链接到已找到的插入位置                                                                  向左子树中插入元素                                       向右子树中插入元素此算法中的树根指针参数  必须说明为引用因为当它为空时需要由它带回树根指针或者在递归时由它提供新插入结点的链接位置同一叉搜索树的递归查找算法一样此算法也属于末尾递归的调用所以为了消除末尾递归减少算法运行的时间和空间也可编写出对应的非递归算法注意消除末尾递归不需要使用栈对于插入过程的非递归算法需要首先查找插入位置然后再进行插入查找插入位置从树根结点开始若树根指针为空则新结点就是树根结点否则若  小于根结点则沿着根的左指针在左子树上继续查找插入位置若  大于等于根结点则沿着根的右指针在右子树上继续查找插入位置当查找到一个结点设由  指针所指向的左指针或右指针为空时则这个空的指针位置就是新元素结点的插入位置在进行插入时若原树为空则将新结点指针赋给 该新结点就成为树根结点否则将新结点赋给  结点的左指针域或右指针域作为该结点的左孩子或右孩子插入过程的非递归算法具体描述如下 1      为插入新元素寻找插入位置定义指针  指向当前待比较的结点初始    指向树根结点定义指针  指向  结点的双亲结点初始为                                             建立值为  左右指针域为空的新结点          将新结点插入到二叉搜索树  中    二叉搜索树插入算法的时间和空间复杂度 与其查找和更新算法完全相同利用二叉搜索树的插入算法 可以很容易地编写出生成一棵具有个结点的二叉搜索树的算法 设生成二叉搜索树的个元素由数组提供 则算法描述如下          利用数组中的个元素建立二叉搜索树的算法         0           在一般情况下 此算法的时间复杂度为   若建立二叉搜索树的一组元素的关键字为3826629435502855按照上述算法 每插入一个结点后得到的二叉搜索树如图 62 所示 插入 38  插入 26  插入 62  插入 94  插入 35 插入 50  插入 28  插入 55图 62 二叉搜索树的生成过程4 删除二叉搜索树的删除比插入要复杂一些 因为被插入的结点都是被链接到树中的叶子结点上 因而不会破坏树的原有结构 也就是说 不会破坏树中原有结点之间的链接关系从二叉搜索树上删除结点元素则不同它可能删除的是叶子结点也可能删除的是分支结点当删除分支结点时就破坏了原有结点之间的链接关系需要重新修改指针使得删除后仍为一棵二叉搜索树结合如图 63  所示的二叉搜索树分 3 种情况介绍删除结点的操作 二叉搜索树 删除  和  后 删除  结点后 删除  结点后图 63 二叉搜索树的删除1 删除叶子结点此种删除操作很简单只要将其双亲结点链接到它的指针去掉即置为空如删除图 63  树中叶子结点  时把  结点的左指针域置空删除叶子结点  时把  结点的右指针域置空2 删除单支结点这种删除操作也比较简单因为该结点只有左子树或右子树一支也就是说其后继只有一个左孩子或右孩子删除该结点时只要将后继指针链接到它所在的链接位置即可如删除图 63  树中单支结点  时将  的左指针即指向  结点的指针赋给  结点的右指针域即可删除单支结点  时将  的右指针即指向  结点的指针赋给  结点的右指针域即可删除这两个结点后得到的二叉搜索树如图 63  所示3 删除双支结点这种删除比较复杂因为待删除的结点有两个后继指针需要妥善处理删除这种结点的第 1 种方法是首先把它的右子树链接到它的中序前驱结点即中序序列中处于它前面的一个结点的右指针域此中序前驱结点必是它的左子树中最右下的一个右指针为空左指针可能为空也可能不为空的结点在图 63  树中双支结点  的中序前驱为  结点双支结点  的中序前驱为  结点然后把它的左子树链接到它所在的链接位置如在图 63  树中删除双支结点  时则首先把  的右子树链接到  结点的右指针域然后把  的左子树链接到  的左指针域删除  结点后得到的二叉搜索树如图 63  所示这种方法往往容易增加树的深度使树的结构变坏所以通常采用下面介绍的第 2 种方法删除双支结点的第 2 方法是首先把它的中序前驱结点的值赋给该结点的值域然后再删除它的中序前驱结点因为它的中序前驱结点的右指针为空所以只要把中序前驱结点的左指针链接到中序前驱结点所在的链接位置即可如删除图 63  树中双支结点  时首先把它的中序前驱结点  的值赋给  结点的值域然后把  结点的左指针此时为空链接到  结点的左指针域删除  结点后得到的二叉搜索树如图 63  所示又如若从图 63  树中删除根结点 因为  是双支结点所以首先把它的中序前驱结点  的值赋给  结点的值域然后把  结点的左指针此时指向  结点链接到  结点的右指针域删除  结点后得到的二叉搜索树如图 63  所示采用以上方法从二叉搜索树中删除结点后得到的仍然是一棵二叉搜索树从二叉搜索树中删除结点的算法可以是递归的也可以是非递归的下面只给出递归算法读者可以编写出相应的非递归算法       从二叉搜索树  中删除值为  的结点树根指针必须为引用    树为空未找到待删除元素返回假表示删除成功           待删除元素小于树根结点值继续在左子树中删除            待删除元素大于树根结点值继续在右子树中删除                待删除元素等于树根结点值且左子树为空将右子树作为整棵树并返回真                          待删除元素等于树根结点值且右子树为空将左子树作为整棵树并返回真                           待删除元素等于树根结点值且左右子树均不为空时的处理情况             中序前驱结点就是左孩子结点时把左孩子结点值赋给树根结点        然后从左子树中删除根结点                                                    找出中序前驱结点即左子树的右下角结点把该结点值赋给树根结点        然后从以中序前驱结点为根的树上删除根结点          122 12 222 1 2二叉搜索树的查找插入删除元素的运算都具有相同的时间复杂度都与具体二叉搜索树的深度成正比时间复杂度的平均情况为 最差情况为它们的空间复杂度对于递归算法来说平均情况为 最差情况为对于非递归算法来说均为1可以采用下面程序调试对二叉搜索树各种运算的算法定义二叉搜索树结点值的类型为整型  定义二叉搜索树结点类型                 二叉树运算二叉搜索树运算 保存对二叉搜索树运算的算法          定义指向二叉搜索树结点的指针并用它作为树根指针         初始化二叉搜索树即置树根指针为空        定义数组并初始化     1030502040257054238092    利用数组建立树根指针为的二叉搜索树    10    以广义表形式输出二叉搜索树         求出以为树根指针的二叉搜索树的深度    深度      中序遍历以为树根指针的二叉搜索树中序                                   从二叉搜索树中查找一个结点输入一个待查找的整数值1 查找元素成功 查找元素失败                        向二叉搜索树中插入一个结点输入一个待插入结点的整数值1                            从二叉搜索树中删除一个结点输入一个待删除结点的值 删除元素成功 删除元素失败                    再以广义表形式输出二叉搜索树                 再次中序遍历以为树根指针的二叉搜索树中序                           清除以为树根指针的二叉树程序的一次运行结果如下30202523504070548092深度 5中序 20 23 25 30 40 50 54 70 80 92输入一个待查找的整数值70查找元素70 成功输入一个待插入结点的整数值15输入一个待删除结点的值30删除元素30 成功25201523504070548092中序 15 20 23 25 40 50 54 70 80 9262 堆621 堆的定义堆分为小根堆和大根堆两种 对于一个小根堆 它是具有如下特性的一棵完全二叉树1若树根结点存在左孩子则根结点的值 或某个域的值 小于等于左孩子结点的值 或某个域的值2若树根结点存在右孩子则根结点的值 或某个域的值 小于等于右孩子结点的值或某个域的值3 以左右孩子为根的子树又各是一个堆大根堆的定义与上述类似 只要把小于等于改为大于等于就得到了由堆的定义可知 若一棵完全二叉树是堆 则该树中以每个结点为根的子树也都是一个堆如图 64 所示分别为一个小根堆和一个大根堆根据堆的定义可知 堆顶结点 即整个完全二叉树的根结点 对于小根堆来说具有最小值 对于大根堆来说具有最大值图 64  是一个小根堆 堆中的最小值为堆顶结点的值 18 图 64  是一个大根堆堆中的最大值为堆顶结点的值 74若用堆来表示优先级队列 则堆顶结点具有最高的优先级 每次做删除操作要删除堆顶结点     小根堆       大根堆  图 64 小根堆和大根堆62 2 堆的抽象数据类型堆的抽象数据类型中的数据部分是按任一种存储结构表示的堆 用标识符  表示其存储类型用标识符  表示堆的抽象数据类型中的操作部分通常为 向堆中插入一个元素从堆中删除堆顶元素初始化一个堆清除一个堆和判断一个堆是否为空等堆的抽象数据类型的具体定义如下  具有  类型的一个堆     初始化一个堆为空    清除一个堆 使之变为空    判断一个堆是否为空      向堆中插入元素    从堆中删除堆顶元素并返回 62 3 堆的存储结构堆同一般二叉树一样既可采用顺序存储 也可采用链接存储但由于堆是一棵完全二叉树 所以适宜采用顺序存储 这样能够充分利用其存储空间对堆进行顺序存储时 首先要对堆中的所有结点进行编号 然后再以编号为下标存储到指定数组的对应元素中为了利用数组的 0 号元素 堆中结点的编号从 0 而不是从 1 开始 当然编号次序仍然按照从上到下同一层从左到右进行 若堆中含有个结点 则编号范围为0  1堆中的结点从 0 开始编号后 编号为 0 至   21的结点为分支结点 编号为   2  1的结点为叶子结点 当为奇数则每个分支结点既有左孩子又有右孩子 当为偶数则编号最大的一个分支结点只有左孩子没有右孩子 对于每个编号为的分支结点 其左孩子结点的编号为21 右孩子结点的编号为22 除编号为 0 的堆顶结点外 对于其余编号为的结点 其双亲结点的编号为12对于图 64 所示的堆 对应的顺序存储结构 如图 65 所示 0  1  2  3  4  5  6  7  8  9  18  26  35  73  48  60      图 64  的存储结构 0  1  2  3  4  5  6  7  8  9  74  53  42  25  36  35  20  18  22   图 64  的存储结构图 65 堆的顺序存储结构根据此存储结构可以验证给出的双亲和左右孩子结点之间的下标关系当一个堆采用顺序存储结构时 需要定义一个元素类型为 长度为  的一个数组来存储堆中的所有元素 还需要定义一个整型变量 用以存储堆的长度 即堆中当前包含的结点数设存储堆元素的数组名用  表示 存储堆长度的变量名用  表示 并且把它们连同存储空间大小  一起定义在一个结构类型中 结构类型名用  表示 则该类型定义为         定义指向动态数组空间的指针              定义保存堆长度的变量          用于保存初始化时所给的动态数组空间的大小624 堆的运算在堆的抽象数据类型中列出的每一种操作的具体算法描述如下对于插入和删除算法将以小根堆为例给出 当为大根堆时只是相应条件中的比较操作符不同 其余都相同1 初始化堆    置  为一个空堆    10                           初始定义数组长度为 10以后可增减           动态分配存储堆的数组空间             用于动态分配的内存空间用完 退出运行        1        0                                设置  域的初值为 02 清除堆                       清除 使之成为一个空堆                              0        0    3 检查一个堆是否为空                       判断  是否为空是返真否返假     04 向堆中插入一个元素向堆中插入一个元素时 首先将该元素写入到堆尾 即堆中最后一个元素的后面 亦即下标为的位置上 然后经调整为一个新堆由于在原有堆上插入一个新元素后 可能使以该元素为根的子树不为堆 从而使整个树不为堆 所以必须进行调整使之仍为一个堆调整的方法很简单 若新元素小于双亲结点的值 就让它们互换位置 新元素换到双亲位置后 使得以该位置为根的子树成为堆 但新元素可能还小于此位置的双亲结点的值 从而使以上一层的双亲结点为根的子树不为堆 还需要按上述方法继续调整 这样持续传递上去 直到以新位置的双亲结点为根的子树仍为一个堆或者调整到堆顶为止 此时得到的整个树又成为一个堆对于图 64  所示的堆 若向它插入一个新元素 50 时 由于它不小于双亲结点的值 35 所以以 35 为根的子树仍为一个堆 从而使整个二叉树仍然是一个堆 此次插入不需要作任何调整插入新元素 50 后得到的堆 如图 66  所示 插入 50 插入 30 插入 15图 66 堆的插入对于图 64  所示的堆 若向它插入一个新元素30 由于它小于双亲结点的值35所以需要将30与35对调位置 对调后因新元素30不小于其双亲元素18 所以调整结束得到的整个二叉树为一个堆 插入结果如图 66  所示对于图 64  所示的堆 若向它插入的一个新元素为15 由于它小于双亲元素35所以需要将15与35对调位置 对调后因新元素15小于其双亲元素18 所以又需要将15与18对调位置 此时新元素被调整到了堆顶位置 所以调整结束 得到的插入后结果如图 66  所示向堆中插入一个元素的算法描述如下     向小根堆  中插入元素堆满时重分配大一倍的存储空间并进行相应操作    2 计算每个元素存储空间的长度堆动态存储空间扩展为原来的 2 倍 原内容自动保持不变 动态可分配的存储用完 退出运行12 把堆空间大小修改为新的长度用  指向待调整元素的位置 初始指向新元素所在的堆尾位置 寻找新元素的最终位置 每次使双亲元素下移一层0  12  指向下标为  的元素的双亲元素  比较调整结束退出循环 双亲元素下移 改变调整元素的位置为其双亲位置把新元素调整到最终位置 并使堆的长度增 1此算法的运行时间主要取决于  循环的执行次数它等于新元素向双亲位置逐层上移的次数此次数最多等于整个树的深度减 1所以算法的时间复杂度为 其中表示堆的大小5 从堆中删除元素从堆中删除元素就是删除堆顶元素并使之返回堆顶元素被删除后留下的堆顶位置应由堆尾元素来填补这样既保持了顺序存储结构又不需要移动其他任何元素把堆尾元素素移动到堆顶位置后它可能不小于左右孩子结点使整个二叉树不为堆所以需要一个调整过程使之变为含有1个元素的堆删除前为个元素调整过程首先从树根结点开始若树根结点的值大于两个孩子结点中的最小值就将它与具有最小值的孩子结点互换位置使得根结点的值小于两个孩子结点的值原树根结点被对调到一个孩子位置后可能使以该位置为根的子树又不为堆因而又需要使新元素向孩子一层调整如此调整下去直到以调整后的位置为根的子树成为一个堆或调整到叶子结点为止对于图 64所示的堆当从中删除顶点元素 18 时需要把堆尾元素 60 写入到堆顶位置成为堆顶元素由于 60 大于两个孩子中的最小值 26所以应互换 60 和 26 的位置60 被移到新位置后又大于两个孩子中的最小值 48所以接着同 48 互换位置此时 60 已被调整到叶子结点所以调整完成后得到的完全二叉树又成为一个堆如图 67 所示67图 67 堆的删除若图 64所示堆的顶元素不是 60 而是 45则进行删除操作时把 45 写入到堆顶位置后因 45 大于两个孩子中的最小值 26所以需把它对调到左孩子 26 的位置此时它小于两个孩子中的最小值 48表明以 45 所在的新位置为根的子树已经成为一个堆至此调整结束从堆中删除元素的算法描述如下      从小根堆  中删除堆顶元素并返回    0               若为空堆则显示出错误信息并退出运行        堆为空退出运行        1         0    将堆顶元素暂存  以便返回                        堆的长度减 1    0     若删除操作后变为空堆则返回      将待调整的堆尾元素暂存  中     0                      用  指向待调整元素的位置初始指向堆顶位置     1                      用  指向  的左孩子位置初始指向下标 1 的位置    1          寻找待调整元素的最终位置        若右孩子存在并且较小应使  指向右孩子        1  1 若条件成立则调整结束退出循环  孩子元素上移到双亲位置使和分别指向下一层结点 21 把待调整元素放到最终位置  返回原堆顶元素此算法的运行时间主要取决于  循环的执行次数它等于堆顶新元素向孩子位置逐层下移的次数此次数最多等于整个树的深度减 1所以堆删除算法的时间复杂度同插入算法相同均为 在解决实际问题时若每次只需要取出即删除具有最小值的元素则适合采用堆这种数据结构因为其插入和删除元素的时间复杂度均为 若采用线性表来实现这种功能其插入和删除元素的时间复杂度将均为在计算机操作系统中管理一个共享资源就需要使用一个堆把等待使用该资源的所有用户按照优先级号组织起来优先级最高的用户一定处于堆首位置系统每次从这个堆中取出删除堆顶元素并为之服务需要使用该资源的新用户被加入到等待使用该资源的堆中使用堆的一个完整程序如下请读者阅读和分析   定义元素类型为整型       定义堆的顺序存储类型          堆运算 假定在  中保存着堆运算的各种算法      82356406238551016      定义一个堆     初始化堆         向堆中依次插入数组中的每一个元素08 按下标位置依次输出堆中的每个元素07 7依次删除堆顶元素并显示出来直到堆空为止                请通过堆的图示操作过程验证下面运行结果的正确性1016233856554062101623384055566263 哈夫曼树631 基本术语1 路径和路径长度在一棵树中存在着一个结点序列12使得是1的双亲1    则称此结点序列是从1到的路径因树中每个结点只有一个双亲结点所以它也是这两个结点之间的唯一路径从1到所经过的分支数称为这两点之间的路径长度它等于路径上的结点数减 1在图 63所示的二叉树中从树根结点  到叶子结点  的路径为结点序列 路径长度为 32 结点的权和带权路径长度在许多应用中常常将树中的结点赋上一个有着某种意义的实数称此实数为该结点的权结点的带权路径长度规定为从树根结点到该结点之间的路径长度与该结点上权的乘积3 树的带权路径长度树的带权路径长度定义为树中所有叶子结点的带权路径长度之和通常记为1  其中表示叶子结点的数目和分别表示叶子结点的权值和树根结点到之间的路径长度4 哈夫曼树哈夫曼树 又称做最优二叉树它是个带权叶子结点构成的所有二叉树中带权路径长度  最小的二叉树因为构造这种树的算法是最早由哈夫曼于 1952 年提出的所以被称为哈夫曼树例如有 4 个叶子结点    分别带权为 9 4 5 2由它们构成的三棵不同的二叉树当然还有其他许多种分别如图 68   图 68  所示 带权二叉树之一 带权二叉树之二 带权二叉树之三图 68 由四个叶子结点构成的三棵不同的带权二叉树每一棵二叉树的带权路径长度  分别为①  9  2  4  2  5  2  2  2  40②  4  1  2  2  5  3  9  3  50③  9  1  5  2  4  3  2  3  37其中③树的  最小稍后便知此树就是哈夫曼树因此在个带权叶子结点所构成的二叉树中满二叉树或完全二叉树不一定是最优二叉树权值越大的结点离树根越近的二叉树才是最优二叉树63 2 构造哈夫曼树构造最优二叉树的算法具体叙述如下1 根据与个权值1 2  对应的个结点构成具有棵二叉树的森林1 2  其中每棵二叉树 1    都只有一个权值为的根结点其左右子树均为空2 在森林中选出两棵根结点的权值最小的树作为一棵新树的左右子树且置新树的根结点的权值为其左右子树上根结点的权值之和3 从中删除构成新树的那两棵树同时把新树加入中4 重复 2 和 3 步直到中只含有一棵树为止此树便是哈夫曼树若仍采用图 68 中的 4 个带权叶子结点来构造一棵哈夫曼树按照上述算法则构造过程如图 69 所示其中图 69  就是最后生成的哈夫曼树它的带权路径长度为 37由此可知图 68  是一棵哈夫曼树 四棵树 三棵树 两棵树 一棵树图 69 构造哈夫曼的过程在构造哈夫曼树的过程中 当每次由两棵权值最小的树生成一棵新树时 新树的左子树和右子树可以任意安排 这样将会得到具有不同结构的多个哈夫曼树 但它们都具有相同的带权路径长度为了使得到的哈夫曼树的结构尽量唯一 通常规定生成的哈夫曼树中每个结点的左子树根结点的权小于等于右子树根结点的权上述哈夫曼树的构造过程就是依照这一规定进行的根据上述构造哈夫曼树的方法可以写出相应的用 语言描述的算法如下        根据数组  中  个权值建立一棵哈夫曼树 返回树根指针         动态分配一个由  指向的指针数组              初始化  指针数组 使每个指针元素指向  数组中对应元素的结点    0                             进行 1 次循环建立哈夫曼树    1           用 1 表示森林中具有最小权值的树根结点的下标        用 2 表示森林中具有次最小权值的树根结点的下标         112        让 1 初始指向森林中第一棵树 2 初始指向森林中第二棵树        0                 11 1             2        从当前森林中求出最小权值树和次最小权值树2                1 211         2 2    由最小权值树和次最小权值树建立一棵新树指向树根结点 121 2将指向新树的指针赋给指针数组中1位置2位置为空1 2删除动态建立的数组 返回整个哈夫曼树的树根指针 在一颗哈夫曼树的生成过程中每次都由两棵子树构成一棵树对于个叶子结点共需要构成1棵子树所以在一棵哈夫曼树中只存在双支结点和叶子结点若叶子结点为个则双支结点必为1个根据哈夫曼树求出带权路径长度的算法如下       根据指针所指向的哈夫曼树求出带权路径长度初值为0      0 空树则返回0             访问到叶子结点时返回该结点的带权路径长度其中值参        保存当前被访问结点的路径长度                                        访问到非叶子结点时进行递归调用返回左右子树的带权        路径长度之和向下深入一层时值增1                      1                   1            63 3 哈夫曼编码哈夫曼树的应用很广 哈夫曼编码就是其中的一种 下面简要介绍在电报通信中 电文是以二进制的 01 序列传送的在发送端需要将电文中的字符序列转换成二进制的 01 序列即编码在接收端又需要把接收到的 01 序列转换成对应的字符序列即译码最简单的二进制编码方式是等长编码若电文中只使用  这 6 种字符若进行等长编码则需要二进制的三位可依次编码为 000001010011100101若用这 6 个字符作为 6 个叶子结点生成一棵二叉树让该二叉树中每个分支结点的左右分支分别用 0 和 1 编码从树根结点到每个叶子结点的路径上所经分支的 01 编码序列应等于该叶子结点的二进制编码则对应的编码二叉树如图 610 所示           图 610 编码二叉树通常电文中每个字符的出现频率即次数一般是不同的在一份电文中这 6 个字符的出现频率依次为426832则电文被编码后的总长度可由下式计算1  其中表示电文中使用的字符数和分别表示对应字符在电文中的出现频率和编码长度因此可求出为16  33 42683275可知采用等长编码时传送电文的总长度为 75那么如何能缩短传送电文的总长度从而节省传送时间呢若采用不等长编码让出现频率高的字符具有较短的编码让出现频率低的字符具有较长的编码这样有可能缩短传送电文的总长度采用不等长编码要避免译码的二义性或多义性假设用 0 表示字符 用 01 表示字符 则当接收到编码串01并译到字符 0 时是立即译出对应的字符 还是接着与下一个字符 1 一起译为对应的字符 这就产生了二义性因此若对某一字符集进行不等长编码则要求字符集中任一字符的编码都不能是其他字符编码的前缀符合此要求的编码叫做无前缀编码显然等长编码是无前缀编码这从等长编码所对应的编码二叉树也可直观地看出任一叶子结点都不可能是其他叶子结点的双亲也就是说只有当一个结点是另一个结点的双亲时该结点的字符编码才会是另一个结点的字符编码的前缀为了使不等长编码成为无前缀编码可用该字符集中的每个字符作为叶子结点生成一棵编码二叉树为了获得传送电文的最短长度可将每个字符的出现频率作为字符结点的权值赋予该结点上求出此树的最小带权路径长度就等于求出了传送电文的最短长度因此求传送电文的最短长度问题就转化为求由字符集中的所有字符作为叶子结点由字符的出现频率作为其权值所产生的哈夫曼树的问题由上例生成的编码哈夫曼树如图 611 所示由编码哈夫曼树得到的字符编码称作哈夫曼编码其中 这 6 个字符的哈夫曼编码依次为00101001111001011电文的最短传送长度为    16    4  2  2  4  6  2  8  2  3  3  2  4  61显然计算结果比等长编码所得到的传送电文总长度 75 要小得多对求哈夫曼树带权路径长度的算法略加修改就可以得到求哈夫曼编码的算法具体如下        根据  指针所指向的哈夫曼树输出每个叶子的编码 初值为 0      10 数组的长度要至少等于哈夫曼树的深度减 1                访问到叶子结点时输出其保存在数组  中的 0 和 1 序列编码                              结点权值为    的编码                0                                        访问到非叶子结点时分别向左右子树递归调用并分别把分支上的 01 编码保存到数组  的对应元素中向下深入一层时  值增 1                       0    1              1    1            采用如下程序调试对哈夫曼树的算法            二叉树运算根据数组  中  个权值建立一棵哈夫曼树返回树根指针     补充函数定义根据  指针所指向的哈夫曼树求出带权路径长度 初值为 0     补充函数定义根据  指针所指向的哈夫曼树输出每个叶子的编码 初值为 0     补充函数定义               输入哈夫曼树中叶子结点数    输入待构造的哈夫曼树中带权叶子结点数         用数组  保存从键盘输入的  个叶子结点的权值         输入个整数作为权值    0       根据数组  建立哈夫曼树        以广义表形式输出哈夫曼树    广义表形式的哈夫曼树            输出哈夫曼树的权值即带权路径长度    哈夫曼树的权    0    输出哈夫曼编码即每个叶子结点所对应的 01 序列    树中每个叶子的哈夫曼编码    0    程序的一次运行结果如下输入待构造的哈夫曼树中带权叶子结点数 6输入 6 个整数作为权值3 9 5 12 6 15广义表形式的哈夫曼树50219122914683515哈夫曼树的权122树中每个叶子的哈夫曼编码结点权值为 9 的编码0  0结点权值为 12 的编码0  1结点权值为 6 的编码1  0  0结点权值为 3 的编码1  0  1  0结点权值为 5 的编码1  0  1  1结点权值为 15 的编码1  164 线索二叉树641 二叉树的线索化对二叉树进行某种遍历得到的结点序列 可以看作一个线性表在该线性表中 除第一个结点外 每个结点有且仅有一个前驱 除最后一个结点外 每个结点有且仅有一个后继为了同在二叉树中所具有的结点前驱 即双亲 和后继 即孩子 区别开来 在容易混淆的地方 通常把遍历序列中结点的前驱或后继冠以某种遍历的名称 如把中序序列中结点的前驱称作中序前驱 结点的后继称作中序后继对于如图 612 所示的二叉树 中序遍历的结点序列为  其中  结点为中序遍历得到的线性序列的表头结点 它没有前驱 其中序后继为  结点  结点的中序前驱为  结点 中序后继为  结点等对于一棵具有个结点的二叉树 对应的二叉链表中共有2个指针域 其中1个用于指向除树根结点以外的其余1个结点 另有1个指针域空闲着若把每个结点中空着的左指针域和右指针域用于分别指向某种遍历次序的前驱结点和后继结点 则在遍历这种二叉树时 可由此信息直接找到在该遍历次序下的前驱结点或后继结点 从而比递归遍历提高了遍历速度节省了建立系统栈所使用的存储空间这种在结点的空指针域中存放的该结点在某次遍历次序下的前驱结点或后继结点的指针叫做线索  其中在空的左指针域中存放的指向其前驱结点的指针叫做左线索或前驱线索 在空的右指针域中存放的指向其后继结点的指针叫做右线索或后继线索对一棵二叉树中的所有结点的空指针域按照某种遍历次序加线索的过程叫做线索化 被线索化了的二叉树称做线索二叉树如图 612  所示是对图 612  的二叉树加中序线索而得到的中序线索二叉树 二叉树 加中序线索后的二叉树图 612 中序线索二叉树在一个线索二叉树中为了区别各个结点的左右指针域所存放的是孩子指针或是线索必须在结点结构中增加两个线索标志域一个是左线索标志域用表示另一个是右线索标志域用表示和只需取两种值以区别其对应的指针域保存的是孩子指针或是线索取真时指向线索取假时指向孩子增加线索标志域后的二叉树结点结构如下          该结点结构的类型定义为         值域        线索标志域       左指针域       右指针域如图 613 所示是图 612 的中序线索二叉树的链接存储结构图 613 索引二叉树的链接存储结构对一棵结点类型为  的二叉树进行线索化时该二叉树的初始状态应为每个结点的线索标志域均为假0若一个结点有左孩子或右孩子则相应的指针域指向孩子否则为空以便在线索化的过程中加入线索对一棵二叉树进行某种遍历次序的线索化显然就是对该二叉树进行这种遍历的过程只不过在访问根结点时不是简单地打印根结点的值而是对指针域为空的结点加线索具体做法如下1 若前驱结点不为空或者说当前结点不是序列中的第 1 个结点同时前驱结点的右线索标志域为真表示此结点的右指针域为空时则将当前结点的指针赋给前驱结点的右指针域即给前驱结点加右线索2 若当前结点的左指针域为空则将左线索标志域置真同时把前驱结点的指针赋给当前结点的左指针域即给当前结点加左线索3 若当前结点的右指针域为空则将右线索标志域置为真以便当访问到下一个即后继结点时给它加右线索4 将当前结点指针赋给保存前驱结点指针的变量以便当访问下一个结点时此当前结点成为前驱结点设是用来保存前驱结点指针的引用参数初始为空设是用来保存当前结点指针的值参初始指向待线索化的一棵二叉树的根结点下面给出对二叉树进行中序线索化即建立中序线索的算法它是在中序遍历算法的基础上改造而成的         对二叉树  加中序线索                                   左子树非空时给左子树加中序线索                                        给前驱结点加后继线索                                                    给当前结点加前驱线索                                            给右指针域为空的结点加右线索标记                                把刚访问过的当前结点置为前驱结点                          右子树非空时给右子树加中序线索    在对二叉树进行中序线索化的算法中若把对左子树加线索的条件语句放到对右子树加线索的条件语句之上则得到前序线索化的算法所建立的线索为前序线索若把对右子树加线索的条件语句放到对左子树加线索的条件语句之下则得到后序线索化的算法所建立的线索为后序线索若在该函数中不使用参数也可以在函数体的开始位置加上如下语句替代    利用下面算法向带线索标志域的二叉搜索树插入元素但不进行中序线索的链接          向带线索的二叉搜索树插入元素但不链接线索                                                      0                          向左子树中插入元素      利用下面算法建立带线索标志域的二叉搜索树但不进行中序线索链接              0           带线索标志域的二叉搜索树建立后随时可以调用  算法建立其中序线索若要向带线索的二叉搜索树中插入结点并且要进行实际的线索链接则应采用下面插入算法 1      向带线索的二叉搜索树插入元素并进行线索链接    为新结点寻找插入位置                                                                       建立值为  的新结点               叶子结点的左右孩子指针均为线索    将新结点插入到线索二叉搜索树  中               作为树根结点插入                             作为左孩子结点插入          置双亲的左线索标志域为假          新结点链接为双亲的左孩子          双亲结点成为新结点的后继                   作为右孩子结点插入          置双亲的右线索标志域为假          新结点链接为双亲的右孩子          双亲结点成为新结点的前驱     置双亲的右线索标志域为假 新结点链接为双亲的右孩子 双亲结点成为新结点的前驱利用 1 算法建立一棵带线索的二叉搜索树的算法如下 1    利用数组中的  个元素建立带线索的二叉搜索树的算法         0          1 642 利用线索进行遍历以中序线索为例来讨论这个问题首先讨论一下如何在中序线索二叉树上寻找一个结点 即指针  所指向的结点的中序后继结点它分为如下两种情况1 若  结点的右线索标志域为真则表明为右线索它直接指向  的中序后继结点2 若  的右线索标志域为假则表明指向右孩子结点 的中序后继结点必是其右子树中第一个中序遍历到的结点因此从  的右孩子开始沿左指针链往下查找直到找到一个没有左孩子即左线索标志域为 1的结点为止该结点是  的右子树中最左下的结点它就是  的中序后继结点如图 614所示 的中序后继结点是   1可能是叶子结点也可能是只含有右子树的单支结点另外若1则表示  的右孩子1是  的中序后继结点 二叉树表示 二叉链表表示图 614 求中继后继结点示意图根据以上分析给出在中序线索二叉树上求结点  的中序后继的算法如下   返回  结点的中继后继结点                                                有了求中序后继结点的算法就不难写出在中序线索二叉树上进行中序遍历的算法此算法可叙述为首先从根结点起沿左指针链往下查找直到找到一个左线索标志域为真的结点为止该结点的左指针域必为空它就是整个中序序列的第一个结点然后打印该结点接着利用上述求中序后继结点的算法得到下一个结点以此类推直到中序后继结点为空时止设  为具有 指针类型的一个值参初始指向一棵中序线索二叉树的根结点则对此树进行中序遍历的算法可描述如下   按中序线索遍历二叉树                           查找出中序遍历中的第一个结点                       输出结点的值             查找出  结点的中序后继结点          当  为空时算法结束    利用线索进行二叉树遍历的时间复杂度为空间复杂度为1实际运行时间要少于不加线索的情况以广义表形式输出一棵线索二叉树的算法如下                输出根结点的值                        输出左括号                             输出左子树                              若右子树不为空则首先输出逗号分隔符                 输出右子树 输出右括号利用下面程序调试上述每个算法   定义二叉树结点值的类型为整型        值域       线索标志域      左指针域      右指针域线索二叉树运算     1     1030502040257054238092    10        1    中序       1137    11    中序  1 该程序的运行结果如下30202523504070548092中序20  23  25  30  40  50  54  70  80  9240252370548092中序23  25  40  54  70  80  9265 平衡二叉树平衡二叉树  是对二叉搜索树的一种改进二叉搜索树有一个缺陷那就是树的结构事先无法预料随机性很大它只与结点的值和插入次序有关往往得到的是一棵很不平衡的二叉树即树的高度与相同结点数的理想平衡树相差甚远在最坏的情况下有可能变为一棵单支二叉树其高度与结点数相同相当于一个单链表对其运算的时间复杂度由正常的 变为从而部分或全部地丧失了利用二叉搜索树组织数据的优点为了克服二叉搜索树的这个缺陷需要在插入和删除结点时对树的结构进行必要的调整使二叉搜索树的结构始终处于一种较平衡的状态当然它没有理想平衡树那样绝对的平衡若要使二叉搜索树调整成理想平衡树那样的结构将会使调整运算变得很复杂使调整带来的好处得不偿失651 平衡二叉树的定义平衡二叉树简称平衡树是由阿德尔森维尔斯基和兰迪斯  于 1962 年首先提出的所以又称为  树若一棵二叉树中每个结点的左右子树的高度至多相差 1则称此树为平衡的把二叉树中每个结点的左子树高度减去右子树高度定义为该结点的平衡因子 因此平衡树中每个结点的平衡因子只能是 10 或 1如图 615  所示是一棵平衡二叉树如图 615  和图 615  所示分别是一棵非平衡树每个结点上方所标数字为该结点的平衡因子 平衡二叉树 非平衡二叉树例 1 非平衡二叉树例 2图 615 带平衡因子的二叉树虽然平衡树的平衡性比理想平衡树要差一些但理论上已经证明具有个结点的平衡树的高度在任何情况下决不会比具有相同结点数的理想平衡树高出45以上因此在平衡树上进行查找运算虽比理想平衡树要慢一些但通常比任意生成的二叉排序树快得多当然其时间复杂度的数量级表示仍为 当向一棵平衡树插入一个新结点时插入后某些结点的左右子树的高度不变就不会影响这些结点的平衡因子因而也不会因为这些结点造成不平衡若插入后某些结点的左子树高度增加1右子树高度增加1的情况与之类似则就影响了这些结点的平衡因子具体分为如下3种情况1 若插入前一部分结点的左子树高度与右子树高度相等即平衡因子为0则插入后将使平衡因子变为1但仍符合平衡的条件不必对它们加以调整2 若插入前一部分结点的小于即平衡因子为1则插入后将使平衡因子变为0平衡更加改善不必对它们进行调整3 若插入前一部分结点的大于即平衡因子为1则插入后将使平衡因子变为2破坏了平衡树的限制条件需对它们加以调整使整个二叉排序树恢复为平衡树若插入后某些结点的右子树高度增加1则也分为相应的3种情况对于第1种情况平衡因子将由0变为1不必进行调整对于第2种情况是平衡因子由1变为2则必须对它们进行调整对于第3种情况是平衡因子由1变为0平衡更加改善也不必进行调整向平衡树中插入一个结点后破坏了其平衡性首先要找出最小不平衡子树然后再调整这个子树中有关结点之间的链接关系使之成为新的平衡子树当然调整前后该子树的二叉搜索树性质不变即调整前后得到的中序序列要完全相同稍后便知最小不平衡子树被调整为平衡子树后原有其他所有不平衡子树无需调整整个二叉搜索树就又成为一棵平衡树所谓最小不平衡子树是指以离插入结点最近且平衡因子绝对值大于1的结点做根的子树在图615中以值为30的结点做根的子树是该树的最小不平衡子树分别以20和36做根的不平衡子树不是最小不平衡子树在图615中以值为32的结点做根的子树是该树的最小不平衡子树当然它也是唯一一个不平衡子树652 平衡二叉树的调整为了便于讨论不妨设最小不平衡子树的根结点用表示则调整该子树的操作可归纳为下列4种1 型调整操作在结点的左孩子用表示的左子树上插入结点使得结点的平衡因子由1变为2而引起的不平衡所进行的调整操作调整过程如图616所示图中用长方框表示子树用长方框的高度表示子树的高度用带阴影的小方框表示被插入的结点图616为插入前的平衡子树和的子树高度均为  0若0则它们均为空树结点和结点的平衡因子分别为1和0图616为在的左子树上插入一个新结点使以为根的子树成为最小不平衡子树的情况图616为调整后成为新的平衡子树的情况调整规则是将的左孩子向右上旋转代替成为原不平衡子树的根结点将结点向下旋转成为的右子树的根结点而的原右子树β则作为结点的左子树此调整过程需要修改3个指针如图616中的箭头所示一是将原指向结点的指针修改为指向结点二是将的右指针修改为指向结点三是将的左指针修改为指向的原右子树的根结点另外还需要修改和结点的平衡因子应均被置为0 插入前 插入后 调整后图616 型调整操作示意图从图616可以看出调整前后对应的中序序列相同即为αβγ所以经调整后仍保持了二叉搜索树的特性不变如图617所示是型搜索调整的两个实例其中图617图617图617为一例此处结点为9结点为6αβγ均为空树图617图617图617为另一例此处结点为50结点为45αβγ分别为只含有一个结点304860的子树 插入前 插入3后 调整后 插入前 插入20后 调整后图617 调整实例2 型调整操作在结点的右孩子用表示的右子树上插入结点使得结点的平衡因子由1变为2而引起的不平衡所进行的调整操作调整过程如图618所示图618为插入前的平衡子树子树的高度相同均为0结点和结点的平衡因子分别为1和0图618为在结点的右子树上插入一个新结点使以为根的子树成为最小不平衡子树的情况图618为调整后重新恢复平衡的情况调整规则是将的右孩子向左上旋转代替成为原最小不平衡子树的根结点将结点向左下旋转成为的左子树的根结点而的原左子树则作为结点的右子树此调整过程同型调整过程对称要修改的3个指针如图618中的箭头所示同样进行型调整前后仍保持着二叉搜索树的特性不变另外在插入前和调整后其子树高度均为2由插入所引起的上层其他结点的不平衡将自动消失 插入前 插入后 调整后图618 型调整操作示意图3 型调整操作在结点的左孩子用表示的右子树上插入结点使得结点的平衡因子由1变为2而引起的不平衡所进行的调整操作调整过程如图619所示图619为插入前的平衡子树和子树的高度均为0和子树的高度均为1特别地若和子树为空树时则结点的右子树也同时为空此时结点将是被插入的新结点插入前结点和结点的平衡因子分别为1和0若结点存在则结点的平衡因子为0图619为在结点的右子树上插入一个新结点当的右子树为空时则为结点否则为的左子树或右子树上带阴影的结点图中给出在左子树上插入的情况若在右子树上插入情况类似使得以为根的子树成为最小不平衡子树的情况此处结点和结点的平衡因子是按相反方向变化的而不像前两种调整操作那样都是按同一方向变化的图619为调整后的情况调整规则是将的左孩子的右子树的根结点提升到结点的位置将结点作为的左子树的根结点而结点的原左子树则作为结点的右子树将结点作为的右子树的根结点而结点的原右子树则作为结点的左子树此调整过程比前两种要复杂需修改5个指针如图619中的箭头所示 插入前 插入后 调整后图 619  型调整操作示意图可以看出 调整前后对应的中序序列相同 即为       只是链接次序不同罢了但没有影响其二叉搜索树的特性另外在插入前和调整后的子树高度不改变如图 620 所示是  型调整操作的两个实例其中图 620 图 620 图 620 为一例 此处  结点为 9  结点为 3  结点为 6 它是新插入的结点均为空树 图 620 图 620 图 620  为另一例 此处  结点为 85  结点为 74  结点为 80和子树分别只含有一个结点 65 和 92和均为空 插入前 插入 6 后  调整后 插入前 插入 78 后  调整后图 620  型调整实例4  型调整操作在  结点的右孩子的左子树上插入结点 使  结点的平衡因子由 1 变为 2 而引起的不平衡所进行的调整操作调整过程如图 621 所示它同型调整过程对称请读者分析调整过程 插入前 插入后 调整后图 621 型调整操作示意图在上述每一种调整操作中以  为根的最小不平衡子树的高度在插入结点前和调整后相同因此对其所有祖先结点的平衡性不会产生任何影响即原有的平衡因子不变故按照上述方法将最小不平衡子树调整为平衡子树后整个二叉搜索树就成为了一棵新的平衡树下面用一组关键字为461520352858185054生成一棵平衡的二叉搜索树生成过程如图 622 所示 插 46  插 15  插入 20 后  插 35  插入 28 后   插入 58 后  插 18  插入 50 后  型调整  插 54图 622 建立平衡二叉树实例在二叉搜索树的插入和删除运算中采用平衡树的优点是使树的结构较好从而提高查找运算的速度缺点是使插入和删除运算变得复杂化从而降低它们的运算速度在每次插入或删除运算中不仅要进行插入和删除结点的操作而且要检查是否存在有最小不平衡子树若存在则需要对最小不平衡子树中有关指针进行修改因此采用平衡树适合于那种对二叉搜索树一经建立就很少进行插入和删除运算而主要是进行查找运算的应用场合对二叉搜索树删除结点而引起的不平衡而进行的调整操作比插入结点的情况还要复杂当调整完最小不平衡子树后还可能引起祖先结点中的不平衡还需要继续向上调整平衡二叉树的插入和删除算法是在二叉搜索树算法的基础上修改而成的是比较复杂的有关这方面的内容超出了教学要求故本节不做介绍习 题 6习题 61运算题1 已知一组元素为4625786212377029画出按元素排列顺序输入生成的一棵二叉搜索树再以广义表形式给出该二叉搜索树2 已知一棵二叉搜索树的广义表表示为2812164934307263若从中依次删除 72124928 等 4 个结点试分别画出每删除一个结点后得到的图形表示的二叉搜索树并写出对应的广义表表示3 从空堆开始依次向小根堆中插入集合38645215734048552612中的每个元素试以顺序表的形式给出每插入一个元素后堆的状态4 已知一个堆为1215403826524864若从堆中依次删除 4 个元素请给出每删除一个元素后堆的状态5 有 7 个带权结点其权值分别为 378261014试以它们为叶子结点构造一棵哈夫曼树给出其广义表表示并计算带权路径长度 6 在一份电文中共使用 5 种字符即 它们的出现频率依次为 47529试画出对应的编码哈夫曼树求每个字符的哈夫曼编码和传送电文的总长度7 一棵二叉树的广义表表示为 试画出对应的图示二叉树并在此树上添加先序线索8 一组关键字为4028165650323063试依次插入结点生成一棵平衡二叉搜索树并标明插入时所需平衡的类型9 一组关键字为36758354126760409272试依次插入结点分别生成一棵二叉搜索树和二叉平衡树并分别求查找每个元素的平均查找长度习题 62算法设计题1 设在一棵二叉搜索树的每个结点的数据域中含有用于排序的  域和统计相同排序码结点个数的  域当向该树插入一个元素时若树中已存在与该元素的排序码相同的结点则就使该结点的  域增 1否则就由该元素生成一个新结点而插入到树中并使其  域置为 1试按照这种插入要求编写一个算法2 编写一个非递归算法求出二叉搜索树中的关键字最大的元素3 求一棵二叉搜索树中单分支结点数4 写出在先序线索二叉树上求  结点的先序后继结点的算法和利用先序线索进行遍历的算法5 一棵二叉搜索树被存储在具有  数据类型已在第 5 章中定义的一个对象  中试编写以下算法1 初始化对象 2 向二叉搜索树中插入一个元素3 根据数组中的个元素建立一棵二叉搜索树4 中序遍历二叉搜索树5 写出一个完整程序调用上述算法
第8章 图的应用图在工程技术和日常生活中有着广泛地应用常常都涉及到求图的最小生成树最短路径拓扑序列关键路径等对图的特定运算的问题本章就这些运算的方法和算法进行深入讨论81 图的生成树和最小生成树811 生成树和最小生成树的概念在一个连通图中如果取它的全部顶点和一部分边构成一个子图即   和    若边集中的边将图中的所有顶点连通又不形成回路则称子图是原图的一棵生成树既连通图中的全部个顶点又没有回路的子图即生成树必含有1条边要构造子图首先从图中任取一个顶点加入中此时中只有一个顶点假定具有一个顶点的图是连通的以后每向中加入一个顶点都要加入以该顶点为一个端点以已连通的顶点之中的一个顶点为另一个端点的一条边这样既连通了该顶点又不会产生回路进行1次后就向中加入了1个顶点和1条边使得中的个顶点既连通又不产生回路在图的一棵生成树中若再增加一条边就会出现一条回路这是因为此边的两个端点已连通再加入此边后这两个端点间有两条路径因此就形成了一条回路子图也就不再是生成树了同样若从生成树中删去一条边就使得变为非连通图因为此边的两个端点是靠此边唯一连通的删除此边后必定使这两个端点分属于两个连通分量中使变成了具有两个连通分量的非连通图同一个图可以有不同的生成树如图 81图 81图 81 所示都是图 81 的生成树在每棵生成树中都包含有 8 个顶点和 7 条边它们的差别只是边的选取不同在这 3 棵生成树中图 81 所示生成树是从图中顶点0出发利用深度优先搜索遍历得到的被称为深度优先生成树生成树图 81 所示是从顶点0出发利用广度优先搜索遍历得到的被称为广度优先生成树生成树图 81 所示是任意一棵生成树当然图 81 的生成树远不止这几种只要能连通所有顶点而又不产生回路的子图都是它的生成树由于连通图的生成树使用最少的边连通了图中的所有顶点所以它又是能够连通图中所有顶点的极小连通子图对于一个连通网即无向连通带权图假定每条边上的权均为大于零的实数来说生成树不同每棵树的权即树中所有边上的权值总和也可能不同如图 82  所示是一个连通网如图 82 图 82 图 82  所示是它的三棵生成树每棵树的权都不同它们分别为 5753 和 38具有权最小的生成树称为图的最小生成树  通过后面将要介绍的构造最小生成树的算法可知图 82  所示就是图 82  所示的最小生成树求图的最小生成树具有实际意义例如若一个连通网表示城市之间的通信系统网的顶点代表城市网的边代表城市之间架设通信线路的造价各城市之间的距离不同地理条件不同其造价也不同即边上的权不同现在要求既连通所有城市又使总造价最低这就是一个求图的最小生成树的问题求图的最小生成树的算法主要有两个普里姆算法和克鲁斯卡尔算法下面分别进行讨论812 普里姆算法假设 是一个具有个顶点的连通网 是的最小生成树其中是的顶点集是的边集和的初值均为空集算法开始时首先从中任取一个顶点取0将它并入中此时0然后只要是的真子集即  就从那些其一个端点已在中另一个端点仍在外的所有边中找一条最短即权值最小边假定为 其中    并把该边 和顶点分别并入的边集和顶点集如此进行下去每次往生成树里并入一个顶点和一条边直到1次后就把所有个顶点都并入到生成树的顶点集中此时中含有1条边就是最后得到的最小生成树普里姆算法的关键之处是每次如何从生成树中到外的所有边中找出一条最短边例如在第次 1    1 前生成树中已有个顶点和1条边此时中到外的所有边数为当然它包括两顶点间没有直接边相连其权值被看做为常量 的边在内从如此多的边中查找最短边其时间复杂度为显然是很费时的是否有一种好的方法能够降低查找最短边的时间复杂度呢回答是肯定的它能够使查找最短边的时间复杂度降低到方法是设在进行第次前已经保留着从中到外每一顶点共个顶点的一条最短边进行第次时首先从这条最短边中找出一条最短的边它就是从中到外的所有边中的最短边设为 此步需进行次比较然后把边 和顶点分别并入中的边集和顶点集中此时外只有1个顶点对于其中的每个顶点若 边上的权值小于已保留的从原中到顶点的最短边的权值则用 修改之使从中到外顶点的最短边为 否则原有最短边保持不变这样就把第次后从中到外每一顶点的各一条最短边都保留下来了为进行第1次运算做好了准备此步需进行1次比较所以利用此方法求第次的最短边共需比较21次即时间复杂度为对于图 82  所示生成树它的邻接矩阵如图 83所示若从0出发利用普里姆算法构造最小生成树在其过程中每次第 0 次为初始状态向中并入一个顶点和一条边后顶点集边集每条边的后面为该边的权以及从中到外每个顶点的各一条最短边所构成的集合设用表示的状态如下第 0 次001802035040506第 1 次0303531302043573615第2次031035313121214103573615第3次03150353133575225493615第4次031520353133575222463615第5次0315240353133575222463615第6次03152460353133575222463615每次对应的图形如图84图84所示其中粗实线表示新加入到集合中的边细实线表示已加入到集合中的边虚线表示集合中的边但权值为的边实际上是不存在的所以没被画出 连通网 第0次 第1次 第2次 第3次 第4次 第5次 第6次图84 利用普里姆算法求图的最小生成树的示意图如图 84  所示就是最后得到的最小生成树 它同图 82  是完全一样的 所以图 82  是图 82  的最小生成树通过以上分析可知在构造最小生成树的过程中在进行第次1    1前边集中的边数为1条从中到外每一顶点的最短边集中的边数为条和中的边数总和为1条为了保存这1条边设用至少具有1个元素的边集数组类型即  类型的对象  来存储其中  的前1个元素即 02保存中的边后个元素即 12保存中的边在进行第次时首先从下标为12的元素即中的边中查找出权值最小的边设为 接着把边 1与 对调确保在第次后  的前个元素保存着中的边后1个元素保存着中的边然后再修改中的有关边使得从中到外每一顶点的各一条最短边被保存下来这样经过1次运算后 中就按序保存着最小生成树中的全部1条边根据分析编写利用普里姆算法产生图的最小生成树的算法描述如下          利用普里姆算法从顶点 0 出发求出用邻接矩阵  表示的图的    最小生成树最小生成树的边集存于数组  中         给  赋初值对应第 0 次的  值    0 1          0        1        01        进行 1 次循环每次求出最小生成树中的第  条边    1              从 12即 中查找最短边                 1        1 1                                                                  把最短边对调到第 1 下标位置         1        1                把新加入最小生成树  中的顶点序号赋给         1        修改  中的有关边使  中到  外的每一个顶点各保持一条到目前为止最短的边 1                                    内   外  若利用图 83 所示的邻接矩阵调用此算法则得到的边集数组  中的内容如表 81 所示表 81 边集数组   0  1  2  3  4  5    0  3  3  5  2  3    3  1  5  2  4  6    5  3  7  2  6  15 813 克鲁斯卡尔算法假设 是一个具有个顶点的连通网 是的最小生成树的初值等于即包含有中的全部顶点的初值为空此算法的基本思想是将图中的边按权值从小到大的顺序依次选取若选取的边使生成树不形成回路则把它并入中保留作为的一条边若选取的边使生成树形成回路则将其舍弃如此进行下去直到中包含有1条边为止此时的即为最小生成树以如图 85所示为例来说明此算法设此图是用边集数组表示的且数组中各边是按权值从小到大的顺序排列的若没有按序排列则可通过调用排序算法使之成为有序如图 85所示这样按权值从小到大选取各边就转换成按边集数组中下标次序选取各边当选取前 3 条边时均不产生回路应保留作为生成树的边如图 85所示选第 4 条边23时将与已保留的边形成回路应舍去接着保留15边舍去35边取到01边并保留后保留的边数已够 5 条即1条此时必定将全部 6 个顶点连通起来如图 85所示它就是图 85的最小生成树实现克鲁斯卡尔算法的关键之处是如何判断欲加入中的一条边是否与生成树中已保留的边形成回路这可将各项点划分为不同集合的方法来解决每个集合中的顶点表示一个无回路的连通分量算法开始时由于生成树的顶点集等于图的顶点集边集为空所以个顶点分属于个集合每个集合中只有一个顶点表明顶点之间互不连通例如对于图 85其六个集合为0 1 2 3 4 5 连通网 取到三条边 最小生成树 边集数组图 85 克鲁斯卡尔算法求最小生成树的示意图当从边集数组中按次序选取一条边时 若它的两个端点分属于不同的集合 则表明此边连通了两个不同的连通分量 因每个连通分量无回路 所以连通后得到的连通分量仍不会产生回路 此边应保留作为生成树的一条边 同时把端点所在的两个集合合并成一个 即成为一个连通分量 当选取的一条边的两个端点同属于一个集合时 此边应放弃 因同一个集合中的顶点是连通无回路的 若再加入一条边则必产生回路在上述例子中 当选取041213这三条边后 顶点的集合则变成如下 3 个04 123 5下一条边23的两端点同属于一个集合 故舍去 再下一条边15的两端点属于不同的集合 应保留 同时把两个集合123和5合并成一个1235 以此类推 直到所有顶点同属于一个集合 即进行了1次合并 保留了1条生成树的边为止为了用 语言编写出利用克鲁斯卡尔算法求图的最小生成树的具体实现 设  是具有  类型的边集数组 并假定每条边是按照权值从小到大的顺序存放的 再设  也是一个具有  类型的边集数组 用该数组存储依次所求得的生成树中的每一条边 另外 还要设一个具有  类型的一个二维数组 用 表示 它的每一行元素用来保存相应连通子图所在的顶点集合 若该行中的下标为  的元素为真 则表明顶点属于这个集合根据以上分析 给出克鲁斯卡尔算法的具体描述如下          求边集数组  所示图的最小生成树 树中每条边依次存于数组  中         定义具有  个元素的动态分配的二维数组          0      初始化  集合 使每一个顶点分属于对应集合    0   0            定义相应变量 1      表示待获取的最小生成树中的边数初值为1 0      表示在中待扫描边元素的下标位置初值为0 12    1和2分别保存一条边的两个顶点所在集合的序号进行1次循环得到最小生成树中的1条边    0              求出边的两个顶点所在集合的序号1和2         1         2        12            若两集合序号不等则表明是生成树中的一条边        应将它加入到数组中        1                0                      合并两个集合并将另一个置为空集            11  2            2                       后移一个位置以便扫描中的下一条边释放为动态分配的数组空间0   若利用图85所示的边集数组调用此算法则最后得到的数组如表82所示表82 数组  0  1  2  3  4   0  1  1  1  0   4  2  3  5  1   4  5  8  12  18 以上两个算法的时间复杂度均为2普里姆算法的空间复杂度为1克鲁斯卡尔算法的空间复杂度为2当一个连通网中不存在权值相同的边时无论采用什么方法得到的最小生成树都是唯一的但若存在着相同权值的边则得到的最小生成树可能不唯一当然最小生成树的权是相同的82 最短路径821 最短路径的概念由图的概念可知在一个图中若从一顶点到另一项点存在着一条路径本节只讨论无回路的简单路径则路径长度为该路径上所经过的边的数目它也等于该路径上的顶点数减1由于从一项点到另一项点可能存在着多条路径每条路径上所经过的边数可能不同即路径长度不同把路径长度最短即经过的边数最少的那条路径叫做最短路径其路径长度叫做最短路径长度或最短距离图的最短路径问题不只是对无权图而言的若图是带权图则把从一个顶点到图中其余任一个顶点的一条路径上所经过边的权值之和定义为该路径的带权路径长度从到可能不止一条路径把带权路径长度最短即其值最小的那条路径也称做最短路径其权值也称做最短路径长度或最短距离如图 86 所示从0  4共有 3 条路径0 40 1 3 4和0 1 2 4其带权路径长度分别为 30 23 和 38可知最短路径为0 1 3 4最短距离为 23 带权图 邻接矩阵图 86 带权图和对应的邻接矩阵实际上这两类最短路径问题可合并为一类只要把无权图上的每条边标上数值为1的权就归属于有权图了所以在以后的讨论中若不特别指明均认为是求带权图的最短路径问题求图的最短路径问题用途很广例如若用一个图表示城市之间的运输网图的顶点代表城市图上的边表示两端点对应城市之间存在着运输线边上的权表示该运输线上的运输时间或单位重量的运费考虑到两城市间的海拔高度不同流水方向不同等因素将造成来回运输时间或运费的不同所以这种图通常是一个有向图如何能够使从一城市到另一城市的运输时间最短或者运费最省呢这就是一个求两城市间的最短路径问题求图的最短路径问题包括两个方面求图中一顶点到其余各项点的最短路径求图中每对顶点之间的最短路径下面分别进行讨论82 2 从一顶点到其余各顶点的最短路径对于一个具有个顶点和条边的图 从某一项点称此为源点 到其余任一项点称此为终点 的最短路径 可能是它们之间的边或  也可能是经过个1    2 最多经过除源点和终点之外的所有顶点 中间顶点和1条边所形成的路径在图 86 中 从0到1的最短路径就是它们之间的有向边 01 其长度为 3 从0到4的最短路径经过两个中间点1和3以及 3 条有向边 01 13和 34 其长度为 23那么 如何求出从源点到图中其余每一个顶点的最短路径呢 狄克斯特拉  于 1959 年提出了解决此问题的一般算法 具体做法是按照从源点到其余每一顶点的最短路径长度的升序依次求出从源点到各顶点的最短路径及长度 每次求出从源点到一个终点的最短路径及长度后 都要以该顶点作为新考虑的中间点 用到的最短路径和最短路径长度对到其他尚未求出最短路径的那些终点的当前最短路径及长度作必要地修改 使之成为当前新的最短路径和最短路径长度 当进行2次 因最多考虑2个中间点 后算法结束狄克斯特拉算法需要设置一个集合 用表示 其作用是保存已求得最短路径的终点序号 它的初值中只有一个元素 即源点 以后每求出一个从源点到终点的最短路径 就将该顶点并入集合中 以便作为新考虑的中间点 还需要设置一个具有权值类型的一维数组   该数组中的第个元素  用来保存从源点到终点的目前最短路径长度 它的初值为或 边上的权值 若到没有边 则权值为  以后每考虑一个新的中间点时  的值可能变小 另外 再设置一个与  数组相对应的类型为  的一维指针数组  该数组中的第个元素  指向一个单链表 该单链表中保存着从源点到终点的目前最短路径 即一个顶点序列 当到存在着一条边时 则  初始指向由顶点和构成的单链表 否则  的初值为空此算法的执行过程是 首先从集合以外的顶点 即待求出最短路径的终点 所对应的  数组元素中 查找出其值最小的元素 假定为   该元素值就是从源点到终点的最短路径长度 证明从略 对应  数组中的元素  所指向的单链表链接着从源点到终点的最短路径 即经过的顶点序列或称边序列 接着把己求得最短路径的终点并入集合中 然后以作为新考虑的中间点 对集合以外的每个顶点 比较      为图的邻接矩阵 与  的大小 若前者小于后者 表明加入了新的中间点之后 从到的路径长度比原来变短 应用它替换  的原值 使  始终保持到目前为止最短的路径长度 同时把  单链表复制到  上 并在其后插入结点 使之构成从源点到终点的目前最短路径重复2次上述运算过程 即可在  数组中得到从源点到其余每个顶点的最短路径长度 在  数组中得到相应的最短路径为了简便起见 可采用一维数组来保存已求得最短路径的终点的集合 具体做法是 若顶点在集合中 则令数组元素的值为真 否则为假这样 当判断一个顶点是否在集合以外时 只要判断对应的数组元素是否为假即可例如对于图 86 来说若求从源点0到其余各顶点的最短路径则开始时 3 个一维数组  和  的值如表 83 所示表 83 初始状态  0  1  2  3  4    1  0  0  0  0    0  3  30    0 1  0 4开始进行第 1 次运算求出从源点0到第 1 个终点的最短路径首先从  元素为 0 的对应  元素中查找出值最小的元素求得 1的值最小所以第 1 个终点为1最短距离为 13最短路径为 101接着把 1置为真1表示1已加入  集合中然后以1为新考虑的中间点对  数组中元素为假0的每个顶点 此时2    4的目前最短路径长度 和目前最短路径 进行必要的修改因 11232528小于 2所以将 28 赋给 2将 1并上2后赋给 2同理因 1133811小于 3所以将 11 赋给 3将 1并上3后赋给 3最后再看从0到4以1作为新考虑的中间点的情况由于1到4没有出边所以 14故 114不小于 4因此 4和 4无需修改应维持原值至此第 1 次运算结束3 个一维数组的当前状态如表 84 所示表 84 得到终点1  0  1  2  3  4    1  1  0  0  0    0  3  28  11  30    0 10 1 20 1 30 4接着进行第 2 次运算求出从源点0到第 2 个终点的最短路径首先从  数组中元素为 0 的对应  元素中查找出值最小的元素求得 3的值最小所以第 2 个终点为3最短距离为 311最短路径为 3013接着把 3置为 1然后以3作为新考虑的中间点对  中元素为 0 的每个顶点 此时24的 和 进行必要的修改因 33211415小于 228所以将 15 赋给 2将 3并上2后赋给 2同理因 334111223小于 430所以将 23 赋给 4将 3并上4后赋给 4至此第 2 次运算结束3 个一维数组的当前状态如表 85 所示表 85 得到终点3  0  1  2  3  4    1  1  0  1  0    0  3  15  11  23    0 10 1 3 20 1 30 1 3 4然后进行第 3 次运算求出从源点0到第 3 个终点的最短路径首先从  中元素为0 的对应  元素中 查找出值最小的元素为2所以求得第 3 个终点为2最短距离为215最短路径为20132接着把2置为 1然后以2作为新考虑的中间点对中元素为 0 的每个顶点此时只有4一个的和进行必要的修改因224151025大于423所以无需修改原值不变至此第 3 次运算结束3 个一维数组的当前状态如表 86 所示表 86 得到终点2  0  1  2  3  4  3    5 0 1    0  3  15  11  23    0101320130134由于图中有 5 个顶点只需运算 3 次即2次虽然此时还有一个顶点未加入  集合中但它的最短路径及最短距离已经最后确定所以整个运算结束最后在中得到从源点0到每个顶点的最短路径长度在中得到相应的最短路径如果用图形表示上述过程中每次运算的结果则对应的图形分别如图 87图 87所示其中实线有向边所指向的顶点为集合  中的顶点虚线有向边所指向的顶点为集合  外的顶点 集合中的顶点上所标数值为从源点0到该顶点的最短路径长度从源点0到该顶点所经过的有向边为从0到该顶点的最短路径 集合外的顶点上所标数值为从源点0到该顶点的目前最短路径长度从0到该顶点所经过的有向边为从0到该顶点的目前最短路径为了便于对照分析把图 86重画于图 87中 带权图 初始状态 得到终点1 得到终点3 得到终点2图 87 利用狄克斯特拉算法求最短路径的图形说明根据以上分析和举例不难给出狄克斯特拉算法的描述如下                            利用狄克斯德拉算法求图中从顶点到其余每个顶点间的    最短距离和最短路径它们分别被存于数组和中         定义作为集合使用的动态数组         分别给和数组赋初值    0                                             1             2             1 2 2            12 1                                    共进行2次循环每次求出从源点到终点的最短路径及长度    1 2             求出第个终点                 0                                                      若条件成立则把顶点并入集合中否则退出循环因为剩余        的顶点其最短路径长度均为无需再计算下去                          对元素为的对应和中的元素作必要修改        0                                                     调用此函数由到顶点的最                                    短路径和顶点构成到顶点的目前最短路径                 函数的定义如下           由到顶点的最短路径和顶点构成到顶点的目前最短路径         把顶点的当前最短路径清除掉                                          把到顶点的最短路径复制过来到顶点的最短路径上                                                                    把顶点加入到 单链表的最后形成新的目前最短路径                 823 每对顶点之间的最短路径求图中每对顶点之间的最短路径是指把图中任意两个顶点和  之间的最短路径都计算出来若图中有个顶点则共需要计算1条最短路径解决此问题有两种方法第 1 种是分别以图中的每个顶点为源点共调用次狄克斯特拉算法因狄克斯特拉算法的时间复杂度为2所以此方法的时间复杂度为3第 2 种是采用下面介绍的弗洛伊德算法此算法的时间复杂度仍为3但比较简单弗洛伊德算法从图的邻接矩阵开始按照顶点011的次序分别以每个顶点0    1作为新考虑的中间点在第1次运算得到的11为图的邻接矩阵的基础上求出每对顶点到的目前最短路径长度计算公式为1 11  0    1  0    1其中函数表示取其参数表中的较小值参数表中的前项表在第1次运算后得到的从到的目前最短路径长度后项表示考虑以作为新的中间点所得到的从到的路径长度若后项小于前项则表明以作为中间点不排除已经以011中的一部分作为其中间点使得从到的路径长度变短所以应把它的值赋给否则把1的值赋给总之使保存第次运算后得到的从到的目前最短路径长度当从0取到1后矩阵1就是最后得到的结果其中每个元素1就是从顶点到的最短路径长度对于上面的计算公式当时变为1 11  0  1若0则参数表中的前项10后项1010必定大于等于0所以0中的对角线元素同1中的对角线元素一样均为0同理当121时中的对角线元素也均为0对于上面的计算公式当或时分别变为  1 11  0  1   1 11  0  1每个参数表中的后一项都由它的前一项加上1所组成因10所以和分别取上一次的运算结果1和1的值也就是说矩阵中的第行和第列上的元素均取上一次运算的结果下面以如图88所示中每对顶点之间的最短路径长度为例来说明弗洛伊德算法的运算过程 有向带权图 邻接矩阵 第0次运算结果 第1次运算结果 第2次运算结果 第3次运算结果图88 弗洛伊德算法求最短路径的运算过程1 令取0即以0作为新考虑的中间点对图88所示1中的每对顶点之间的路径长度进行必要的修改后得到第0次运算结果0如图88所示在0中第0行和第0列用虚线框起来表示和的情况它们同对角线上的元素一样为1中的对应值对于其他6个元素若通过新中间点0然后到的路径长度1010小于原来的路径长度1则用前者修改之否则仍保持原值因2到1的路径长度1215通过新中间点0后变短即为120101314所以被修改为 4  对应的路径为201 同样2到3的路径长度通过新中间点0后也由 8 变为 7  所以被修改为 7  对应的路径为203 剩余的 4 对顶点的路径长度 因加入0作为新中间点后仍不变短 所以保持原值不变2 令1 即以1作为新考虑的中间点 对0中每对顶点之间的路径长度进行必要的修改后得到第 1 次运算结果1 如图 88  所示此时第 1 行和第 1 列同对角线的元素一样 取上一次的值 对于其他 6 个元素 若通过新中间点1然后到的路径长度0101小于原来的路径长度0 则用前者修改之 否则仍保持原值因0到2的路径长度002 通过新中间点1后变短 即为0010121910 所以被修改为 10  对应的路径为0120到3的路径长度0034 通过新中间点1后变短 即为001013123 所以也被修改为 3  对应的路径为0132到3的路径长度0237 通过新中间点1后也变短 即为021013426 所以在第一次被修改的基础上又重新被修改为 6  对应的路径为021的路径201并上013的路径13 即为2013 剩余 3 对顶点的路径长度 因加入新中间点1后不变短 所以仍保持原值不变3 令2 即以2作为新考虑的中间点 对1中每对顶点的路径长度进行必要地修改 得到第 2 次运算的结果 如图 88 所示同上两次的分析过程一样 请读者分析这一次结果4 令3 即以3作为新考虑的中间点 这也是最后一个要考虑的中间点 在2的基础上进行运算 得到的运算结果3 如图 88 所示 也请读者自行分析3中的每个元素3的值就是图 88 中顶点到的最短路径长度当然相应的最短路径也可以 通过另设一个矩阵记录下来通过以上分析可知 在每次运算中 对 或的那些元素无需进行计算因为它们不会被修改 对于其余元素 只有满足111的元素才会被修改 即把小于号左边的两个元素之和赋给 在这两个元素中 前者是列号等于 后者是行号等于 所以它们在进行第次运算的整个过程中 其值都不会改变即为上一次运算的结果 故每一次运算都可以在原数组上 就地 进行 即用新修改的值替换原值即可 不需要使用两个数组交替进行假设有个顶点的一个带权图的邻接矩阵用  表示 与  同类型的 求每对顶点之间最短路径长度的二维数组用  表示  的初值等于 弗洛伊德算法需要在  上进行次运算 每次以0    1作为一个新考虑的中间点 求出每对顶点之间的当前最短路径长度 最后一次运算后  中的每个元素  就是图  中从顶点到顶点的最短路径长度利用 语言编写弗洛伊德算法如下 假定在该算法中不需要记录每对顶点之间的最短路径 只需要记录每对顶点之间的最短长度      利用弗洛伊德算法求  表示的图中每对顶点之间的最短长度对应保存于二维数组  中 给二维数组  赋初值 它等于图的邻接矩阵 0      0          依次以每个顶点作为中间点 逐步优化数组 0      0          0                                                          用下面程序调试弗洛伊德算法 使用字符串流所需的系统头文件   定义顶点值的类型   定义边上权值的类型  10 定义图的最多顶点数  1000 定义无边上的特定权值   定义  为存储顶点信息的数组类型   定义  为存储邻接矩阵的数组类型采用邻接矩阵存储的图的常用运算          弗洛伊德算法 函数定义同上      12    输入待处理图的顶点数    输入图的有无向和有无权选择 0 为无 非 0 为有12 2输入图的边集  100 输入一个图的边集011034129132203215238326 字符数组  中保存图 88的边集12以二元组形式输出邻接矩阵 12 2 每对顶点的最短路径保存在  中以二元组形式输出邻接矩阵 12程序运行结果如下输入待处理图的顶点数4输入图的有无向和有无权选择 0 为无 非 0 为有1 1输入图的边集以二元组形式输出邻接矩阵 0123011034129132203215238326以二元组形式输出邻接矩阵 01230110290341011128132203214236309311032683 拓扑排序831 拓扑排序的概念一个较大的工程经常被分成许多子工程把这些子工程称做活动在整个工程中有些子工程活动必须在其他有关子工程完成之后才能开始也就是说一个子工程的开始是以它的所有前序子工程的结束为先决条件的但有些子工程没有先决条件可以安排在任何时间开始为了形象地反映出整个工程中各个子工程活动之间的先后关系可用一个有向图来表示图中的顶点代表活动子工程图中的有向边代表活动的先后关系即有向边的起点的活动是终点活动的前序活动只有当起点活动完成之后其终点活动才能进行通常把这种顶点表示活动边表示活动间先后关系的有向图称做顶点活动网     例如一个计算机专业的学生必须完成如图 89 所示的全部课程   课程代号  课程名称  先修课程  1  高等数学  无 2  程序设计基础  无 3  离散数学  12 4  数据结构  35 5  算法语言  2 6  编译技术  45 7  操作系统  49 8  普通物理  1 9  计算机原理  8 图 89 课程表这里用课程代表活动学习一门课程就表示进行一项活动学习每门课程的先决条件是学完它的全部先修课程学习数据结构课程就必须安排在学完它的两门先修课程离散数学和算法语言之后学习高等数学课程则可以随时安排因为它是基础课程没有先修课用  网来表示这种课程安排的先后关系如图 810 所示图中的每个顶点代表一门课程每条有向边代表起点对应的课程是终点对应课程的先修课从图中可以清楚地看出各课程之间的先修和后续的关系如课程 5 的先修课为 2后续课程为 4 和 66 的先修课为 4 和 5它无后续课一个  网应该是一个有向无环图即不应该带有回路因为若带有回路则回路上的所有活动都无法进行如图 811 所示是一个具有三个顶点的回路由边可得  活动必须在  活动之后由边可得  活动必须在  活动之后所以推出  活动必然在  活动之后但由边可得  活动必须在  活动之前从而出现矛盾使每一项活动都无法进行这种情况若在程序中出现则称为死锁或死循环是应该必须避免的041  2022 图 810  网  2图 811 三个顶点的回路在  网中若不存在回路则所有活动可排列成一个线性序列使得每个活动的所有前驱活动都排在该活动的前面把此序列叫做拓扑序列 由 网构造拓扑序列的过程叫做拓扑排序 网的拓扑序列不是唯一的满足上述定义的任一线性序列都称做它的拓扑序列例如下面的3个序列都是图810的拓扑序列当然还可以写出许多1 1892354762 2135468973 123895467由网构造出拓扑序列的实际意义是如果按照拓扑序列中的顶点次序在开始每一项活动时能够保证它的所有前驱活动都已完成从而使整个工程顺序进行不会出现冲突的情况由网构造拓扑序列的拓扑排序算法主要是循环执行以下两步直到不存在入度为0的顶点为止1 选择一个入度为0的顶点并输出之2 从网中删除此顶点及所有出边循环结束后若输出的顶点数小于网中的顶点数则输出有回路信息否则输出的顶点序列就是一种拓扑序列如图812所示为例来说明拓扑排序算法的执行过程1 在图812中0和1的入度都为0不妨选择0并输出之接着删去顶点0及出边02得到的结果如图812所示2 在图812中只有一个入度为0的顶点1输出1接着删去1和它的三条出边1213和14得到的结果如图812所示3 在图812中2和4的入度都为0不妨选择2并输出之接着删去2及两条出边23和25得到的结果如图812所示4 在图812上依次输出顶点34和5并在每个顶点输出后删除该顶点及出边操作都很简单不再赘述 网 删除0后 删除1后 删除2后图812 拓扑排序的图形说明832 拓扑排序算法为了利用 语言在计算机上实现  网的拓扑排序  网采用邻接表表示较方便如对于图 812  对应的邻接表 如图 813 所示813图 813 图 812的链接表在拓扑排序算法中 需要设置一个包含个元素的一维整型数组 设用表示 用它来保存  网中每个顶点的入度值如对于图 812  得到数组的初始值为在进行拓扑排序中 为了把所有入度为 0 的顶点都保存起来 而且又便于插入删除以及节省存储 最好的方法是把它们链接成一个栈另外 在保存入度的数组中 当一个顶点的入度为 0 时 下标为的元素的值为 0  该元素也就空闲下来了 正好可利用它作为链栈中的一个结点使用 保存下一个入度为 0 的顶点的序号 这样就可以把所有入度为 0 的顶点通过数组中的对应元素静态地链接成一个栈对于被删除入边而新产生的入度为 0 的顶点就压入此栈 输出一个入度为 0 的顶点就是删除栈顶元素在这个链栈中 栈顶指针  指向一个入度为 0 的顶点 其值是数组中下一个入度为 0 的元素的下标 此处元素的值又是数组中另一个入度为 0 的元素的下标 以此类推 最后一个入度为 0 元素的值为 1  表示为栈底根据如图 813 所示的邻接表 建立的入度为 0 的初始栈的过程如下1 开始置链栈为空 即给链栈指针  赋初值为 1 12 将入度为 0 的元素0进栈0    0 此时  指向0元素 表示顶点0的入度为 0  而0的值为 1  表明为栈底3 将入度为 0 的元素1进栈 即1 1此时  指向 1元素表示顶点1的入度为 0而 1的值为 0表明下一个入度为 0 的元素为 0即对应下一个入度为 0 的顶点为00的值为 1所以此栈当前有两个元素 1和 04因 25的值均不为 0即对应的2  5的入度均不为 0所以它们均不进栈至此初始栈建立完毕得到的数组  为0  1  2  3  4  5 1  0  2  2  1  3 1由此可知数组  具有两方面功能存储所有顶点的入度链接入度为 0 的顶点形成链栈将入度为 0 的顶点利用上述链栈链接起来后拓扑算法中循环执行的选择一个入度为 0 的顶点并输出之可通过输出栈顶指针  所代表的顶点序号来实现从  网中删除刚输出的顶点假定为其中  等于  的值及所有出边可通过首先做退栈处理使  指向下个入度为 0 的元素然后遍历的邻接表分别把所有邻接点的入度减 1若减 1 后的入度为 0 则令该元素进栈等操作来实现此外该循环的终止条件直到不存在入度为 0 的顶点为止可通过判断栈空来实现对于图 812 当删除由  值所代表的顶点1及所有出边后数组  变为0  1  2  3  4  5 1  0  1  1  0  3 4当依次删除  所表示的每个顶点及所有出边后数组  的变化分别如图 814 所示0  1  2  3  4  5 1  0  1  1  0  2 0 删除顶点4及所有出边0  1  2  3  4  5 1  0  1  1  0  1 3 删除顶点2及所有出边0  1  2  3  4  5 1  0  1  1  0  2 2 删除顶点0及所有出边0  1  2  3  4  5 1  0  1  1  0  1 5 删除顶点3及所有出边图 814 数组  变化示意图当删除顶点5及所有出边后 的值为 1表示栈空至此此算法执行结束得到的拓扑序列为 140235根据以上分析给出拓扑排序算法的具体描述如下     对用邻接表  表示的有向图进行拓扑排序 0          用来统计拓扑序列中的顶点数定义存储图中每个顶点入度的一维整型数组  初始化数组  中的每个元素值为 00   0利用数组  中的对应元素统计出每个顶点的入度0                          初始化用于链接入度为 0 的元素的栈的栈顶指针  为11建立初始栈0      0   每循环一次删除一个顶点及所有出边1                                                   0                                  当输出的顶点数小于图中的顶点数时 输出有回路信息                        删除动态分配的数组 拓扑排序实际上是对邻接表表示的图  进行遍历的过程依次访问入度为 0 顶点的邻接表若  图没有回路则需要扫描邻接表中的所有边结点加上在算法开始时为建立入度数组  需要访问表头向量中的每个域和单链表中的每个结点所以此算法的时间复杂度为84 关键路径841 顶点事件的发生时间与上节  网相对应的是  网 即边表示活动的网络它与  网比较 更具有实用价值 通常用它表示一个工程的计划或进度 网是一个有向带权图 图中的边表示活动 子工程 边上的权表示该活动的持续时间  即完成该活动所需要的时间 图中的顶点表示事件 每个事件是活动之间的转接点 即表示它的所有入边活动到此完成 所有出边活动从此开始 网中有两个特殊的顶点 事件 一个称作源点 表示整个工程的开始 亦即最早活动的起点 显然它只有出边 没有入边 另一个称作汇点 表示整个工程的结束 亦即最后活动的终点 显然它只有入边 没有出边除这两个顶点外 其余顶点都既有入边 也有出边 是入边活动和出边活动的转接点在一个  网中 若包含有个事件 通常令源点为第 0 个事件 假定从 0 开始编号 汇点为第1个事件 其余事件的编号 即顶点序号 分别从1  2如图 815 所示是一个  网 该网中包含有 11 项活动和 9 个事件如边01表示活动1 持续时间 即权值 为 6  若以天为单位 即1需要 6 天完成 它以0事件为起点 以1事件为终点 边46和47分别表示活动7和8 它们的持续时间分别为 9 天和 7 天 它们均以4事件为起点 但分别以6和7事件为终点该网中的源点和汇点分别为第 0 个事件0和最后一个事件8 它们分别表示整个工程的开始和结束图 815 一个  网对于一个  网 待研究的问题是1 整个工程至少需要多长时间完成2 哪些活动是影响工程进度的关键在  网中 一个顶点事件的发生或出现必须在它的所有入边活动 或称前驱活动 都完成之后 也就是说 只要有一个入边活动没有完成 该事件就不可能发生显然 一个事件的最早发生时间是它的所有入边活动 或者说最后一个入边活动刚完成的时间同样 一个活动的开始必须在它的起点事件发生之后 也就是说 一个顶点事件没有发生时 它的所有出边活动 或称后继活动 都不可能开始显然一个活动的最早开始时间是它的起点事件的最早发生时间若用表示顶点事件的最早发生时间 用表示一条出边活动的最早开始时间则有对于  网中的源点事件来说因为它没有入边所以随时都可以发生整个工程的开始时间就是它的发生时间亦即最早发生时间通常把此时间定义为 0 即00从此开始推出其他事件的最早发生时间在图 815所示的  网中4事件的发生必须在4和5活动都完成之后而4和5活动的开始又必须分别在1和2事件的发生之后1和2事件的发生又必须分别在1和2活动的完成之后因1和2的活动都起于源点其最早开始时间均为 0 所以1和2的完成时间分别为 6 和 4 这也分别是1和2的最早发生时间以及4和5的最早开始时间故4和5的完成时间分别为 7 和 5 由此可知4事件的最早发生时间为 7 即所有入边活动中最后一个完成的时间从以上分析可知一个事件的发生有待于它的所有入边活动的全部完成而每个入边活动的开始和完成又有待于前驱事件的发生而每个前驱事件的发生又有待于它们的所有入边活动的完成总之一个事件发生在从源点到该顶点的所有路径上的活动都完成之后显然其最早发生时间应等于从源点到该顶点的所有路径上的最长路径长度这里所说的路径长度是指带权路径长度即等于路径上所有活动的持续时间之和如从源点0到顶点4共有两条路径长度分别为 7 和 5 所以4的最早发生时间为 7 从源点0到汇点8有多条路径通过分析可知其最长路径长度为 18 所以汇点8的最早发生时间为 18 汇点事件的发生表明整个工程中的所有活动都已完成所以完成图 815 所对应的工程至少需要 18 天现在接着讨论如何从源点0的最早发生时间 0 出发求出其余各事件的最早发生时间求一个事件的最早发生时间即从源点0  的最长路径长度的常用方法是由它的每个前驱事件的最早发生时间即从源点0  的最长路径长度分别加上相应入边上的权其值最大者就是的最早发生时间由此可知必须按照拓扑序列中的顶点次序即拓扑有序求出各个事件的最早发生时间才能保证在求一个事件的最早发生时间时它的所有前驱事件的最早发生时间都已求出设表示事件的最早发生时间表示的一个前驱事件的最早发生时间 表示边 上的权表示顶点所有入边的集合则  网中每个事件0    1的最早发生时间可由下式按照拓扑有序计算出来   1    1    00按照此公式和拓扑有序计算出图 815 所示的  网中每个事件的最早发生时间如下  00   1001066   2002044   3003055   4 114 224    61417   5335527   64467916 7 447 557 7774148 668 778 16214418最后得到的 8就是汇点的最早发生时间从而可知整个工程至少需要 18 天完成在不影响整个工程按时完成的前提下一些事件可以不在最早发生时间发生而允许向后推迟一些时间发生把最晚必须发生的时间叫做该事件的最迟发生时间同样在不影响整个工程按时完成的前提下一些活动可以不在最早开始时间开始而允许向后推迟一些时间开始把最晚必须开始的时间叫做该活动的最迟开始时间 网中的任一个事件若在最迟发生时间仍没有发生或任一项活动在最迟开始时间仍没有开始则必将影响整个工程的按时完成使工期拖延若用表示顶点事件的最迟发生时间用表示的一条入边 上活动的最迟开始时间用 表示的持续时间则有 因活动的最迟完成时间也就是它的终点事件的最迟发生时间所以的最迟开始时间应等于的最迟发生时间减去的持续时间或者说要比的最迟发生时间提前所需要的时间开始为了保证整个工程的按时完成所以把汇点的最迟发生时间定义为它的最早发生时间即其他每个事件的最迟发生时间应等于汇点的最迟发生时间减去从该事件的顶点到汇点的最长路径长度或者说每个事件的最迟发生时间比汇点的最迟发生时间所提前的时间应等于从该事件的顶点到汇点的最长路径上所有活动的持续时间之和求一个事件的最迟发生时间的常用方法是由它的每个后继事件的最迟发生时间分别减去相应出边 上的权其值最小者就是的最迟发生时间由此可知必须按照逆拓扑有序求出各个事件的最迟发生时间这样才能保证在求一个事件的最迟发生时间时它的所有后继事件的最迟发生时间都已求出设表示待求的事件的最迟发生时间表示的一个后继事件的最迟发生时间 表示边 上的权表示顶点的所有出边的集合则  网中每个事件0    1的最迟发生时间由下式按照逆拓扑有序计算出来1     10    2   按照此公式和逆拓扑有序计算得出图 815 所示的  网中每个事件的最迟发生时间如下  8818   787818414   686818216   575714410   4 747 646    1471697   35351028 24247161414716 0   101 202 303    6664850 84 2 计算关键路径的方法和算法 网中每个事件的最早发生时间和最迟发生时间计算出来后 可根据它们计算出每个活动的最早开始时间和最迟开始时间设事件的最早发生时间为 它的一个后继事件的最迟发生时间为 则边 上的活动的最早开始时间和最迟开始时间的计算公式重新列出如下  根据此计算公式可计算出  网中每一个活动的最早开始时间 最迟开始时间和开始时间余量如图 816 所示列出了图 815 中每一活动的这 3 个时间1234567891011                         0  0  0  6  4  5  7  7  7  16  14  0  2  3  6  6  8  7  7  10  16  14  0  2  3  0  2  3  0  0  3  0  0 图 816 计算出的图 815 中每个活动的 3 个时间其中 有些活动的开始时间余量不为 0  表明这些活动不在最早开始时间开始 至多向后拖延相应的开始时间余量所规定的时间开始也不会延误整个工程的进展如对于活动5 它最早可以从整个工程开工后的第 4 天开始 至多向后拖延两天 即从第 6 天开始有些活动的开始时间余量为 0  表明这些活动只能在最早开始时间开始 并且必须在持续时间内按时完成 否则将拖延整个工期把开始时间余量为 0 的活动称为关键活动 由关键活动所形成的从源点到汇点的每一条路径称为关键路径由图 815 中的关键活动构成两条关键路径为01468和01478 如图 817 所示 1项活动的开始时间余量为 0 故它们都是关键活动求一个  网的关键路径后 可通过加快关键活动 即缩短它的持续时间 来实现缩短整个工程的工期但并不是加快任何一个关键活动都可以缩短其整个工程的工期只有加快那些包括在所有关键路径上的关键活动才能达到这个目的例如加快图 817 中关键活动11的速度使之由 4 天完成变为 3 天完成则不能使整个工程的工期由 18 天变为 17因为另一条关键路径01468中不包括活动11这只能使它所在的关键路径01478变为非关键路径而活动1和4是包括在所有的关键路径中的若活动1由 6 天变为 4 天完成则整个工程的工期可由 18 天缩短为 16 天另一方面关键路径是可以变化的提高某些关键活动的速度可能使原来的非关键路径变为新的关键路径因而关键活动的速度提高是有限度的例如图 815 中关键活动1由 6 改为 4 后路径02468和02478都变成了关键路径此时再提高1的速度也不能使整个工程的工期提前下面给出用邻接表  表示一个  网的求关键路径的算法     求邻接表  表示的网的关键路径             动态定义具有个元素的三个一维整型数组和               保存拓扑排序的顶点序列              保存每个事件的最早发生时间              保存每个事件的最迟发生时间    调用拓扑排序算法使排序结果存于数组  中              需对上一节介绍的此算法做必要的修改 即在                                参数表中增加 一项把输出语句更换为即可                                给每个事件的最早发生时间置初值 0    0   0                                求出每个事件的最早发生时间    0                                                                                                         把每个事件的最迟发生时间都置为1以作为它们的初值    0   1                            求出每个事件的最迟发生时间    1 0                            输出网中每一个活动的最早开始时间最迟开始时间以及开始时间余量0                                    输出有向边用它表示该边上的活动                         输出的开始时间余量            求关键路径算法的时间复杂度同拓扑排序算法一样也为和分别表示图的顶点数和边数利用下面程序调试图的拓扑排序算法和关键路径算法  20                     采用邻接表存储的图的常用运算          对用邻接表表示的有向图进行拓扑排序       求邻接表表示的网的关键路径      12    输入待处理图的顶点数        输入图的有无向和有无权选择0为无非0为有    12             输入图的边集     100        12    程序的一次输入和运行结果如下输入待处理图的顶点数9输入图的有无向和有无权选择0为无非0为有1 1输入图的边集016024035141241352469477574682784030330202201000146602466235583477704677057710368161607814140习题 8习题 81运算题1 如图 818 所示针对有向图操作如下1 画出最小生成树并求出它的权2 从顶点0出发根据普里姆算法求出最小生成树的过程中把依次得到的各条边按序写出来3 根据克鲁斯卡尔算法求出最小生成树的过程中把依次得到的各条边按序写出来2 如图 819 所示利用狄克斯特拉算法求从顶点0到其余各顶点的最短路径并画出对应的图形表示图 818 无向带权图图 819 有向带权图3 已知一个图的二元组表示为01234567018032051012614201612241027153573674745666781按照克鲁斯卡尔算法求最小生成树写出依次得到的各条边2按照迪杰斯特拉算法求从顶点 0 到其余各顶点的最短路径4 如图 820 所示利用弗洛伊德算法求每对顶点之间的最短路径即仿照图 88 的运算过程给出从邻接矩阵出发每加入一个中间点后矩阵的变化5 如图 821 所示试给出一种拓扑序列若在它的邻接表存储结构中每个顶点邻接表中的边结点都是按照终点序号从大到小链接的则按此给出唯一一种拓扑序列图 820 有向带权图图 821  网6 一个  网的二元组表示为01234567891002041215243546475768767879810910在此  网的邻接表存储中若各项点邻接表中的边结点是按照邻接顶点序号从大到小链接的请写出按此邻接表和介绍的拓扑排序算法得到的拓扑序列提示先画出图形再运算7 如图 822 所示的网求1每个事件的最早发生时间和最迟发生时间2完成整个工程至少需要多长时间3每项活动的最早开始时间和最迟开始时间以及开始时间余量4画出由所有关键活动所构成的图5哪些活动加速可使整个工程提前完成图 822  网习题 82算法设计题1 采用简单插入排序方法对图的边集数组  中的所有边按边的权值的升序进行排序排序结果仍存于  中2 修改  算法在算法内部使用具有  类型的一个邻接表  代替二维数组 用一个单链表  表示一个集合若一个顶点属于这个集合则对应该单链表中的一个结点该结点的  域的值为该顶点序号3 编写一个程序调试上面第 1 和第 2 小题的两个算法4 编写一个程序调试一个带权图的狄克斯特拉算法以及对邻接矩阵常用运算的算法
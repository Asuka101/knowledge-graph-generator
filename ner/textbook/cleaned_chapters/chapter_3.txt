第 3 章 集合、稀疏矩阵和广义表

section3.1 集合的定义和抽象数据类型

subsection3.1.1 集合定义

集合 (set) 又称集合结构，由具有相同属性的数据元素组合而成，数据之间没有任何前驱和后继关系。集合中数据元素的个数称为集合的长度，假定用n表示，n geqslant 0。当n=0时则为空集。若集合为空，则表示为，若非空则表示为：lefta_1, a_2, cdots, a_i, a_i+1, cdots, a_nright其中每个元素的下标为对该元素的编号，它是为了区别而任意标注的，不代表任何次序。因为集合中的元素可以按任何次序排列，假定按元素前后位置编号的次序排列，那么a_1就是集合中第 1 个元素，a_2就是第 2 个元素，a_i就是第i个元素，a_n就是第n个（最后一个）元素。

像线性表一样，集合的长度是变化的，当向它插入一个元素后其长度就增加 1，当从中删除一个元素后其长度就减少 1。

集合中的元素类型可以为任何一种类型，用标识符 ElemType 表示。若实际的元素类型为某一具体类型，如整型，则可以通过 typedef 语句指定为 ElemType 类型。

subsection3.1.2 集合的抽象数据类型

集合的抽象数据类型同样包括数据和操作两个部分。数据部分为一个集合，假定用标识符 S 表示。操作部分包括对集合进行的各种常用运算，如初始化集合为空、清除集合中的所有元素、求集合中元素个数、判断集合是否为空、判断一个元素是否属于集合、输出集合中所有元素、从集合中查找一个元素、从集合删除一个元素、向集合插入一个元素、修改集合中的一个指定元素、求两个集合的并集、求两个集合的交集、求两个集合的差集等。

集合的抽象数据类型定义如下。

ADT SET is

Data:

一个集合 S，假定用标识符 SetT 表示抽象存储类型

Operation:

void InitSet(SetT& S); // 初始化集合为空

void ClearSet(SetT& S); // 清除集合中的所有元素

int LengthSet(SetT& S); // 求出集合的长度

bool EmptySet(SetT& S); //判断集合是否为空
bool InSet(SetT& S, ElemType item); //判断一个元素是否属于集合
void OutputSet(SetT& S); //输出集合中所有元素
bool FindSet(SetT& S, ElemType& item); //从集合中查找一个元素
bool ModifySet(SetT& S, const ElemType& item); //修改集合元素
bool InsertSet(SetT& S, ElemType item); //向集合插入一个元素
bool DeleteSet(SetT& S, ElemType& item); //从集合删除一个元素
void UnionSet(SetT& S1, SetT& S2, SetT& S); //求两个集合的并集
void InterseSet(SetT& S1, SetT& S2, SetT& S); //求两个集合的交集
void DifferenceSet(SetT& S1, SetT& S2, SetT& S); //求两个集合的差集
end SET

在以上列出的各种运算操作中，第 1、2、8~13 种运算需要改变集合 S 的状态，所以 S 必须为引用参数，而其他运算中的 S 参数和 11~13 种运算中的 S1 和 S2 参数，由于不需要改变它们，所以可采用常量引用，即在参数前加上 const 保留字。

section3.2 集合的顺序存储结构和操作实现

集合的顺序存储就是定义一个数组类型的对象来存储集合元素，同时要定义一个整数变量来存储当前集合长度和定义一个整型常量或变量来存储数组类型的长度。这 3 个对象的定义假定如下。

const int MaxSize=20; //定义存储集合元素的数组的长度
ElemType set[MaxSize]; //定义存储集合所有元素的数组
int len; //定义集合当前长度变量，取值在 0~MaxSize 之间

集合中的元素可以按任何次序存入到 set 数组中，不妨按照元素在集合中的位置次序相应保存到对应元素中，即第 1 个元素保存到下标为 0 的元素 set[0]中，第 2 个元素保存到下标为 1 的元素 set[1]中，以此类推。因为集合中的元素与次序无关，所以新添的元素则直接加到后面，删除一个元素后则把最后一个元素调到这个空出的位置上，使得插入和删除不需要移动任何元素，从而节省运算时间。

为了集合操作方便，可以把 set 数组和 len 变量封装在一个结构类型中，结构类型名用 Set 表示，具体定义如下。

struct Set 
    ElemType set[MaxSize];
    int len;
;

若对存储集合的数组空间采用动态分配，并且其数组长度能够随之改变，则可以定义出如下的 Set 类型。

struct Set 
    ElemType set; //set 指向动态分配的数组空间
    int len; //存集合当前长度
    int MaxSize; //存 set 数组长度，亦即所能存储集合的最大长度
;

定义一个集合对象之后，在初始化时要使该对象中的 set 指针指向由 new ElemType[MaxSize]或(ElemType)malloc(sizeof(Elemtype)MaxSize))分配的动态数组空间，同时使 len 的值为 0，表示为空集。

集合的顺序存储结构如图 3-1 所示。

下标012cdotsn-1n+1rightarrowMaxSize-1
set |a_1|a_2|a_3|cdots|a_n| | | | |
|---|---|---|---|---|---|---|---|---|---|
|  |  |  |  |  |  |  |  |  |  |

图 3-1 集合的顺序存储结构示意图

下面以 set 为集合的顺序存储类型，给出每个集合运算的算法。

1. 初始化集合并置为空

初始化集合时，让 set 指向动态数组空间，用于保存集合元素，数组空间的初始大小可以任意设定，假定为 10，以后可以在插入元素的过程中根据需要增加。

void InitSet(Set& S)

    //初始定义数组长度为 10,以后可增减
    S.MaxSize=10;
    //动态存储空间分配
    S.set=new ElemType [10];
    if (!S.set) 
        cout<<“动态可分配的存储空间用完,退出运行!”<<endl;
        exit(1);
    
    //置集合长度为 0,即为空集合
    S.len=0;


2. 清除集合中的所有元素

在 Set 集合类型的对象中，由于集合数组空间是动态分配的，所以清除集合就是释放所拥有的动态存储空间。

void ClearSet(Set& S)

    if(S.set!=NULL) 
        delete []S.set;
        S.set=NULL;
    
    S.MaxSize=0;


S.len=0;

3. 求出集合的长度, 即所含元素的个数

此算法返回集合 S 中的 len 域的值。

int LenthSet (Set& S)

    return S.len;


4. 判断集合是否为空

此算法很简单, 若集合长度为 0 则返回真表示空, 否则返回假表示非空。

bool EmptySet(Set& S)

    return S.len==0;


5. 判断一个元素是否属于集合

此算法就是一个顺序查找元素的过程。若找到表明该元素属于这个集合，则返回真;否则不属于这个集合，则返回假。

bool InSet(Set& S, ElemType item)

    for(int i=0; i<S.len; i++)
        if(S.set[i]==item) return true;
    return false;


6. 输出集合中所有元素

此算法使用一个 for 循环，依次输出 S 集合中 set 域数组中保存的每个元素的值。

void OutputSet(Set& S)

    for(int i=0; i<S.len; i++)
        cout<<S.set[i]<<' ';
    cout<<endl;


若要求输出的所有集合元素是按值的升序排列的，并且原有集合 S 的状态保持不变。
这时首先把集合 S 中 set 数组内容复制到一个临时数组中，然后对这个临时数组进行排序，
并按下标位置依次输出各元素值。对数组进行排序有多种不同方法，最简单的方法是简单插入排序和简单选择排序。

设数组 a 中含有n个元素，简单选择排序的方法是：需要依次进行n-1次循环，每次把 a 中n个元素看为一个有序表和一个无序表，第 1 次有序表为空，无序表含有全部n个元素，从无序表中顺序查找出一个最小值，把它与此表中第一个元素 a[0]交换其值，经此次后 a[0]成为最小值元素；接着进行第二次循环处理时，有序表中有一个元素 a[0]，无序表中有n-1个元素 a[1]~a[n-1]，第 2 次从当前无序表中查找一个最小值元素，把它与此表中第 1 个元素 a[1]交换其值，经此次后 a[1]成为此表的最小值元素，当然它小于等于 a[0]；然后进入第 3 次循环处理时，有序表中有两个元素 a[0]~a[1]，无序表中有n-2个元素 a[2]~a[n-1]，以此类推，进行n-1次循环处理时，有序表中已有n-2个元素 a[0]~a[n-3]，无序表中只有两个元素 a[n-2]~a[n-1]，从这两个元素中查找到最小值并交换到 a[n-2]位置后，整个数组中的元素就按值的升序排列好了。此排序方法与简单插入排序方法具有相同的时间复杂度，即为O(n^2)。

采用简单选择排序方法进行有序输出集合元素的算法如下。

void OutputSet1(Set& S)


    int i,j,k;
    ElemType a=new ElemType[S.len]; //定义临时数组 a
    for(i=0;i<S.len; i++)
        a[i]=S.set[i]; //把集合元素赋给数组 a
    for(i=0; i<S.len-1; i++) 
        k=i; //k 暂存本次最小值元素的下标
        for(j=i+1; j<S.len; j++)
            if(a[j]<a[k]) k=j; //顺序查找找出本次最小值元素 a[k]
        ElemType x=a[i]; a[i]=a[k]; a[k]=x; //a[k]同 a[i]交换其值
        cout<<a[i]<<' ';
    
    cout<<endl;
    delete []a;


7. 从集合中查找一个元素

此算法首先从集合中顺序查找值等于待查值 item 的元素，若存在则把该元素值赋给 item 引用参数带回，并返回真表示查找成功；若不存在，则返回假表示查找失败。

通常传递给 item 的待查值是一个元素的关键字，不是完整的记录。如对于学生记录，待查值是学号，对于产品记录，待查值是产品号。若查询到对应值的元素，则需要把该元素的完整值赋给 item 带回，以便使用。如可以通过 item 得到某个学生的成绩，某个产品的价格等。

bool FindSet(Set& S, ElemType& item) //从集合中查找一个元素

    for(int i=0; i<S.len; i++)
        if(S.set[i]==item) break;
    if(i<S.len) 

item=S.set[i];nreturn true;nnelse return false;nnn8. 修改集合中的一个指定元素nn此算法与查找算法类似, 需要首先在集合中顺序查找待修改的元素, 即关键字等于item关键字的元素, 若找到相应元素则用item的完整值修改这个元素, 使它具有item的值, 并返回真; 若未找到则无法修改, 返回假表示修改失败。nnbool ModifySet(Set& S, const ElemType& item)nn    for(int i=0; i<S.len; i++)n        if(S.set[i]==item) break;n    if(i<S.len) n        S.set[i]=item;n        return true;n    n    else return false;nnn9. 向集合插入一个元素nn此算法包含如下5个步骤。n(1) 顺序查找集合中是否存在值为待插值item的元素, 若存在则不能插入, 返回假, 因为集合中不允许存在重复的元素。n(2) 检查集合空间是否用完, 若是则动态重分配, 增加存储空间。n(3) 把item值插入到表尾 (即最后一个集合元素的后面空位置) 上。n(4) 集合长度增 1 。n(5) 返回真表示插入成功。n对应的算法描述如下。nnbool InsertSet(Set& S, ElemType item)   //向集合插入一个元素nn    int i;n    for(i=0; i<S.len; i++)                  //元素已存在, 返回假表示不用插入n        if(S.set[i]==item) return false;n    if(S.len==S.MaxSize)                  //若集合存储空间用完, 则重新分配较大空间n        int k=sizeof(ElemType);             //计算每个元素存储空间的长度n        S.set=(ElemType)realloc(S.set, 2S.MaxSizek);n        //集合动态存储空间扩展为原来的 2 倍, 原内容不变n        if(S.set==NULL) n            cout<<"动态可分配的存储空间用完,退出运行!"<<endl;n            exit(1);n


S.MaxSize=2S.MaxSize; //把集合空间大小修改为新的长度

S.set[S.len]=item; //在末尾插入新元素
S.len++; //集合长度增1
return true; //返回真表示插入成功


10. 从集合删除一个元素

此算法首先从集合中顺序查找值等于待删值 item 的元素, 若存在该元素, 则由 item 带回并删除它, 把空出的位置用最后一个元素填补, 接着若集合数组空间空余过多可释放一半, 然后使集合长度减 1 , 返回真表示删除成功。若集合中不存在, 则无法删除, 返回假表示删除失败。

bool DeleteSet(Set& S, ElemType& item) //从集合删除一个元素

int i;
for(i=0; i<S.len; i++)
if(S.set[i]==item) break;
if(i<S.len) 
//删除 set[i]元素
item=S.set[i]; //由 item 带回被删元素的完整值
S.set[i]=S.set[S.len-1]; //用最后一个元素填补
S.len--; //集合长度减1
if((float(S.len)/S.MaxSize<0.4 && S.MaxSize>10))
 //若集合存储空间空余太多,则进行适当削减,若不削减可省此步
int k=sizeof(ElemType);
S.set=(ElemType)realloc(S.set, S.MaxSizek/2);
S.MaxSize=S.MaxSize/2; //把集合空间大小修改为新的长度

return true; //删除成功返回真

else return false; //删除失败返回假


集合的插入和删除元素均需要一个查找过程, 所以其算法的时间复杂度均为O(n),n表示集合长度。

11. 求两个集合的并集

该算法是求两个集合 S1 和 S2 的并集, 并将结果存入 S 引用参数所表示的集合中带回。首先把 S1 集合复制到 S 集合中, 然后把 S2 中的每个元素依次插入到集合 S 中, 当然重复的元素不应该被插入, 最后在 S 中就得到了 S1 和 S2 的并集, 也就是在 S 所对应的实际参数集合中得到并集。

把 S1 集合复制到 S 集合中, 可以通过遍历 S1 集合中的每个元素, 并调用插入算法把

它插入到 S 集合来实现, 这样其时间复杂度为O(n^2), 其中n表示集合 S1 的长度。因为每插入一个元素都要比较 S 集合中的当前所有元素后, 才能插入到表尾。每插入一个元素的时间复杂度为O(n), 所以插入n个元素的时间复杂度为O(n^2)。在下面算法中, S1 复制到 S 采用元素直接赋值的方法, 其时间复杂度仅为O(n)。

在 Set 集合类型的对象中, 存在着动态分配的存储空间, 所以不能简单地采用赋值语句进行直接赋值式的复制, 若这样的话, 不同对象的 set 指针将指向同一个动态存储空间, 即不同的对象共同占用该空间, 这是系统所不允许的。道理很简单, 正常释放一个对象中 set 所指向的动态存储空间后, 共同使用该空间的其他对象中由 set 所指向的动态存储空间也被非法的释放而无法访问。因此, 对于含有动态存储空间的对象, 在复制时必须使之具有不同的动态存储空间, 并且必须把被复制对象中动态存储空间所保存的内容复制到复制对象的动态存储空间中。

下面算法共包含 4 步, 其中前 3 步完成把 S1 复制到 S 的任务, 第 4 步通过把 S2 中的每个元素插入到 S 集合中, 完成两集合的并运算。设 S1 和 S2 集合的长度分别为n和m, 则此算法的时间复杂度主要由第 4 步求出, 为O(n times m)。

void UnionSet(Set& S1, Set& S2, Set& S)

    int i;
    if(S.MaxSize<S1.MaxSize)    //为了把S1复制到S,重分配S动态数组
        delete []S.set;
        S.set=new ElemType[S1.MaxSize];
        S.MaxSize=S1.MaxSize;
    
    for(i=0; i<S1.len; i++)       //S1集合中的全部元素依次复制到S中
        S.set[i]=S1.set[i];
    S.len=S1.len;                 //置集合S的长度为S1的长度
    for(i=0; i<S2.len; i++)       //向集合S依次插入集合S2中的每个元素
        InsertSet(S,S2.set[i]);


12. 求两个集合的交集

此算法首先把存放结果的集合 S 变为一个空集, 然后依次从 S2 集合中取出每一个元素, 利用它去查找 S1 集合, 看是否存在, 若存在则把它写入交集 S 中, 这样写入 S 中的元素既属于 S1 又属于 S2。在此算法中, 从 S1 中查找一个元素的时间复杂度为O(n), 所以整个算法的时间复杂度为O(n times m)。

void InterseSet(Set& S1, Set& S2, Set& S)

    int i;
    ElemType x;
    S.len=0;                      //置集合S为一个空集
    for(i=0; i<S2.len; i++)      //用S2中的每个元素去查找S1集合

x=S2.set[i];
if(FindSet(S1,x)) 
    S.set[S.len]=x; S.len++;              //把x插入S集合末尾
    if(S.len==S.MaxSize) 
        int k=sizeof(ElemType);
        S.set=(ElemType)realloc(S.set, 2S.MaxSizek);
        S.MaxSize=2S.MaxSize;
    


13. 求两个集合的差集

此算法同求交集的算法类似，首先把存放结果的集合S变为一个空集，然后依次从S1n集合中取出每一个元素，利用它去查找S2集合，看是否存在，若不存在则把它写入差集Sn中，这样写入S中的元素仅属于S1而不属于S2。此算法的时间复杂度同样为O(ntimes m)。

void DifferenceSet(Set& S1, Set& S2, Set& S)

    int i;
    ElemType x;
    S.len=0;                              //置集合S为一个空集
    for(i=0; i<S1.len; i++) 
        x=S1.set[i];                      //用S1中的每个元素去查找S2集合
        if(!FindSet(S2,x)) 
            S.set[S.len]=x; S.len++;      //把x插入S集合末尾
            if(S.len==S.MaxSize) 
                int k=sizeof(ElemType);
                S.set=(ElemType)realloc(S.set, 2S.MaxSizek);
                S.MaxSize=2S.MaxSize;
            
        
    


3.3 集合的链接存储结构和操作实现

集合的顺序存储结构是通过数组实现的，而集合的链接存储结构是通过存储结点之间的n链接实现的，链接形成的结果称为链接表，通常采用单链表。n当一个集合利用单链表存储时，集合中的每个元素对应单链表中的一个结点，把这个n元素存储到相应结点的值域中。由于集合中的元素是无序的，所以在单链表中可以按任何

次序链接。通常, 当向表示集合的单链表中插入一个元素结点时, 为操作简便, 把它插入到表头, 即插入到第1个结点的前面, 使它成为新的表头结点, 而原来的表头结点成为第2个结点, 此时只修改新插入结点的指针域, 使其指向原来的表头结点, 再修改表头指针,使其指向新插入的结点, 从而完成结点的插入过程。当从单链表中删除一个结点时, 就是把该结点的指针域的值 (即后一结点的地址) 赋给其前一结点的指针域即可, 若它本身为表头结点, 则应把该结点的指针域的值赋给表头指针。

表示集合的单链表的结点结构定义如下。

struct SNode 
    ElemType data;
    SNode next;
;

其中 SNode 为结点类型, data 为存储元素值的结点值域, next 为存储下一个结点地址的指针域。

由于单链表中的结点通常是靠动态分配产生的, 不需要事先分配存储空间, 所以存储一个单链表只需要存储它的表头指针即可。由表头指针就能够访问该单链表。假定表头指针用 HT 表示, 则 HT 应定义为:

SNode Head;   //集合单链表的表头指针

集合单链表的示意图如图 3-2 所示。

HTrightarrowboxeda_1rightarrowboxeda_2rightarrow...rightarrowboxeda_irightarrowboxeda_i+1rightarrow...rightarrowboxeda_n

图 3-2 集合单链表的示意图

按照集合的抽象数据类型的定义, 假定集合存储采用单链表结构, 由表头指针 HT 表示, 下面给出对集合的各种操作在单链表上的实现。熟悉了第 2 章对用单链表表示的进行线性表操作的各种算法, 以及上面面对顺序表 (数组) 表示的进行集合操作的各种算法后,同学们也不难写出下面面对用单链表表示的进行集合操作的各种算法。

section1. 初始化集合为空

void InitSet(SNode& HT)

    HT=NULL;


section2. 清除集合中的所有元素并释放占有的动态存储空间

void ClearSet(SNode& HT)

    SNode p=HT, q;           //p 指向 Head 单链表
    while(p!=NULL)             //回收 Head 集合中的每个结点
        q=p->next;              //q 指向 p 的后继结点

delete p; //删除p结点
p=q; //使p指向原来的后继结点

HT=NULL; //置Head为空


3. 求出集合中元素个数

int LenthSet(SNode HT) //求集合长度

    int n=0;
    while(HT!=NULL) 
        n++;
        HT=HT->next;
    
    return n;


4. 判断集合是否为空

bool EmptySet(SNode HT)

    return HT==NULL;


5. 判断一个元素是否属于集合

bool InSet(SNode HT, ElemType item)

    while(HT!=NULL) 
        if(HT->data==item) return true;
        else HT=HT->next;
    
    return false;


6. 输出集合中所有元素

void OutputSet(SNode HT)

    while(HT!=NULL) 
        cout<<HT->data<<' ';
        HT=HT->next;
    
    cout<<endl;


7. 从集合中查找一个元素

bool FindSet (SNode HT, ElemType& item)

    //从集合单链表中顺序查找是否存在值为item的结点
    while(HT!=NULL) 
        if(HT->data==item) break;
        else HT=HT->next;
    
    //若存在由item带回已查找到的元素并返回真,否则返回假
    if(HT!=NULL) 
        item=HT->data; return true;
    
    else return false;


8. 修改集合中的一个指定元素

bool ModifySet(SNode HT, const ElemType& item)

    //从集合单链表中顺序查找是否存在值为item的结点
    while(HT!=NULL) 
        if(HT->data==item) break;
        else HT=HT->next;
    
    //若存在,由item修改已查找到的元素并返回真,否则返回假
    if(HT!=NULL) 
        HT->data=item; return true;
    
    else return false;


9. 向集合插入一个元素

bool InsertSet(SNode& HT, ElemType item)

    //建立值为item的新结点
    SNode tp=new SNode;
    tp->data=item;
    //从单链表中顺序查找是否存在值为item的结点
    SNode p=HT;
    while(p!=NULL) 
        if(p->data==item) break;
        else p=p->next;
    
    //若不存在则把新结点插入到表头并返回真,否则不插入返回假

```cpp
if(p==NULL) 
    tp->next=HT; HT=tp; return true;

else return false;


10. 从集合删除一个元素

bool DeleteSet(SNode& HT, ElemType& item)

    //从单链表中顺序查找是否存在值为 item 的结点
    SNode cp=HT, ap=NULL;
    while(cp!=NULL) 
        if(cp->data==item) break;
        else ap=cp; cp=cp->next;
    
    //若不存在则返回假，表明删除成功
    if(cp==NULL) return false;
    //由 item 带回待删除结点 cp 的完整值，若不需要带回可设 item 为值参
    item=cp->data;
    //从单链表中删除已找到的 cp 结点，对是否为表头应做不同处理
    if(ap==NULL) HT=cp->next;
    else ap->next=cp->next;
    //删除 cp 结点后返回真
    delete cp;
    return true;


11. 求两个集合的并集

void UnionSet(SNode HT1, SNode HT2, SNode& HT)

    //置并集的表头指针 HT 为空
    HT=NULL;
    //把 HT1 集合单链表复制到 HT 集合单链表中
    SNode p=HT1;
    while(p!=NULL) 
        //建立新结点并赋值为 p->data
        SNode newp=new SNode;
        newp->data=p->data;
        //把新结点插入到 HT 集合单链表的表头
        newp->next=HT; HT=newp;
        //使 p 指向下一个结点
        p=p->next;
    
    //把 HT2 集合单链表中的每个元素插入到 HT 集合单链表中

```

p=HT2;
while(p!=NULL) 
    InsertSet(HT, p->data);
    p=p->next;


12. 求两个集合的交集

void InterseSet(SNode HT1, SNode HT2, SNode& HT)

//置交集的表头指针 HT 为空
HT=NULL;
//把 HT1 集合与 HT2 集合中共同的元素插入到 HT 集合中
ElemType x;
SNode p=HT2;
while(p!=NULL) 
    x=p->data;                      //将 p->data 赋给 x
    bool b=FindSet(HT1,x);         //用 x 查找 HT1 集合
    if(b) InsertSet(HT,x);         //若查找成功则把 x 插入到 HT 集合中
    p=p->next;                     //使 p 指向下一个结点



13. 求两个集合的差集

void DifferenceSet(SNode HT1, SNode HT2, SNode& HT)

//置差集的表头指针 HT 为空
HT=NULL;
//把存在于 HT1 集合而不存在于 HT2 集合中的元素插入到 HT 集合中
ElemType x;
SNode p=HT1;
while(p!=NULL) 
    x=p->data;                      //将 p->data 赋给 x
    bool b=FindSet(HT2,x);         //用 x 查找 HT2 集合
    if(!b) InsertSet(HT,x);        //若查找失败则把 x 插入到 HT 集合中
    p=p->next;                     //使 p 指向下一个结点



同对线性表的存储一样，对集合除了可以进行顺序存储和链接存储外，还可以进行散列存储和索引存储，相应地也能够根据具体的运算要求编写出利用 C++语言实现的算法，待以后学习过这两种存储结构后能够比较容易地编写出来。n在集合抽象数据类型中规定的各种操作只是一些典型的操作，当然在实际应用中还有

许多。如根据一个集合建立顺序存储结构或建立链接存储结构, 从集合顺序表或单链表中查找出所有具有同一属性值的元素并输出出来, 从任一存储结构的集合中查找具有最大或最小值的元素, 把一个顺序表或单链表表示的集合按某一条件分解为两个集合等。读者只要掌握集合的典型操作, 对其他任何操作的算法将不难编写出来。

section3.4 稀疏矩阵

subsection3.4.1 稀疏矩阵的定义

section1. 稀疏矩阵的概念

为了说明什么是稀疏矩阵, 首先要清楚矩阵的概念。矩阵 (matrix) 是一个具有m行times n列的数表, 共包含有m times n个数（元素）, 每个元素处在确定行和列的交点位置上, 都与一对行号和列号唯一对应。当一个矩阵中的行数和列数相同时, 即m=n时则称为n阶矩阵或方阵。如图 3-3(a) 就是一个3 times 4的矩阵, 它包含 3 行、4 列, 具有 12 个元素, 每个元素都对应着唯一的行号和列号, 如第 1 行与第 1 列交点位置上的元素 5 对应的行号和列号均为 1 , 第 2 行与第 4 列交点位置上的元素 9 对应的行号和列号分别为 2 和 4 。beginarrayll1 & 2  1 & 5 -284  2 & 94-19  3 & 0721endarray(a) 一般矩阵beginarraylll1 & 2 & 3  1 & 300500  2 & 00-2000  3 & 104060  4 & 000000  5 & 00-1000endarray(b) 稀疏矩阵

图 3-3 矩阵和稀疏矩阵

稀疏矩阵 (sparse matrix) 是矩阵中的一种特殊情况, 其非零元素的个数远远小于零元素的个数。如图 3-3(b) 就是一个5 times 6的稀疏矩阵, 该矩阵共有 30 个元素, 其中非零元素为 7 个, 占元素总数的 7/30。在实际应用中, 稀疏矩阵一般都比较大, 非零元素所占的比例都比较小。如对于一个100 times 100的稀疏矩阵, 若非零元素的个数为 200 , 则非零元素占总元素个数的比例仅为 1/50。

section2. 稀疏矩阵的三元组线性表示

在计算机中存储矩阵的一般方法是采用二维数组, 其优点是可以随机地访问任一个元素, 因而能够较容易地实现矩阵的各种运算, 如转置运算、加法运算、乘法运算等。但对于稀疏矩阵来说, 采用二维数组的存储方法既浪费大量的存储单元用来存放零元素, 又要在运算中花费大量的时间来进行零元素的无效计算, 显然是不可取的。一种较好的方法是:只考虑存储占元素中极少数的非零元素。

对于稀疏矩阵中的每个非零元素，可用它所在的行号、列号以及元素值这三元组(i,j,a_ij)来表示。若把所有的三元组按照行号为主序（即为主关键字）、列号为辅序（即为次关键字，当行号相同时再考虑列号次序）进行排列，则就构成了一个表示稀疏矩阵的三元组线性表。图 3-3 (b) 稀疏矩阵所对应的三元组线性表表示为：left((1,1,3),(1,4,5),(2,3,-2),(3,1,1),(3,3,4),(3,5,6),(5,3,-1)right)稀疏矩阵采用三元组线性表表示后，可以使用顺序或链接方式存储，从而比采用二维数组存储要大大地节省存储空间。

section3. 稀疏矩阵的抽象数据类型

该抽象数据类型的数据部分为用三元组线性表表示的稀疏矩阵，操作部分所包含的操作与对一般矩阵所做的操作相同，通常为求一个稀疏矩阵的转置，计算两个矩阵的和，计算两个矩阵的乘积等。一个矩阵的转置结果仍是一个矩阵，该矩阵中的第i行与第j列交点位置上的元素等于被转置矩阵中第j行与第i列交点位置上的元素。两个矩阵的和仍然是一个矩阵，该矩阵中的第i行第j列位置上的元素等于两个相加矩阵中对应位置上的元素之和。两矩阵求和的条件是它们的行数和列数必须分别对应相同。两个矩阵的乘积仍然是一个矩阵，该矩阵中的第i行与第j列位置上的元素等于第 1 个乘数矩阵中的第i行与第 2 个乘数矩阵中的第j列上对应元素乘积之累加和。假定第 1 个乘数矩阵为A[m][n]，第 2 个乘数矩阵为B[n][p]，乘积结果矩阵为C[m][p]，则C中任一元素C[i][j]等于sum_k=1^n(A[i][k] times B[k][j])，其中1 leq i leq m，1 leq j leq p。两矩阵求积的条件是第 1 个矩阵的列数必须等于第 2 个矩阵的行数。

下面给出稀疏矩阵的抽象数据类型的定义。

ADT SparseMatrix is

Data:

采用顺序或链接方式存储的稀疏矩阵，假定其存储类型用 SMatrix 标识符表示

Operation:

//初始化稀疏矩阵 M，使它成为不含任何元素的空矩阵

void InitMatrix(SMatrix& M);

//求出稀疏矩阵 M 的转置矩阵并返回

SMatrix Transpose(SMatrix& M);

//求出 M1 和 M2 稀疏矩阵之和并返回

SMatrix Add(SMatrix& M1, SMatrix& M2);

//求出 M1 和 M2 稀疏矩阵之乘积并返回

SMatrix Multiply(SMatrix& M1, SMatrix& M2);

//按照一定格式向稀疏矩阵 M 输入所对应的三元组线性表

void InputMatrix(SMatrix& M, int m, int n);

//按照一定格式输出稀疏矩阵 M

void OutputMatrix(SMatrix& M);

end SparseMatrix

3.4.2 稀疏矩阵的存储结构

稀疏矩阵的存储结构包括顺序存储结构和链接存储结构两种。在任一种存储结构中,除了存储三元组线性表中的所有元素之外，通常还需要存储稀疏矩阵的行数、列数和非零元素的个数这 3 个整型量。

1. 顺序存储

稀疏矩阵的顺序存储就是对其相应的三元组线性表进行顺序存储。假定每个非零元素的三元组用如下记录结构定义。

struct Triple 
    int row, col;
    ElemType val;
;

其中, row 和 col 用来分别存储元素的行号和列号, val 用来存储元素值。

一个稀疏矩阵的顺序存储类型定义如下。

struct SMatrix 
    int m, n, t;
    Triple sm[MaxTerms+1];
;

其中, m、n 和 t 域分别用来存储稀疏矩阵的行数、列数和非零元素的个数, sm 数组域用来顺序存储每个三元组元素, 假定下标为 0 的元素 sm[0]不用, 从下标为 1 起使用.MaxTerms 为一个事先定义的全局常量, 由它决定 sm 数组的大小, 该数组最多能够存储 MaxTerms 个三元组元素。例如, 若用 SMatrix 类型的对象存储图 3-3(b) 所示的稀疏矩阵, 则 m、n 和 t 域的值应分别为 5、6 和 7, MaxTerms 常量应大于等于 7, sm 数组中的内容如图 3-4 所示。

下标
1 | 1 | 1 | 3 |
2 | 1 | 4 | 5 |
3 | 2 | 3 | -2 |
4 | 3 | 1 | 1 |
5 | 3 | 3 | 4 |
6 | 3 | 5 | 6 |
7 | 5 | 3 | -1 |
| ... | ... | ... | ... |
MaxTerms | ... | ... | ... |

图 3-4 稀疏矩阵的顺序存储结构

2. 链接存储

稀疏矩阵的链接存储就是对其相应的三元组线性表进行链接存储。下面介绍两种链接存储方法。

(1) 带行指针向量的链接存储。

在这种链接存储中, 需要把具有相同行号的三元组结点按照列号从小到大的顺序链接成一个单链表, 每个三元组结点的类型定义如下。

struct TripleNode 
    int row, col;                // 存储行号和列号
    ElemType val;                // 存储元素值
    TripleNode next;            // 指向同一行的下一个结点
;

稀疏矩阵中的每一行对应一个单链表, 每一个单链表都有一个表头指针, 为了把它们保存起来, 便于访问每一个单链表, 需要使用一个行指针向量 (即一维数组), 该向量中的第i个分量 (即对应数组中下标为i的元素) 用来存储稀疏矩阵中第i行所对应的单链表的表头指针。带行指针向量的链接存储类型定义如下。

struct LMatrix 
    int m, n, t;
    TripleNode vector[MaxRows+1];
;

其中, 整数域mathrmm 、 mathrmn和mathrmt分别用来保存稀疏矩阵的行数、列数和非零元素的个数, vector 数组 (向量) 域用来保存稀疏矩阵所对应的mathrmm个行单链表的表头指针, 第 0 分量未用, 第i行单链表的表头指针存于第i分量 vector[i] 中, MaxRows 为全局变量, 其值要大于等于所存储矩阵的行数。

利用 LMatrix 类型的对象存储图 3-3(b) 所示的稀疏矩阵, 则链接存储结构如图 3-5 所示, 其中每个单链表中的结点由动态分配链接而成。

分量编号 行指针向量

1 |-> [1 1 3]->[1 4 5]

2 |-> [2 3 -2]

3 |-> [3 1 1]->[3 3 4]->[3 5 6]

4

5 |-> [5 3 -1]

图 3-5 带行指针向量的链接存储结构

(2) 十字链接存储。

十字链接存储是既带行指针向量又带列指针向量的链接存储。在这种链接存储中, 每个三元组结点既处于同一行的单链表中, 又处于同一列的单链表中, 即处于所在的行单链

表和列单链表的交点处。

在十字链接存储中，每个结点的类型可定义如下。

struct CrossNode 
    int row, col;
    ElemType val;
    CrossNode down, right;
;

其中 row、col 和 val 域分别用来存储非零元素的行号、列号和元素值，down 域用来存储指向同一列下一个结点的指针，right 域用来存储指向同一行下一个结点的指针，当然若不存在下一个结点，则相应的指针域为空值。

在稀疏矩阵的十字链接存储中，需要使用两个指针向量，一个是行指针向量，用来存储行单链表的表头指针，另一个是列指针向量，用来存储列单链表的表头指针。稀疏矩阵的十字链接存储类型定义如下。

struct C1Matrix 
    int m, n, t;
    CrossNode rv[MaxRows+1];
    CrossNode cv[MaxColumns+1];
;

其中，全局常量 MaxRows 用来规定行指针向量的大小，全局常量 MaxColumns 用来规定列指针向量的大小，它们应分别大于等于所存稀疏矩阵的行数和列数。同样，在 rv 和 cv 向量中，下标为 0 的元素未用。

利用图 3-3(b) 所示的稀疏矩阵，则得到十字链接存储结构的示意图，如图 3-6 所示。

列向量 1 2 3 4 5 6
行向量
1 [1 1 3] -> [1 4 5]
2 [2 3 -2]
3 [3 1 1] -> [3 3 4] -> [3 5 6]
4 [5 3 -1]

图 3-6 稀疏矩阵的十字链接存储结构

3.4.3 稀疏矩阵的运算

1. 初始化运算

稀疏矩阵的存储类型不同，其初始化过程也不同。

(1) 对于 SMatrix 类型的对象，初始化过程如下。

void InitMatrix(SMatrix& M)

    M.m=0; M.n=0; M.t=0;


(2) 对于 LMatrix 类型的对象，其初始化如下。

void InitMatrix(LMatrix& M)

    M.m=0; M.n=0; M.t=0;
    for(int i=1; i<=MaxRows; i++)
        M.vector[i]=NULL;


(3) 对于 CLMatrix 类型的对象，初始化如下。

void InitMatrix(CLMatrix& M)

    M.m=0; M.n=0; M.t=0;
    for(int i=1; i<=MaxRows; i++)
        M.rv[i]=NULL;
    for(i=1; i<=MaxColumns; i++)
        M.cv[i]=NULL;


2. 稀疏矩阵的输入

稀疏矩阵的输入应按照对应三元组线性表中三元组排列的次序输入，每行输入一个三元组，行号、列号和元素值之间用空格分开，最后以回车键结束。当输入完所有三元组后，以输入一个特殊的三元组(0,0,0)结束整个输入过程。假定稀疏矩阵采用 SMatrix 类型存储，下面给出相应的输入算法。其中，引用参数 M 表示 SMatrix 类型的稀疏矩阵，m 和 n 分别表示矩阵的行数和列数。

void InputMatrix(SMatrix& M, int m, int n)

    M.m=m; M.n=n;
    int row, col, val;
    int k=0;
    cin>>row>>col>>val;

```c
while(row!=0) 
    k++;
    M.sm[k].row=row;
    M.sm[k].col=col;
    M.sm[k].val=val;
    cin>>row>>col>>val;

M.t=k;


若稀疏矩阵采用十字链表存储，则相应的输入算法如下。

void InputMatrix(CLMatrix& M, int m, int n)

    M.m=m; M.n=n;
    int row, col, val;
    int k=0;
    cin>>row>>col>>val;
    while(row!=0) 
        k++;
        CrossNode cp, newptr;
        //建立一个新结点
        newptr=new CrossNode;
        newptr->row=row;
        newptr->col=col;
        newptr->val=val;
        newptr->down=newptr->right=NULL;
        //把新结点链接到所在行单链表的末尾
        cp=M.rv[row];
        if(cp==NULL) M.rv[row]=newptr;
        else 
            while(cp->right!=NULL) cp=cp->right;
            cp->right=newptr;
        
        //把新结点链接到所在列单链表的末尾
        cp=M.cv[col];
        if(cp==NULL) M.cv[col]=newptr;
        else 
            while(cp->down!=NULL) cp=cp->down;
            cp->down=newptr;
        
        //输入一个新三元组
        cin>>row>>col>>val;
    
    M.t=k;

```

请自行编写出采用带行指针向量的链接存储所对应的输入算法。

3. 稀疏矩阵的输出

对于采用顺序存储的稀疏矩阵，按三元组线性表的格式输出，其输出算法如下。

void OutputMatrix (SMatrix& M)

    cout<<"( ";
    for(int i=1; i<M.t; i++) 
        cout<<"(<M.sm[i].row<<",";
        cout<<M.sm[i].col<<",";
        cout<<M.sm[i].val<<") "<<",";
    
    if(M.t!=0) 
        cout<<"(<M.sm[M.t].row<<",";
        cout<<M.sm[M.t].col<<",";
        cout<<M.sm[M.t].val<<")";
    
    cout<<")"<<endl;


对于采用其他存储结构的稀疏矩阵，不难写出其相应的输出算法。

4. 稀疏矩阵的转置运算

以稀疏矩阵的顺序存储结构为例讨论稀疏矩阵的转置运算。

设图 3-3(b) 所示的稀疏矩阵命名为A，它所对应的顺序存储类型的对象命名为M，则图 3-4 就是该对象中数组 sm 中的内容。矩阵A的转置矩阵如图 3-7(a) 所示，其命名为B，用顺序存储类型的对象S来存储它，S中 sm 数组的内容如图 3-7(b) 所示。left[beginarrayrrrrr3 & 0 & 1 & 0 & 0  0 & 0 & 0 & 0 & 0  0 & -2 & 4 & 0 & -1  5 & 0 & 0 & 0 & 0  0 & 0 & 6 & 0 & 0  0 & 0 & 0 & 0 & 0endarrayright](a)A的转置矩阵beginarrayc|c|c|c hline S & text  row  & text  col  & text  val   hline 1 & 1 & 1 & 3  hline 2 & 1 & 3 & 1  hline 3 & 2 & -2 &  hline 4 & 3 & 3 & 4  hline 5 & 3 & 5 & -1  hline 6 & 4 & 1 & 5  hline 7 & 5 & 3 & 6  hline vdots & & &  hline endarrayMaxTerms

(b)B的顺序存储结构

图 3-7 稀疏矩阵B和它的顺序存储结构

下面根据稀疏矩阵A的顺序存储对象M求它的转置矩阵的顺序存储对象S，来讨论进行稀疏矩阵转置运算的两种方法：普通转置方法和快速转置方法。

(1) 普通转置方法。

普通转置方法要对 M 中的 sm 数组进行n次扫描 (n为 A 的列数, 即 B 的行数) 才能完成。具体地说, 第 1 次扫描 col 域的值等于 1 (即列为 1) 所在的三元组 (即对应 B 中第 1 行非零元素) 按照从上到下 (因行号为从小到大, 所以对应 B 中是列号从小到大的) 的顺序, 行列值互换写入到对象 S 的 sm 数组中, 第 2 次扫描把 col 域的值等于 2 (即列为 2) 所在的三元组 (即对应 B 中第 2 行非零元素) 按照从上到下的顺序接着写入到对象 S 的 sm 数组中, 以此类推。具体算法描述如下。

SMatrix Transpose(SMatrix& M)

    SMatrix S; //用 S 暂存转置结果
    InitMatrix(S);
    int m, n, t;
    //用 m, n, t 分别暂存 M 的行数、列数和非零元素的个数
    m=M.m; n=M.n; t=M.t;
    //分别置 s 的行数域、列数域和非零元素的个数域为 n, m 和 t
    S.m=n; S.n=m; S.t=t;
    //若是矩矩阵 (即非零元素的个数为 0 的矩阵) 则转换完毕返回
    if(t==0) return S;
    //按列进行每个元素的转换
    int k=1; //用 k 指示 S.sm 数组中待存元素的下标
    for(int col=1; col<=n; col++)
        //用 col 扫描 M.sm 数组中的 col 域
        for(int i=1; i<=t; i++)
            //用 i 指示 M.sm 数组中当前元素下标
            if(M.sm[i].col==col) 
                S.sm[k].row=col;
                S.sm[k].col=M.sm[i].row;
                S.sm[k].val=M.sm[i].val;
                k++;
            
    return S; //返回转置矩阵 S


此算法的运行时间主要取决于最后的双重 for 循环, 故算法的时间复杂度为O(n times t), 即同 M 的列数与非零元素的个数的乘积成正比。当稀疏矩阵接近一般矩阵时, 非零元素的个数t等于矩阵中的行数m乘以列数n, 此时算法的时间复杂度为O(m times n^2), 它比采用二维数组存储时进行转置运算的时间复杂度O(m times n)要坏得多。因此, 对于一般矩阵最好采用二维数组存储和运算。

(2) 快速转置方法。

用快速转置的方法进行稀疏矩阵转置要对 M 中的 sm 数组进行两次扫描, 第 1 次扫描统计出对应 A 矩阵中每一列 (即对应转置矩阵 B 中每一行) 非零元素的个数, 由此求出每一列的第 1 个非零元素 (即对应 B 中每一行的第 1 个非零元素) 在 S.sm 数组中应有的位置, 第 2 次扫描把数组 M.sm 中的每一个三元组, 行列值互换写入到数组 S.sm 中确定的位置上。

设col表示A中元素的列号（即对应转置矩阵B中元素的行号），num和pot均表示具有n（n为A中的列数即B中的行数）个分量的向量，num向量的第col分量（即num[col]）用来统计第col列中的非零元素的个数，pot向量的第col分量（即pot[col]）用来指向第col列待转换的非零元素被存储在S.sm数组中的下标位置，显然pot向量的第col分量的初始值（即第col列的第一个非零元素被存储在S.sm数组中的下标位置）由下式计算。beginaligned
& pot[1]=1 
& pot[col]=pot[col-1]+num[col-1] quad (2 leq col leq n)
endaligned根据稀疏矩阵A和顺序存储对象M，得到num向量的各分量值和pot向量的各分量初始值如表 3-1 所示。

表 3-1 num 和 pot 向量初始值

|       | 1 | 2 | 3 | 4 | 5 | 6 |
|-------|---|---|---|---|---|---|
| col   | 1 | 2 | 3 | 4 | 5 | 6 |
| num[col] | 2 | 0 | 3 | 1 | 1 | 0 |
| pot[col] | 1 | 3 | 3 | 6 | 7 | 8 |

结合图 3-7 进行分析，验证num和pot数组中各分量值的正确性，num数组中的第i个分量值等于稀疏矩阵B中第i行上非零元素的个数，pot数组中的第i个分量值等于B中第i行上第一个（即列号最小的）非零元素在S.sm数组中的下标位置。

用 C++语言描述稀疏矩阵的快速转置方法的算法如下。

```cpp
SMatrix FastTranspose(SMatrix& M)

    SMatrix S; //用 S 暂存转置结果
    InitMatrix(S);
    int m, n, t;
    //用 m,n,t 分别暂存 M 的行数、列数和非零元素的个数
    m=M.m; n=M.n; t=M.t;
    //分别置 S 的行数域、列数域和非零元素的个数域为 n,m 和 t
    S.m=n; S.n=m; S.t=t;
    //若是零矩阵(即非零元素的个数为 0 的矩阵)则转换完毕返回
    if(t==0) return S;
    //为 num 和 pot 向量动态分配存储空间
    int num=new int[n+1];
    int pot=new int[n+1];
    //对 num 向量进行初始化, 置每个分量为 0
    int col,i;
    for(col=1; col<=n; col++) num[col]=0;
    //对第 1 遍扫描数组 M.sm, 统计出每一列(即转换后的每一行)非零元素的个数
    for(i=1; i<=t; i++) 
        int j=M.sm[i].col;
        num[j]++;
    
    //计算每一列(即转换后的每一行)的第 1 个非零元素在 S.sm 中存储位置

```

pot[1]=1;
for(col=2; col<=n; col++)
    pot[col]=pot[col-1]+num[col-1];
//对M.sm进行第2遍扫描,把每个元素行、列值互换写入到S.sm的确定位置
for(i=1; i<=t; i++) 
    int j=M.sm[i].col;                      //取待转换元素的列号
    int k=pot[j];                           //取待转换元素在S.sm中的位置
    S.sm[k].row=j;                          //以下3行存储被转换的元素
    S.sm[k].col=M.sm[i].row;
    S.sm[k].val=M.sm[i].val;
    pot[j]++;                               //使pot[j]指向下—个位置

//删除动态分配的数组
delete[] num;
delete[] pot;
//返回转置矩阵S
return S;


此算法的运行时间主要取决于4个for单重循环，故时间复杂度为O(n+t)，显然它比第一种转置算法的时间复杂度要好得多。当稀疏矩阵接近一般矩阵时，其时间复杂度变为O(mtimes n)，与采用二维数组表示时相同。当然进行每一个元素转换的运算步骤要比使用二维数组时的直接赋值（即b[i][j]=a[j][i]）操作要复杂一些。

section5. 稀疏矩阵的加法运算

假定采用带行指针向量的存储结构进行稀疏矩阵的加法运算，设M1和M2为两个加数矩阵，M为和矩阵，即结果矩阵。两矩阵相加的前提条件是：两矩阵的大小相同，即行数和列数分别对应相等。两矩阵相加的结果仍为一个具有相同大小的矩阵，结果矩阵M中每个行单链表仍然要按列号有序，它是对M1和M2中对应行单链表的按列号有序的合并结果。当M1和M2中对应行单链表的两个结点分别具有相同的行号和列号时，若它们的元素值之和为0，则不在结果矩阵中建立结点，只有当其和不为0或者列号不同时，才需要在结果矩阵中建立结点。具体算法描述如下。

LMATRIX Add(LMATRIX& M1, LMATRIX& M2)

    LMATRIX M;  //暂存运算结果，以便返回
    InitMatrix(M);
//若两个矩阵尺寸不同，则给出错误信息并停止运行
    if((M1.m!=M2.m) || (M1.n!=M2.n)) 
        cerr<<"two matrix measurements are different!"<<endl;
        exit(1);
    
//把其中一个加数矩阵的尺寸赋给结果矩阵
    M.m=M1.m; M.n=M1.n;

//若两个矩阵均为零矩阵，则无须计算返回M
if((M1.t==0) && (M2.t==0)) return M;
//进行两矩阵相加产生和矩阵
int k=0; //用k统计结果矩阵中结点的个数
for(int i=1; i<=M1.m; i++) //循环的次数等于矩阵的行数

    TripleNode p1, p2, p;
    p1=M1.vector[i]; //p1指向M1矩阵中第i行单链表的待相加的结点
    p2=M2.vector[i]; //p2指向M2矩阵中第i行单链表的待相加的结点
    p=M.vector[i]; //p指向M矩阵中第i行单链表的表尾结点
    //当p1和p2均不为空时进行比较和加法运算，把结点复制到结果矩阵中
    while((p1!=NULL)&&(p2!=NULL)) 
        TripleNode newptr=new TripleNode;
        if(p1->col<p2->col)  //赋值新结点，p1指针后移
            newptr=p1; p1=p1->next;
        
        else if(p1->col>p2->col)  //赋值新结点，p2指针后移
            newptr=p2; p2=p2->next;
        
        else //对具有相同列号的结点进行处理
            if(p1->val+p2->val==0)  //不建立新结点和链接
                p1=p1->next; p2=p2->next; //p1和p2指针后移
                continue;
            
            else  //新结点值为两结点值之和，p1和p2指针后移
                newptr=p1;
                newptr->val+=p2->val;
                p1=p1->next; p2=p2->next;
            
        newptr->next=NULL; //将新结点的指针域置空
        //把新结点链接到结果矩阵的第i行单链表的表尾
        if(p==NULL) M.vector[i]=newptr;
        else p->next=newptr;
        p=newptr; //修改p指针，使之指向新的表尾
        k++; //结果矩阵中的结点数加1
     //end of while
    //若p1不为空，则把剩余结点复制链接到结果矩阵中
    while(p1!=NULL) 
        TripleNode newptr=new TripleNode;
        newptr=p1;
        newptr->next=NULL;
        if(p==NULL) M.vector[i]=newptr;
        else p->next=newptr;
        p=newptr;
        p1=p1->next;
    


```cpp
k++;
 //end of while
//若p2不为空,则把剩余结点复制链接到结果矩阵中
while(p2!=NULL) 
    TripleNode newptr=new TripleNode;
    newptr=p2;
    newptr->next=NULL;
    if(p==NULL) M.vector[i]=newptr;
    else p->next=newptr;
    p=newptr;
    p2=p2->next;
    k++;

//end of while
 //end of for
M.t=k;        //置和矩阵中结点数
return M;     //返回和矩阵


在这个算法中，需要扫描 M1 和 M2 中的每一个结点，并建立新结点和把它链接到结果矩阵中相应行单链表的表尾，因为对每个结点的处理均为时间常量，其时间复杂度为O(1)，所以整个算法的时间复杂度为O(M1.t+M2.t)，即与两个加数矩阵中结点数（即非零元素个数）之和成正比。当稀疏矩阵相当稀疏时，即非零元素的个数 t 远远小于行列数的乘积 m×n 时，该算法的时间复杂度比采用二维数组表示时进行矩阵求和的时间复杂度O(m times n)要小得多。

section3.5 广义表

subsection3.5.1 广义表的定义

广义表 (generalized list) 简称表，它是线性表的推广。一个广义表是n(n geqslant 0)个元素的一个有限序列，当n=0时则称为空表。在一个非空的广义表中，其元素可以是某一确定类型的对象，这种元素被称为单元素；也可以是由单元素构成的表，这种元素被称为子表（或表元素）。显然，广义表的定义是递归的，广义表是一种递归的数据结构。

设a_i为广义表的第i个元素，则广义表的一般表示与线性表相同，具体如下。
[
(a_1, a_2, cdots, a_i, a_i+1, cdots, a_n)
]
其中，n表示广义表的长度，即广义表中所含元素的个数，n geqslant 0。

同线性表一样，也可以用一个标识符来命名一个广义表，如用 LS 命名上面的广义表，则为：
[
textLS=(a_1, a_2, cdots, a_i, a_i+1, cdots, a_n)
]

在广义表的讨论中，为了把单元素同表元素区别开来，一般用小写字母表示单元素，用大写字母表示表，如：
```

A=()
B=(e)
C=(a,(b,c,d))
D=(A,B,C)=(( ),(e),(a,(b,c,d)))
E=((a,(a,b)),((a,b),c))

其中，A是一个空表，其长度为0；B是一个只含有单元素e的表，其长度为1；C中有两个元素，一个是单元素a，另一个是表元素(b,c,d)，C的长度为2；D中有三个元素，其中每个元素又都是一个表，D的长度为3；E中只含有一个元素，该元素是一个表，该表中包含有三个元素，其中后两个元素又都是表。

若把每个表的名字（若有的话）写在其表的前面，则上面的五个广义表可相应地表示为：
A()
B(e)
C(a,(b,c,d))
D(A(),B(e),C(a,(b,c,d)))
E((a,(a,b)),((a,b),c))

若用圆圈和方框分别表示表和单元素，并用线段把表和它的元素（元素结点应在其表结点的下方）连接起来，则可得到一个广义表的图形表示。上面5个广义表的图形表示如图3-8所示。

可以看出，广义表的图形表示像倒着画的一棵树，树根结点代表整个广义表，各层树枝结点代表相应的子表，树叶结点代表单元素或空表。

一个表的深度是指该表中括号嵌套的最大次数，在图形表示中，则是从树根结点到每个树枝结点所经过的结点个数的最大值。如表A和B的深度为1，表C、D、E的深度分

别为 2、3 和 4。

section3.5 .2 广义表的存储结构

广义表是一种递归的数据结构, 因此很难为每个广义表分配固定大小的存储空间, 所以其存储结构只好采用动态链接结构。

在一个广义表中, 其数据元素有单元素和子表之分, 所以在对应的存储结构中, 其存储结点也有单元素结点和子表结点之分。对于单元素结点, 应包括值域和指向其后继结点的指针域; 对于子表结点, 应包括指向子表中第一个结点的表头指针域和指向其后继结点的指针域。为了把广义表中的单元素结点和子表结点区别开来, 还必须在每个结点中增设一个标志域, 让标志域取两种不同的值, 从而区分两种不同的结点。

根据分析, 广义表中的结点类型在 C++语言中可定义如下。

struct GLNode 
    bool tag; //标志域
    union
        ElemType data; //值域或子表的表头指针域
        GLNode sublist;
    ;
    GLNode next; //指向后继结点的指针域
;

其中, tag 作为标志域, 其值为 false 时表示单元素结点, 使用无名联合中的 data 域, 用来存储元素值; 其值为 true 时表示子表结点, 使用无名联合中的 sublist 域, 用来存储指向子表中第一个结点的指针, 即子表的表头指针, 通过它实现向子表的链接, 即实现广义表的递归结构, 结点中的 next 作为指向其后继结点的指针域, 通过它把表中同一层的所有结点依次链接起来。

上述 5 个广义表的存储结构的示意图, 如图 3-9 所示。

A=NULL

B→[0 e ∧]

D→[1 ∧]→[1]→[1 ∧]

E→[1 ∧]→[0 a]→[1]→[0 a]→[0 b ∧]→[1]→[0 c ∧]→[0 d ∧]

C [0 a] [1]∧

[0 b]→[0 c]→[0 d ∧]

[0 e ∧]→[0 a]→[1]∧

[0 b]→[0 c]→[0 d ∧]

[0 a]→[0 b ∧]

[0 a]→[0 b ∧]

图 3-9 广义表的链接存储结构

若把整个广义表也同样用一个表结点来表示，则应在每个广义表的表头结点（即表中第一个结点）之前增加一个表结点（称此为表头附加结点），此表结点的 sublist 域指向表头结点，next 域为空，表头指针则指向这个表结点。例如，若在广义表 A,B,C 的表头结点之前增加这样的表结点，对应的示意图如图 3-10 所示。

Arightarrow[1 ∧∧] Crightarrow[1 ∧∧]
Brightarrow[1 ∧∧] [0 arightarrow[1 ∧∧]]
[0 e ∧] [0 brightarrow[0 crightarrow[0 d ∧]]

图 3-10 带表头附加结点的广义表的链存储结构

这种带表头附加结点的广义表表示，将给广义表的某些运算带来方便。

section3.5 .3 广义表的运算

广义表的运算主要有求广义表的长度和深度、向广义表插入元素和从广义表中查找或删除元素、建立广义表的存储结构、打印广义表等。由于广义表是一种递归的数据结构，所以对广义表的运算一般采用递归的算法。全面介绍广义表的各种运算的算法，超出了本课程的教学内容，这里只讨论其中一些算法。

section1. 求广义表的长度

在广义表中，同一层次的每个结点是通过 next 域链接起来的，所以可把它看作是由 next 域链接起来的单链表。这样，求广义表的长度就是求单链表的长度，可以采用以前介绍的求单链表长度的方法求其长度。由于单链表的结构也是一种递归结构，即每个结点的指针域均指向一个单链表（称为该结点的后继单链表），它所指向的结点为该单链表的第一个结点（即表头结点），所以求单链表的长度也可以采用递归算法，即若单链表非空的话，其长度等于 1 加上表头结点的后继单链表的长度，若单链表为空，则长度为 0，这是递归的终止条件。

求广义表长度的递归算法如下。

int Length(GLNode GL) //求值参 GL 所指向的广义表的长度

    if (GL!=NULL)
        return 1+Length(GL->next);
    else
        return 0;


此算法每次被调用时，无论是从外部对它的非递归调用，还是从内部对它的递归调用，都需要给值参 GL 分配存储空间，用以存储由实参传来的指针值，所以算法的空间复杂度为O(n)，若采用非递归算法，其空间复杂度为O(1)，两者的时间复杂度均为O(n)，n为广义表的长度。这里介绍递归算法，是想通过这个简单的例子为后面介绍更复杂的递归算

法做准备。

2. 求广义表的深度

广义表深度的递归定义是它等于所有子表中表的最大深度加 1，若一个表为空或仅由单元素所组成，则深度为 1。设 dep 表示任一子表的深度，max 表示所有子表中表的最大深度，Depth 表示广义表的深度，则有：textDepth=max+1因一个表不包含任何子表时，其深度为 1，所以 max 的初值应为 0。

求一个广义表深度的算法如下。

int Depth(GLNode GL) //求值参 GL 所指向的广义表的深度

    int max=0; //给 max 赋初值 0
    while (GL!=NULL) 
        if (GL->tag==true) 
            int dep=Depth(GL->sublist); //递归调用求出子表的深度
            if (dep>max) max=dep; //让 max 为同层求过子表深度的最大值
        
        GL=GL->next; //使 GL 指向同一层的下一个结点
    
    return max+1; //返回表的深度


从这个算法可以看出，当 GL 为一个空表或仅由单元素组成的线性表时，不进入下一层的递归调用，而结束本次调用并返回 1，当 GL 含有子表时才会进入求子表深度的递归调用，返回后修改 max 的值，使之为所求过的本层次子表中深度的最大值，本层次的所有结点都扫描完毕后，结束本次调用并返回表的深度。

设一个广义表为:G=((),a,((b,c),d))它的存储结构如图 3-11 所示。

为了便于分析，在图中每个链接指针上都标明数字，假定它为该指针的具体值。

在第 1 次非递归调用和以后每次递归调用 Depth 算法时，系统都要在动态堆存储区中为值参 GL，局部变量 max 和 dep 以及保存调用后的返回地址分配存储空间，每次调用结束按所保存的返回地址返回后，系统都释放为本次调用所分配的存储空间，从而使上一

层调用所分配的存储空间成为变量的当前存储空间。若以表头指针 G 作为实参去调用 Depth 算法，则在算法的执行过程中，动态堆栈的数据变化情况如图 3-12 所示。其中，用 r 表示返回地址域，第 1 次调用（即非递归调用，又称为第 0 次递归调用）后的返回地址用 r1 表示，以后每次递归调用的返回地址用 r2 表示。

(a) 第 0 次递归调用
| GL | max | dep | r |
| --- | --- | --- | --- |
| 10 | 0 |   | r1 |

(b) 第 1 次递归调用
| GL | max | dep | r |
| --- | --- | --- | --- |
| ∧ | 0 |   | r2 |
| 10 | 0 |   | r1 |

(c) 返回
| GL | max | dep | r |
| --- | --- | --- | --- |
| 10 | 1 | 1 | r1 |

(d) GL 指向 20 结点
| GL | max | dep | r |
| --- | --- | --- | --- |
| 20 | 1 | 1 | r1 |

(e) GL 指向 30 结点
| GL | max | dep | r |
| --- | --- | --- | --- |
| 30 | 1 | 1 | r1 |

(f) 第 2 次递归调用
| GL | max | dep | r |
| --- | --- | --- | --- |
| 40 | 0 |   | r2 |
| 30 | 1 | 1 | r1 |

(g) 第 3 次递归调用
| GL | max | dep | r |
| --- | --- | --- | --- |
| 50 | 0 |   | r2 |
| 40 | 0 |   | r2 |
| 30 | 1 | 1 | r1 |

(h) GL 指向 60 结点
| GL | max | dep | r |
| --- | --- | --- | --- |
| 60 | 0 |   | r2 |
| 40 | 0 |   | r2 |
| 30 | 1 | 1 | r1 |

(i) GL 变为空
| GL | max | dep | r |
| --- | --- | --- | --- |
| ∧ | 0 |   | r2 |
| 40 | 0 |   | r2 |
| 30 | 1 | 1 | r1 |

(j) 返回
| GL | max | dep | r |
| --- | --- | --- | --- |
| 40 | 1 | 1 | r2 |
| 30 | 1 | 1 | r1 |

(k) GL 指向 70 结点
| GL | max | dep | r |
| --- | --- | --- | --- |
| 70 | 1 | 1 | r2 |
| 30 | 1 | 1 | r1 |

(l) GL 变为空
| GL | max | dep | r |
| --- | --- | --- | --- |
| ∧ | 1 | 1 | r2 |
| 30 | 1 | 1 | r1 |

(m) 返回
| GL | max | dep | r |
| --- | --- | --- | --- |
| 30 | 2 | 2 | r1 |

(n) GL 变为空
| GL | max | dep | r |
| --- | --- | --- | --- |
| ∧ | 2 | 2 | r1 |

(o) 返回 3

图 3-12 系统动态堆栈中数据的变化情况

可以分析出，该算法需要扫描广义表中的所有结点，对于单元素结点需要访问两次，一次为读取 tag 域值，另一次为读取 next 域值；对于子表结点需要访问 3 次，分别为读取 tag、sublist 和 next 域的值。所以此算法的时间复杂度为O(n)，其中n为广义表中所有结点的个数。该算法的空间复杂度为O(m)，m为广义表的深度。

3. 建立广义表的存储结构

设广义表中的元素类型 ElemType 为字符类型 char，每个单元素的值被限定为英文字母，广义表由键盘输入，其格式为：元素之间用一个逗号分隔，表元素的起止符号分别为左、右圆括号，空表在其圆括号内使用一个 “” 字符表示，最后使用一个分号作为整个广

义表的结束符号。如 “(a,(),b,c,(d,(e)))”; 就是一个符合上述规定的广义表输入格式。

建立广义表存储结构的算法同样是一个递归算法，该算法使用一个具有GLNode^类型的引用指针参数，用以返回所建广义表的表头指针，用 GL 表示。在算法的执行过程中，对于从键盘上输入的一个广义表，需要从头到尾扫描每一个字符，当碰到左括号时，表明它是一个表元素的开始，则应建立一个由 GL 指向的表结点，并用它的 sublist 域作为子表的表头指针进行递归调用，来建立子表的存储结构：当碰到一个英文字母时，表明它是一个单元素，则应建立一个由 GL 指向的单元素结点；当碰到一个“”字符时，表明它是一个空表，则应置 GL 为空。当建立了一个由 GL 指向的结点后，接着碰到逗号字符时，表明存在后继结点，需要建立当前结点（即由 GL 指向的结点）的后继表，当碰到右括号或分号字符时，表明当前所处理的表已结束，应置当前结点的 next 域为空。

根据广义表输入格式和建立存储结构的思路，可知所建立的广义表存储结构将带有表头附加结点，因为一开始就会遇到左括号，就会建立起整个表的表元素结点。若要建立不带表头附加结点的广义表存储结构，则只要使输入格式中省去最外层的一对圆括号即可。

根据分析，编写算法如下。

void Create(GLNode& GL)


    char ch;
    //读入一个字符,此处只可能读入,左括号和英文字母
    cin>>ch;
    //若输入为,则置 GL 为空
    if(ch=='') GL=NULL;
    //若输入为左括号则建立由 GL 所指向的子表结点并递归构造子表
    else if(ch=='(') 
        GL=new GLNode;
        GL->tag=true;
        Create(GL->sublist);
    
    //建立由 GL 所指向的单元素结点
    else 
        GL=new GLNode;
        GL->tag=false;
        GL->data=ch;
    
    //此处读入的字符必为逗号、右括号或分号
    cin>>ch;
    //若 GL 为空,此时输入的字符必然为 ')',则什么都不用做
    if(GL==NULL);
    //若输入为逗号则递归构造后继表
    else if(ch==',') Create(GL->next);
    //若输入为右括号或分号则置 GL 的后继指针域为空
    else if((ch==')')||(ch==';')) GL->next=NULL;


该算法需要扫描输入广义表中的所有字符，并且处理每个字符都是简单的比较或赋值操作，其时间复杂度为O(1)，所以整个算法的时间复杂度为O(n)，n表示广义表中所有字符的个数。由于平均每两个字符可以生成一个表结点或单元素结点，所以n也可以看做生成的广义表中所有结点的个数。在这个算法中，既包含向子表的递归调用，也包含向后继表的递归调用，所以递归调用的最大深度（即动态堆栈的最大深度）不会超过生成的广义表中所有结点的个数，因此其空间复杂度也为O(n)。

4. 打印输出广义表

根据以 GL 为带表头附加结点的广义表的表头指针，打印输出该广义表同样需要向子表递归调用和向后继表递归调用。当 GL 结点为元素结点时，则应首先输出作为一个表的起始符号的左括号，然后再输出以 GL->sublist 为表头指针的表；当 GL 结点为单元素结点时，则应输出该元素的值。当以 GL->sublist 为表头指针的表输出完毕后，应在其最后输出一个作为表终止符的右括号。当 GL 结点输出结束后，若存在后继结点，则应首先输出一个逗号作为分隔符，然后再递归输出由 GL->next 指针所指向的后继表。

打印输出一个广义表的算法描述如下，其中值参 GL 指向一个带有表头附加结点的广义表，GL 也可采用指针引用参数。

void Print(GLNode GL)

    if (GL->tag==true) 
        cout<<'(';
        if (GL->sublist ==NULL)
            cout<<'';
        else
            Print(GL->sublist);
        cout<<')';
    
    else cout<<GL->data;
    if (GL->next!=NULL) 
        cout<<',';
        Print(GL->next);
    


该算法的时间复杂度和空间复杂度与建立广义表存储结构的情况相同，均为O(n)，n为广义表中所有结点的个数。

3.5.4 简单程序举例

以上介绍的几种进行广义表运算的算法假定被保存在 “广义表运算.cpp” 程序文件中，现要求利用它们编写一个程序，首先建立广义表 “(a,(b,(c)),((),((d,e))),f,(g))” 的存储结构，然后输出该广义表，最后求该广义表的长度和深度。

该程序比较简单，如下所示。

```c
include<iostream.h>
include<stdlib.h>
typedef char ElemType;
struct GLNode

    bool tag;
    union 
        ElemType data;
        GLNode sublist;
    ;
    GLNode next;
;
include"广义表运算.cpp"
void main()

    GLNode g=NULL;
    Create(g);
    Print(g);
    cout<<endl;
    cout<<"广义表的长度："<Length(g->sublist)><<endl;
    cout<<"广义表的深度："<Depth(g->sublist)><<endl;


该程序运行后，从键盘上输入如下一行字符：(a,(b,(c)),( (),( (d,e))),f,(g));

则得到的输出结果如下:(a,(b,(c)),( (),( (d,e))),f,(g))广义表的长度：5

广义表的深度：4

习 题 3

【习题 3-1】按要求进行稀疏矩阵运算。
已知一个稀疏矩阵，如图 3-13 所示。beginbmatrix
0 & 4 & 0 & 0 & 0 & 0 & 0 
0 & 0 & 0 & -3 & 0 & 0 & 1 
8 & 0 & 0 & 0 & 0 & 0 & 0 
0 & 0 & 0 & 5 & 0 & 0 & 0 
0 & -7 & 0 & 0 & 0 & 2 & 0 
0 & 0 & 0 & 6 & 0 & 0 & 0
endbmatrix图 3-13 具有6行×7列的一个稀疏矩阵
```

1. 写出它的三元组线性表。
2. 给出它的顺序存储表示。
3. 给出它的转置矩阵的三元组线性表和顺序存储表示。
4. 给出对它进行快速转置时，num 向量中各分量的值。
5. 给出对它进行快速转置前和转置后，pot 向量中各分量的值。

【习题 3-2】按要求进行广义表运算。
画出下列每个广义表的带表头附加结点的链接存储结构图并分别计算它们的长度和深度。
1. A=()
2. B=(a,b,c)
3. C=(a,(b,c))
4. D=((a,b),(c,d))
5. E=(a,(b,(c,d)),(e))
6. F=((a,(b,(),c)),((d),e))

【习题 3-3】写出下列每个主程序段的运行输出结果。

1. void main()

    Set a;
    InitSet(a);
    ElemType r[8]=1,5,90,5,7,25,34,16;
    int i;
    for(i=0; i<8; i++) InsertSet(a,r[i]);
    ElemType x=25,y=90;
    DeleteSet(a,x);
    DeleteSet(a,y);
    OutputSet(a);
    cout<<EmptySet(a)<' '<LengthSet(a)<<endl;


2. void main()

    ElemType r[8]=1,5,90,5,7,25,34,16;
    ElemType r1[6]=5,60,16,30,34,8;
    Set a; InitSet(a);
    Set b; InitSet(b);
    Set c; InitSet(c);
    int i;
    for(i=0; i<8; i++) InsertSet(a,r[i]);
    for(i=0; i<6; i++) InsertSet(b,r1[i]);
    UnionSet(a,b,c);
    OutputSet(c);
    IntersectSet(a,b,c);
    OutputSet(c);
    DifferenceSet(a,b,c);
    OutputSet(c);
    ClearSet(a); ClearSet(b); ClearSet(c);


3. void main()

    ElemType r[8]=1,5,90,5,7,25,34,16;
    SNode a;
    InitSet(a);
    int i;
    for(i=0; i<8; i++) InsertSet(a,r[i]);
    OutputSet(a);
    ElemType x=34;
    DeleteSet(a,x);
    InsertSet(a,48);
    x=5; DeleteSet(a,x);
    OutputSet(a);
    ClearSet(a);


4. void main()

    SNode a; InitSet(a);
    SNode b; InitSet(b);
    SNode c; InitSet(c);
    int i;
    ElemType r[8]=1,5,90,5,7,25,34,16;
    ElemType r1[5]=5,60,16,30,8;
    for(i=0; i<8; i++) InsertSet(a,r[i]);
    for(i=0; i<5; i++) InsertSet(b,r1[i]);
    UnionSet(a,b,c);
    OutputSet(c);
    InterseSet(a,b,c);
    OutputSet(c);


【习题3-4】根据下列每个题目的要求编写算法。

1. 比较两个集合的大小。若两集合长度不等则退出运行。在两集合长度相等的情况下，若各集合的元素值的累加和相等则认为它们相等，返回0；若第1个集合的元素值的累加和大于第2个集合的元素值的累加和，则认为第1个集合大于第2个集合，返回1；若第1个集合的元素值的累加和小于第2个集合的元素值的累加和，则认为第1个集合小于第2个集合，返回-1。

2. 定义等于号运算符重载函数，比较两个集合是否相等。若两集合长度不等则退出运行。在两集合长度相等情况下，若各集合的元素值的累加和相等则认为它们相等，返回真；否则认为它们不等，返回假。

3. 从键盘上输入一个三元组线性表，当输入(0,0,0)元素时结束，实现稀疏矩阵的带行指针向量的链接存储。

4. 以三元组线性表的形式输出一个稀疏矩阵，其中稀疏矩阵采用的是带行指针向量的链接存储。

5. 实现稀疏矩阵的十字链表存储的三元组线性表输出。

6. 采用顺序存储方式实现稀疏矩阵M1和M2相加的运算，运算结果由引用参数M带回。

7. 编写一个建立广义表链接存储结构的算法，广义表由字符串值参提供。

8. 编写一个从广义表中查找单元素字符等于给定值的算法，若查找成功则返回真，否则返回假。


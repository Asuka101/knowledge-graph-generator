第4章 栈和队列栈和队列都属于线性表但由于对它们操作的特殊性并且是最常用的线性数据结构所以需要专门进行讨论41 栈411 栈的定义栈又称堆栈它是一种运算受限的线性表其限制是仅允许在表的一端进行插入和删除运算人们把对栈进行运算的一端称为栈顶栈顶的第1个元素被称为栈顶元素相对地把另一端称为栈底向一个栈插入新元素又称为进栈或入栈它是把该元素放到栈顶元素的上面使之成为新的栈顶元素从一个栈删除元素又称为出栈或退栈它是把栈顶元素删除掉使其下面的相邻元素成为新的栈顶元素在日常生活中有许多类似栈的例子如刷洗盘子时依次把每个洗净的盘子放到洗好的一摞盘子上相当于进栈取用盘子时从一摞盘子上一个接一个地向下拿相当于出栈又如向枪支弹夹里装子弹时子弹被一个接一个地压入相当于进栈射击时子弹总是从顶部一个接一个地被射出相当于子弹出栈由于栈的插入和删除运算仅在栈顶一端进行后进栈的元素必定先出栈所以又把栈称为后进先出表   例如一个栈为其中表尾的一端为栈顶字符为栈顶元素若向压入一个元素则变为此时字符为栈顶元素若接着从栈中依次删除两个元素则首先删除的是元素接着删除的是元素栈变为栈顶元素为412 栈的抽象数据类型栈的抽象数据类型中的数据部分为具有  元素类型的一个栈它可以采用任一种存储结构实现用  标识符表示栈对象类型操作部分应包括元素进栈元素出栈读取栈顶元素检查栈是否为空等下面给出栈的抽象数据类型的具体定义      一个栈假定用标识符  表示栈对象类型   初始化栈即把它置为空     元素进栈即插入到栈顶   删除栈顶元素并返回之   返回栈顶元素的值但不改变栈    判断是否为空   清除栈中所有元素使之成为空栈 对于判断栈是否为空和返回栈顶元素这两种操作由于它们不改变栈的状态所以可在参数类型说明前使用常量定义符 也可以取消引用定义改为值参定义假定栈  的元素类型为 下面给出调用上述栈操作的一些例子 把栈  置空18 元素 18 进栈 46   的值 46 进栈3  除以 3 的整数值 15 进栈 栈顶元素 15 退栈并赋给  读取栈顶元素 46 并输出 栈顶元素 46 出栈返回值 46 自动丢失 因栈非空应返回  栈顶元素 18 退栈并输出 因栈为空返回 对应整数 1赋给 42 栈的顺序存储结构和操作实现栈的顺序存储结构同样需要使用一个数组和一个整型变量来实现利用数组来顺序存储栈中的所有元素利用整型变量来存储栈顶元素的下标位置栈数组用 表示指示栈顶位置的整型变量用  表示则元素类型为  的栈的顺序存储结构可定义如下   其中 为一个整型全局常量需先通过  语句定义由它确定顺序栈即顺序存储的栈的最大长度又称为深度即栈空间最多能够存储的元素个数由于  用来指示栈顶元素的位置所以把它称为栈顶指针栈的顺序存储结构所使用的栈数组和栈顶指针同样可以定义在一个记录类型中该记录类型用  表示则定义如下            若要对存储栈的数组空间采用动态分配则  结构类型可定义如下                 存栈元素                       存栈顶元素的下标位置                   存  数组长度 即所能存储栈的最大长度在顺序存储的栈中的值为1表示栈空每次向栈中压入一个元素时首先使增 1用以指示新的栈顶位置然后再把元素赋值到这个空位置上每次从栈中弹出一个元素时首先取出栈顶元素然后再使减 1指出前一个元素成为新的栈顶元素由此可知对顺序栈的插入和删除运算相当于是在顺序表即顺序存储的线性表的表尾进行的其时间复杂度为1在一个顺序栈中若已经指向了1的位置则表示栈满若再向其插入新元素时就需要进行栈满处理需分配更大的存储空间满足插入要求或输出栈满信息告之用户等相反若的值已经等于1则表示栈空通常利用栈空作为循环结束的条件表明数据已经处理完毕设一个栈为对应的顺序存储结构如图 41  所示向中插入一个元素如图 41  所示接着执行两次出栈操作后如图 41  所示依次使栈中的所有元素出栈则变为空如图 41  所示在这里栈是垂直画出的并且使下标编号向上递增这样可以形象地表示出栈顶在上栈底在下 1  1  1  1    1    1  4  1  5  1  3  1  4  1  2  1  3  1  1  1  2  1  0  1  1  1 4 1  1  1  1    1    1  4  1  4  1  3  1  3  1  2  1  2  1  1  1  1  1  0  1  0  1 5 1  1  1  1    1    1  4  1  4  1  3  1  3  1  2  1  2  1  1  1  1  1  0  1  0  1 31图 41 栈的顺序存储结构和操作过程示意图下面是出栈在顺序存储结构下的实现算法1 初始化栈  为空把栈设置为空并完成栈空间的动态存储分配      初始设置栈空间大小为 10 个元素位置    10    动态存储空间分配 若分配失败则退出运行      动态存储分配失败    1初始置栈为空12 元素  进栈 即插入到栈顶        若栈空间用完则自动扩大 2 倍空间原有栈内容不变    1           计算每个元素存储空间的长度         2        2   把栈空间大小修改为新的长度        栈项指针后移一个位置        将新元素插入到栈顶    3 删除栈顶元素并返回      若栈空则退出运行    1                   1        栈项指针减 1 表示退栈        返回原栈顶元素的值     1注意 做出栈操作时 栈顶指针下移 但原栈顶位置中保存的元素依然存在 仍可以被利用 只是不属于当前栈中的元素而已当前栈中的元素为从栈顶到栈底之间的所有元素4 读取栈顶元素的值  若栈空则退出运行 1           1返回栈顶元素的值 此算法只访问栈顶元素而不改变栈的状态并不修改栈顶指针的值5 判断是否为空若是则返回 否则返回        16 清除栈中的所有元素 释放动态存储空间                        0        1    0可采用下面程序调试上面介绍的栈的各种操作算法                   存栈元素                       存栈顶元素的下标位置                   存  数组长度 即所能存储栈的最大长度顺序栈运算     保存有上述 6 种对栈运算的算法               8385179301522 0 8    68     则得到的运行结果如下22 1568 6830 9 17 5 8 343 栈的链接存储结构和操作实现栈的链接存储结构与线性表的链接存储结构相同是通过由结点构成的单链表实现的此时表头指针被称为栈顶指针由栈顶指针指向的表头结点被称为栈顶结点整个单链表被称为链栈即链接存储的栈当向一个链栈插入元素时是把该元素插入到栈顶即使该元素结点的指针域指向原来的栈顶结点而栈顶指针则修改为指向该元素结点使该结点成为新的栈顶结点当从一个链栈中删除元素时是把栈顶元素结点删除掉即取出栈顶元素后使栈顶指针指向原栈顶结点的指针域所指向的结点由此可知对链栈的插入和删除操作是在单链表的表头进行的其时间复杂度为1设一个栈为 当采用链接存储时对应的存储结构示意图如图 42所示其中  表示栈顶指针其值为存储元素  结点的地址当向这个栈插入一个元素  后如图 42所示当从这个栈依次删除两个元素后如图 42所示当链栈中的所有元素全部出栈后栈顶指针  的值为空即常量  所表示的数值 0 原有栈 插入元素  删除两个元素图 42 栈的链接存储结构及操作过程示意图设链栈中的结点仍采用以前已经定义的  或  结点类型栈顶指针用  表示 下面给出对由  所指向的链栈进行每一种栈操作的算法1 初始化链栈       将链栈置空2 向链栈中插入一个元素         为插入元素获取动态结点          给新分配的结点赋值        向栈顶插入新结点        3 从链栈中删除一个元素并返回               不能从空栈删除                   1                         暂存栈顶结点指针                    使栈顶指针指向下结点           暂存原栈顶元素                        回收原栈顶结点                     返回原栈顶元素4 读取栈顶元素          为值参或引用形参均可             无法从空栈中操作                   1                     返回栈顶结点的值5 检查链栈是否为空                      为值参或引用形参均可     6 清除链栈为空                       给指针赋初值使之指向栈顶结点                从栈顶到栈底依次删除每个结点                                          置链栈为空44 栈的简单应用举例例41从键盘上输入一批整数然后按照相反的次序打印出来分析根据题意可知后输入的整数将先被打印出来这正好符合栈的后进先出的特点所以此题很容易用栈来解决若采用链栈其参考程序如下     定义元素类型为整型            链栈运算  保存着6种链栈运算的算法                       1       假定用1作为终止键盘输入的标志 栈不为空时依次退栈打印出来     从键盘上输入为78 63 45 82 91 34 1则输出为34 91 82 45 63 78例42栈在计算机语言的编译过程中用来进行语法检查 试编写一个算法 用来检查一个 语言程序中的大括号方括号和圆括号是否配对 若能够全部配对则返回 1 否则返回 0 分析 在这个算法中 需要扫描待检查程序中的每一个字符 当扫描到每个大中圆左括号时 令其进栈 当扫描到每个大中圆右括号时 则检查栈顶是否为相应的左括号 若是则作退栈处理 若不是则表明出现了语法错误 应返回 0 当扫描到程序文件结尾后 若栈为空则表明没有发现括号配对错误 应返回 1  否则表明栈中还有未配对的括号 应返回 0 另外 对于一对单引号或双引号内的字符不进行括号配对检查根据分析 编写出算法如下      对由所指字符串为文件名的文件进行括号配对检查          用文件输入流对象打开以所指字符串为文件名的文件    的系统头文件中定义有文件输入流类                       1                                   定义一个顺序栈                         栈被初始化                           顺序从文件中得到一个字符到变量中            39                   单引号内的字符不参与配对比较                            39      39为单引号的值              0      读到文件结束返回0 34             34  34为双引号的值      0 读到文件结束返回0                          出现以上3种左括号则进栈                                  栈顶的大括号出栈          0                                  栈顶的左中括号出栈          0                                  栈顶的左圆括号出栈          0  1  0下面程序调试上述算法                   顺序栈运算 该程序文件保存着6种顺序栈运算的算法       函数体同上       41    41为当前目录下的一个程序文件中括号配对正确     41 程序文件中括号配对正确     41 程序文件中括号配对错误例 43把十进制整数转换为二至九之间的任一进制数输出分析由计算机基础知识可知把一个十进制整数转换为任一种进制数得到的是一个进制的整数假定为转换方法是逐次除基数取余法具体叙述为首先用十进制整数除以基数得到的整余数是进制数的最低位0接着以除以的整数商作为被除数用它除以得到的整余数是的次最低位1以此类推直到商为 0 时得到的整余数是的最高位这里假设共有1位这样得到的与等值的按权展开式为01 2 2 若十进制整数为 3425把它转换为八进制数的过程如图 43 所示8  3425 余数 对应的八进制数位8  428  1 08  53  4 18  6  5 20  6 3图 43 十进制整数 3425 转换为八进制数的过程最后得到的八进制数为65418对应的十进制数为6835824813425即为被转换的十进制数证明转换过程是正确的从十进制整数转换为进制数的过程中由低到高依次得到进制数中的每一位数字而输出时又需要由高到低依次输出每一位所以此问题适合利用栈来解决具体算法描述如下        把一个长整型数  转换为一个  进制数输出               0                                  由高到低输出  进制数的每一位    用下面程序调用  函数的过程              链栈运算     实际运行时需要加上函数定义     3425 的八进制数为     34258    3425 的六进制数为     34256    3425 的四进制数为     34254    3425 的二进制数为     34252运行结果如下3425的八进制数为65413425的六进制数为235053425的四进制数为3112013425的二进制数为11010110000145 算术表达式的计算在计算机中进行算术表达式的计算是通过栈来实现的本节首先讨论算术表达式的两种表示方法即中缀表示法和后缀表示法接着讨论后缀表达式求值的算法最后讨论中缀表达式转换为后缀表达式的算法451 算术表达式的两种表示通常书写的算术表达式是由操作数又叫运算对象或运算量和运算符以及改变运算次序的圆括号连接而成的式子操作数可以是常量变量和函数同时还可以是表达式运算符包括单目运算符和双目运算符两类单目运算符只要求一个操作数并被放在该操作数的前面双目运算符要求有两个操作数并被放在这两个操作数的中间单目运算符为取正和取负双目运算符有加减乘和除等为了方便在讨论中只考虑双目运算符并且仅限于这4种运算如对于一个算术表达式25  6乘法运算符的两个操作数是它两边的5和6对于加法运算符的两个操作数一个是它前面的2另一个是它后面的5  6的结果即30把双目运算符出现在两个操作数中间的这种习惯表示叫做算术表达式的中缀表示这种算术表达式被称为中缀算术表达式或中缀表达式中缀表达式的计算比较复杂它必须遵守以下3条规则1 先计算括号内后计算括号外2 在无括号或同层括号内先进行乘除运算后进行加减运算即乘除运算的优先级高于加减运算的优先级3 同一优先级运算从左向右依次进行可以看出在中缀表达式的计算过程中既要考虑括号的作用又要考虑运算符的优先级还要考虑运算符出现的先后次序因此各运算符实际的运算次序往往同它们在表达式中出现的先后次序是不一致的是不可预测的当然凭直观判别一个中缀表达式中哪个运算符最先算哪个次之哪个最后算并不困难但通过计算机处理将困难得多那么能否把中缀算术表达式转换成另一种形式的算术表达式使计算简单化呢回答是肯定的波兰科学家卢卡谢维奇很早就提出了算术表达式的另一种表示即后缀表示又称逆波兰式其定义是把运算符放在两个运算对象的后面采用后缀表示的算术表达式被称为后缀算术表达式或后缀表达式在后缀表达式中不存在括号也不存在运算符优先级的差别计算过程完全按照运算符出现的先后次序进行整个计算过程仅需扫描一遍便可完成显然比中缀表达式的计算要简单得多例如对于后缀表达式12405其中字符表示空格因减法运算符在前除法运算符在后所以应先做减法后做除法减法的两个操作数是它前面的12和4其中第1个数12是被减数第2个数4是减数除法的两个操作数是它前面的124的差即8和5其中8是被除数5是除数中缀算术表达式转换成对应的后缀算术表达式的规则是把每个运算符都移到它的两个运算对象的后面然后删除掉所有的括号即可例如对于下列各中缀表达式13  5  6216  9  4  332      1  425          对应的后缀表达式分别为1356216943320  00  0  0100  04250  0  0000  0  00  0 从以上实例可以看出 转换前后每个数据元素的前后次序没有改变 改变的只是表达式中每个运算符的位置和次序45 2 后缀表达式求值的算法后缀表达式的求值比较简单 扫描一遍即可完成它需要使用一个栈 假定用  表示其元素类型应为操作数的类型 假定为浮点型  用此栈存储后缀表达式中的操作数计算过程中的中间结果以及最后结果一个后缀算术表达式以一个字符串的方式提供 后缀表达式求值算法的基本思路是 把包含后缀算术表达式的一个字符串由一个字符指针参数所指明 每次从该字符串中读入一个字符 若它是空格则不做任何处理 若它是运算符 则表明它的两个操作数已经在栈  中 其中栈顶元素为运算符的后一个操作数 栈顶元素的前一个元素为运算符的前一个操作数 把它们弹出后进行相应运算并保存到一个变量 假定为  中 否则 扫描到的字符必为数字或小数点 应把从此开始的浮点数字符串转换为一个浮点数并存入  中 然后把计算或转换得到的浮点数 即  的值 压入到栈  中依次向下扫描每一个字符并进行上述处理 直到遇到字符串结束符 即  为 0 的空字符 为止 表明后缀表达式计算完毕 最终结果保存在栈中 并且栈中仅存这一个值 把它弹出返回即可具体算法描述如下   计算由  所指字符串的后缀表达式的值用  栈存储操作数和中间计算结果 元素类型为  初始化栈 定义  用于保存浮点数 定义  用于扫描后缀表达式  0扫描后缀表达式中的每个字符 并进行相应处理   扫描到空格字符不做任何处理    做栈顶两个元素的加法 和赋给    做栈顶两个元素的减法 差赋给  弹出减数   做栈顶两个元素的乘法 积赋给    做栈顶两个元素的除法 商赋给 00  弹出被除数并计算   01  扫描到的是浮点数字符串 生成对应的浮点数0 利用  保存扫描到的整数部分的值48  57 1048  0 利用  保存扫描到的小数部分的值 100 用  作为相应小数位的权值48  57 48 10 把小数部分合并到整数部分  中把扫描转换后或进行相应运算后得到的一个浮点数压入栈  中  若计算结束后栈为空则中止运行    1若栈中仅有一个元素 则它就是后缀表达式的值 否则为出错     1释放  栈中动态存储空间此算法的运行时间主要消耗在 循环上 它从头到尾扫描后缀表达式中的每一个字符 若后缀表达式的字符串长度为 则此算法的时间复杂度为此算法在运行时所占用的临时空间主要取决于栈  的大小 显然 它的最大深度不会超过表达式中所含操作数的个数 因为操作数的个数比运算符的个数多1 所以此算法的空间复杂度也同样为若一个字符串  为 10 35  43 248   5 对应的中缀算术表达式为1035432485则使用如下语句调用上述函数得到的输出结果为8814在进行这个后缀算术表达式求值的过程中每处理一个操作数或运算符后栈中保存的操作数和中间结果的情况如图44所示  10   35      43   248            10  35  65  43  248    10    65  43          65         5             678  4407  5  8814  65    4407           图44 栈中数据的变化453 把中缀表达式转换为后缀表达式的算法设中缀算术表达式已经保存在1字符串中转换后得到的后缀算术表达式拟存于2字符串中由中缀表达式转换为后缀表达式的规则可知转换前后表达式中的数值项的次序不变而运算符的次序发生了变化由处在两个运算对象的中间变为处在两个运算对象的后面同时去掉了所有的括号为了使转换正确必须设定一个运算符栈并在栈底放入一个特殊算符假定为字符让它具有最低的运算符优先级假定为数值0此栈用来保存扫描中缀表达式时得到的暂不能放入后缀表达式中的运算符待它的两个运算对象都放入到后缀表达式以后再令其出栈并写入到后缀表达式中把中缀表达式转换为后缀表达式算法的基本思路是从头到尾扫描中缀表达式中的每个字符对于不同类型的字符按不同情况进行处理若遇到的是空格则认为是分隔符不需要进行任何处理若遇到的是数字或小数点则直接写入到2中并在每个数值的最后写入一个空格若遇到的是左括号则应把它压入到运算符栈中待以它开始的括号内的表达式转换完毕后再出栈若遇到的是右括号则表明括号内的中缀表达式已经扫描完毕把从栈顶直到保存着的对应左括号之间的运算符依次退栈并写入2串中若遇到的是运算符当该运算符的优先级大于栈顶运算符的优先级加减运算符的优先级设定为1乘除运算符的优先级设定为2在栈中保存的特殊运算符和的优先级设定为0时 表明该运算符的后一个运算对象还没有被扫描并放入到 2 串中 应把它暂存于运算符栈中 待它的后一个运算对象从 1 串中读出并写入到 2 串中后 再令其出栈并写入 2 串中 若遇到的运算符的优先级小于等于栈顶运算符的优先级 这表明栈顶运算符的两个运算对象已经被保存到 2 串中 应将栈顶运算符退栈并写入到 2 串中 对于新的栈顶运算符仍继续进行比较和处理 直到被处理的运算符的优先级大于栈顶运算符的优先级为止 然后令该运算符进栈即可按照以上过程扫描到中缀表达式字符串结束符时 把栈中剩余的运算符依次退栈并写入到后缀表达式中 再向 2 写入字符串结束符 0 整个转换过程就处理完毕 在 2 中就得到了转换成的后缀表达式将中缀算术表达式转换为后缀算术表达式的算法描述如下  1  2将字符串 1 中的中缀表达式转换为 2 字符串中的后缀表达式    定义用于暂存运算符的栈  并初始化 该栈的元素类型为              给栈底放入  字符 它具有最低优先级 0         定义   分别用于扫描 1 和指示 2 串中待存字符的位置     0 0    定义  保存 1 串中扫描到的字符 初值为第 1 个字符     1    依次处理中缀表达式中的每个字符    0         对于空格字符不做任何处理 顺序读取下一个字符          1        对于左括号 直接进栈                        1                对于右括号 使括号内的仍停留在栈中的运算符依次出栈并写入 2                         2             删除栈顶的左括号            1                对于运算符 使暂存于栈顶且不低于  优先级的运算符依次出栈并写入 2                                                            函数返回运算符形参的优先级                2                              把  运算符写入栈中1此处必然为数字或小数点字符否则为中缀表达式错误 若  不是数字或小数点字符则退出运行0  9   中缀表达式表示错误1把一个数值中的每一位依次写入到 2 串中0  9   21被放入 2 中的每个数值后面接着放入一个空格字符2 将暂存在栈中的运算符依次退栈并写入到 2 串中    1 2在后缀表达式的末尾放入字符串结束符20其中求运算符优先级的  函数定义如下    返回运算符  所对应的优先级数值    1 定义加减运算的优先级为 1   2 定义乘除运算的优先级为 2       0            定义在栈中的左括号和栈底字符的优先级为0在这个转换算法中 中缀算术表达式中的每个字符均需要扫描一遍 对于从 1 中扫描得到的每个运算符 最多需要进行入  栈出  栈和写入 2 后缀表达式这三次操作对于从 1 中扫描得到的每个数字或小数点 只需要把它直接写入到 2 后缀表达式即可所以 此算法的时间复杂度为为后缀表达式中字符的个数该算法需要使用一个运算符栈 需要的深度不会超过中缀表达式中运算符的个数 所以此算法的空间复杂度至多为利用表达式的后缀表示和堆栈技术只需要两遍扫描就可完成中缀算术表达式的计算显然比直接进行中缀算术表达式计算的扫描次数要少得多在上述讨论的中缀算术表达式求值的两个算法中 把中缀表示转换为后缀表示的算法需要使用一个字符栈 而进行后缀表达式求值的算法又需要使用一个浮点数栈 这两个栈的元素类型不同 所以栈的类型无法作为全局量来定义 栈运算的函数也无法适应这种要求为了解决这个问题 必须把  栈类型定义为模板类 把栈运算的函数定义为该类的公用成员函数 通过调用成员函数来实现栈的运算这里对此不作深入讨论 留给读者练习采用下面程序调试上述中缀转后缀的算法                       存栈元素                           存栈顶元素的下标位置                       存  数组长度亦即所能存储栈的最大长度顺序栈运算      1  2   给出函数具体定义      30     30    请输入一个中缀算术表达式         对应的后缀算术表达式为 显示结果如下请输入一个中缀算术表达式12320486对应的后缀算术表达式为12 3 20 4   8  6  46 栈与递归递归是一种非常重要的数学概念和解决问题的方法 在计算机科学和数学等领域有着广泛地应用当求解一个问题时 是通过求解与它具有同样解法的子问题而得到的 这就是递归一个递归的求解问题必然包含有终止递归的条件 当满足一定条件时就终止向下递归 从而使最小的问题得到解决 然后再依次返回解决较大的问题 最后解决整个问题解决递归问题的算法称为递归算法 在递归算法中需要根据递归条件直接或间接地调用算法本身 当满足终止条件时结束递归调用当然对于一些简单的递归问题 很容易把它转换为循环问题来解决 从而使编出的算法更为有效例44采用递归算法求解正整数的阶乘分析 由数学知识可知阶乘的递归定义为 它等于乘以1的阶乘 即1并且规定0的阶乘为1设函数 则可表示为 1  0   1  0其中0为递归终止条件 使函数返回10实现递归调用 由的值乘以1的返回值 求出的值用 语言编写出求解的递归函数如下      0         1             1当从主程序或其他函数非递归调用此阶乘函数时 首先把实参的值传送给形参 同时把调用后的返回地址保存起来 以便调用结束后返回之用 接着执行循环体 当等于 0 时则返回函数值 1  结束本次非递归调用或递归调用 并按返回地址返回到进行本次调用的调用函数的位置继续向下执行 当大于 0 时 则以实参1的值去调用本函数 即递归调用 返回的值与本次递归调用所求值的乘积因为进行一次递归调用 传送给形参的值就减 1  所以最终必然导致的值为 0  从而结束递归调用 接着不断地执行与递归调用相对应的返回操作 最后返回到进行非递归调用的调用函数的位置向下执行若用4去调用函数 该函数返回4  3的值 因返回表达式中包含有函数3所以接着进行递归调用 返回3  2的值 以此类推 当最后进行0递归调用 返回函数值 1 后 结束本次递归调用 返回到调用函数0的位置 从而计算出1  0的值 1 即1  0  1  1  1 作为调用函数1的返回值 返回到2  1表达式中 计算出值 2 作为2函数的返回值 接着返回到3  2表达式中 计算出值 6 作为3函数的返回值 再接着返回到4  3表达式中 计算出4的返回值 24  从而结束整个调用过程 返回到调用函数4的位置继续向下执行上述调用和返回过程 如图 45 所示45图 45 利用4调用递归函数的执行流程在计算机系统内 执行递归函数是通过自动使用栈来实现的 栈中的每个元素包含有递归函数的每个参数域每个局部变量量和调用后的返回地址域 其中引用参数域只保存传送来的实参的地址 以便按此地址访问实参的存储空间存取其值 其他的每个域是用于存储其值的实际存储空间每次进行函数调用时 都把相应的值压入栈 每次调用结束时都按照本次返回地址返回到指定的位置执行 并且自动做一次退栈操作 使得上一次调用所使用的参数成为新的栈顶项 继续被使用例如对于求阶乘的递归函数 当调用它时系统自动建立一个栈 该栈中的元素包含值参的域和返回地址  域 若用4去调用函数 调用后的返回地址用 1 表示在函数中 每次进行1调用的返回地址用 2 表示 则系统所使用栈的数据变化情况如图 46 所示其中 每个栈状态的栈顶元素的  域是调用函数时为值参所分配的存储空间  域为保存当前一次调用结束后的返回地址所分配的存储空间如进行4调用时 栈顶元素中的值参域保存的值为 4  返回地址域保存的值为 1 当执行4调用结束 即执行到函数体的右花括号结束符 后 就返回到 1 的位置执行又如当执行3调用时 栈顶元素中的值参域保存的值为 3  返回地址域保存的值为 2 当调用3结束后 就返回到 2 的位置 即上一层返回表达式中乘号后面的位置 执行当调用算法时 系统所使用栈的最大深度为1为首次调用时传送给来的实参的值 所以其空间复杂度为又因为每执行一次递归调用就是执行一条条件语句 其时 计算4值 计算3值 计算2值 计算1值 计算0值 返回0值 1 返回1值 1 返回2值 2 返回3值 6 返回4值 24图 46 进行4调用的系统栈的变化状态间复杂度为1 执行整个算法求出的值需要进行1次调用 所以其时间复杂度也为由于采用循环算法求解的问题 其空间复杂度为1 时间复杂度为 并且省去进出栈的繁琐操作 显然比采用递归算法更为有效求阶乘采用递归算法 是为了详细说明系统对递归算法的处理过程 以便能够理解更复杂的递归算法例 45编写一个算法输出个布尔量的所有可能的组合分析 每个布尔量取真和假两种值 分别对应为数值 1 和 0根据题意 当为 1 时有两种输出 0 和 1 当为 2 时有 4 种组合输出 依次为 000110 和 11 当为 3 时有 8 种组合输出 依此为 000001010011100101110 和 111总之 对于个布尔量所有可能的组合数为2种 每一种为位 即个布尔量的值个布尔量的2种所有不同的输出可以看成2  21种输出 其中21种输出是1个布尔量的全部输出 每种输出包含有1个布尔量的值个布尔量的每一种输出是在1个布尔量的每种输出的前面加上假 即 0 或加上真 即 1 而分别得到的结果 合起来正好是2  21  2种输出由此可以看出它是一个递归的过程设个布尔量用一个布尔型数组来表示 要得到0  1这个布尔量的每一种可能的组合 则要首先在0被置 0 的情况下得到1  1这1个布尔量的每一种可能的组合 然后在0被置 1 的情况下得到1  1这1个布尔量的每一种可能的组合 同理 要得到1  1这1个布尔量的每一种可能的组合 则要首先在1被置 0 的情况下得到2  1这2个布尔量的每一种可能的组合 然后在1被置 1 的情况下得到2  1这2个布尔量的每一种可能的组合 以此类推 直到最后一个布尔量1被置 0 后输出整个数组和被置 1 后输出整个数组为止下面递归算法是对  1之间的个布尔量输出所有可能的组合 初始调用该算法时值为 0                       终止递归输出在数组中排列好的一种组合          0                                           把下标为的布尔量置0后从下标1起递归调用          1         把下标为的布尔量置1后从下标1起递归调用          1     此算法的每一次调用都要引起两次递归调用当时输出一种组合并结束本次调用返回到原来调用函数的位置继续执行若第1次非递归调用为叙述方便可把这次调用称为第0次递归调用时传送给的值为0则共需要进行211次递归调用含第0次递归调用对于个布尔量共需要输出2种所有不同的组合所以在211次递归调用中共有2次递归调用输出数组的值例如当3时整个递归调用的次数为15次输出8种不同的组合当4时整个递归调用的次数为31次输出16种不同的组合当用户调用这个算法时系统自动建立一个栈该栈包含布尔型指针值参的域整型值参的域和的域以及返回地址的域第0次递归调用后的返回地址假定为1该算法中第1条递归调用语句执行后的返回地址即为执行语句的地址假定为2第2条递归调用语句执行后的返回地址即为语句块结束的地址亦即算法的结束地址假定为3若用03去调用这个算法其中是一个元素个数大于等于3的布尔型数组感兴趣的同学可以画出系统栈和数组在算法执行过程中的变化状态由于值参和的值始终不变在栈中不用给出它们所对应的域只用给出值域和返回地址即可此算法需要递归调用211次其中有2次需要调用输出数组中个元素的值所以算法的时间复杂度为 2该算法所使用的系统栈的最大深度为1所以其空间复杂度为为布尔量的个数例46编写一个递归算法输出自然数1 这个元素的全排列分析由排列组合的知识可知个元素的全排列共有种如对于123这三个元素其全排列为123132213231321312共36种种可分解为1种而1种又可分解为12种以此类推对于个元素可把它们分别放入到个位置上让第一个位置依次取每一个元素共有种不同的取法对其后1个位置上的1个元素共有1种不同的排列所以总共有1种不同的排列同样对于从第2个位置开始的所有元素让第2个位置依次取除第1个位置上的元素之外的剩余1个元素共有1种不同的取法对其后2个位置上的2个元素共有2种不同的排列以此类推当进行到第位置时只有一种取法因为前1个位置已经固定了1个元素剩余的一个元素被放在这个位置上若用一个数组 来保存 1之间的 个自然数 对于 01 每次使 0同 交换 0121 后 对 11中的 1个元素进行全排列 然后再交换 0与 的值 使它恢复为此次排列前的状态 同样 对于 11区间内的 1个元素每次使 1同 交换 121 后 对 21区间内的 2个元素进行全排列 然后再把交换的元素交换回来 以此类推 直到对 1进行全排列时 输出整个数组的值 即得到一种排列结果对 个元素的全排列是一个递归过程 具体描述如下          对 1中的 个元素进行全排列  的初值应为 0          当递归排序到最后一个元素时结束递归 输出  中保存的一种排列     1         0                    其他情况需要递归排列                             循环  次 每次使 取一个新值            交换 与 的元素值                          对 11中的元素进行递归排序             1             恢复 与 的原有值                      此算法的时间复杂度为 因为共需要进行 次递归调用 空间复杂度为因为系统栈的最大深度为 可以使用下面程序调用此算法  6          定义全排列的元素个数的最大值          对 1中的 个元素进行全排列  的初值为 0     函数体如上所述                 定义存储  个整型元素的数组         1         输入  的值 它应在 1 和 之间                输入待全排列的元素的实际个数        1        0   1 给数组赋初值 0  对数组中的个元素即1 进行全排列程序运行时假定从键盘上输入的值为3则运行结果如下输入的值它应在1和6之间31 2 31 3 22 1 32 3 13 2 13 1 2例47求解迷宫问题分析一个迷宫包含有行 列个小方格每个方格用0表示可通行用1表示墙壁即不可通行迷宫中通常有一个入口和一个出口设入口点的坐标为11出口点的坐标为当然入口点和出口点的值应均为0即可通行从迷宫中的某一个坐标位置向东南西北任一方向移动一步即一个方格时若前面的小方格为0则可前进一步否则通行受阻不能前进应按顺时针改变为下一个方向移动求解迷宫问题是从入口点出发寻找一条通向出口点的路径并打印出这条路径即经过的每个小方格的坐标如图47所示为一个68的迷宫入口点坐标为11出口点坐标为68其中的一条路径为111222233334353646475767680  0  0  1  1  0  1  0 1  0  0  1  1  0  0  0 0  0  0  0  0  0  1  1 1  1  0  1  1  0  0  0 0  0  0  0  0  1  0  1 1  0  1  0  0  0  0  0  一个68的迷宫0  1  2  3  4  5  6  7  8 1  1  1  1  1  1  1  1  1 1  0  0  1  1  0  1  0  1 1  1  0  0  1  1  0  0  0 1  0  0  0  0  0  1  1  1 1  1  1  0  1  1  0  0  0 1  0  0  0  0  0  1  0  1 1  1  0  1  0  0  0  0  1 1  1  1  1  1  1  1  1  1  带四周墙壁的迷宫图47 迷宫阵列图在一个迷宫中中间的每个方格位置都有四个可选择的移动方向而在四个顶点只有两个方向并且每个顶点的两个方向均有差别每条边线上除顶点之外的每个位置只有三个方向并且也都有差别为了在求解迷宫的算法中避免判断边界条件和进行不同处理的麻烦使每一个方格都能够试着按四个方向移动可在迷宫的周围镶上边框在边框的每个方格里填上1作为墙壁如图47所示这样需要用一个22大小的二维整型数组用表示数组名来存储迷宫数据当从迷宫中的一个位置称它为当前位置前进到下一个位置时下一个位置相对于当前位置的位移量包括行位移量和列位移量随着前进方向的不同而不同东南西北即右下左上各方向的位移量依次为011001和10用一个42的整型数组来存储位移量数据则数组的内容如右上面表格所示其中03依次存储向东南西北每个方向移动一步的位移量如10和11分别为从当前位置向南移动一步的行位移量和列位移量其值分别为1和0在求解迷宫问题时还需要使用一个与存储迷宫数据的数组同样大小的辅助数组用标识符表示用它来标识迷宫中对应位置是否被访问过该数组每个元素的初始值为0表示迷宫中的所有位置均没有被访问过每访问迷宫中一个可通行的位置时都使数组中对应元素置1表示该位置已经被访问过以后不会再访问到这样才能够探索新的路径避免重走已经走不通的老路为了寻找从入口点到出口点的一条通路首先从入口点出发按照东南西北各方向的次序试探前进若向东可通行同时没有被访问过则向东前进一个方格否则表明向东没有通向出口的路径接着应向南方向试着前进若向南可通行同时没有被访问过应向南前进一步否则依次向西和向北试探若试探完当前位置上的所有方向都没有通路则应退回一步到达该当前位置的下一个方向试探着前进如到达该当前位置的方向为东则下一个方向为南因此每前进一步都要记录其上一步的坐标位置以及前进到此步的方向以便退回之用这正好需要用栈来解决每前进一步时都把当前位置和前进方向进栈接着使向前一步后的新位置成为当前位置若从当前位置无法继续前进时就做一次退栈操作从上一次位置的下一个方向试探着前进若当前位置是出口点时则表明找到了一条从入口点到出口点的路径应结束算法执行此时路径上的每个方格坐标除出口坐标外均被记录在栈中若做退栈操作时栈为空则表明入口点也已经退栈并且其所有方向都已访问过没有通向出口点的路径此时应结束算法打印出无通路信息栈和递归是可以相互转换的当编写递归算法时虽然表面上没有使用栈但系统执行时会自动建立和使用栈求解迷宫问题也是一个递归问题适合采用递归算法来解决若迷宫中的当前位置初始为入口点就是出口位置则表明找到了通向出口的一条路径应返回结束递归若当前位置上的所有方向都试探完毕表明从当前位置出发没有寻找到通向出口点的路径应返回结束递归若从当前位置按东南西北方向的次序前进到下一个位置时若该位置可通行且没有被访问过则应以该位置为参数进行递归调用若返回的话表明从该位置到出口点有通路输出该位置坐标后继续向上一个位置返回结束递归下面给出求解迷宫问题的递归算法其中和为全局整型常量分别表示迷宫的行数和列数 亦即出口点的坐标  和  分别为具有22大小的全局整型数组 分别用来保存迷宫数据和访问标记  为具有42大小的全局整型数组 用来保存向每个方向前进的位移量       从迷宫中坐标点的位置寻找通向终点的路径若找到则    返回 否则返回 的初始值通常为11     作为循环变量代表从当前位置移到下一个位置的方向          和  用作为下一个位置的行坐标和列坐标         到达终点返回  结束递归           依次按每个方向寻找通向终点的路径0123分别为东南西北方向    04             求出下一个位置的行坐标和列坐标01        若下一位罝可通行同时没有被访问过则从该位置起寻找         00                    置  数组中对应位置为 1 表明已访问过            1            当条件成立 即返回 时表明从到终点存在            通路应输出该位置坐标同时返回  结束递归            否则进入下一轮循环向下一个方向试探                                                                             从当前位置没有通向终点的路径应返回      当用户调用这个递归算法时 系统将自动建立含有值参  和  域 局部变量  和  域以及返回地址  域的一个栈 每次递归调用时都自动进行进栈操作 每次算法执行结束 包括执行到  语句或算法最后的花括号 后都自动进行出栈操作若算法执行时的  数组 如图 47  所示 第 0 次递归调用时的返回地址用 1 表示 算法中仅有一处递归调用 其返回地址用 2 表示 则从第 0 次递归调用到第 3 次递归调用前系统栈的变化状态 如图 48 所示对于系统栈的以后变化 读者可继续分析该算法的运行时间和使用系统栈所占有的存储空间与迷宫的大小成正比在最好情况下的时间和空间复杂度均为在最差情况下均为  平均情况在它们之间下面给出求解迷宫算法的完整程序  68 定义和常量假定求解图47所示的迷宫问题 22 定义保存迷宫数据的数组 22 定义保存访问标记的数组 4201100110行下标0123分别代表东南西北方向    函数体在此省略          输入迷宫数据    0 2         0 2                 初始化数组    0 2         0 2             0    置入口点对应的访问标记为1    111    从入口点11开始调用求解迷宫的递归算法    11        11 从入口到出口的路径    按所经位置的相反次序输出最后需要输出入口点的坐标当按图 47 输入迷宫数据则得到如下输出结果在第8个坐标后的回车是另加的68675747463635343323221211例 48求解汉诺塔  问题此问题为有3个台柱分别编号为或123在柱上穿有个圆盘每个圆盘的直径均不同并且按照直径从大到小的次序叠放在柱子上要求把柱上的个圆盘搬到柱上柱可以作为过渡并且每次只能搬动一个圆盘同时必须保证在任何柱子上的圆盘在任何时候都要按序码放即大的在下小的在上当把若干个圆盘从一个柱子搬到另一个柱子时第3个柱子作为过渡使用题目要求编写出一个算法输出搬动圆盘的过程分析若一个柱子上只有一个圆盘则不需要使用过渡台柱直接把它放到目的地柱上即可若一个柱子上有两个圆盘则先把一个只能是上面一个放到过渡柱子上再把另一个放到目的地柱上最后把过渡柱上的一个圆盘放到目的地柱上到此完成搬动过程若一个柱子上有3个4个又如何解决呢必须找出适用于任意多个即大于等于2个情况的通用方法或规则才行由此可能想到递归即先把原柱子上的1个圆盘设法搬到过渡柱上再把原柱子上剩下的最后一个圆盘直接搬到目的地柱上最后设法把过渡柱上的1个圆盘搬到目的地柱上从而完成全部搬动过程当把1个圆盘从一个柱子搬到另一个柱子时若它的圆盘数不是一个又需要使用第3个柱子作为过渡此递归就是把的问题化解为两个1的问题当等于1时不需要再递归只需要直接移动即可例如当柱上有3个圆盘要求把它移动到柱上则需要如下步骤完成1 把柱上的2个圆盘直接移到过渡柱上① 把柱上的1个圆盘直接移到此时的过渡柱上② 把柱上剩余的1个圆盘直接移到此时的目的柱上③ 把此时的过渡柱上的1个圆盘直接移到此时的目的柱上2 把柱上剩下的1个圆盘直接移到目的地柱上3 把过渡柱上的2个圆盘移到目的地柱上① 把柱上的1个圆盘直接移到此时的过渡柱上② 把柱上剩余的1个圆盘直接移到此时的目的柱上③ 把此时的过渡柱上的1个圆盘直接移到此时的目的柱上上述整个移动过程为7个直接步骤依此如下或用数字编号写为13123213212313根据以上分析设把个盘子由值参所表示的柱子搬到由值参所表示的柱子用值参所表示的柱子作为过渡则编写出递归算法如下            当只有一个盘子时直接由柱搬到柱后结束一次调用1 当多于一个盘子时 向下递归     首先把1个盘子由值参  所表示的柱子搬到由值参  所表示    的柱子上 用值参  所表示的柱子作为过渡    1    把由值参  所表示的柱子上的最后一个盘子搬到由值参  所    表示的柱子上        最后把1个盘子由值参  所表示的柱子搬到由值参  所表示    的柱子上 用值参  所表示的柱子作为过渡    1采用 3123 去调用该递归函数则得到的整个递归调用关系如图 49 所示它是一棵树结构每个树叶结点下面的输出是执行  1 子句中输出语句的结果每个树枝结点下的输出是执行  子句中输出语句的结果其中函数名简记为 图 49 执行 3123 时的递归调用关系树调用上述递归算法时若实参的值为 1 则算法被执行 1 次若值为 2 则被执行 3 次若为 3 则被执行 7 次以此类推总之被执行21次所以此算法的时间复杂度为2算法在执行时系统需要自动建立工作栈栈的深度等于对应递归调用关系树的深度即层数该深度等于所以此算法的空间复杂度为若采用 4123 调用上述递归函数则得到的输出结果如下其中为了节省篇幅把换行换成了空格12 13 23 12 31 32 13 21 23 12 31 23 13 21 2347 队列471 队列的定义队列  简称队它也是一种运算受限的线性表其限制是仅允许在表的一端进行插入 而在表的另一端进行删除把进行插入的一端称作队尾  进行删除的一端称作队首向队列中插入新元素称为进队或入队新元素进队后就成为新的队尾元素从队列中删除元素称为离队或出队元素离队后其后继元素就成为队首元素由于队列的插入和删除操作分别是在各自的一端进行的每个元素必然按照进入的次序离队所以又把队列称为先进先出表   在日常生活中人们为购物或等车时所排的队就是一个队列新来购物或等车的人接到队尾即进队站在队首的人购到物品或上车后离开即出队当最后一人离队后则队列为空若有共4个元素依次进队则得到的队列为其中字符为队首元素字符为队尾元素若从此队中删除一个元素则字符出队字符成为新的队首元素此队变为若接着向该队列插入一个字符则成为新的队尾元素此队变为若接着做3次删除操作则队列变为此时只有一个元素它既是队首元素又是队尾元素当它被删除后队列变为空47 2 队列的抽象数据类型队列的抽象数据类型中的数据部分为具有元素类型的一个队列它可以采用任一种存储结构实现操作部分包括元素进队出队读取队首元素检查队列是否为空等队列的抽象数据类型的具体定义如下  一个队列假定用标识符表示队列的存储类型   初始化队列置为空     将新元素插入队尾   从队列中删除队首元素并返回   返回队首元素不改变队列状态   判断队列是否为空   清除队列使之成为空队 有一个队列其元素类型为整型下面给出调用上述操作的一些例子 把队列置空35 元素35进队 12 23 元素23的值27进队16 元素16进队此时队列为352716 输出队首元素35  依次删除元素35和27   依次输出队列中的所有元素因中只有一个元素16所以此循环只输出它473 队列的顺序存储结构和操作实现队列的顺序存储结构需要使用一个数组和 23 个整型变量来实现 利用数组来顺序存储队列中的所有元素 利用一个整型变量存储队首元素的位置 通常存储队首元素的前一个位置 利用另一个整型变量存储队尾元素的位置 利用第三个整型变量 若使用的话 存储队列的长度 即队列中当前已有的元素个数把指向队首元素前一个位置的变量称为队首指针 由它加 1 就得到队首元素的下标位置 把指向队尾元素位置的变量称为队尾指针 由它可直接得到队尾元素的下标位置若存储队列的数组用 表示 队首指针和队尾指针分别用  和  表示 存储队列长度的变量用  表示 则元素类型为  的队列的顺序存储结构可通过下列一组定义来描述   为已定义的常量   其中  的值确定了  数组所能存储队列的最大长度队列的顺序存储结构同样可以被定义在一个结构类型中 假定该结构类型用  表示 则定义为              若要对存储队列的数组空间采用动态分配 则定义为        指向存储队列的数组空间        队首指针队尾指针队列长度变量       数组长度每次向队列插入一个元素 需要首先使队尾指针后移一个位置 然后再向这个位置写入新元素当队尾指针指向数组空间的最后一个位置 1 时 若队首元素的前面仍存在空闲的位置 则表明队列未占满整个数组空间 下一个存储位置应是下标为 0 的空闲位置 因此 首先要使队尾指针指向下标为 0 的位置 然后再向该位置写入新元素通过赋值表达式1可使存储队列的整个数组空间变为首尾相接的一个环 所以顺序存储的队列又称为循环队列在循环队列中 其存储空间是首尾循环利用的 当  指向最后一个存储位置时 下一个所求的位置自动为数组空间的开始位置 即下标为 0 的位置每次从队列中删除一个元素时 若队列非空 则首先把队首指针后移 使之指向队首元素 然后再返回该元素的值使队首指针后移也必须采用取模运算 该计算表达式为1 这样才能够实现存储空间的首尾相接当一个顺序队列中的域的值为 0 时 表明该队列为空 则不能进行出队和读取队首元素的操作 当域的值等于时 表明队列已满 即存储空间已被用完 此时应动态扩大存储空间 然后才能插入新元素在队列类型的定义中 若省略长度域也是可行的 但此时的长度为的数组空间最多只能存储长度为1的队列 也就是说必须有一个位置空闲着因为若使用全部个位置存储队列 则当队首和队尾指针指向同一个位置时 也可能为空队 也可能为满队 就存在二义性 无法进行判断为了解决这个矛盾 只有牺牲一个位置的存储空间 让队首指针所指的存储位置始终空闲着 利用队首和队尾指针是否相等只作为判断空队的条件 而利用队尾指针加 1 并对取模后是否等于队首指针 即队尾是否从后面又追上了队首 作为判断满队的条件采用顺序存储结构的队列被称为顺序队列下面给出在顺序队列上进行各种队列运算的算法1 初始化队列初始化队列为空并带有动态存储空间分配   初始设置队列空间大小为 10 个元素位置10动态存储空间分配 初始置队列为空02 向队列插入元素 若队列已满需重新分配更大的存储空间    对存储空间用完情况进行处理 1 扩大 2 倍的存储空间  2把原队列的尾部内容向后移动  个位置  1  0   队尾指针后移  个位置把队列空间大小修改为原值的 2 倍2求出队尾的下一个位置1把的值赋给新的队尾位置3 从队列中删除元素并返回      若队列为空则终止运行             队列已空无法删除        1        使队首指针指向下一个位置    1    返回队首元素     4 读取队首元素不改变队列状态      若队列为空则退出程序运行             队列已空无法读取        1        队首元素是队首指针的下一个位置中的元素     15 检查一个队列是否为空若是则返回 否则返回        6 清除一个队列为空并释放动态存储空间            0        0在顺序队列中进行任何操作的时间复杂度均为1 当然队满时可能需要复制原队列部分内容的情况除外顺序队列的插入和删除过程 如图 410 所示 从中可以清楚地看出队列内容及队首和队尾指针的变化情况此队列的初始数组空间长度为 51 0  1  2  3  4 空队列首尾指针均为 02 0  1  2  3  4 连续插入三个元素 2536493 0  1  2  3  4 接着插入一个元素 304 0  1  2  3  4 连续删除两个元素 25 和 365 66 23 49 30 连续插入两个元素 66 和 236 0  1  2  3  4  5  6  7  8  9 插入元素 52 时 队满扩大空间7 38 49 30 66 23 52 47 15 连续插入元素 47 15388 38 49 30 66 23 52 47 15 连续删除四元素图 410 顺序队列的插入和删除操作示意图47 4 队列的链接存储结构和操作实现队列的链接存储结构也是通过由结点构成的单链表实现的 此时只允许在单链表的表头进行删除和在单链表的表尾进行插入 因此它需要使用两个指针 队首指针  和队尾指针 用  指向队首即表头结点的存储位置用  指向队尾即表尾结点的存储位置用于存储队列的单链表简称链接队列或链队设链队中的结点类型仍为以前定义的单链表结点类型  或 那么队首和队尾指针为 指针类型若把一个链队的队首指针和队尾指针定义在一个结构类型中并设该结构类型用标识符  表示则具体定义如下        队首指针       队尾指针其中 结点类型在第 2 章已经给出这里重写如下        值域        链接指针域一个链接存储的队列如图 411 所示图 411 链队的示意图在类型为  的链队  上进行队列的各种操作的算法如下1 初始化链队       把队首和队尾指针置为空2 向链队中插入一个元素           得到一个新结点           把  的值赋给新结点的值域           把新结点的指针域置空            若链队为空则新结点既是队首又是队尾                                 若链队非空则新结点被链接到队尾并修改队尾指针        3 从队列中删除一个元素         若链队为空则中止运行        链队为空无法删除        1          暂存队首元素以便返回      暂存队首指针以便回收队首结点     使队首指针指向下一个结点     若删除后链队为空则使队尾指针为空              回收原队首结点      返回被删除的队首元素4 读取队首元素         若链队为空则中止执行        链队为空无队首元素        1          返回队首元素5 检查链队是否为空      判断队首或队尾任一个指针是否为空即可     6 清除链队中的所有元素使之变为空队        队首指针赋给             依次删除队列中的每一个结点                              循环结束后队首指针已经变为空     置队尾指针为空除清除队列操作外其余对链队操作的时间复杂度均为1 清除队列操作的时间复杂度为表示队列的长度可以用下面程序调试对链接队列进行各种运算的算法                   值域                 链接指针域                  队首指针                 队尾指针链接队列运算               938517930152220         0 9                    68    0 9 2                        运行结果如下3 8 517 179 30 15 22 20 68 3 5 9 15 20除了上面介绍的一般队列外还有一种特殊的队列叫做优先级队列这种队列中的每个元素都带有一个优先级号用以表示其优先级别在优先级队列中优先级最高的元素必须处在队首位置 因此 每次向它插入元素时 都要按照一定次序调整元素位置 确保把优先级最高的元素调整到队首 每次从中删除队首元素 即优先级最高的元素 时 也都要按照一定次序调整队列中的有关元素 确保把优先级最高的元素调整到队首优先级队列在操作系统中的各种调度算法中应用广泛 它需要使用堆结构来实现 这将在第6章中介绍48 队列应用举例队列在日常生活和计算机领域都有着广泛的应用 下面以一个轮船渡口管理为例 来说明队列的具体应用有一个渡口 每条渡轮一次能装载 10 辆汽车过江 过江车辆分为客车和货车两类 上渡轮有如下规定1 同类汽车先到先上船2 客车先于货车上船3 每上 4 辆客车才允许上一辆货车 但若等待的客车不足 4 辆则用货车填补 反过来 若没有货车等待则用客车填补4 装满 10 辆后则自动开船 当等待时间较长时车辆不足 10 辆也应人为控制发船分析 此题应建立和使用两个队列 一个为客车队列 另一个为货车队列 到渡口需过江的汽车分别进入到相应队列中当渡口有渡轮时先让客车队列中的 4 个车辆出队并开进渡轮 再让货车队列中的一个车辆出队并开进渡轮 若某一类车辆队列为空则从另一个队列中补充当渡轮上的车辆已装满则自动开船 此时应打印出已装车辆的每个车号若装载不足 10 辆 但两个车辆队列全为空 应继续等待一段时间 若等待时间较长 仍不满载则应人为控制开船根据分析可编写出如下程序 此头文件中含有  函数和  函数的声明                   值域                 链接指针域                  队首指针                 队尾指针链接队列运算输出每次渡轮所载汽车的编号          0 当前机器系统时间被保存到中单位为秒        轮渡开始起航    本次过江时间            函数的值为根据参数转换得到的日期和时间的字符串    本次轮渡所载汽车     0        输出汽车排队等待情况   1   2    客车排队的情况     1     暂时无客车等候                                  货车排队的情况    2     暂时无货车等候                                   1和2队列用来分别存储待渡江的客车和货车     12    对1和2进行初始化    1    2    用保存用户选择用登记渡轮到渡口     0    用数组记录渡轮船上的每个汽车号用记录汽车的个数     10 0    用1和2登记时间     12    程序处理过程     显示功能表并接受用户选择    1功能表    1车到渡口进行登记    2渡轮到渡口进行登记    3汽车上渡轮    4命令渡轮起航    5输出当前汽车排队情况    6结束程序运行    请输入你的选择16                      1   6 输入功能号错重输      1   6         根据不同选择进行相应处理               1            输入车辆号假定小于100为客车否则为货车            可以输入多辆车用空格分开直到输入1为止            1                                 1                  100 1 客车进 1 队                 2          货车进 2 队                                                   结束  语句         2            1                 渡轮已在渡口等待不要重复登记                                       结束  语句                        1                          渡轮到口岸登记            渡轮已到渡口可以上船            0                             装载车辆数初始为010                      登记渡轮到渡口时间单位为秒                                       结束  语句         3            12                 暂无汽车过江                10                     201           计算到目前为止渡轮等待时间的秒数                    轮渡未满有车辆已等待260分                    260秒等候其他汽车上渡轮                              结束  语句1     渡轮未到请汽车稍后上渡轮      结束  语句     0    首先上4辆客车    1  10  4         1                满10辆开船打印车辆号重新对和清0转功能号表    10  0 0  1    进4辆客车则接着进一辆货车不满4辆则由货车补    4         2 2                 2  10  5             2                            满10辆则开船    10  0 0  1 1  2    只要客车或货车队列不全为空则继续执行循环201  登记渡轮已经等待时间的秒数轮渡上有车辆已等待260分260秒等候其他汽车上渡轮  结束  语句 4    0  0        轮渡上无车过江或根本无渡轮不需要起航              0 0          结束  语句 5    12      结束  语句 6    1  2 还有汽车未渡江暂不能结束                      结束  语句0     渡轮上有车不能结束需命令开渡轮                      结束  语句程序运行结束                     执行结束返回                            语句终端位置 1                 外层  循环终端位置12                           主函数结束位置习 题 4习题 41运算题1 有 6 个元素  依次进栈允许任何时候出栈能否得到下列的每个出栈序列若能给出栈的操作过程若不能简述其理由1 2 3 4 2 有 4 个元素  依次进栈任何时候都可以出栈请写出所有可能的出栈序列和所有不存在的序列3 用一维数组 7顺序存储一个循环队列队首和队尾指针分别用  和  表示当前队列中已有 5 个元素2345678034其中23 为队首元素 的值为 3请画出对应的存储状态当连续做 4 次出队运算后再让 153648 元素依次进队请再次画出对应的存储状态4 用于顺序存储一个队列的数组的长度为 队首和队尾指针分别为  和 写出求此队列长度即所含元素个数的公式习题 42算法分析写出每个算法的功能1         0  0      112                            第1次使用 00调用此算法    1000  1                                  3     为正整数             0            16                16                          10                                         10                   11                   12                   13                   14                   15                             4  1 1      0 函数在  头文件中定义     0              100  函数在  头文件中定义          平方根函数  在  头文件中定义        2              0           10 1    5  2 1  2           从键盘输入个正整数0           2 1     2习题 43改写算法根据顺序栈的运算和表达式转换与求值的算法做如下变化1 给出下面顺序栈模板类定义中每个成员函数的类外定义                          存栈元素                               存栈顶元素的下标位置                           存  数组长度 即所能存储栈的最大长度                              构造函数                       复制构造函数             赋值重载函数               元素进栈函数                        元素出栈函数                       读取栈顶元素函数                     判栈空函数                             析构函数2 给出后缀表达式求值的函数定义其中使用的操作数栈由引用参数提供该函数原型如下    3 给出把中缀表达式转换为后缀表达式的函数定义其中使用的运算符栈由引用参数提供该函数原型如下    1  24 建立一个工程文件其中包括 3 个文件第 1 个为含有主函数的主程序文件第 2 个为含有表达式转换与求值函数的次程序文件第 3 个为含有模板栈类定义与实现的次程序文件习题 44算法设计1 采用递归方法求1  之间的所有整数平方的和2 采用递归方法把任一十进制正整数转换为进制2    9数输出3 采用辗转相除和递归的方法求出两个正整数的最大公约数4 采用递归方法求两个正整数的最小公倍数5 裴波那契数列的定义为它的第 1 项和第 2 项分别为 0 和 1以后各项为其前两项之和若裴波那契数列中的第项用表示则计算公式为 1  1   或  2  12  2 试编写出计算的递归算法和非递归算法 分析每个算法的时间和空间复杂度6 根据代数中的二项式定理 二项式的展开式的系数序列可以表示成三角形 如图 412 所示其中除每一行最左和最右两个系数等于 1 以外 其余各系数均等于上一行左右两系数之和这个系数三角形称作杨辉三角形012345678图 412 杨辉三角形设 表示杨辉三角形中第行  0的第个系数0     按照二项式定理 可递归定义为  1  0   或    1 11   0 1 写出计算 的递归算法2 利用二维数组写出计算 的非递归算法3 分析递归算法和非递归算法的时间复杂度和空间复杂度7 在一个链队列中只设置队尾指针 不设置队首指针 并且让队尾结点的指针域指向队首结点 称此为循环链队 试分别写出在循环链队上进行插入和删除操作的算法8 在一个数组空间 中可以同时存放两个顺序栈 栈底分别处在数组的两端 当第 1 个栈的栈顶指针 1 等于 1 时则栈 1 为空 当第 2 个栈的栈顶指针 2 等于  时则栈 2 为空两个栈均向中间增长 当向栈 1 插入元素时 使 1 增 1 得到新的栈顶位置 当向栈 2 插入元素时则使 2 减 1 才能够得到新的栈顶位置当 1 等于 21 或者 2 等于 11 时 存储空间用完无法再向任一栈插入元素 此时可考虑给出错误信息并停止运行用于双栈操作的顺序存储类型可定义为            1 2双栈操作的抽象数据类型可定义为  采用顺序结构存储的双栈其存储类型为 初始化栈当1或2时对应置栈1或2为空3时置两个栈均空    清除栈当1或2时对应栈1或2被清除3时两个栈均被清除    判断栈是否为空当1或2时判断对应的栈1或栈2是否为空3时判断两个栈是否同时为空    取栈顶元素当1或2时对应返回栈1或栈2的栈顶元素    进栈当1或2时对应向栈1或栈2的顶端压入元素       退栈当1或2时对应使栈1或栈2退栈并返回栈顶元素     试写出上述抽象数据类型中每一种操作的算法9 利用堆栈编写出求解迷宫问题的非递归算法10 编写出解决汉诺塔问题的非递归算法11 判断任意个字符串能否首尾相接成为一个字符串若一个字符串的尾字符等于另外一个字符串的首字符则认为这两个字符串能够首尾相接形成一个字符串
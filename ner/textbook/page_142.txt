层调用所分配的存储空间成为变量的当前存储空间。若以表头指针 G 作为实参去调用 Depth 算法，则在算法的执行过程中，动态堆栈的数据变化情况如图 3-12 所示。其中，用 r 表示返回地址域，第 1 次调用（即非递归调用，又称为第 0 次递归调用）后的返回地址用 r1 表示，以后每次递归调用的返回地址用 r2 表示。

(a) 第 0 次递归调用
| GL | max | dep | r |
| --- | --- | --- | --- |
| 10 | 0 |   | r1 |

(b) 第 1 次递归调用
| GL | max | dep | r |
| --- | --- | --- | --- |
| ∧ | 0 |   | r2 |
| 10 | 0 |   | r1 |

(c) 返回
| GL | max | dep | r |
| --- | --- | --- | --- |
| 10 | 1 | 1 | r1 |

(d) GL 指向 20 结点
| GL | max | dep | r |
| --- | --- | --- | --- |
| 20 | 1 | 1 | r1 |

(e) GL 指向 30 结点
| GL | max | dep | r |
| --- | --- | --- | --- |
| 30 | 1 | 1 | r1 |

(f) 第 2 次递归调用
| GL | max | dep | r |
| --- | --- | --- | --- |
| 40 | 0 |   | r2 |
| 30 | 1 | 1 | r1 |

(g) 第 3 次递归调用
| GL | max | dep | r |
| --- | --- | --- | --- |
| 50 | 0 |   | r2 |
| 40 | 0 |   | r2 |
| 30 | 1 | 1 | r1 |

(h) GL 指向 60 结点
| GL | max | dep | r |
| --- | --- | --- | --- |
| 60 | 0 |   | r2 |
| 40 | 0 |   | r2 |
| 30 | 1 | 1 | r1 |

(i) GL 变为空
| GL | max | dep | r |
| --- | --- | --- | --- |
| ∧ | 0 |   | r2 |
| 40 | 0 |   | r2 |
| 30 | 1 | 1 | r1 |

(j) 返回
| GL | max | dep | r |
| --- | --- | --- | --- |
| 40 | 1 | 1 | r2 |
| 30 | 1 | 1 | r1 |

(k) GL 指向 70 结点
| GL | max | dep | r |
| --- | --- | --- | --- |
| 70 | 1 | 1 | r2 |
| 30 | 1 | 1 | r1 |

(l) GL 变为空
| GL | max | dep | r |
| --- | --- | --- | --- |
| ∧ | 1 | 1 | r2 |
| 30 | 1 | 1 | r1 |

(m) 返回
| GL | max | dep | r |
| --- | --- | --- | --- |
| 30 | 2 | 2 | r1 |

(n) GL 变为空
| GL | max | dep | r |
| --- | --- | --- | --- |
| ∧ | 2 | 2 | r1 |

(o) 返回 3

图 3-12 系统动态堆栈中数据的变化情况

可以分析出，该算法需要扫描广义表中的所有结点，对于单元素结点需要访问两次，一次为读取 tag 域值，另一次为读取 next 域值；对于子表结点需要访问 3 次，分别为读取 tag、sublist 和 next 域的值。所以此算法的时间复杂度为$O(n)$，其中$n$为广义表中所有结点的个数。该算法的空间复杂度为$O(m)$，$m$为广义表的深度。

3. 建立广义表的存储结构

设广义表中的元素类型 ElemType 为字符类型 char，每个单元素的值被限定为英文字母，广义表由键盘输入，其格式为：元素之间用一个逗号分隔，表元素的起止符号分别为左、右圆括号，空表在其圆括号内使用一个 “#” 字符表示，最后使用一个分号作为整个广

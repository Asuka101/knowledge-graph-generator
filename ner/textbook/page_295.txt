//一条到目前为止最短的边
for(i=k; i<n-1; i++) {
    t=CT[i].endvex;
    w=GA[j][t];
    if(w<CT[i].weight) {
        CT[i].weight=w;
        CT[i].fromvex=j;
    }
} //内 for end
} //外 for end

若利用图 8-3 所示的邻接矩阵调用此算法，则得到的边集数组 CT 中的内容如表 8-1 所示。

表 8-1 边集数组

\begin{tabular}{c|c|c|c|c|c|c}
\hline CT & 0 & 1 & 2 & 3 & 4 & 5 \\
\hline fromvex & 0 & 3 & 3 & 5 & 2 & 3 \\
\hline endvex & 3 & 1 & 5 & 2 & 4 & 6 \\
\hline weight & 5 & 3 & 7 & 2 & 6 & 15 \\
\hline
\end{tabular}

8.1.3 克鲁斯卡尔算法

假设$G=(V, E)$是一个具有$n$个顶点的连通网，$T=(U, TE)$是$G$的最小生成树，$U$的初值等于$V$，即包含有$G$中的全部顶点，$TE$的初值为空。此算法的基本思想是：将图$G$中的边按权值从小到大的顺序依次选取，若选取的边使生成树$T$不形成回路，则把它并入$TE$中，保留作为$T$的一条边；若选取的边使生成树$T$形成回路，则将其舍弃，如此进行下去，直到$TE$中包含有$n-1$条边为止，此时的$T$即为最小生成树。

以如图 8-5(a)所示为例来说明此算法。设此图是用边集数组表示的，且数组中各边是按权值从小到大的顺序排列的，若没有按序排列，则可通过调用排序算法，使之成为有序，如图 8-5(b)所示，这样按权值从小到大选取各边就转换成按边集数组中下标次序选取各边。当选取前 3 条边时，均不产生回路，应保留作为生成树$T$的边，如图 8-5(b)所示；选第 4 条边(2,3)时，将与已保留的边形成回路，应舍去；接着保留(1,5)边，舍去(3,5)边；取到(0,1)边并保留后，保留的边数已够 5 条（即$n-1$条），此时必定将全部 6 个顶点连通起来，如图 8-5(c)所示，它就是图 8-5(a)的最小生成树。

实现克鲁斯卡尔算法的关键之处是：如何判断欲加入$T$中的一条边是否与生成树中已保留的边形成回路。这可将各项点划分为不同集合的方法来解决，每个集合中的顶点表示一个无回路的连通分量。算法开始时，由于生成树的顶点集等于图$G$的顶点集，边集为空，所以$n$个顶点分属于$n$个集合，每个集合中只有一个顶点，表明顶点之间互不连通。例如对于图 8-5(a)，其六个集合为：$\{0\}, \{1\}, \{2\}, \{3\}, \{4\}, \{5\}$

int i;
for(i=0; i<8; i++) Push(s,a[i]);
cout<<Pop(s); cout<<' '<<endl;
Push(s,68);
cout<<Peek(s); cout<<' '<<Pop(s)<<endl;
while (!EmptyStack(s)) cout<<Pop(s)<<' ';
cout<<endl;
ClearStack(s);

则得到的运行结果如下:

22 15
68 68
30 9 17 5 8 3

\section*{4.3 栈的链接存储结构和操作实现}

栈的链接存储结构与线性表的链接存储结构相同，是通过由结点构成的单链表实现的，此时表头指针被称为栈顶指针，由栈顶指针指向的表头结点被称为栈顶结点，整个单链表被称为链栈，即链接存储的栈。当向一个链栈插入元素时，是把该元素插入到栈顶，即使该元素结点的指针域指向原来的栈顶结点，而栈顶指针则修改为指向该元素结点，使该结点成为新的栈顶结点。当从一个链栈中删除元素时，是把栈顶元素结点删除掉，即取出栈顶元素后，使栈顶指针指向原栈顶结点的指针域所指向的结点。由此可知，对链栈的插入和删除操作是在单链表的表头进行的，其时间复杂度为$O(1)$。

设一个栈为 (a,b,c)，当采用链接存储时，对应的存储结构示意图，如图 4-2（a）所示，其中 HS 表示栈顶指针，其值为存储元素 c 结点的地址。当向这个栈插入一个元素 d 后，如图 4-2（b）所示。当从这个栈依次删除两个元素后，如图 4-2（c）所示。当链栈中的所有元素全部出栈后，栈顶指针 HS 的值为空，即常量 NULL 所表示的数值 0。

(a) 原有栈
(b) 插入元素 d
(c) 删除两个元素

图 4-2 栈的链接存储结构及操作过程示意图

设链栈中的结点仍采用以前已经定义的 SNode 或 LNode 结点类型，栈顶指针用 HS 表

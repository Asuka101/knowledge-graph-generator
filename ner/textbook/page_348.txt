{
    //从树根指针为MT的B_树上查找关键字为K的对应记录的存储位置
    int i;
    MBNode *p=MT;
    while(p!=NULL) {
        i=1;
        while(K>p->key[i]) i++;
        if(K==p->key[i])
            return p->recptr[i];
        else p=p->ptr[i-1];
    }
    return -1;
}

在 B_树上进行查找需比较的结点数最多为 B_树的高度。B_树的高度与 B_树的阶$m$和关键字总数$N$有关，下面就来讨论它们之间的关系。

在一棵 B_树中，第 1 层结点（即树根结点）的子树数至少为 2 个，第 2 层结点的子树 数至少为$2 \times \lceil m / 2 \rceil$个，第 3 层结点的子树数至少为$2 \times \lceil m / 2 \rceil^2$，以此类推，若 B_树的高度用$h$表示，则最低层（即树叶层）的空子树（即空指针）数至少为$2 \times \lceil m / 2 \rceil^{(h-1)}$。另一方面， B_树中的空指针数$C_1$应等于总指针数$C_2$减去非空指针数$C_3$，而总指针数又等于关键字的 总数$N$加上所有结点数$C_4$，因为每个结点中的指针数等于其关键字数加 1，所以，所有结 点的指针数就等于所有结点的关键字数加上结点数。除树根结点外，每个结点都由 B_树中 的一个非空指针所指向，所以$C_4 = C_3 + 1$，从而得到：$C_1 = C_2 - C_3 = (N + C_4) - C_3 = (N + C_3 + 1) - C_3 = N + 1$即 B_树中的空指针数等于关键字总数加 1，这与二叉树中的空指针数与关键字总树的 关系相同。
综上所述，可列出如下不等式：$N + 1 \geq 2 \times \lceil m / 2 \rceil^{(h-1)}$即空指针数应大于等于它所具有的最小值，求解后得：$h \leq 1 + \log_{\lceil m / 2 \rceil} \left(\frac{N + 1}{2}\right)$又因为具有高度为$h$的$m$阶 B_树的最后一层结点的所有空子树个数不会超过$m^h$个， 即：$N + 1 \leq m^h$求解后得：$h \geq \log_m (N + 1)$由以上分析可知，$m$阶 B_树的高度$h$为：$\log_m (N + 1) \leq h \leq 1 + \log_{\lceil m / 2 \rceil} \left(\frac{N + 1}{2}\right)$若当$N = 10000$，$m = 10$时，B_树的高度在 5~6 之间，若由$N = 10000$个记录构成一棵 二叉搜索树时，则树的高度至少为 14，即为对应的理想平衡树的高度。由此可见，在 B_ 树上查找所需比较的结点数比在二叉搜索树上查找所需比较的结点数要少得多。这意味着 若 B_树和二叉排序树都被保存在外存上，若每读取一个结点需访问一次外存，则使用 B_ 树可以大大地减少访问外存的次数，从而大地提高处理数据的速度。

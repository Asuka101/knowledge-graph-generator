c[i][j]=a[i][j]+b[i][j];

运行此算法需要执行的简单操作的次数就等于双重 for 循环语句所包含的简单操作的次数，对该语句可进行如下分解计算。

i=0; //1次
mark1: if(i>=n) goto mark4; //n+1次
j=0; //n次
mark2: if(j>=n) goto mark3; //(n*(n+1))次
c[i][j]=a[i][j]+b[i][j]; //n*n次
j++; //n*n次
goto mark2; //n*n次
mark3: i++; //n次
goto mark1; //n次
mark4: ;

把分解后的每一条简单语句的执行次数加起来，就得到了它所包含的简单操作的次数。因此，算法 1-2 的时间复杂度为:$f(n)=4n^2+5n+2$【算法 1-3】 简单选择排序。

void SelectSort(int b[],int n)
{
    int i,j,k,x;
    for(i=0;i<n-1;i++)
    {
        k=i;
        for(j=i+1;j<n;j++)
            if(b[j]<b[k]) k=j;
        x=b[i];
        b[i]=b[k];
        b[k]=x;
    }
}

此算法包含有双重 for 循环，外层 for 循环的循环变量为$i$，它从 0 取值到$n-2$，对于$i$的每一取值，首先通过$k=i$赋初值语句和内层 for 循环语句，在 b[i]~b[n-1]之间顺序查找出具有最小值的元素 b[k]，然后通过 3 条赋值语句交换 b[i]和 b[k]的值，使得 b[i]为 b[i]~b[n-1]之间的最小值。这样，当算法执行结束后，数组 b 中的 n 个元素就按照其值从小到大的次序排列好了。

要计算出该算法包含的简单操作的次数，可将双重 for 循环语句分解如下:

i=0; //1次
mark1: if(i>=n-1) goto mark4; //n次
k=i; //n-1次
j=i+1; //n-1次

(a) 连通网

(b) 取到三条边

(c) 最小生成树

(d) 边集数组

图 8-5 克鲁斯卡尔算法求最小生成树的示意图

当从边集数组中按次序选取一条边时, 若它的两个端点分属于不同的集合, 则表明此边连通了两个不同的连通分量, 因每个连通分量无回路, 所以连通后得到的连通分量仍不会产生回路, 此边应保留作为生成树的一条边, 同时把端点所在的两个集合合并成一个, 即成为一个连通分量; 当选取的一条边的两个端点同属于一个集合时, 此边应放弃, 因同一个集合中的顶点是连通无回路的, 若再加入一条边则必产生回路。在上述例子中, 当选取(0,4)、(1,2)、(1,3)这三条边后, 顶点的集合则变成如下 3 个:$\{0,4\}, \{1,2,3\}, \{5\}$下一条边(2,3)的两端点同属于一个集合, 故舍去, 再下一条边(1,5)的两端点属于不同的集合, 应保留, 同时把两个集合$\{1,2,3\}$和$\{5\}$合并成一个$\{1,2,3,5\}$, 以此类推, 直到所有顶点同属于一个集合, 即进行了$n-1$次合并, 保留了$n-1$条生成树的边为止。

为了用 C++语言编写出利用克鲁斯卡尔算法求图的最小生成树的具体实现, 设 GE 是具有 edgeset 类型的边集数组, 并假定每条边是按照权值从小到大的顺序存放的; 再设 CT 也是一个具有 edgeset 类型的边集数组, 用该数组存储依次所求得的生成树中的每一条边; 另外, 还要设一个具有 bool 类型的一个二维数组, 用 s[n][n]表示, 它的每一行元素用来保存相应连通子图所在的顶点集合, 若该行中的下标为 t 的元素为真, 则表明顶点$v_t$属于这个集合。

根据以上分析, 给出克鲁斯卡尔算法的具体描述如下。

void Kruskal(edgeset GE, edgeset CT, int n)
    //求边集数组 GE 所示图的最小生成树, 树中每条边依次存于数组 CT 中
{
    int i,j;
    //定义具有 n*n 个元素的动态分配的二维数组 s
    bool**s=new bool*[n];
    for(i=0;i<n;i++) s[i]=new bool[n];
    //初始化 s 集合, 使每一个顶点分属于对应集合
    for(i=0; i<n; i++) {

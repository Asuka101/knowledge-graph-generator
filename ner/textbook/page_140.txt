若把整个广义表也同样用一个表结点来表示，则应在每个广义表的表头结点（即表中第一个结点）之前增加一个表结点（称此为表头附加结点），此表结点的 sublist 域指向表头结点，next 域为空，表头指针则指向这个表结点。例如，若在广义表 A,B,C 的表头结点之前增加这样的表结点，对应的示意图如图 3-10 所示。

A$\rightarrow$[1 ∧∧] C$\rightarrow$[1 ∧∧]
B$\rightarrow$[1 ∧∧] [0 a$\rightarrow$[1 ∧∧]]
[0 e ∧] [0 b$\rightarrow$[0 c$\rightarrow$[0 d ∧]]

图 3-10 带表头附加结点的广义表的链存储结构

这种带表头附加结点的广义表表示，将给广义表的某些运算带来方便。

\section*{3.5 .3 广义表的运算}

广义表的运算主要有求广义表的长度和深度、向广义表插入元素和从广义表中查找或删除元素、建立广义表的存储结构、打印广义表等。由于广义表是一种递归的数据结构，所以对广义表的运算一般采用递归的算法。全面介绍广义表的各种运算的算法，超出了本课程的教学内容，这里只讨论其中一些算法。

\section*{1. 求广义表的长度}

在广义表中，同一层次的每个结点是通过 next 域链接起来的，所以可把它看作是由 next 域链接起来的单链表。这样，求广义表的长度就是求单链表的长度，可以采用以前介绍的求单链表长度的方法求其长度。由于单链表的结构也是一种递归结构，即每个结点的指针域均指向一个单链表（称为该结点的后继单链表），它所指向的结点为该单链表的第一个结点（即表头结点），所以求单链表的长度也可以采用递归算法，即若单链表非空的话，其长度等于 1 加上表头结点的后继单链表的长度，若单链表为空，则长度为 0，这是递归的终止条件。

求广义表长度的递归算法如下。

int Length(GLNode* GL) //求值参 GL 所指向的广义表的长度
{
    if (GL!=NULL)
        return 1+Length(GL->next);
    else
        return 0;
}

此算法每次被调用时，无论是从外部对它的非递归调用，还是从内部对它的递归调用，都需要给值参 GL 分配存储空间，用以存储由实参传来的指针值，所以算法的空间复杂度为$O(n)$，若采用非递归算法，其空间复杂度为$O(1)$，两者的时间复杂度均为$O(n)$，$n$为广义表的长度。这里介绍递归算法，是想通过这个简单的例子为后面介绍更复杂的递归算

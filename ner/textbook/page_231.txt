使用数据栈的空间，相应的非递归算法如下。

bool Find1(BTreeNode*BST, ElemType& item) //二叉搜索树查找的非递归算法
{
    while(BST!=NULL) {
        if(item==BST->data) {
            item=BST->data; return true;
        }
        else if(item<BST->data) BST=BST->left;
        else BST=BST->right;
    }
    return false;
}

从图 6-1 所示的二叉搜索树中查找关键字为 23 的元素时, 首先用 23 同根结点 30 进行比较, 因为$23<30$, 所以向 30 的左子树继续查找; 再用 23 同当前根结点 15 进行比较, 因为$23>15$, 所以向 15 的右子树继续查找; 再用 23 同当前根结点 23 进行比较, 因为相等,所以由 item 带回该结点的值并返回真, 整个查找过程就此结束。若从图 6-1 中查找关键字为 48 的元素时, 其查找过程为: 首先用 48 同根结点 30 进行比较, 因为$48>30$, 所以向 30 的右子树继续查找; 再用 48 同当前根结点 52 进行比较, 因为$48<52$, 所以向 52 的左子树继续查找, 此时左子树为空, 所以返回假, 表明查找失败, 整个查找过程就此结束。

在二叉搜索树上进行查找的过程中, 给定值 item 同树中结点比较的次数最少为一次 (即树根结点就是待查的结点), 最多为树的深度, 所以平均查找次数要小于等于树的深度。若二叉搜索树是一棵理想平衡树或接近理想平衡树, 则进行查找的时间复杂度为$O(\log n)$; 若退化为一棵单支树（最极端和最差的情况），则其时间复杂度为$O(n)$。对于一般情况, 其时间复杂度可大致看作$O(\log n)$。因此在二叉搜索树上查找比在集合或线性表上进行顺序查找的时间复杂度$O(n)$要好得多, 这正是构造二叉搜索树的优势所在。二叉搜索树查找的递归算法的空间复杂度平均情况为$O(\log n)$, 最差情况为$O(n)$, 非递归算法的空间复杂度为$O(1)$。

2. 更新

二叉搜索树的更新算法与查找算法基本相同, 区别仅有两点: 一是在更新算法中当查找到待更新的元素时, 应将 item 的值赋给该元素, 而在查找算法中是将该元素的值赋给 item 带回; 二是在更新算法中参数 item 可以为变参 (即引用参数), 也可以为值参, 并且在参数说明的前面可以加或不加常量标识符 const, 而在查找算法中参数 item 只能为变参, 并且不能加常量标识符 const。请同学们编写此更新算法。

3. 插入

根据二叉搜索树的定义, 向二叉搜索树中插入元素 item 的过程为: 若二叉树为空, 则由 item 元素生成的新结点将作为根结点插入; 否则, 若 item 小于根结点, 则将新结点插入到根的左子树上, 若 item 大于等于 (若不允许具有相同值的结点存在, 则对等于情况应

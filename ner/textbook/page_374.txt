排序过程中比较记录的总次数 C 小于等于$n \times (h-1)$, 因$h-1 \leq \lg n$, 故总次数$C \leq n \times \lg n$。

由以上分析可知，在快速排序过程得到的是一棵理想平衡树的情况下，其算法的时间复杂度为$O(n \lg n)$。当然这是最好的情况，在一般情况下，由快速排序得到的是一棵随机的二叉搜索树，树的具体结构与每次划分时选取的关键元素有关。理论上已经证明，在平均情况下，快速排序的比较次数是最好情况下的$2 \ln 2$倍，约 1.39 倍。所以在平均情况下快速排序算法的时间复杂度仍为$O(n \lg n)$，并且系数比其他同数量级的排序方法要小。大量的实验结果已经证明：当$n$较大时，它是目前为止在平均情况下速度最快的一种排序方法。另外，在平均和最好情况下快速排序算法的空间复杂度为$O(\lg n)$，显然它比前面讨论过的所有排序方法要多占用一些辅助存储空间。

快速排序的最坏情况是得到的二叉搜索树为一棵单支树，如待排序区间上的记录已为正序或逆序时就是如此，图 8-8（b）给出了对为正序的 5 个元素$(1,2,3,4,5)$时的情况。在这种情况下共需要进行$n-1$层，同时也是$n-1$次划分，每次划分得到一个子区间为空，另一个子区间包含有$n-i$个记录，$i$代表层数，取值范围为$1 \leq i \leq n-1$，每层划分需要比较$(n-i+1)$次，所以总的比较次数为$\sum_{i=1}^{n-1}(n-i+1)=\frac{1}{2}(n^2+n-2)$，即时时间复杂度为$O(n^2)$。在这种情况下需要递归处理$n-1$次（含第 0 次递归调用），所以其空间复杂度为$O(n)$。换言之，在最坏情况下，快速排序就退化为像简单排序方法那样的“慢速”排序了，而且比简单排序还要多占用一个具有$n$个单元的栈空间，从而使快速排序成为最差的排序方法。

为了避免快速排序最差的情况发生，一是若事先知道待排序的记录已基本有序（包括正序和逆序），则采用其他排序方法，而不要采用快速排序方法；二是修改上面的快速排序算法，使得在每次划分之前比较当前区间的第 1 个元素、最后一个元素和中间一个元素的排序码，取排序码居中的一个元素作为基准元素并调换到第 1 个元素位置。

\section*{10.5 归并排序}

在讨论归并排序之前，首先给出归并的概念。归并（merge）就是将两个或多个有序表合并成一个有序表的过程。若将两个有序表合并成一个有序表则称为二路归并，同理，有三路归并、四路归并等。二路归并最为简单和常用，既适应于内排序，也适应于外排序，所以本节只讨论二路归并。例如有两个有序表$(7,12,15,20)$和$(4,8,10,17)$，归并后得到的有序表为$(4,7,8,10,12,15,17,20)$。以后若不特别指明，所提的归并均指二路归并。

二路归并算法很简单，假定待归并的两个有序表分别存于数组 A 中从下标 s 到下标 m 的单元和从下标$m+1$到下标 t 的单元 ($s \leq m, m+1 \leq t$)，结果有序表存于数组 R 中从下标 s 到下标 t 的单元，并令$i,j,k$分别指向这些有序表的第一个单元。归并过程为：比较 A[i].stm 和 A[j].stm 的大小，若 A[i].stm ≤ A[j].stm，则将第 1 个有序表中的元素 A[i] 复制到 R[k] 中，并令$i$和$k$分别加 1，使之分别指向后一单元（位置），否则将第 2 个有序表中的元素 A[j] 复制到 R[k] 中，并令$j$和$k$分别加 1；如此循环下去，直到其中的一个有序表比较和复制完，然后再将另一个有序表中剩余的元素复制到 R 中从下标 k 到下标 t 的单元。

二路归并算法描述如下。

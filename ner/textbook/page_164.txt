时, 表明该运算符的后一个运算对象还没有被扫描并放入到 S2 串中, 应把它暂存于运算符栈中, 待它的后一个运算对象从 S1 串中读出并写入到 S2 串中后, 再令其出栈并写入 S2 串中; 若遇到的运算符的优先级小于等于栈顶运算符的优先级, 这表明栈顶运算符的两个运算对象已经被保存到 S2 串中, 应将栈顶运算符退栈并写入到 S2 串中, 对于新的栈顶运算符仍继续进行比较和处理, 直到被处理的运算符的优先级大于栈顶运算符的优先级为止, 然后令该运算符进栈即可。

按照以上过程扫描到中缀表达式字符串结束符时, 把栈中剩余的运算符依次退栈并写入到后缀表达式中, 再向 S2 写入字符串结束符 “0”, 整个转换过程就处理完毕, 在 S2 中就得到了转换成的后缀表达式。

将中缀算术表达式转换为后缀算术表达式的算法描述如下。

void Change(char* S1, char* S2)

//将字符串 S1 中的中缀表达式转换为 S2 字符串中的后缀表达式

{
    //定义用于暂存运算符的栈 R 并初始化, 该栈的元素类型为 char
    Stack R;
    InitStack(R);
    //给栈底放入 '@' 字符, 它具有最低优先级 0
    Push(R, '@');
    //定义 i, j 分别用于扫描 S1 和指示 S2 串中待存字符的位置
    int i=0, j=0;
    //定义 ch 保存 S1 串中扫描到的字符, 初值为第 1 个字符
    char ch=S1[i];
    //依次处理中缀表达式中的每个字符
    while(ch!='\0') {
        //对于空格字符不做任何处理, 顺序读取下一个字符
        if(ch==' ') ch=S1[++i];
        //对于左括号, 直接进栈
        else if(ch=='(') {
            Push(R, ch); ch=S1[++i];
        }
        //对于右括号, 使括号内的仍停留在栈中的运算符依次出栈并写入 S2
        else if(ch==')') {
            while(Peek(R) != '(') S2[j++]=Pop(R);
            Pop(R); //删除栈顶的左括号
            ch=S1[++i];
        }
        //对于运算符, 使暂存于栈顶且不低于 ch 优先级的运算符依次出栈并写入 S2
        else if(ch=='+' || ch=='-' || ch=='*' || ch=='/') {
            char w=Peek(R);
            while(Precedence(w)>=Precedence(ch)) {
                // Precedence(w) 函数返回运算符形参的优先级
                S2[j++]=w; Pop(R);
                w=Peek(R);
            }

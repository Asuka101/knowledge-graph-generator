第4章 栈和队列

栈和队列都属于线性表，但由于对它们操作的特殊性，并且是最常用的线性数据结构，
所以需要专门进行讨论。

\section*{4.1 栈}

\subsection*{4.1.1 栈的定义}

栈（stack）又称堆栈，它是一种运算受限的线性表，其限制是仅允许在表的一端进行
插入和删除运算。人们把对栈进行运算的一端称为栈顶，栈顶的第$1$个元素被称为栈顶元
素，相对地，把另一端称为栈底。向一个栈插入新元素又称为进栈或入栈，它是把该元素
放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称为出栈或退栈，它
是把栈顶元素删除掉，使其下面的相邻元素成为新的栈顶元素。

在日常生活中，有许多类似栈的例子。如刷洗盘子时，依次把每个洗净的盘子放到洗
好的一摞盘子上，相当于进栈；取用盘子时，从一摞盘子上一个接一个地向下拿，相当于
出栈。又如向枪支弹夹里装子弹时，子弹被一个接一个地压入，相当于进栈；射击时子弹
总是从顶部一个接一个地被射出，相当于子弹出栈。

由于栈的插入和删除运算仅在栈顶一端进行，后进栈的元素必定先出栈，所以又把栈
称为后进先出表（Last In First Out，LIFO）。

例如，一个栈$S$为（a,b,c），其中表尾的一端为栈顶，字符$c$为栈顶元素。若向$S$压
入一个元素$d$，则$S$变为（a,b,c,d），此时字符$d$为栈顶元素；若接着从栈$S$中依次删除两
个元素，则首先删除的是元素$d$，接着删除的是元素$c$，栈$S$变为（a,b），栈顶元素为$b$。

\subsection*{4.1.2 栈的抽象数据类型}

栈的抽象数据类型中的数据部分为具有 ElemType 元素类型的一个栈，它可以采用任
一种存储结构实现，用 StackType 标识符表示栈对象类型；操作部分应包括元素进栈、元
素出栈、读取栈顶元素、检查栈是否为空等。下面给出栈的抽象数据类型的具体定义。

ADT STACK is
Data:
    一个栈$s$，假定用标识符 StackType 表示栈对象类型
Operation:

void InitStack(StackType& S); //初始化栈s,即把它置为空
void Push(StackType& S, ElemType item) //元素进栈,即插入到栈顶
ElemType Pop(StackType& S) //删除栈顶元素并返回之
ElemType Peek(StackType& S) //返回栈顶元素的值,但不改变栈
bool EmptyStack (StackType& S); //判断s是否为空
void ClearStack(StackType& S); //清除栈中所有元素,使之成为空栈
end STACK

对于判断栈是否为空和返回栈顶元素这两种操作，由于它们不改变栈的状态，所以可在参数类型说明前使用常量定义符 const，也可以取消引用定义，改为值参定义。
假定栈 a 的元素类型为 int，下面给出调用上述栈操作的一些例子。

InitStack(a); //把栈 a 置空
Push(a,18); //元素 18 进栈
int x=46; Push(a,x); //x 的值 46 进栈
Push(a,x/3); //x 除以 3 的整数值 15 进栈
x=Pop(a); //栈顶元素 15 退栈并赋给 x
cout<<Peek(a); //读取栈顶元素 46 并输出
Pop(a); //栈顶元素 46 出栈,返回值 46 自动丢失
EmptyStack(a); //因栈非空,应返回 false
cout<<(Pop(a))<<endl; //栈顶元素 18 退栈并输出
x=EmptyStack(a); //因栈为空,返回 true(对应整数 1)赋给 x

\section*{4.2 栈的顺序存储结构和操作实现}

栈的顺序存储结构同样需要使用一个数组和一个整型变量来实现，利用数组来顺序存储栈中的所有元素，利用整型变量来存储栈顶元素的下标位置。栈数组用 stack[MaxSize]表示，指示栈顶位置的整型变量用 top 表示，则元素类型为 ElemType 的栈的顺序存储结构可定义如下。

ElemType stack [MaxSize];
int top;

其中，MaxSize 为一个整型全局常量，需先通过 const 语句定义，由它确定顺序栈（即顺序存储的栈）的最大长度，又称为深度，即栈空间最多能够存储的元素个数；由于 top 用来指示栈顶元素的位置，所以把它称为栈顶指针。

栈的顺序存储结构所使用的栈数组和栈顶指针同样可以定义在一个记录类型中，该记录类型用 Stack 表示，则定义如下。

struct Stack {
    ElemType stack[MaxSize];
    int top;
};

若要对存储栈的数组空间采用动态分配，则 Stack 结构类型可定义如下。

struct Stack {
    ElemType *stack;          //存栈元素
    int top;                  //存栈顶元素的下标位置
    int MaxSize;              //存 stack 数组长度, 即所能存储栈的最大长度
};

在顺序存储的栈中，$top$的值为$-1$表示栈空，每次向栈中压入一个元素时，首先使$top$增 1，用以指示新的栈顶位置，然后再把元素赋值到这个空位置上，每次从栈中弹出一个元素时，首先取出栈顶元素，然后再使$top$减 1，指出前一个元素成为新的栈顶元素。由此可知，对顺序栈的插入和删除运算相当于是在顺序表（即顺序存储的线性表）的表尾进行的，其时间复杂度为$O(1)$。

在一个顺序栈中，若$top$已经指向了$MaxSize-1$的位置，则表示栈满，若再向其插入新元素时就需要进行栈满处理，需分配更大的存储空间满足插入要求，或输出栈满信息告之用户等；相反，若$top$的值已经等于$-1$，则表示栈空，通常利用栈空作为循环结束的条件，表明数据已经处理完毕。

设一个栈$S$为$(a,b,c,d,e)$，对应的顺序存储结构，如图 4-1 (a) 所示。向$S$中插入一个元素$f$，如图 4-1 (b) 所示。接着执行两次出栈操作后，如图 4-1 (c) 所示。依次使栈$S$中的所有元素出栈，则$S$变为空，如图 4-1 (d) 所示。在这里，栈是垂直画出的，并且使下标编号向上递增，这样可以形象地表示出栈顶在上，栈底在下。

\begin{tabular}{|c|c|c|c|}
\hline MaxSize-1 & \multicolumn{1}{|l|}{} & MaxSize-1 & \multicolumn{1}{|l|}{} \\
\hline \vdots & \multicolumn{1}{|l|}{} & \vdots & \multicolumn{1}{|l|}{} \\
\hline 4 & \multicolumn{1}{|l|}{$e$} & 5 & \multicolumn{1}{|l|}{$f$} \\
\hline 3 & \multicolumn{1}{|l|}{$d$} & 4 & \multicolumn{1}{|l|}{$e$} \\
\hline 2 & \multicolumn{1}{|l|}{$c$} & 3 & \multicolumn{1}{|l|}{$d$} \\
\hline 1 & \multicolumn{1}{|l|}{$b$} & 2 & \multicolumn{1}{|l|}{$c$} \\
\hline 0 & \multicolumn{1}{|l|}{$a$} & 1 & \multicolumn{1}{|l|}{$b$} \\
\hline
\end{tabular}

(a)$top=4$\begin{tabular}{|c|c|c|c|}
\hline MaxSize-1 & \multicolumn{1}{|l|}{} & MaxSize-1 & \multicolumn{1}{|l|}{} \\
\hline \vdots & \multicolumn{1}{|l|}{} & \vdots & \multicolumn{1}{|l|}{} \\
\hline 4 & \multicolumn{1}{|l|}{$d$} & 4 & \multicolumn{1}{|l|}{} \\
\hline 3 & \multicolumn{1}{|l|}{$c$} & 3 & \multicolumn{1}{|l|}{$d$} \\
\hline 2 & \multicolumn{1}{|l|}{$b$} & 2 & \multicolumn{1}{|l|}{$c$} \\
\hline 1 & \multicolumn{1}{|l|}{$a$} & 1 & \multicolumn{1}{|l|}{$b$} \\
\hline 0 & \multicolumn{1}{|l|}{} & 0 & \multicolumn{1}{|l|}{$a$} \\
\hline
\end{tabular}

(b)$top=5$\begin{tabular}{|c|c|c|c|}
\hline MaxSize-1 & \multicolumn{1}{|l|}{} & MaxSize-1 & \multicolumn{1}{|l|}{} \\
\hline \vdots & \multicolumn{1}{|l|}{} & \vdots & \multicolumn{1}{|l|}{} \\
\hline 4 & \multicolumn{1}{|l|}{} & 4 & \multicolumn{1}{|l|}{} \\
\hline 3 & \multicolumn{1}{|l|}{$d$} & 3 & \multicolumn{1}{|l|}{} \\
\hline 2 & \multicolumn{1}{|l|}{$c$} & 2 & \multicolumn{1}{|l|}{} \\
\hline 1 & \multicolumn{1}{|l|}{$b$} & 1 & \multicolumn{1}{|l|}{} \\
\hline 0 & \multicolumn{1}{|l|}{$a$} & 0 & \multicolumn{1}{|l|}{} \\
\hline
\end{tabular}

(c)$top=3$(d)$top=-1$图 4-1 栈的顺序存储结构和操作过程示意图

下面是出栈在顺序存储结构下的实现算法。

1. 初始化栈 S 为空

把栈设置为空并完成栈空间的动态存储分配。

void InitStack(Stack& S)
{
    //初始设置栈空间大小为 10 个元素位置
    S.MaxSize=10;
    //动态存储空间分配, 若分配失败则退出运行

S.stack=new ElemType[S.MaxSize];
if(!S.stack) {
    cerr<<"动态存储分配失败!"<<endl;
    exit(1);
}
//初始置栈为空
S.top=-1;
}

2. 元素 item 进栈, 即插入到栈顶

void Push(Stack& S, ElemType item)
{
    //若栈空间用完则自动扩大 2 倍空间,原有栈内容不变
    if(S.top==S.MaxSize-1) {
        int k=sizeof(ElemType); //计算每个元素存储空间的长度
        S.stack=(ElemType*)realloc(S.stack, 2*S.MaxSize*k);
        S.MaxSize=2*S.MaxSize;   //把栈空间大小修改为新的长度
    }
    //栈项指针后移一个位置
    S.top++;
    //将新元素插入到栈顶
    S.stack[S.top]=item;
}

3. 删除栈顶元素并返回

ElemType Pop(Stack& S)
{
    //若栈空则退出运行
    if(S.top==-1) {
        cerr<<"Stack is empty!"<<endl;
        exit(1);
    }
    //栈项指针减 1 表示退栈
    S.top--;
    //返回原栈顶元素的值
    return S.stack[S.top+1];
}

注意: 做出栈操作时, 栈顶指针下移, 但原栈顶位置中保存的元素依然存在, 仍可以被利用, 只是不属于当前栈中的元素而已。当前栈中的元素为从栈顶到栈底之间的所有元素。

4. 读取栈顶元素的值

ElemType Peek(Stack& S)
{

//若栈空则退出运行
if (S.top==-1) {
    cerr<<"Stack is empty!"<<endl;
    exit(1);
}
//返回栈顶元素的值
return S.stack[S.top];
}

此算法只访问栈顶元素，而不改变栈的状态，并不修改栈顶指针的值。

5. 判断$S$是否为空，若是则返回 true，否则返回 false

bool EmptyStack(Stack& S)
{
    return S.top==-1;
}

6. 清除栈$S$中的所有元素, 释放动态存储空间

void ClearStack(Stack& S)
{
    if(S.stack) {
        delete []S.stack;
        S.stack=0;
    }
    S.top=-1;
    S.MaxSize=0;
}

可采用下面程序调试上面介绍的栈的各种操作算法。

#include<iostream.h>
#include<stdlib.h>

typedef int ElemType;
struct Stack {
    ElemType *stack;          //存栈元素
    int top;                  //存栈顶元素的下标位置
    int MaxSize;              //存 stack 数组长度, 即所能存储栈的最大长度
};

#include"顺序栈运算.cpp"     //保存有上述 6 种对栈运算的算法

void main()
{
    Stack s;
    InitStack(s);
    int a[8]={3,8,5,17,9,30,15,22};

int i;
for(i=0; i<8; i++) Push(s,a[i]);
cout<<Pop(s); cout<<' '<<endl;
Push(s,68);
cout<<Peek(s); cout<<' '<<Pop(s)<<endl;
while (!EmptyStack(s)) cout<<Pop(s)<<' ';
cout<<endl;
ClearStack(s);

则得到的运行结果如下:

22 15
68 68
30 9 17 5 8 3

\section*{4.3 栈的链接存储结构和操作实现}

栈的链接存储结构与线性表的链接存储结构相同，是通过由结点构成的单链表实现的，此时表头指针被称为栈顶指针，由栈顶指针指向的表头结点被称为栈顶结点，整个单链表被称为链栈，即链接存储的栈。当向一个链栈插入元素时，是把该元素插入到栈顶，即使该元素结点的指针域指向原来的栈顶结点，而栈顶指针则修改为指向该元素结点，使该结点成为新的栈顶结点。当从一个链栈中删除元素时，是把栈顶元素结点删除掉，即取出栈顶元素后，使栈顶指针指向原栈顶结点的指针域所指向的结点。由此可知，对链栈的插入和删除操作是在单链表的表头进行的，其时间复杂度为$O(1)$。

设一个栈为 (a,b,c)，当采用链接存储时，对应的存储结构示意图，如图 4-2（a）所示，其中 HS 表示栈顶指针，其值为存储元素 c 结点的地址。当向这个栈插入一个元素 d 后，如图 4-2（b）所示。当从这个栈依次删除两个元素后，如图 4-2（c）所示。当链栈中的所有元素全部出栈后，栈顶指针 HS 的值为空，即常量 NULL 所表示的数值 0。

(a) 原有栈
(b) 插入元素 d
(c) 删除两个元素

图 4-2 栈的链接存储结构及操作过程示意图

设链栈中的结点仍采用以前已经定义的 SNode 或 LNode 结点类型，栈顶指针用 HS 表

示, 下面给出对由 HS 所指向的链栈进行每一种栈操作的算法。

1. 初始化链栈

void InitStack(SNode*& HS)
{
    HS=NULL; //将链栈置空
}

2. 向链栈中插入一个元素

void Push(SNode*& HS, const ElemType& item)
{
    //为插入元素获取动态结点
    SNode* newptr=new SNode;
    //给新分配的结点赋值
    newptr->data=item;
    //向栈顶插入新结点
    newptr->next=HS;
    HS=newptr;
}

3. 从链栈中删除一个元素并返回

ElemType Pop(SNode*& HS)
{
    if(HS==NULL) {
        //不能从空栈删除
        cerr<<"Linked stack is empty!"<<endl;
        exit(1);
    }
    SNode* p=HS;                //暂存栈顶结点指针
    HS=HS->next;                //使栈顶指针指向下—结点
    ElemType temp=p->data;      //暂存原栈顶元素
    delete p;                   //回收原栈顶结点
    return temp;                //返回原栈顶元素
}

4. 读取栈顶元素

ElemType Peek(SNode* HS)       //HS 为值参或引用形参均可
{
    if(HS==NULL) {
        //无法从空栈中操作
        cerr<<"Linked stack is empty!"<<endl;
        exit(1);
    }
    return HS->data;            //返回栈顶结点的值
}

5. 检查链栈是否为空

bool EmptyStack(SNode* HS)
                    //HS为值参或引用形参均可
{
    return HS==NULL;
}

6. 清除链栈为空

void ClearStack(SNode*& HS)
{
    SNode *cp, *np;
    cp=HS;           //给cp指针赋初值,使之指向栈顶结点
    while(cp!=NULL)
    {
        //从栈顶到栈底依次删除每个结点
        np=cp->next;
        delete cp;
        cp=np;
    }
    HS=NULL;         //置链栈为空
}

4.4 栈的简单应用举例

【例4-1】从键盘上输入一批整数，然后按照相反的次序打印出来。
分析：根据题意可知，后输入的整数将先被打印出来，这正好符合栈的后进先出的特点。所以此题很容易用栈来解决。若采用链栈，其参考程序如下。

#include<iostream.h>
#include<stdlib.h>
typedef int ElemType;   //定义元素类型为整型
struct SNode {
    ElemType data;
    SNode* next;
};
#include"链栈运算.cpp"  //保存着6种链栈运算的算法
void main()
{
    SNode* a;
    InitStack(a);
    int x;
    cin>>x;
    while(x!=-1) {      //假定用-1作为终止键盘输入的标志

Push(a,x);
cin>>x;
}
while(!EmptyStack(a)) //栈不为空时依次退栈打印出来
    cout<<Pop(a)<<" ";
cout<<endl;
ClearStack(a);
}

从键盘上输入为:

78 63 45 82 91 34 -1

则输出为:

34 91 82 45 63 78

【例4-2】栈在计算机语言的编译过程中用来进行语法检查, 试编写一个算法, 用来检查一个 C/C++语言程序中的大括号、方括号和圆括号是否配对, 若能够全部配对则返回 1 ,否则返回 0 。

分析: 在这个算法中, 需要扫描待检查程序中的每一个字符, 当扫描到每个大、中、圆左括号时, 令其进栈, 当扫描到每个大、中、圆右括号时, 则检查栈顶是否为相应的左括号, 若是则作退栈处理, 若不是则表明出现了语法错误, 应返回 0 。当扫描到程序文件结尾后, 若栈为空则表明没有发现括号配对错误, 应返回 1 , 否则表明栈中还有未配对的括号, 应返回 0 。另外, 对于一对单引号或双引号内的字符不进行括号配对检查。

根据分析, 编写出算法如下:

int BracketsCheck(char* fname)
{
    //对由fname所指字符串为文件名的文件进行括号配对检查
    ifstream ifstr(fname, ios::in|ios::nocreate);
    //用文件输入流对象ifstr打开以fname所指字符串为文件名的文件
    //C++的系统头文件fstream.h中定义有文件输入流类ifstream
    if(!ifstr) {
        cerr<<"File"<<"\""<<fname<<"\""<< "not found!"<<endl;
        exit(1);
    }
    Stack a;                          //定义一个顺序栈
    InitStack(a);                     //栈a被初始化
    char ch;
    while(ifstr>>ch)                  //顺序从文件中得到一个字符到ch变量中
    {
        if(ch==39) {                  //单引号内的字符不参与配对比较
            while(ifstr>>ch)
                if(ch==39) break;     //39为单引号的ASCII值
            if(!ifstr) return 0;      //读到文件结束返回0

}
else if(ch==34) {
    while(ifstr->ch)
        if(ch==34) break; //34为双引号的ASCII值
    if(!ifstr) return 0; //读到文件结束返回0
}
switch (ch) {
    case '{':
    case '[':
    case '(':
        Push(a,ch); //出现以上3种左括号则进栈
        break;
    case '}':
        if(Peek(a)=='(')
            Pop(a); //栈顶的大括号出栈
        else return 0;
        break;
    case ']':
        if(Peek(a)=='[')
            Pop(a); //栈顶的左中括号出栈
        else return 0;
        break;
    case ')':
        if(Peek(a)=='(')
            Pop(a); //栈顶的左圆括号出栈
        else return 0;
}
if(EmptyStack(a)) return 1;
else return 0;
}

下面程序调试上述算法。

#include<iostream.h>
#include<stdlib.h>
#include<fstream.h>

typedef int ElemType;
struct Stack {
    ElemType *stack;
    int top;
    int MaxSize;
};

#include"顺序栈运算.cpp" //该程序文件保存着6种顺序栈运算的算法

```c
int BracketsCheck(char* fname) {
    //函数体同上
}

void main() {
    int b=BracketsCheck("xxk4-1.cpp");
    //“xxk4-1.cpp”为当前目录下的一个C++程序文件中括号配对正确!"<<endl;
    if(b) cout<<"xxk4-1.cpp 程序文件中括号配对正确!"<<endl;
    else cout<<"xxk4-1.cpp 程序文件中括号配对错误!"<<endl;
}

【例 4-3】把十进制整数转换为二至九之间的任一进制数输出。

分析：由计算机基础知识可知，把一个十进制整数$x$转换为任一种$r$进制数得到的是一个$r$进制的整数，假定为$y$，转换方法是逐次除基数$r$取余法。具体叙述为：首先用十进制整数$x$除以基数$r$，得到的整余数是$r$进制数$y$的最低位$y_0$，接着以$x$除以$r$的整数商作为被除数，用它除以$r$得到的整余数是$y$的次最低位$y_1$，以此类推，直到商为 0 时得到的整余数是$y$的最高位$y_m$，这里假设$y$共有$m+1$位。这样得到的$y$与$x$等值，$y$的按权展开式为：$y=y_0+y_1\cdot r+y_2\cdot r^2+\cdots+y_m\cdot r^m$若十进制整数为 3425，把它转换为八进制数的过程，如图 4-3 所示。

8 | 3425 余数 对应的八进制数位
8 | 428 ... 1 y_0
8 | 53 ... 4 y_1
8 | 6 ... 5 y_2
0 ... 6 y_3

图 4-3 十进制整数 3425 转换为八进制数的过程

最后得到的八进制数为$(6541)_8$，对应的十进制数为$6\times8^3+5\times8^2+4\times8+1=3425$，即为被转换的十进制数，证明转换过程是正确的。

从十进制整数转换为$r$进制数的过程中，由低到高依次得到$r$进制数中的每一位数字，而输出时又需要由高到低依次输出每一位。所以此问题适合利用栈来解决，具体算法描述如下。

void Transform(long num, int r)
    //把一个长整型数 num 转换为一个 r 进制数输出
{
    SNode* a; 
    InitStack(a); 
    while(num!=0) { 
        int k=num % r;
        Push(a,k);
        num/=r;
    }
}
```

while(!EmptyStack(a)) //由高到低输出 r 进制数的每一位
    cout<<Pop(a);
cout<<endl;
}

用下面程序调用 Transform 函数的过程。

#include<iostream.h>
#include<stdlib.h>
typedef int ElemType;
struct SNode {
    ElemType data;
    SNode* next;
};
#include"链栈运算.cpp"
void Transform(long num, int r); //实际运行时需要加上函数定义
void main()
{
    cout<<"3425 的八进制数为: ";
    Transform(3425,8);
    cout<<"3425 的六进制数为: ";
    Transform(3425,6);
    cout<<"3425 的四进制数为: ";
    Transform(3425,4);
    cout<<"3425 的二进制数为: ";
    Transform(3425,2);
}

运行结果如下。$3425$的八进制数为:$6541$3425$的六进制数为:$23505$3425$的四进制数为:$311201$3425$的二进制数为:$110101100001$\section*{4.5 算术表达式的计算}

在计算机中进行算术表达式的计算是通过栈来实现的。本节首先讨论算术表达式的两种表示方法，即中缀表示法和后缀表示法，接着讨论后缀表达式求值的算法，最后讨论中缀表达式转换为后缀表达式的算法。

\subsection*{4.5.1 算术表达式的两种表示}

通常书写的算术表达式是由操作数（又叫运算对象或运算量）和运算符以及改变运算

次序的圆括号连接而成的式子。操作数可以是常量、变量和函数，同时还可以是表达式。运算符包括单目运算符和双目运算符两类，单目运算符只要求一个操作数，并被放在该操作数的前面，双目运算符要求有两个操作数，并被放在这两个操作数的中间。单目运算符为取正“+”和取负“-”，双目运算符有加“+”，减“-”，乘“*”和除“/”等。为了方便，在讨论中只考虑双目运算符，并且仅限于“+”、“-”、“*”、“/”这4种运算。

如对于一个算术表达式$2+5 \times 6$，乘法运算符“*”的两个操作数是它两边的5和6；对于加法运算符“+”的两个操作数，一个是它前面的2，另一个是它后面的$5 \times 6$的结果即30。把双目运算符出现在两个操作数中间的这种习惯表示叫做算术表达式的中缀表示，这种算术表达式被称为中缀算术表达式或中缀表达式。

中缀表达式的计算比较复杂，它必须遵守以下3条规则。

(1) 先计算括号内，后计算括号外。

(2) 在无括号或同层括号内，先进行乘除运算，后进行加减运算，即乘除运算的优先级高于加减运算的优先级。

(3) 同一优先级运算，从左向右依次进行。

可以看出，在中缀表达式的计算过程中，既要考虑括号的作用，又要考虑运算符的优先级，还要考虑运算符出现的先后次序。因此，各运算符实际的运算次序往往同它们在表达式中出现的先后次序是不一致的，是不可预测的。当然凭直观判别一个中缀表达式中哪个运算符最先算，哪个次之，哪个最后算并不困难，但通过计算机处理将困难得多。

那么，能否把中缀算术表达式转换成另一种形式的算术表达式，使计算简单化呢？回答是肯定的。波兰科学家卢卡谢维奇（Lukasiewicz）很早就提出了算术表达式的另一种表示，即后缀表示，又称逆波兰式，其定义是把运算符放在两个运算对象的后面。采用后缀表示的算术表达式被称为后缀算术表达式或后缀表达式。在后缀表达式中，不存在括号，也不存在运算符优先级的差别，计算过程完全按照运算符出现的先后次序进行，整个计算过程仅需扫描一遍便可完成，显然比中缀表达式的计算要简单得多。例如，对于后缀表达式$12\text{□}40\text{□}5\text{□}$，其中“□”字符表示空格，因减法运算符在前，除法运算符在后，所以应先做减法，后做除法；减法的两个操作数是它前面的12和4，其中第1个数12是被减数，第2个数4是减数；除法的两个操作数是它前面的$12-4$的差（即8）和5，其中8是被除数，5是除数。

中缀算术表达式转换成对应的后缀算术表达式的规则是：把每个运算符都移到它的两个运算对象的后面，然后删除掉所有的括号即可。

例如，对于下列各中缀表达式：

(1)$3 / 5 + 6$(2)$16 - 9 \times (4 + 3)$(3)$2 \times (x + y) \times (1 - x)$(4)$(25 + x) \times (a \times (a + b) + b)$对应的后缀表达式分别为：

(1)$3\text{□}5\text{□}/\text{□}6\text{□}+$(2)$16\text{□}9\text{□}4\text{□}3\text{□}+\text{□}\times\text{□}-$

(3)$20 \times 0y0 + 0 \times 010x0 - 0/$(4)$250 \times 0 + 0a0a0b0 + 0 \times 0b0 + 0 \times$从以上实例可以看出, 转换前后每个数据元素的前后次序没有改变, 改变的只是表达式中每个运算符的位置和次序。

\section*{4.5 .2 后缀表达式求值的算法}

后缀表达式的求值比较简单, 扫描一遍即可完成。它需要使用一个栈, 假定用 S 表示,其元素类型应为操作数的类型, 假定为浮点型 double, 用此栈存储后缀表达式中的操作数、计算过程中的中间结果以及最后结果。一个后缀算术表达式以一个字符串的方式提供, 后缀表达式求值算法的基本思路是: 把包含后缀算术表达式的一个字符串由一个字符指针参数所指明, 每次从该字符串中读入一个字符, 若它是空格则不做任何处理, 若它是运算符, 则表明它的两个操作数已经在栈 S 中, 其中栈顶元素为运算符的后一个操作数, 栈顶元素的前一个元素为运算符的前一个操作数, 把它们弹出后进行相应运算并保存到一个变量 (假定为 x) 中, 否则, 扫描到的字符必为数字或小数点, 应把从此开始的浮点数字符串转换为一个浮点数并存入 x 中, 然后把计算或转换得到的浮点数 (即 x 的值) 压入到栈 S 中。依次向下扫描每一个字符并进行上述处理, 直到遇到字符串结束符 (即 ASCII 为 0 的空字符) 为止, 表明后缀表达式计算完毕, 最终结果保存在栈中, 并且栈中仅存这一个值, 把它弹出返回即可。具体算法描述如下。

double Compute(char* str) //计算由 str 所指字符串的后缀表达式的值

{
//用 S 栈存储操作数和中间计算结果, 元素类型为 double
Stack S;
//初始化栈 s
InitStack(S);
//定义 x,y 用于保存浮点数, 定义 i 用于扫描后缀表达式
double x,y;
int i=0;
//扫描后缀表达式中的每个字符, 并进行相应处理
while(str[i]) {
if(str[i]==' ') //扫描到空格字符不做任何处理
{i++; continue;}
switch(str[i]) {
case '+':
x=Pop(S)+Pop(S); //做栈顶两个元素的加法, 和赋给 x
i++; break;
case '-':
x=Pop(S)-x; //做栈顶两个元素的减法, 差赋给 x
x=Pop(S)-x; //弹出减数
i++; break;
case '*': //做栈顶两个元素的乘法, 积赋给 x

x=Pop(S)*Pop(S);
i++; break;
case '/':
x=Pop(S); //做栈顶两个元素的除法, 商赋给 x
if(x!=0.0) x=Pop(S)/x; //弹出被除数并计算
else {
cerr<<"Divide by 0!"<<endl;
exit(1);
}
i++; break;
default: //扫描到的是浮点数字符串, 生成对应的浮点数
x=0; //利用 x 保存扫描到的整数部分的值
while(str[i]>=48 & str[i]<=57) {
x=x*10+str[i]-48; i++;
}
if(str[i]=='.') {
i++;
y=0; //利用 y 保存扫描到的小数部分的值
double j=10.0; //用 j 作为相应小数位的权值
while(str[i]>=48 & str[i]<=57) {
y=y+(str[i]-48)/j;
i++; j*=10;
}
x+=y; //把小数部分合并到整数部分 x 中
}
//把扫描转换后或进行相应运算后得到的一个浮点数压入栈 S 中
Push(S,x);
} //while end
//若计算结束后栈为空则中止运行
if(EmptyStack(S)) {cerr<<"Stack is empty!"<<endl; exit(1);}
//若栈中仅有一个元素, 则它就是后缀表达式的值, 否则为出错
x=Pop(S);
if(EmptyStack(S)) return x;
else {cerr<<"expression error!"<<endl; exit(1);}
//释放 S 栈中动态存储空间
ClearStack(S);

此算法的运行时间主要消耗在 while(str[i])循环上, 它从头到尾扫描后缀表达式中的每一个字符, 若后缀表达式的字符串长度为$n$, 则此算法的时间复杂度为$O(n)$。此算法在运行时所占用的临时空间主要取决于栈 S 的大小, 显然, 它的最大深度不会超过表达式中所含操作数的个数, 因为操作数的个数比运算符的个数多1, 所以此算法的空间复杂度也同样为$O(n)$。

若一个字符串 a 为:

char* a="10 3.5 - 4.3 2.48 + * 5 /";

对应的中缀算术表达式为$(10-3.5)*(4.3+2.48)/5$，则使用如下语句调用上述函数得到的输出结果为8.814。

cout<<Compute(a)<<endl;

在进行这个后缀算术表达式求值的过程中，每处理一个操作数或运算符后，栈S中保存的操作数和中间结果的情况，如图4-4所示。

| (a) 10 | (b) 3.5 | (c) - | (d) 4.3 | (e) 2.48 |
| --- | --- | --- | --- | --- |
| 10 | 3.5 | 6.5 | 4.3 | 2.48 |
|  | 10 |  | 6.5 | 4.3 |
|  |  |  |  | 6.5 |

| (f) + | (g) * | (h) 5 | (i) / |
| --- | --- | --- | --- |
| 6.78 | 44.07 | 5 | 8.814 |
| 6.5 |  | 44.07 |  |
|  |  |  |  |

图4-4 栈S中数据的变化

\section*{4.5.3 把中缀表达式转换为后缀表达式的算法}

设中缀算术表达式已经保存在S1字符串中，转换后得到的后缀算术表达式拟存于S2字符串中。由中缀表达式转换为后缀表达式的规则可知：转换前后，表达式中的数值项的次序不变，而运算符的次序发生了变化，由处在两个运算对象的中间变为处在两个运算对象的后面，同时去掉了所有的括号。为了使转换正确，必须设定一个运算符栈，并在栈底放入一个特殊算符，假定为“@”字符，让它具有最低的运算符优先级，假定为数值0，此栈用来保存扫描中缀表达式时得到的暂不能放入后缀表达式中的运算符，待它的两个运算对象都放入到后缀表达式以后，再令其出栈并写入到后缀表达式中。

把中缀表达式转换为后缀表达式算法的基本思路是：从头到尾扫描中缀表达式中的每个字符，对于不同类型的字符按不同情况进行处理。若遇到的是空格则认为是分隔符，不需要进行任何处理；若遇到的是数字或小数点，则直接写入到S2中，并在每个数值的最后写入一个空格；若遇到的是左括号，则应把它压入到运算符栈中，待以它开始的括号内的表达式转换完毕后再出栈；若遇到的是右括号，则表明括号内的中缀表达式已经扫描完毕，把从栈顶直到保存着的对应左括号之间的运算符依次退栈并写入S2串中；若遇到的是运算符，当该运算符的优先级大于栈顶运算符的优先级（加减运算符的优先级设定为1，乘除运算符的优先级设定为2，在栈中保存的特殊运算符“@”和“(”的优先级设定为0

时, 表明该运算符的后一个运算对象还没有被扫描并放入到 S2 串中, 应把它暂存于运算符栈中, 待它的后一个运算对象从 S1 串中读出并写入到 S2 串中后, 再令其出栈并写入 S2 串中; 若遇到的运算符的优先级小于等于栈顶运算符的优先级, 这表明栈顶运算符的两个运算对象已经被保存到 S2 串中, 应将栈顶运算符退栈并写入到 S2 串中, 对于新的栈顶运算符仍继续进行比较和处理, 直到被处理的运算符的优先级大于栈顶运算符的优先级为止, 然后令该运算符进栈即可。

按照以上过程扫描到中缀表达式字符串结束符时, 把栈中剩余的运算符依次退栈并写入到后缀表达式中, 再向 S2 写入字符串结束符 “0”, 整个转换过程就处理完毕, 在 S2 中就得到了转换成的后缀表达式。

将中缀算术表达式转换为后缀算术表达式的算法描述如下。

void Change(char* S1, char* S2)

//将字符串 S1 中的中缀表达式转换为 S2 字符串中的后缀表达式

{
    //定义用于暂存运算符的栈 R 并初始化, 该栈的元素类型为 char
    Stack R;
    InitStack(R);
    //给栈底放入 '@' 字符, 它具有最低优先级 0
    Push(R, '@');
    //定义 i, j 分别用于扫描 S1 和指示 S2 串中待存字符的位置
    int i=0, j=0;
    //定义 ch 保存 S1 串中扫描到的字符, 初值为第 1 个字符
    char ch=S1[i];
    //依次处理中缀表达式中的每个字符
    while(ch!='\0') {
        //对于空格字符不做任何处理, 顺序读取下一个字符
        if(ch==' ') ch=S1[++i];
        //对于左括号, 直接进栈
        else if(ch=='(') {
            Push(R, ch); ch=S1[++i];
        }
        //对于右括号, 使括号内的仍停留在栈中的运算符依次出栈并写入 S2
        else if(ch==')') {
            while(Peek(R) != '(') S2[j++]=Pop(R);
            Pop(R); //删除栈顶的左括号
            ch=S1[++i];
        }
        //对于运算符, 使暂存于栈顶且不低于 ch 优先级的运算符依次出栈并写入 S2
        else if(ch=='+' || ch=='-' || ch=='*' || ch=='/') {
            char w=Peek(R);
            while(Precedence(w)>=Precedence(ch)) {
                // Precedence(w) 函数返回运算符形参的优先级
                S2[j++]=w; Pop(R);
                w=Peek(R);
            }

}
Push(R,ch); //把 ch 运算符写入栈中
ch=s1[++i];
}
//此处必然为数字或小数点字符,否则为中缀表达式错误
else {
//若 ch 不是数字或小数点字符则退出运行
if((ch<'0' | ch>'9') && ch!='.') {
cout<<"中缀表达式表示错误!"<<endl;
exit(1);
}
}
//把一个数值中的每一位依次写入到 s2 串中
while((ch>='0' && ch<='9') || ch=='.') {
S2[j++]=ch;
ch=s1[++i];
}
//被放入 S2 中的每个数值后面接着放入一个空格字符
S2[j++]=' ';
}
//将暂存在栈中的运算符依次退栈并写入到 S2 串中
ch=Pop(R);
while(ch!='@') {
if(ch=='(') {cerr<<"expression error!"<<endl; exit(1);}
else {
S2[j++]=ch;
ch=Pop(R);
}
}
//在后缀表达式的末尾放入字符串结束符
S2[j++]='\0';

其中，求运算符优先级的 Precedence 函数定义如下。

int Precedence(char op) { //返回运算符 op 所对应的优先级数值
switch(op) {
case '+':
case '-':
return 1; //定义加减运算的优先级为 1
case '*':
case '/':
return 2; //定义乘除运算的优先级为 2
case '(':
case '@':

default:
    return 0;            //定义在栈中的左括号和栈底字符的优先级为0
}

在这个转换算法中, 中缀算术表达式中的每个字符均需要扫描一遍, 对于从 S1 中扫描得到的每个运算符, 最多需要进行入 R 栈、出 R 栈和写入 S2 后缀表达式这三次操作,对于从 S1 中扫描得到的每个数字或小数点, 只需要把它直接写入到 S2 后缀表达式即可。所以, 此算法的时间复杂度为$O(n)$,$n$为后缀表达式中字符的个数。该算法需要使用一个运算符栈, 需要的深度不会超过中缀表达式中运算符的个数, 所以此算法的空间复杂度至多为$O(n)$。

利用表达式的后缀表示和堆栈技术只需要两遍扫描就可完成中缀算术表达式的计算,显然比直接进行中缀算术表达式计算的扫描次数要少得多。

在上述讨论的中缀算术表达式求值的两个算法中, 把中缀表示转换为后缀表示的算法需要使用一个字符栈, 而进行后缀表达式求值的算法又需要使用一个浮点数栈, 这两个栈的元素类型不同, 所以栈的类型无法作为全局量来定义, 栈运算的函数也无法适应这种要求。为了解决这个问题, 必须把 Stack 栈类型定义为模板类, 把栈运算的函数定义为该类的公用成员函数, 通过调用成员函数来实现栈的运算。这里对此不作深入讨论, 留给读者练习。

采用下面程序调试上述中缀转后缀的算法。

#include<iostream.h>
#include<stdlib.h>

typedef char ElemType;
struct Stack {
    ElemType *stack;              //存栈元素
    int top;                      //存栈顶元素的下标位置
    int MaxSize;                  //存 stack 数组长度,亦即所能存储栈的最大长度
};

#include"顺序栈运算.cpp"

int Precedence(char op) { }
void Change(char* s1, char* s2) { } //给出函数具体定义

void main()
{
    char a[30];
    char b[30];
    cout<<"请输入一个中缀算术表达式: "<endl;
    cin.getline(a,sizeof(a));
    Change(a,b);
}

cout<<"对应的后缀算术表达式为: "<
cout<<b<<endl;
}
显示结果如下:
请输入一个中缀算术表达式:
12+(3*(20/4)-8)*6
对应的后缀算术表达式为:
12 3 20 4 / * 8 - 6 * +

\section*{4.6 栈与递归}

递归是一种非常重要的数学概念和解决问题的方法, 在计算机科学和数学等领域有着广泛地应用。当求解一个问题时, 是通过求解与它具有同样解法的子问题而得到的, 这就是递归。一个递归的求解问题必然包含有终止递归的条件, 当满足一定条件时就终止向下递归, 从而使最小的问题得到解决, 然后再依次返回解决较大的问题, 最后解决整个问题。解决递归问题的算法称为递归算法, 在递归算法中需要根据递归条件直接或间接地调用算法本身, 当满足终止条件时结束递归调用。当然对于一些简单的递归问题, 很容易把它转换为循环问题来解决, 从而使编出的算法更为有效。

【例4-4】采用递归算法求解正整数$n$的阶乘$(n!)$。

分析: 由数学知识可知,$n$阶乘的递归定义为: 它等于$n$乘以$(n-1)$的阶乘, 即$n!=n\times(n-1)!$,并且规定$0$的阶乘为$1$。设函数$f(n)=n!$, 则$f(n)$可表示为:$f(n)=\begin{cases} 
1 & (n=0) \\
n \times f(n-1) & (n>0)
\end{cases}$其中$n=0$为递归终止条件, 使函数返回$1$,$n>0$实现递归调用, 由$n$的值乘以$f(n-1)$的返回值, 求出$f(n)$的值。

用 C/C++语言编写出求解$n!$的递归函数如下:

long f(int n)
{
    if(n==0)
        return 1;
    else
        return n*f(n-1);
}

当从主程序或其他函数非递归调用此阶乘函数时, 首先把实参的值传送给形参$n$, 同时把调用后的返回地址保存起来, 以便调用结束后返回之用; 接着执行循环体, 当$n$等于 0 时则返回函数值 1 , 结束本次非递归调用或递归调用, 并按返回地址返回到进行本次调用的调用函数的位置继续向下执行, 当$n$大于 0 时, 则以实参$n-1$的值去调用本函数 (即递归调用), 返回$n$的值与本次递归调用所求值的乘积。因为进行一次递归调用, 传送给形

参$n$的值就减 1 , 所以最终必然导致$n$的值为 0 , 从而结束递归调用, 接着不断地执行与递归调用相对应的返回操作, 最后返回到进行非递归调用的调用函数的位置向下执行。

若用$f(4)$去调用$f(n)$函数, 该函数返回$4 \times f(3)$的值, 因返回表达式中包含有函数$f(3)$,所以接着进行递归调用, 返回$3 \times f(2)$的值, 以此类推, 当最后进行$f(0)$递归调用, 返回函数值 1 后, 结束本次递归调用, 返回到调用函数$f(0)$的位置, 从而计算出$1 \times f(0)$的值 1 ,即$1 \times f(0) = 1 \times 1 = 1$, 作为调用函数$f(1)$的返回值, 返回到$2 \times f(1)$表达式中, 计算出值 2 作为$f(2)$函数的返回值, 接着返回到$3 \times f(2)$表达式中, 计算出值 6 作为$f(3)$函数的返回值, 再接着返回到$4 \times f(3)$表达式中, 计算出$f(4)$的返回值 24 , 从而结束整个调用过程, 返回到调用函数$f(4)$的位置继续向下执行。

上述调用和返回过程, 如图 4-5 所示。

![image](attachment://figure_4_5.png)

图 4-5 利用$f(4)$调用$f(n)$递归函数的执行流程

在计算机系统内, 执行递归函数是通过自动使用栈来实现的, 栈中的每个元素包含有递归函数的每个参数域、每个局部变量量和调用后的返回地址域, 其中引用参数域只保存传送来的实参的地址, 以便按此地址访问实参的存储空间存取其值, 其他的每个域是用于存储其值的实际存储空间。每次进行函数调用时, 都把相应的值压入栈, 每次调用结束时,都按照本次返回地址返回到指定的位置执行, 并且自动做一次退栈操作, 使得上一次调用所使用的参数成为新的栈顶项, 继续被使用。

例如对于求$n$阶乘的递归函数$f(n)$, 当调用它时系统自动建立一个栈, 该栈中的元素包含值参$n$的域和返回地址 r 域, 若用$f(4)$去调用$f(n)$函数, 调用后的返回地址用 r1 表示,在$f(n)$函数中, 每次进行$f(n-1)$调用的返回地址用 r2 表示, 则系统所使用栈的数据变化情况如图 4-6 所示。

其中, 每个栈状态的栈顶元素的 n 域是调用$f(n)$函数时为值参$n$所分配的存储空间, r 域为保存当前一次调用结束后的返回地址所分配的存储空间。如进行$f(4)$调用时, 栈顶元素中的值参$n$域保存的值为 4 , 返回地址域保存的值为 r1, 当执行$f(4)$调用结束 (即执行到函数体的右花括号结束符) 后, 就返回到 r1 的位置执行。又如当执行$f(3)$调用时, 栈顶元素中的值参$n$域保存的值为 3 , 返回地址域保存的值为 r2, 当调用$f(3)$结束后, 就返回到 r2 的位置 (即上一层返回表达式中乘号后面的位置) 执行。

当调用$f(n)$算法时, 系统所使用栈的最大深度为$n+1$,$n$为首次调用时传送给来的实参的值, 所以其空间复杂度为$O(n)$。又因为每执行一次递归调用就是执行一条条件语句, 其时

(a) 计算$f(4)$值
(b) 计算$f(3)$值
(c) 计算$f(2)$值
(d) 计算$f(1)$值
(e) 计算$f(0)$值

(f) 返回$f(0)$值 1
(g) 返回$f(1)$值 1
(h) 返回$f(2)$值 2
(i) 返回$f(3)$值 6
(j) 返回$f(4)$值 24

图 4-6 进行$f(4)$调用的系统栈的变化状态

间复杂度为$O(1)$, 执行整个算法求出$n!$的值需要进行$n+1$次调用, 所以其时间复杂度也为$O(n)$。由于采用循环算法求解$n!$的问题, 其空间复杂度为$O(1)$, 时间复杂度为$O(n)$, 并且省去进出栈的繁琐操作, 显然比采用递归算法更为有效。求$n$阶乘采用递归算法, 是为了详细说明系统对递归算法的处理过程, 以便能够理解更复杂的递归算法。

【例 4-5】编写一个算法输出$n$个布尔量的所有可能的组合。

分析: 每个布尔量取真和假两种值, 分别对应为数值 1 和 0。根据题意, 当$n$为 1 时有两种输出 0 和 1, 当$n$为 2 时有 4 种组合输出, 依次为 00、01、10 和 11, 当$n$为 3 时有 8 种组合输出, 依此为 000、001、010、011、100、101、110 和 111。总之, 对于$n$个布尔量所有可能的组合数为$2^n$种, 每一种为$n$位, 即$n$个布尔量的值。$n$个布尔量的$2^n$种所有不同的输出可以看成$2 \times 2^{n-1}$种输出, 其中$2^{n-1}$种输出是$n-1$个布尔量的全部输出, 每种输出包含有$n-1$个布尔量的值。$n$个布尔量的每一种输出是在$n-1$个布尔量的每种输出的前面加上假 (即 0) 或加上真 (即 1) 而分别得到的结果, 合起来正好是$2 \times 2^{n-1} = 2^n$种输出。由此可以看出它是一个递归的过程。

设$n$个布尔量用一个布尔型数组$b[n]$来表示, 要得到$b[0] \sim b[n-1]$这$n$个布尔量的每一种可能的组合, 则要首先在$b[0]$被置 0 的情况下得到$b[1] \sim b[n-1]$这$n-1$个布尔量的每一种可能的组合, 然后在$b[0]$被置 1 的情况下得到$b[1] \sim b[n-1]$这$n-1$个布尔量的每一种可能的组合; 同理, 要得到$b[1] \sim b[n-1]$这$n-1$个布尔量的每一种可能的组合, 则要首先在$b[1]$被置 0 的情况下得到$b[2] \sim b[n-1]$这$n-2$个布尔量的每一种可能的组合, 然后在$b[1]$被置 1 的情况下得到$b[2] \sim b[n-1]$这$n-2$个布尔量的每一种可能的组合; 以此类推, 直到最后一个布尔量$b[n-1]$被置 0 后输出整个数组和被置 1 后输出整个数组为止。

下面递归算法是对$b[k] \sim b[n-1]$之间的$n-k$个布尔量输出所有可能的组合, 初始调用该算法时$k$值为 0。

void Coding(bool b[], int k, int n)
{
    if (k==n)
    {
        //终止递归,输出在b数组中排列好的一种组合
        for (int i=0; i<n; i++)
            cout<<b[i];
        cout<<" ";
    }
    else
    {
        //把下标为k的布尔量置0后,从下标k+1起递归调用
        b[k]=false; Coding(b, k+1, n);
        //把下标为k的布尔量置1后,从下标k+1起递归调用
        b[k]=true; Coding(b, k+1, n);
    }
}

此算法的每一次调用都要引起两次递归调用，当$k=n$时输出一种组合并结束本次调用，返回到原来调用函数的位置继续执行。若第1次非递归调用（为叙述方便，可把这次调用称为第0次递归调用）时传送给$k$的值为0，则共需要进行$2^{n+1}-1$次递归调用（含第0次递归调用）。对于$n$个布尔量共需要输出$2^n$种所有不同的组合，所以在$2^{n+1}-1$次递归调用中共有$2^n$次递归调用输出数组$b$的值。例如当$n=3$时，整个递归调用的次数为15次，输出8种不同的组合；当$n=4$时，整个递归调用的次数为31次，输出16种不同的组合。

当用户调用这个算法时，系统自动建立一个栈，该栈包含布尔型指针值参$b$的域、整型值参$k$的域和$n$的域以及返回地址$r$的域。第0次递归调用后的返回地址假定为$r1$，该算法中第1条递归调用语句执行后的返回地址（即为执行$b[k]=$true语句的地址）假定为$r2$，第2条递归调用语句执行后的返回地址（即为else语句块结束的地址，亦即算法的结束地址）假定为$r3$，若用Coding（a,0,3）去调用这个算法，其中$a$是一个元素个数大于等于3的布尔型数组，感兴趣的同学可以画出系统栈和数组$a$在算法执行过程中的变化状态，由于值参$b$和$n$的值始终不变，在栈中不用给出它们所对应的域，只用给出$k$值域和返回地址$r$即可。

此算法需要递归调用$2^{n+1}-1$次，其中有$2^n$次需要调用输出数组$b$中$n$个元素的值，所以算法的时间复杂度为$O(n\times 2^n)$，该算法所使用的系统栈的最大深度为$n+1$，所以其空间复杂度为$O(n)$，$n$为布尔量的个数。

【例4-6】编写一个递归算法，输出自然数$1\sim n$这$n$个元素的全排列。

分析：由排列组合的知识可知，$n$个元素的全排列共有$n!$种。如对于1、2、3这三个元素，其全排列为123、132、213、231、321、312，共$3!=6$种。$n!$种可分解为$n\times(n-1)!$种，而$(n-1)!$种又可分解为$(n-1)\times(n-2)!$种，以此类推。对于$n$个元素，可把它们分别放入到$n$个位置上，让第一个位置依次取每一个元素，共有$n$种不同的取法，对其后$n-1$个位置上的$n-1$个元素，共有$(n-1)!$种不同的排列，所以总共有$n\times(n-1)!$种不同的排列；同样，对于从第2个位置开始的所有元素，让第2个位置依次取除第1个位置上的元素之外的剩余$n-1$个元素，共有$n-1$种不同的取法，对其后$n-2$个位置上的$n-2$个元素，共有$(n-2)!$种不同的排列，以此类推；当进行到第$n$位置时，只有一种取法，因为前$n-1$个位置已经固定了$n-1$个元素，剩余的一个元素被放在这个位置上。

若用一个数组 a[n]来保存 1～n之间的 n个自然数, 对于 i=0～n-1, 每次使 a[0]同 a[i]交换 (i=0,1,2,\cdots,n-1) 后, 对 a[1]~a[n-1]中的 n-1个元素进行全排列, 然后再交换 a[0]与 a[i]的值, 使它恢复为此次排列前的状态; 同样, 对于 a[1]~a[n-1]区间内的 n-1个元素,每次使 a[1]同 a[i]交换 (i=1,2,\cdots,n-1) 后, 对 a[2]~a[n-1]区间内的 n-2个元素进行全排列, 然后再把交换的元素交换回来, 以此类推, 直到对 a[n-1]进行全排列时, 输出整个数组的值, 即得到一种排列结果。

对 n个元素的全排列是一个递归过程, 具体描述如下。

void Permute(int a[], int s, int n)
    //对 a[s]~a[n-1]中的 n-s个元素进行全排列, s 的初值应为 0
{
    int i, temp;
    //当递归排序到最后一个元素时结束递归, 输出 a 中保存的一种排列
    if (s==n-1) {
        for(i=0; i<n; i++) cout<<a[i]<<" ";
        cout<<endl;
    }
    //其他情况需要递归排列
    else
        for (i=s; i<n; i++) { 
            //循环 n-s 次, 每次使 a[s]取一个新值
            //交换 a[s]与 a[i]的元素值
            temp=a[s]; a[s]=a[i]; a[i]=temp;
            //对 a[s+1]~a[n-1]中的元素进行递归排序
            Permute(a, s+1, n);
            //恢复 a[s]与 a[i]的原有值
            temp=a[s]; a[s]=a[i]; a[i]=temp;
        }
}

此算法的时间复杂度为$O(n!)$, 因为共需要进行 n!次递归调用; 空间复杂度为$O(n)$,因为系统栈的最大深度为 n。可以使用下面程序调用此算法。

#include<iostream.h>
const int UpperLimit=6;          //定义全排列的元素个数的最大值
void Permute(int a[], int s, int n)
    //对 a[s]~a[n-1]中的 n-s个元素进行全排列, s 的初值为 0
{ 
    //函数体如上所述
}
void main(void)
{
    int a[UpperLimit];           //定义存储 n 个整型元素的数组
    int n;
    while(1) {
        cout<<"输入 n 的值, 它应在 1 和 "<<UpperLimit<<"之间:";
        cin>>n;
        //输入待全排列的元素的实际个数
        if(n>=1 && n<=UpperLimit) break;
    }

for(int i=0; i<n; i++) a[i]=i+1; //给数组a赋初值
Permute(a, 0, n); 
//对数组a中的n个元素（即$1\sim n$）进行全排列
cout<<endl;

程序运行时，假定从键盘上输入的$n$值为3，则运行结果如下。

输入$n$的值,它应在1和6之间:3
1 2 3
1 3 2
2 1 3
2 3 1
3 2 1
3 1 2

【例4-7】求解迷宫问题。
分析：一个迷宫包含有$m$行$\times n$列个小方格，每个方格用0表示可通行，用1表示墙壁，即不可通行。迷宫中通常有一个入口和一个出口，设入口点的坐标为$(1,1)$，出口点的坐标为$(m,n)$，当然入口点和出口点的值应均为0，即可通行。从迷宫中的某一个坐标位置向东、南、西、北任一方向移动一步（即一个方格）时，若前面的小方格为0，则可前进一步，否则通行受阻，不能前进，应按顺时针改变为下一个方向移动。求解迷宫问题是从入口点出发寻找一条通向出口点的路径，并打印出这条路径，即经过的每个小方格的坐标。如图4-7（a）所示为一个$6\times8$的迷宫，入口点坐标为$(1,1)$，出口点坐标为$(6,8)$，其中的一条路径为：$(1,1),(1,2),(2,2),(2,3),(3,3),(3,4),(3,5),(3,6),(4,6),(4,7),(5,7),(6,7),(6,8)$。$\begin{array}{|c|c|c|c|c|c|c|c|}
\hline
0 & 0 & 0 & 1 & 1 & 0 & 1 & 0 \\
\hline
1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 \\
\hline
0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 \\
\hline
1 & 1 & 0 & 1 & 1 & 0 & 0 & 0 \\
\hline
0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 \\
\hline
1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
\hline
\end{array}$(a) 一个$6\times8$的迷宫$\begin{array}{|c|c|c|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
\hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
\hline
1 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 1 \\
\hline
1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 \\
\hline
1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
\hline
1 & 1 & 1 & 0 & 1 & 1 & 0 & 0 & 0 \\
\hline
1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 \\
\hline
1 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 \\
\hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
\hline
\end{array}$(b) 带四周墙壁的迷宫

图4-7 迷宫阵列图

在一个迷宫中，中间的每个方格位置都有四个可选择的移动方向，而在四个顶点只有两个方向，并且每个顶点的两个方向均有差别，每条边线上除顶点之外的每个位置只有三个方向，并且也都有差别。为了在求解迷宫的算法中避免判断边界条件和进行不同处理的麻烦，使每一个方格都能够试着按四个方向移动，可在迷宫的周围镶上边框，在边框的每个方格里填上1，作为墙壁，如图4-7(b)所示。这样需要用一个$[m+2][n+2]$大小的二维整型数组（用maze表示数组名）来存储迷宫数据。

当从迷宫中的一个位置（称它为当前位置）前进到下一个位置时，下一个位置相对于当前位置的位移量（包括行位移量和列位移量）随着前进方向的不同而不同，东、南、西、北（即右、下、左、上）各方向的位移量依次为$(0,1),(1,0),(0,-1)$和$(-1,0)$。用一个$4\times2$的整型数组move来存储位移量数据，则move数组的内容如右上面表格所示。其中，move[0]~move[3]依次存储向东、南、西、北每个方向移动一步的位移量。如move[1][0]和move[1][1]分别为从当前位置向南移动一步的行位移量和列位移量，其值分别为1和0。

在求解迷宫问题时，还需要使用一个与存储迷宫数据的maze数组同样大小的辅助数组，用标识符mark表示，用它来标识迷宫中对应位置是否被访问过。该数组每个元素的初始值为0，表示迷宫中的所有位置均没有被访问过。每访问迷宫中一个可通行的位置时，都使mark数组中对应元素置1，表示该位置已经被访问过，以后不会再访问到，这样才能够探索新的路径，避免重走已经走不通的老路。

为了寻找从入口点到出口点的一条通路，首先从入口点出发，按照东、南、西、北各方向的次序试探前进，若向东可通行，同时没有被访问过，则向东前进一个方格；否则表明向东没有通向出口的路径，接着应向南方向试着前进，若向南可通行同时没有被访问过，应向南前进一步；否则依次向西和向北试探。若试探完当前位置上的所有方向都没有通路，则应退回一步，到达该当前位置的下一个方向试探着前进，如到达该当前位置的方向为东，则下一个方向为南。因此每前进一步都要记录其上一步的坐标位置以及前进到此步的方向，以便退回之用，这正好需要用栈来解决，每前进一步时，都把当前位置和前进方向进栈，接着使向前一步后的新位置成为当前位置，若从当前位置无法继续前进时，就做一次退栈操作，从上一次位置的下一个方向试探着前进。若当前位置是出口点时，则表明找到了一条从入口点到出口点的路径，应结束算法执行，此时路径上的每个方格坐标（除出口坐标外）均被记录在栈中。若做退栈操作时栈为空，则表明入口点也已经退栈，并且其所有方向都已访问过，没有通向出口点的路径，此时应结束算法，打印出无通路信息。

栈和递归是可以相互转换的，当编写递归算法时，虽然表面上没有使用栈，但系统执行时会自动建立和使用栈。求解迷宫问题也是一个递归问题，适合采用递归算法来解决。若迷宫中的当前位置（初始为入口点）就是出口位置，则表明找到了通向出口的一条路径，应返回true结束递归；若当前位置上的所有方向都试探完毕，表明从当前位置出发没有寻找到通向出口点的路径，应返回false结束递归；若从当前位置按东、南、西、北方向的次序前进到下一个位置时，若该位置可通行且没有被访问过，则应以该位置为参数进行递归调用，若返回true的话，表明从该位置到出口点有通路，输出该位置坐标后，继续向上一个位置返回true结束递归。

下面给出求解迷宫问题的递归算法，其中$m$和$n$为全局整型常量，分别表示迷宫的行

数和列数, 亦即出口点的坐标, maze 和 mark 分别为具有$[m+2][n+2]$大小的全局整型数组, 分别用来保存迷宫数据和访问标记, move 为具有$[4][2]$大小的全局整型数组, 用来保存向每个方向前进的位移量。

bool SeekPath(int x,int y)
    //从迷宫中坐标点$(x,y)$的位置寻找通向终点$(m,n)$的路径,若找到则
    //返回 true,否则返回 false,$(x,y)$的初始值通常为$(1,1)${
    //i 作为循环变量,代表从当前位置移到下一个位置的方向
    int i;
    //g 和 h 用作为下一个位置的行坐标和列坐标
    int g,h;
    //到达终点返回 true 结束递归
    if ($(x==m)\&\&(y==n)$) return true;
    //依次按每个方向寻找通向终点的路径,$i=0,1,2,3$分别为东,南,西,北方向
    for(i=0;$i<4$; i++)
    {
        //求出下一个位置的行坐标和列坐标$g=x+\operatorname{move}[i][0]$;$h=y+\operatorname{move}[i][1]$;
        //若下一位罝可通行同时没有被访问过,则从该位置起寻找
        if ($(maze[g][h]==0)\&\&(mark[g][h]==0)$)
        {
            //置 mark 数组中对应位置为 1 ,表明已访问过
            mark[g][h]=1;
            //当条件成立 (即返回 true)时,表明从$(g,h)$到终点存在
            //通路,应输出该位置坐标,同时返回 true 结束递归,
            //否则进入下一轮循环,向下一个方向试探
            if (SeekPath(g,h)) {
                cout<<("("<g<", "<h<")", ");
                return true;
            }
        }
    }
    //从当前位置$(x,y)$没有通向终点的路径,应返回 false
    return false;
}

当用户调用这个递归算法时, 系统将自动建立含有值参 x 和 y 域, 局部变量 i、g 和 h 域以及返回地址 r 域的一个栈, 每次递归调用时都自动进行进栈操作, 每次算法执行结束 (包括执行到 return 语句或算法最后的花括号) 后都自动进行出栈操作。若算法执行时的 maze 数组, 如图 4-7 (b) 所示, 第 0 次递归调用时的返回地址用 r1 表示, 算法中仅有一处递归调用, 其返回地址用 r2 表示, 则从第 0 次递归调用到第 3 次递归调用前系统栈的变化状态, 如图 4-8 所示。对于系统栈的以后变化, 读者可继续分析。

该算法的运行时间和使用系统栈所占有的存储空间与迷宫的大小成正比，在最好情况下的时间和空间复杂度均为$O(m+n)$，在最差情况下均为$O(m \times n)$，平均情况在它们之间。

下面给出求解迷宫算法的完整程序。

```cpp
#include<iostream.h>
const int m=6,n=8; //定义m和n常量,假定求解图4-7所示的迷宫问题
int maze[m+2][n+2]; //定义保存迷宫数据的数组
int mark[m+2][n+2]; //定义保存访问标记的数组
int move[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
//行下标0,1,2,3分别代表东,南,西,北方向
int SeekPath(int x,int y)
{ //函数体在此省略
}
void main(void)
{
    int i,j;
    //输入迷宫数据
    for(i=0; i<m+2; i++)
        for(j=0; j<n+2; j++)
            cin>>maze[i][j];
    //初始化mark数组
    for(i=0; i<m+2; i++)
        for(j=0; j<n+2; j++)
            mark[i][j]=0;
    //置入口点对应的访问标记为1
    mark[1][1]=1;
    //从入口点(1,1)开始调用求解迷宫的递归算法
    if(SeekPath(1,1))
        cout<<"("<<1<<","<<1<<")"<<endl; //从入口到出口的路径
    //按所经位置的相反次序输出,最后需要输出入口点的坐标
}
```

当按图 4-7 输入迷宫数据，则得到如下输出结果（在第8个坐标后的回车是另加的）。$(6,8)$，$(6,7)$，$(5,7)$，$(4,7)$，$(4,6)$，$(3,6)$，$(3,5)$，$(3,4)$，$(3,3)$，$(2,3)$，$(2,2)$，$(1,2)$，$(1,1)$【例 4-8】求解汉诺塔(Tower of Hanoi)问题。

此问题为：有3个台柱，分别编号为A、B、C或1、2、3；在A柱上穿有$n$个圆盘，每个圆盘的直径均不同，并且按照直径从大到小的次序叠放在柱子上；要求把A柱上的$n$个圆盘搬到C柱上，B柱可以作为过渡，并且每次只能搬动一个圆盘，同时必须保证在任何柱子上的圆盘在任何时候都要按序码放，即大的在下，小的在上；当把若干个圆盘从一个柱子搬到另一个柱子时，第3个柱子作为过渡使用；题目要求编写出一个算法，输出搬动圆盘的过程。

分析：若一个柱子上只有一个圆盘，则不需要使用过渡台柱，直接把它放到目的地柱上即可。若一个柱子上有两个圆盘，则先把一个（只能是上面一个）放到过渡柱子上，再把另一个放到目的地柱上，最后把过渡柱上的一个圆盘放到目的地柱上，到此完成搬动过程。若一个柱子上有3个、4个……又如何解决呢？必须找出适用于任意多个（即大于等于2个）情况的通用方法或规则才行。由此可能想到递归，即先把原柱子上的$n-1$个圆盘设法搬到过渡柱上，再把原柱子上剩下的最后一个圆盘直接搬到目的地柱上，最后设法把过渡柱上的$n-1$个圆盘搬到目的地柱上，从而完成全部搬动过程；当把$n-1$个圆盘从一个柱子搬到另一个柱子时，若它的圆盘数不是一个，又需要使用第3个柱子作为过渡。此递归就是把$n$的问题化解为两个$n-1$的问题，当$n$等于1时不需要再递归，只需要直接移动即可。

例如，当A柱上有3个圆盘，要求把它移动到C柱上，则需要如下步骤完成。

(1) 把A柱上的2个圆盘直接移到过渡柱B上。

① 把A柱上的1个圆盘直接移到此时的过渡柱C上。

② 把A柱上剩余的1个圆盘直接移到此时的目的柱B上。

③ 把此时的过渡柱C上的1个圆盘直接移到此时的目的柱B上。

(2) 把A柱上剩下的1个圆盘直接移到目的地柱C上。

(3) 把过渡柱B上的2个圆盘移到目的地柱C上。

① 把B柱上的1个圆盘直接移到此时的过渡柱A上。

② 把B柱上剩余的1个圆盘直接移到此时的目的柱C上。

③ 把此时的过渡柱A上的1个圆盘直接移到此时的目的柱C上。

上述整个移动过程为7个直接步骤，依此如下。

A→C；A→B；C→B；A→C；B→A；B→C；A→C

或用数字编号写为：$1\rightarrow3$；$1\rightarrow2$；$3\rightarrow2$；$1\rightarrow3$；$2\rightarrow1$；$2\rightarrow3$；$1\rightarrow3$根据以上分析，设把$n$个盘子由值参a所表示的柱子搬到由值参c所表示的柱子，用值参b所表示的柱子作为过渡，则编写出递归算法如下:

void Hanoi(int n, int a, int b, int c)
{
    //当只有一个盘子时，直接由a柱搬到c柱后结束一次调用

if(n==1) cout<<a<<"->"<<c<<endl;
//当多于一个盘子时, 向下递归
else {
    //首先把$n-1$个盘子由值参 a 所表示的柱子搬到由值参 b 所表示
    //的柱子上, 用值参 c 所表示的柱子作为过渡
    Hanoi(n-1,a,c,b);
    //把由值参 a 所表示的柱子上的最后一个盘子搬到由值参 c 所
    //表示的柱子上
    cout<<a<<"->"<<c<<endl;
    //最后把$n-1$个盘子由值参 b 所表示的柱子搬到由值参 c 所表示
    //的柱子上, 用值参 a 所表示的柱子作为过渡
    Hanoi(n-1,b,a,c);
}

采用 Hanoi(3,1,2,3) 去调用该递归函数，则得到的整个递归调用关系，如图 4-9 所示，
它是一棵树结构，每个树叶结点下面的输出是执行 if (n==1) 子句中输出语句的结果，每个
树枝结点下的输出是执行 else 子句中输出语句的结果。其中函数名简记为 H。

图 4-9 执行 Hanoi(3,1,2,3) 时的递归调用关系树

调用上述递归算法时，若实参$n$的值为 1 则算法被执行 1 次，若值为 2 则被执行 3 次，
若为 3 则被执行 7 次，以此类推，总之被执行$2^n-1$次。所以此算法的时间复杂度为$O(2^n)$。
算法在执行时系统需要自动建立工作栈，栈的深度等于对应递归调用关系树的深度（即层
数），该深度等于$n$。所以此算法的空间复杂度为$O(n)$。

若采用 Hanoi(4,1,2,3) 调用上述递归函数，则得到的输出结果如下，其中为了节省篇幅把换行换成了空格。

1→2 1→3 2→3 1→2 3→1 3→2 1→3 2→1 2→3 1→2 3→1 2→3 1→3 2→1 2→3

4.7 队列

4.7.1 队列的定义

队列 (queue) 简称队，它也是一种运算受限的线性表，其限制是仅允许在表的一端进

行插入, 而在表的另一端进行删除。把进行插入的一端称作队尾 (rear), 进行删除的一端称作队首（front）。向队列中插入新元素称为进队或入队，新元素进队后就成为新的队尾元素；从队列中删除元素称为离队或出队，元素离队后，其后继元素就成为队首元素。由于队列的插入和删除操作分别是在各自的一端进行的，每个元素必然按照进入的次序离队，所以又把队列称为先进先出表（First In First Out，FIFO）。

在日常生活中，人们为购物或等车时所排的队就是一个队列，新来购物或等车的人接到队尾（即进队），站在队首的人购到物品或上车后离开（即出队），当最后一人离队后，则队列为空。

若有$a,b,c,d$共4个元素依次进队，则得到的队列为$(a,b,c,d)$，其中字符$a$为队首元素，字符$d$为队尾元素。若从此队中删除一个元素，则字符$a$出队，字符$b$成为新的队首元素，此队变为$(b,c,d)$；若接着向该队列插入一个字符$e$，则$e$成为新的队尾元素，此队变为$(b,c,d,e)$；若接着做3次删除操作，则队列变为$(e)$，此时只有一个元素$e$，它既是队首元素又是队尾元素，当它被删除后队列变为空。

\section*{4.7 .2 队列的抽象数据类型}

队列的抽象数据类型中的数据部分为具有ElemType元素类型的一个队列，它可以采用任一种存储结构实现；操作部分包括元素进队、出队、读取队首元素、检查队列是否为空等。队列的抽象数据类型的具体定义如下。

ADT QUEUE is

Data:

一个队列Q，假定用标识符QueueType表示队列的存储类型

Operation:

void InitQueue(QueueType& Q); //初始化队列Q，置Q为空

void EnQueue(QueueType& Q, ElemType item); //将新元素插入队尾

ElemType OutQueue(QueueType& Q); //从队列中删除队首元素并返回

ElemType PeekQueue(QueueType& Q); //返回队首元素，不改变队列状态

bool EmptyQueue(QueueType& Q); //判断队列是否为空

void ClearQueue(QueueType& Q); //清除队列Q，使之成为空队

end QUEUE

有一个队列$q$，其元素类型为整型int，下面给出调用上述操作的一些例子。

InitQueue(q); //把队列置空

EnQueue(q,35); //元素35进队

int x=12; EnQueue(q,2*x+3); //元素2*x+3的值27进队

EnQueue(q,-16); //元素-16进队，此时队列为(35,27,-16)

cout<<PeekQueue(q)<<endl; //输出队首元素35

OutQueue(q); OutQueue(q); //依次删除元素35和27

while(!EmptyQueue(q)) cout<<OutQueue(q)<<" "; //依次输出队列q

//中的所有元素，因q中只有一个元素-16，所以此循环只输出它

4.7.3 队列的顺序存储结构和操作实现

队列的顺序存储结构需要使用一个数组和 2~3 个整型变量来实现, 利用数组来顺序存储队列中的所有元素, 利用一个整型变量存储队首元素的位置 (通常存储队首元素的前一个位置), 利用另一个整型变量存储队尾元素的位置, 利用第三个整型变量 (若使用的话) 存储队列的长度, 即队列中当前已有的元素个数。把指向队首元素前一个位置的变量称为队首指针, 由它加 1 就得到队首元素的下标位置, 把指向队尾元素位置的变量称为队尾指针, 由它可直接得到队尾元素的下标位置。若存储队列的数组用 queue[MaxSize]表示, 队首指针和队尾指针分别用 front 和 rear 表示, 存储队列长度的变量用 len 表示, 则元素类型为 ElemType 的队列的顺序存储结构可通过下列一组定义来描述。

ElemType queue[MaxSize]; //MaxSize 为已定义的常量
int front, rear, len;

其中, MaxSize 的值确定了 queue 数组所能存储队列的最大长度。

队列的顺序存储结构同样可以被定义在一个结构类型中, 假定该结构类型用 Queue 表示, 则定义为:

struct Queue {
    ElemType queue[MaxSize];
    int front, rear, len;
};

若要对存储队列的数组空间采用动态分配, 则定义为:

struct Queue {
    ElemType *queue; //指向存储队列的数组空间
    int front, rear, len; //队首指针、队尾指针、队列长度变量
    int MaxSize; //queue 数组长度
};

每次向队列插入一个元素, 需要首先使队尾指针后移一个位置, 然后再向这个位置写入新元素。当队尾指针指向数组空间的最后一个位置 MaxSize-1 时, 若队首元素的前面仍存在空闲的位置, 则表明队列未占满整个数组空间, 下一个存储位置应是下标为 0 的空闲位置, 因此, 首先要使队尾指针指向下标为 0 的位置, 然后再向该位置写入新元素。通过赋值表达式$rear=(rear+1)\%MaxSize$可使存储队列的整个数组空间变为首尾相接的一个环, 所以顺序存储的队列又称为循环队列。在循环队列中, 其存储空间是首尾循环利用的, 当 rear 指向最后一个存储位置时, 下一个所求的位置自动为数组空间的开始位置 (即下标为 0 的位置)。

每次从队列中删除一个元素时, 若队列非空, 则首先把队首指针后移, 使之指向队首元素, 然后再返回该元素的值。使队首指针后移也必须采用取模运算, 该计算表达式为$front=(front+1)\%MaxSize$, 这样才能够实现存储空间的首尾相接。

当一个顺序队列中的$len$域的值为 0 时, 表明该队列为空, 则不能进行出队和读取队首元素的操作, 当$len$域的值等于$MaxSize$时, 表明队列已满, 即存储空间已被用完, 此时应动态扩大存储空间, 然后才能插入新元素。

在队列类型的定义中, 若省略长度$len$域也是可行的, 但此时的长度为$MaxSize$的数组空间最多只能存储长度为$MaxSize-1$的队列, 也就是说必须有一个位置空闲着。因为,若使用全部$MaxSize$个位置存储队列, 则当队首和队尾指针指向同一个位置时, 也可能为空队, 也可能为满队, 就存在二义性, 无法进行判断。为了解决这个矛盾, 只有牺牲一个位置的存储空间, 让队首指针所指的存储位置始终空闲着, 利用队首和队尾指针是否相等只作为判断空队的条件, 而利用队尾指针加 1 并对$MaxSize$取模后是否等于队首指针 (即队尾是否从后面又追上了队首) 作为判断满队的条件。

采用顺序存储结构的队列被称为顺序队列。下面给出在顺序队列上进行各种队列运算的算法。

\section*{1. 初始化队列}

初始化队列为空并带有动态存储空间分配。

void InitQueue (Queue& Q)

{

//初始设置队列空间大小为 10 个元素位置

Q.MaxSize=10;

//动态存储空间分配

Q.queue=new ElemType[Q.MaxSize];

//初始置队列为空

Q.front=Q.rear=0;

}

\section*{2. 向队列插入元素, 若队列已满需重新分配更大的存储空间}

void EnQueue(Queue& Q, ElemType item)

{

//对存储空间用完情况进行处理

if ((Q.rear+1)\%Q.MaxSize==Q.front) {

//扩大 2 倍的存储空间

int k=sizeof(ElemType);

Q.queue=(ElemType*)realloc(Q.queue, 2*Q.MaxSize*k);

//把原队列的尾部内容向后移动 MaxSize 个位置

if(Q.rear != Q.MaxSize-1) {

for(int i=0; i<Q.rear; i++)

Q.queue[i+Q.MaxSize]=Q.queue[i];

Q.rear+=Q.MaxSize; //队尾指针后移 MaxSize 个位置

}

//把队列空间大小修改为原值的 2 倍

Q.MaxSize=2*Q.MaxSize;

}

//求出队尾的下一个位置
Q.rear=(Q.rear+1)%Q.MaxSize;
//把item的值赋给新的队尾位置
Q.queue[Q.rear]=item;
}

3. 从队列中删除元素并返回

ElemType OutQueue(Queue& Q)
{
    //若队列为空则终止运行
    if(Q.front==Q.rear) {
        cerr<<"队列已空,无法删除!"<<endl;
        exit(1);
    }
    //使队首指针指向下一个位置
    Q.front=(Q.front+1)%Q.MaxSize;
    //返回队首元素
    return Q.queue[Q.front];
}

4. 读取队首元素，不改变队列状态

ElemType PeekQueue(Queue& Q)
{
    //若队列为空则退出程序运行
    if(Q.front==Q.rear) {
        cerr<<"队列已空,无法读取!"<<endl;
        exit(1);
    }
    //队首元素是队首指针的下一个位置中的元素
    return Q.queue[(Q.front+1)%Q.MaxSize];
}

5. 检查一个队列是否为空，若是则返回 true，否则返回 false

bool EmptyQueue(Queue& Q)
{
    return Q.front==Q.rear;
}

6. 清除一个队列为空，并释放动态存储空间

void ClearQueue(Queue& Q)
{
    if(Q.queue!=NULL) delete []Q.queue;
    Q.front=Q.rear=0;
    Q.queue=NULL;
    Q.MaxSize=0;
}

在顺序队列中进行任何操作的时间复杂度均为$O(1)$, 当然队满时可能需要复制原队列部分内容的情况除外。

顺序队列的插入和删除过程, 如图 4-10 所示, 从中可以清楚地看出队列内容及队首和队尾指针的变化情况。此队列的初始数组空间长度为 5。

(1) [$\begin{array}{lllll}0 & 1 & 2 & 3 & 4\end{array}$] //空队列，首尾指针均为 0$\uparrow$front,rear

(2) [$\begin{array}{lllll}0 & 1 & 2 & 3 & 4\end{array}$] //连续插入三个元素 25,36,49$\uparrow$front$\uparrow$rear

(3) [$\begin{array}{lllll}0 & 1 & 2 & 3 & 4\end{array}$] //接着插入一个元素 30$\uparrow$front$\uparrow$rear

(4) [$\begin{array}{lllll}0 & 1 & 2 & 3 & 4\end{array}$] //连续删除两个元素 25 和 36$\uparrow$front$\uparrow$rear

(5) [66 23 49 30] //连续插入两个元素 66 和 23$\uparrow$rear$\uparrow$front

(6) [$\begin{array}{llllllllll}0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9\end{array}$] //插入元素 52 时$\uparrow$front$\uparrow$rear //队满扩大空间

(7) [38 49 30 66 23 52 47 15] //连续插入元素 47,$\uparrow$rear$\uparrow$front //15,38

(8) [38 49 30 66 23 52 47 15] //连续删除四元素$\uparrow$rear$\uparrow$front

图 4-10 顺序队列的插入和删除操作示意图

\section*{4.7 .4 队列的链接存储结构和操作实现}

队列的链接存储结构也是通过由结点构成的单链表实现的, 此时只允许在单链表的表头进行删除和在单链表的表尾进行插入, 因此它需要使用两个指针: 队首指针 front 和队尾

指针 rear。用 front 指向队首（即表头）结点的存储位置，用 rear 指向队尾（即表尾）结点的存储位置。用于存储队列的单链表简称链接队列或链队。设链队中的结点类型仍为以前定义的单链表结点类型 SNode 或 LNode，那么队首和队尾指针为 LNode*指针类型。若把一个链队的队首指针和队尾指针定义在一个结构类型中，并设该结构类型用标识符 LinkQueue 表示，则具体定义如下:

struct LinkQueueLk {
    LNode* front; //队首指针
    LNode* rear;  //队尾指针
};

其中，LNode 结点类型在第 2 章已经给出，这里重写如下:

struct LNode {
    ElemType data; //值域
    LNode* next;   //链接指针域
};

一个链接存储的队列，如图 4-11 所示。

front
rear

图 4-11 链队的示意图

在类型为 LinkQueue 的链队 HQ 上进行队列的各种操作的算法如下。

1. 初始化链队

void InitQueue(LinkQueue& HQ)
{
    HQ.front=HQ.rear=NULL; //把队首和队尾指针置为空
}

2. 向链队中插入一个元素

void EnQueue(LinkQueue& HQ, ElemType item)
{
    LNode* newptr=new LNode; //得到一个新结点
    newptr->data=item;       //把 item 的值赋给新结点的值域
    newptr->next=NULL;       //把新结点的指针域置空
    if (HQ.rear==NULL)       //若链队为空，则新结点既是队首又是队尾
        HQ.front=HQ.rear=newptr;
    else                     //若链队非空，则新结点被链接到队尾并修改队尾指针
        HQ.rear=HQ.rear->next=newptr;
}

3. 从队列中删除一个元素

ElemType OutQueue (LinkQueue& HQ)
{
    if(HQ.front==NULL) { //若链队为空则中止运行
        cerr<<"链队为空,无法删除!"<<endl;
        exit(1);
    }
    ElemType temp=HQ.front->data; //暂存队首元素以便返回
    LNode* p=HQ.front; //暂存队首指针以便回收队首结点
    HQ.front=p->next; //使队首指针指向下一个结点
    if(HQ.front==NULL) //若删除后链队为空,则使队尾指针为空
        HQ.rear=NULL;
    delete p; //回收原队首结点
    return temp; //返回被删除的队首元素
}

4. 读取队首元素

ElemType PeekQueue (LinkQueue& HQ)
{
    if(HQ.front==NULL) { //若链队为空则中止执行
        cerr<<"链队为空无队首元素!"<<endl;
        exit(1);
    }
    return HQ.front->data; //返回队首元素
}

5. 检查链队是否为空

bool EmptyQueue(LinkQueue& HQ)
{
    //判断队首或队尾任一个指针是否为空即可
    return HQ.front==NULL;
}

6. 清除链队中的所有元素，使之变为空队

void ClearQueue(LinkQueue& HQ)
{
    LNode* p=HQ.front; //队首指针赋给p
    while(p!=NULL) {
        //依次删除队列中的每一个结点
        HQ.front=HQ.front->next;
        delete p;
        p=HQ.front;
    } //循环结束后队首指针已经变为空
    HQ.rear=NULL; //置队尾指针为空
}

除清除队列操作外，其余对链队操作的时间复杂度均为$O(1)$, 清除队列操作的时间复杂度为$O(n)$,$n$表示队列的长度。

可以用下面程序调试对链接队列进行各种运算的算法。

#include<iostream.h>
#include<stdlib.h>

typedef int ElemType;
struct LNode {
    ElemType data;          //值域
    LNode* next;            //链接指针域
};
struct LinkQueue {
    LNode* front;           //队首指针
    LNode* rear;            //队尾指针
};

#include"链接队列运算.cpp"

void main()
{
    LinkQueue q;
    InitQueue(q);
    int a[9]={3,8,5,17,9,30,15,22,20};
    int i;
    for(i=0; i<9; i++) EnQueue(q,a[i]);
    cout<<OutQueue(q)<<" ";
    cout<<OutQueue(q)<<" ";
    cout<<OutQueue(q)<<endl;
    EnQueue(q,68);
    for(i=0; i<9; i+=2) EnQueue(q,a[i]);
    cout<<PeekQueue(q)<<" ";
    cout<<OutQueue(q)<<endl;
    while(!EmptyQueue(q)) cout<<OutQueue(q)<<" ";
    cout<<endl;
    ClearQueue(q);
}

运行结果如下:

3 8 5
17 17
9 30 15 22 20 68 3 5 9 15 20

除了上面介绍的一般队列外，还有一种特殊的队列叫做优先级队列。这种队列中的每个元素都带有一个优先级号，用以表示其优先级别。在优先级队列中，优先级最高的元素

必须处在队首位置, 因此, 每次向它插入元素时, 都要按照一定次序调整元素位置, 确保把优先级最高的元素调整到队首, 每次从中删除队首元素 (即优先级最高的元素) 时, 也都要按照一定次序调整队列中的有关元素, 确保把优先级最高的元素调整到队首。优先级队列在操作系统中的各种调度算法中应用广泛, 它需要使用堆结构来实现, 这将在第6章中介绍。

*4.8 队列应用举例

队列在日常生活和计算机领域都有着广泛的应用, 下面以一个轮船渡口管理为例, 来说明队列的具体应用。

有一个渡口, 每条渡轮一次能装载 10 辆汽车过江, 过江车辆分为客车和货车两类, 上渡轮有如下规定:

(1) 同类汽车先到先上船。

(2) 客车先于货车上船。

(3) 每上 4 辆客车才允许上一辆货车, 但若等待的客车不足 4 辆则用货车填补, 反过来, 若没有货车等待则用客车填补。

(4) 装满 10 辆后则自动开船, 当等待时间较长时车辆不足 10 辆也应人为控制发船。

分析: 此题应建立和使用两个队列, 一个为客车队列, 另一个为货车队列, 到渡口需过江的汽车分别进入到相应队列中。当渡口有渡轮时先让客车队列中的 4 个车辆出队并开进渡轮, 再让货车队列中的一个车辆出队并开进渡轮, 若某一类车辆队列为空则从另一个队列中补充。当渡轮上的车辆已装满则自动开船, 此时应打印出已装车辆的每个车号。若装载不足 10 辆, 但两个车辆队列全为空, 应继续等待一段时间, 若等待时间较长, 仍不满载则应人为控制开船。根据分析可编写出如下程序。

#include<iostream.h>
#include<stdlib.h>
#include<time.h> //此头文件中含有 time 函数和 ctime 函数的声明

typedef int ElemType;
struct LNode {
    ElemType data;          //值域
    LNode* next;            //链接指针域
};
struct LinkQueue {
    LNode* front;           //队首指针
    LNode* rear;            //队尾指针
};

#include"链接队列运算.cpp"

//输出每次渡轮所载汽车的编号
void Print(int a[], int n)

{
    long t; t=time(0); //当前机器系统时间被保存到t中,单位为秒
    cout<<endl;
    cout<<"轮渡开始起航->"<<endl;
    cout<<"本次过江时间:"<<ctime(&t)<<endl;
            //ctime(&t)函数的值为根据参数t转换得到的日期和时间的字符串
    cout<<"本次轮渡所载汽车:";
    for(int i=0; i<n; i++) cout<<a[i]<<' ';
    cout<<endl;
}

//输出汽车排队等待情况
void OutputQueue(const LinkQueue& q1, const LinkQueue& q2)
{
    cout<<"客车排队的情况:";
    LNode* p=q1.front;
    if(p==NULL) cout<<"暂时无客车等候."<<endl;
    while(p!=NULL) {
        cout<<p->data<<' ';
        p=p->next;
    }
    cout<<endl;
    cout<<"货车排队的情况:";
    p=q2.front;
    if(p==NULL) cout<<"暂时无货车等候."<<endl;
    while(p!=NULL) {
        cout<<p->data<<' ';
        p=p->next;
    }
    cout<<endl;
}

void main()
{
    //q1和q2队列用来分别存储待渡江的客车和货车
    LinkQueue q1,q2;
    //对q1和q2进行初始化
    InitQueue(q1);
    InitQueue(q2);
    //用flag保存用户选择,用mark登记渡轮到渡口
    int flag,mark=0;
    //用数组a记录渡轮船上的每个汽车号,用n记录汽车的个数
    int a[10], n=0;
    //用t1和t2登记时间
    long t1,t2;
    //程序处理过程
}

do {
    //显示功能表并接受用户选择
    L1:cout<<"功能表："$<$endl;
    cout<<"$1$----车到渡口进行登记"$<$endl;
    cout<<"$2$----渡轮到渡口进行登记"$<$endl;
    cout<<"$3$----汽车上渡轮"$<$endl;
    cout<<"$4$----命令渡轮起航"$<$endl;
    cout<<"$5$----输出当前汽车排队情况"$<$endl;
    cout<<"$6$----结束程序运行"$<$endl$<$endl;
    cout<<"请输入你的选择$(1-6)$：";
    do {
        cin>>flag;
        if(flag$< 1 \mid \mid$flag$> 6$) cout<<"输入功能号错,重输：";
    } while(flag$< 1 \mid \mid$flag$> 6$);
    int x,i;
    //根据不同选择进行相应处理
    switch (flag) {
        case 1:
            cout<<"输入车辆号,假定小于$100$为客车,否则为货车,"$<$endl;
            cout<<"可以输入多辆车,用空格分开,直到输入$-1$为止."$<$endl;
            while(1) {
                cin>>x;
                if(x==$-1$) break;
                if(x$< 100$) EnQueue(q1,x); //客车进 q1 队
                else EnQueue(q2,x);          //货车进 q2 队
            }
            break;                           //结束 switch 语句
        case 2:
            if(mark==1) {
                cout<<"渡轮已在渡口等待,不要重复登记!"$<$endl;
                break;                       //结束 switch 语句
            }
            mark=1;                          //渡轮到口岸登记
            cout<<"渡轮已到渡口,可以上船!"$<$endl;
            n=0;                             //装载车辆数初始为$0$t1=time(0);                      //登记渡轮到渡口时间,单位为秒
            break;                           //结束 switch 语句
        case 3:
            if(EmptyQueue(q1)$\&\&$EmptyQueue(q2)) {
                cout<<"暂无汽车过江!"$<$endl;
                if(mark==1$\&\&$n!=0) {
                    t2=time(0)-t1;           //计算到目前为止渡轮等待时间的秒数
                    cout<<"轮渡未满,有车"$<$n$<$"辆,已等待"$<$t2/60$<$"分";
                    cout$<$t2%60$<$"秒,等候其他汽车上渡轮!"$<$endl;
                }
            }

break;  //结束 switch 语句
}
if(mark!=1) {
    cout<<"渡轮未到,请汽车稍后上渡轮!"<<endl;
    break;  //结束 switch 语句
}
do {
    i=0;
    //首先上4辆客车
    while(!EmptyQueue(q1) && n<10 && i<4) {
        a[n++]=OutQueue(q1);
        i++;
    }
    //满10辆开船,打印车辆号,重新对mark和n清0,转功能号表
    if(n==10) {Print(a,n); mark=0; n=0; goto L1;}
    //进4辆客车则接着进一辆货车,不满4辆则由货车补
    if(i==4) {
        if(!EmptyQueue(q2)) a[n++]=OutQueue(q2);
    }
    else {
        while(!EmptyQueue(q2) && n<10 && i<5) {
            a[n++]=OutQueue(q2);
            i++;
        }
    }
    //满10辆则开船
    if(n==10) {Print(a,n); mark=0; n=0; goto L1;}
} while(!EmptyQueue(q1) || !EmptyQueue(q2));
    //只要客车或货车队列不全为空,则继续执行do循环
t2=time(0)-t1;  //登记渡轮已经等待时间的秒数
cout<<"轮渡上有车"<<n<<"辆,已等待"<<t2/60<<"分"<<t2%60;
cout<<"秒,等候其他汽车上渡轮!"<<endl;
break;  //结束 switch 语句
case 4:
    if(n==0 || mark==0)
        cout<<"轮渡上无车过江或根本无渡轮!不需要起航!"<<endl;
    else {
        Print(a,n); mark=0; n=0;
    }
    break;  //结束 switch 语句
case 5:
    OutputQueue(q1,q2);
    break;  //结束 switch 语句
case 6:
    if(!EmptyQueue(q1) || !EmptyQueue(q2)) {

```cpp
cout<<"还有汽车未渡江,暂不能结束!"<<endl;
break;                      //结束 switch 语句
}
if(n!=0) {
    cout<<"渡轮上有车,不能结束,需命令开渡轮!"<<endl;
    break;                  //结束 switch 语句
}
cout<<"程序运行结束!"<<endl;
return;                     //执行结束返回
}                           //switch 语句终端位置
} while(1);                 //外层 do 循环终端位置
ClearQueue(q1);
ClearQueue(q2);
}                           //主函数结束位置

习 题 4

【习题 4-1】运算题。

1. 有 6 个元素 A、B、C、D、E、F 依次进栈，允许任何时候出栈，能否得到下列的每个出栈序列，若能，给出栈的操作过程，若不能，简述其理由。
(1) CDBEFA
(2) ABEDFC
(3) DCEABF
(4) BAEFCD

2. 有 4 个元素 a,b,c,d 依次进栈，任何时候都可以出栈，请写出所有可能的出栈序列和所有不存在的序列。

3. 用一维数组 a[7]顺序存储一个循环队列，队首和队尾指针分别用 front 和 rear 表示，当前队列中已有 5 个元素：23,45,67,80,34，其中，23 为队首元素，front 的值为 3，请画出对应的存储状态，当连续做 4 次出队运算后，再让 15,36,48 元素依次进队，请再次画出对应的存储状态。

4. 用于顺序存储一个队列的数组的长度为 N，队首和队尾指针分别为 front 和 rear，写出求此队列长度（即所含元素个数）的公式。

【习题 4-2】算法分析，写出每个算法的功能。

1. int AE(int a[], int n)
{
    if(n==0) return 0;
    else return a[n-1]+AE(a,n-1);
}

2. int AF(int k, int s)                       //第1次使用 AF(0,0)调用此算法
{
    if(s>=1000) return k-1;
    else {
        k++;
        s+=k*k;
        return AF(k,s);
    }
}
```

}
\n
3. void Transform(long num) //num 为正整数
{
    Stack a;
    InitStack(a);
    while(num!=0) {
        int k=num % 16;
        Push(a,k);
        num/=16;
    }
    while(!EmptyStack(a)) {
        int x=Pop(a);
        if(x<10) cout<<x;
        else {
            switch (x) {
                case 10: cout<'A'; break;
                case 11: cout<'B'; break;
                case 12: cout<'C'; break;
                case 13: cout<'D'; break;
                case 14: cout<'E'; break;
                case 15: cout<'F';
            }
        }
    }
    cout<<endl;
}
\n
4. void Fun1(Stack& s1, int n)
{
    srand(time(0)); //srand()函数在 stdlib.h 头文件中定义
    int i=0,j;
    while(i<n) {
        int x=rand()%100; //rand 函数在 stdlib.h 头文件中定义
        int y=int(sqrt(x)); //平方根函数 sqrt 在 math.h 头文件中定义
        for(j=2; j<=y; j++)
            if(x%j==0) break;
        if(j>y && x>10) {i++;Push(s1,x);}
    }
}
\n
5. void Fun2(Queue& q1, Queue& q2, int n)
{
    int i,x;
    cout<<"从键盘输入"<n<"个正整数:"<<endl;

for(i=0; i<n; i++) {
    cin>>x;
    if(x%2) EnQueue(q1,x);
    else EnQueue(q2,x);
}

*【习题 4-3】改写算法。

根据顺序栈的运算和表达式转换与求值的算法，做如下变化。
1. 给出下面顺序栈模板类定义中每个成员函数的类外定义。

template<class ElemType>
class Stack {
ElemType *stack;                      //存栈元素
int top;                              //存栈顶元素的下标位置
int MaxSize;                          //存 stack 数组长度, 即所能存储栈的最大长度
public:
    Stack();                          //构造函数
    Stack(Stack& s);                  //复制构造函数
    Stack& operator=(Stack& s);       //赋值重载函数
    void Push(ElemType item);         //元素进栈函数
    ElemType Pop();                   //元素出栈函数
    ElemType Peek();                  //读取栈顶元素函数
    bool EmptyStack();                //判栈空函数
    ~Stack();                         //析构函数
};

2. 给出后缀表达式求值的函数定义，其中使用的操作数栈由引用参数提供，该函数原型如下。
double Compute(Stack<double>& S, char* str);

3. 给出把中缀表达式转换为后缀表达式的函数定义，其中使用的运算符栈由引用参数提供，该函数原型如下。
void Change(Stack<char>& R, char* s1, char* s2);

4. 建立一个工程文件，其中包括 3 个文件。第 1 个为含有主函数的主程序文件，第 2 个为含有表达式转换与求值函数的次程序文件，第 3 个为含有模板栈类定义与实现的次程序文件。
【习题 4-4】算法设计。
1. 采用递归方法求$1 \sim n$之间的所有整数平方的和。
2. 采用递归方法把任一十进制正整数转换为$S$进制$(2 \leqslant S \leqslant 9)$数输出。
3. 采用辗转相除和递归的方法求出两个正整数的最大公约数。
4. 采用递归方法求两个正整数的最小公倍数。
5. 裴波那契（Fibonacci）数列的定义为：它的第 1 项和第 2 项分别为 0 和 1，以后各项为其前两项之和。若裴波那契数列中的第$n$项用$\operatorname{Fib}(n)$表示，则计算公式为：

$\operatorname{Fib}(n)=\left\{\begin{array}{cc} n-1 & (n=1 \text { 或 } 2) \\ \operatorname{Fib}(n-1)+\operatorname{Fib}(n-2) & (n>2) \end{array}\right.$试编写出计算$\operatorname{Fib}(n)$的递归算法和非递归算法, 分析每个算法的时间和空间复杂度。

6. 根据代数中的二项式定理, 二项式$(x+y)^{n}$的展开式的系数序列可以表示成三角形, 如图 4-12 所示,其中除每一行最左和最右两个系数等于 1 以外, 其余各系数均等于上一行左右两系数之和。这个系数三角形称作杨辉三角形。$(x+y)^{0}$(x+y)^{1}$(x+y)^{2}$(x+y)^{3}$(x+y)^{4}$(x+y)^{5}$(x+y)^{6}$(x+y)^{7}$(x+y)^{8}$图 4-12 杨辉三角形

设$C(n, k)$表示杨辉三角形中第$n$行$(n \geqslant 0)$的第$k$个系数$(0 \leqslant k \leqslant n)$, 按照二项式定理,$C(n, k)$可递归定义为:$C(n, k)=\left\{\begin{array}{cc} 1 & (k=0 \text { 或 } k=n) \\ C(n-1, k-1)+C(n-1, k) & (0<k<n) \end{array}\right.$(1) 写出计算$C(n, k)$的递归算法。

(2) 利用二维数组写出计算$C(n, k)$的非递归算法。

(3) 分析递归算法和非递归算法的时间复杂度和空间复杂度。

7. 在一个链队列中只设置队尾指针, 不设置队首指针, 并且让队尾结点的指针域指向队首结点 (称此为循环链队), 试分别写出在循环链队上进行插入和删除操作的算法。

8. 在一个数组空间 stack[StackMaxSize]中可以同时存放两个顺序栈, 栈底分别处在数组的两端, 当第 1 个栈的栈顶指针 top1 等于 -1 时则栈 1 为空, 当第 2 个栈的栈顶指针 top2 等于 MaxSize 时则栈 2 为空。两个栈均向中间增长, 当向栈 1 插入元素时, 使 top1 增 1 得到新的栈顶位置, 当向栈 2 插入元素时,则使 top2 减 1 才能够得到新的栈顶位置。当 top1 等于 top2-1 或者 top2 等于 top1+1 时, 存储空间用完,无法再向任一栈插入元素, 此时可考虑给出错误信息并停止运行。用于双栈操作的顺序存储类型可定义为:

struct BothStack {
    ElemType stack[MaxSize];
    int top1, top2;
};

双栈操作的抽象数据类型可定义为:

DAT BSTACK is
Data:
采用顺序结构存储的双栈,其存储类型为 BothStack

Operations:
//初始化栈。当k=1或2时对应置栈1或2为空,k=3时置两个栈均空
void InitStack(BothStack& BS, int k);
//清除栈。当k=1或2时对应栈1或2被清除,k=3时两个栈均被清除
void ClearStack(BothStack& BS, int k);
//判断栈是否为空。当k=1或2时判断对应的栈1或栈2是否为空,
//k=3时判断两个栈是否同时为空
bool StackEmpty(BothStack& BS, int k);
//取栈顶元素。当k=1或2时对应返回栈1或栈2的栈顶元素
ElemType Peek(BothStack& BS, int k);
//进栈。当k=1或2时对应向栈1或栈2的顶端压入元素item
void Push(BothStack& BS, int k, const ElemType& item);
//退栈。当k=1或2时,对应使栈1或栈2退栈并返回栈顶元素
ElemType Pop(BothStack& BS, int k);

End BSTACK

试写出上述抽象数据类型中每一种操作的算法。
9. 利用堆栈编写出求解迷宫问题的非递归算法。
10. 编写出解决汉诺塔问题的非递归算法。
11. 判断任意$n$个字符串能否首尾相接成为一个字符串。若一个字符串的尾字符等于另外一个字符串的首字符，则认为这两个字符串能够首尾相接形成一个字符串。


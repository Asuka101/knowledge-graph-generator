图9-5 采用链表法处理冲突的散列表

词结点，而且包含有非同义词结点，往往非同义词结点比同义词结点还要多。

对于一个具体的散列表来说，要求出在插入或查找过程中的平均查找长度很容易，在随机插入或在查找每个元素概率相等的情况下，它等于每个元素的查找长度（即比较次数）之和除以所有元素的个数。如在例9-3的散列表中，查找成功时平均查找长度为：$\text{ASL}=(8\times1+3\times2+1\times3)/12=17/12$若将例9-3中的线性表B采用线性探查法处理冲突进行散列存储，则得到的散列表为:

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
|---|---|---|---|---|---|---|---|---|---|----|----|----|
| 34 |   | 54 | 15 | 43 | 18 | 31 | 46 | 60 | 58 | 75 | 73 | 90 |

查找成功时的平均查找长度为:$\text{ASL}=(7\times1+2\times2+2\times4+1\times6)/12=25/12$其中，18,75,60,43,54,90,46等7个元素无存储冲突；31和15两个元素各有一次存储冲突，即各自的查找长度为2，58和73的查找长度均为4，34的查找长度为6。

由以上分析可知，开放定址法处理冲突的平均查找长度要高于链接法处理冲突的平均查找长度，但它们都比以前所有查找方法的平均查找长度要短。这里虽然是对具体的散列表进行的分析，但其分析结果具有普遍意义。

\section*{9.4.4 散列表的运算}

在数据的散列存储中，处理冲突的方法不同，其散列表的类型定义也不同，设使用HashMaxSize常量表示待定义的散列表类型的长度，它要大于等于实际使用的散列表的长度m，下面分别给出与采用开放定址法和链接法对应的散列表的类型定义。

若采用开放定址法，其顺序存储的散列表的类型用ArrayHashList表示，该类型定义为:

typedef ElemType ArrayHashList[HashMaxSize];

若采用链接法，其链接存储的散列表的类型用LinkHashList表示，则类型定义为:

typedef LNode* LinkHashList[HashMaxSize];

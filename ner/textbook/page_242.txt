此算法的运行时间主要取决于 while 循环的执行次数，它等于新元素向双亲位置逐层上移的次数，此次数最多等于整个树的深度减 1，所以算法的时间复杂度为$O(\log n)$，其中$n$表示堆的大小。

5. 从堆中删除元素

从堆中删除元素就是删除堆顶元素并使之返回。堆顶元素被删除后，留下的堆顶位置应由堆尾元素来填补，这样既保持了顺序存储结构又不需要移动其他任何元素。把堆尾元素素移动到堆顶位置后，它可能不小于左、右孩子结点，使整个二叉树不为堆，所以需要一个调整过程，使之变为含有$n-1$个元素的堆（删除前为$n$个元素）。调整过程首先从树根结点开始，若树根结点的值大于两个孩子结点中的最小值，就将它与具有最小值的孩子结点互换位置，使得根结点的值小于两个孩子结点的值；原树根结点被对调到一个孩子位置后，可能使以该位置为根的子树又不为堆，因而又需要使新元素向孩子一层调整，如此调整下去，直到以调整后的位置为根的子树成为一个堆或调整到叶子结点为止。

对于图 6-4(a)所示的堆，当从中删除顶点元素 18 时，需要把堆尾元素 60 写入到堆顶位置成为堆顶元素，由于 60 大于两个孩子中的最小值 26，所以应互换 60 和 26 的位置，60 被移到新位置后，又大于两个孩子中的最小值 48，所以接着同 48 互换位置，此时 60 已被调整到叶子结点，所以调整完成后得到的完全二叉树又成为一个堆，如图 6-7 所示。
![image](attachment://figure_6_7.png)
图 6-7 堆的删除

若图 6-4(a)所示堆的顶元素不是 60 而是 45，则进行删除操作时把 45 写入到堆顶位置后，因 45 大于两个孩子中的最小值 26，所以需把它对调到左孩子 26 的位置，此时它小于两个孩子中的最小值 48，表明以 45 所在的新位置为根的子树已经成为一个堆，至此调整结束。

从堆中删除元素的算法描述如下。

```
ElemType DeleteHeap(Heap& HBT)    //从小根堆 HBT 中删除堆顶元素并返回
{
    if(HBT.len==0) {              //若为空堆，则显示出错误信息并退出运行
        cerr<<"堆为空，退出运行!"<<endl;
        exit(1);
    }
    ElemType temp=HBT.heap[0];    //将堆顶元素暂存 temp 以便返回
    HBT.len--;                    //堆的长度减 1
    if(HBT.len==0) return temp;   //若删除操作后变为空堆则返回
    ElemType x=HBT.heap[HBT.len]; //将待调整的堆尾元素暂存 x 中
    int i=0;                      //用 i 指向待调整元素的位置，初始指向堆顶位置
    int j=1;                      //用 j 指向 i 的左孩子位置，初始指向下标 1 的位置
    while(j<=HBT.len-1) {         //寻找待调整元素的最终位置
        //若右孩子存在并且较小，应使 j 指向右孩子
        if(j<HBT.len-1 && HBT.heap[j]>HBT.heap[j+1]) j++;
```

(a) 四棵树
(b) 三棵树

(c) 两棵树
(d) 一棵树

图 6-9 构造哈夫曼的过程

在构造哈夫曼树的过程中, 当每次由两棵权值最小的树生成一棵新树时, 新树的左子树和右子树可以任意安排, 这样将会得到具有不同结构的多个哈夫曼树, 但它们都具有相同的带权路径长度。为了使得到的哈夫曼树的结构尽量唯一, 通常规定生成的哈夫曼树中每个结点的左子树根结点的权小于等于右子树根结点的权。上述哈夫曼树的构造过程就是依照这一规定进行的。

根据上述构造哈夫曼树的方法可以写出相应的用 C++语言描述的算法如下。

BTreeNode* CreateHuffman(ElemType a[], int n)
    //根据数组 a 中 n 个权值建立一棵哈夫曼树, 返回树根指针
{
    BTreeNode** b,*q;
    //动态分配一个由 b 指向的指针数组
    b=new BTreeNode*[n];
    int i,j;
    //初始化 b 指针数组, 使每个指针元素指向 a 数组中对应元素的结点
    for(i=0; i<n; i++) {
        b[i]=new BTreeNode;
        b[i]->data=a[i]; b[i]->left=b[i]->right=NULL;
    }
    //进行 n-1 次循环建立哈夫曼树
    for(i=1; i<n; i++) {
        //用 k1 表示森林中具有最小权值的树根结点的下标
        //用 k2 表示森林中具有次最小权值的树根结点的下标
        int k1=-1,k2;
        //让 k1 初始指向森林中第一棵树, k2 初始指向森林中第二棵树
        for(j=0; j<n; j++) {
            if(b[j]!=NULL & k1==-1) {k1=j;continue;}
            if(b[j]!=NULL) {k2=j;break;}
        }

的剩余关键字和指针连同双亲结点中指向该结点指针的左边（或右边）一个关键字一起合并到左兄弟（或右兄弟）结点中，然后回收（即删除）该结点。

如从图 9-8 (b) 所示的 3 阶 B_树中删除关键字 46 后，该结点（即被删除关键字为 46 的结点）中剩余的关键字个数为 0，低于规定的下限 1，但它的左兄弟和右兄弟中的关键字个数都只有一个（即为最低限），所以只能将该结点中剩余的关键字（在此没有）和指针（在此为空）连同双亲结点中的关键字 24 一起合并到左兄弟结点中，然后将包含被删除关键字 46 的结点回收掉，删除 46 后得到的 B_树，如图 9-8 (c) 所示。

(a) 删除举例 1
(b) 删除举例 2
(c) 删除举例 3

图 9-8 B_树的删除

当从一棵 B_树的叶子结点中删除一个关键字后，可能出现上面所述的第 3 种情况，此时需要合并结点，在合并结点的同时，实际上又从它们的双亲结点中删除（即因合并而被下移）了一个关键字，而双亲结点被删除一个关键字（实际为所在的索引项）后，同从叶子结点中删除一个关键字一样，又可分为上面所述的 3 种情况处理，当属于第 3 种情况时，又需要进行合并，以此类推。在最坏的情况下，这种从叶子结点开始的合并要一直传递到树根结点，使只包含有一个关键字的根结点同它的两个孩子结点合并，形成以一个孩子结点为根结点的 B_树，从而使整个 B_树的高度减少 1，这也是 B_树减少其高度的唯一途径。

如图 9-9 (a) 所示是一棵 5 阶的 B_树，则树中每个结点（除树根结点外）的关键字个数应最少为 2，最多为 4。当从该树中删除关键字 26 时，因它不在叶子结点上，所以应首先把它与中序前驱关键字 20 对调位置，然后再从对应的叶子结点 e 中删除之，删除 26 后得到的中间结果如图 9-9 (b) 所示；e 结点被删除一个关键字后只剩下一个关键字，低于下限值 2，它的左、右兄弟结点中正好只有最低的关键字个数 2，所以必须把该结点中的一个关键字 15 和左、右两个空指针同 b 结点中的关键字 12（或 20）一起合并到 d 结点中（或 f 结点中），得到的中间结果如图 9-9 (c) 所示（e 结点已被回收）；b 结点被删除一个关键字 12 后只剩下一个关键字 20，同时它的右兄弟（没有左兄弟）结点中只有两个关键字，所以又得继续合并，即把 b 结点中的一个关键字和两个指针同根结点 a 的一个关键字一起合并到 c 结点中，使 c 结点成为新的树根结点，导致整个 B_树减少一层，最后得到的结果如图 9-9 (d) 所示，其中 b 结点和 a 结点都已回收。

B_树的删除算法比插入算法更复杂，在删除时，首先要查找出待删除的关键字 K 所在的位置，若它不在叶子结点上，则把它同其中序前驱或后继关键字对调位置，接着按照顺序表的删除方法从对应的叶子结点中删除其关键字 K 所在的索引项，然后再进行删除后的循环处理，直到不需要合并结点为止。关于 B_树的删除算法这里不具体给出，有兴趣者可参考本人编著的、清华大学出版社出版的《数据结构课程实验》一书。

若一棵 B_树的高度为$h$，B_树的阶数为$m$，则 B_树查找、插入和删除算法的时间复杂度均相同，大致为$O(h \times m)$。

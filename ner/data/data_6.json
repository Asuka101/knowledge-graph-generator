{
  "entities": [
    {
      "type": "数据结构",
      "ID": "06DS001",
      "name": "二叉搜索树",
      "attributes": {
        "难度": "中等",
        "内容": "又称二叉排序树。或为空树，或为非空二叉树，满足：若左子树非空，则左子树所有关键字小于根；若右子树非空，则右子树所有关键字大于(或大于等于)根；左右子树本身也是二叉搜索树。特性：中序遍历结果为有序序列。适用场景：需要高效查找、插入、删除的动态集合。",
        "存储开销": "链式存储"
      }
    },
    {
      "type": "概念",
      "ID": "06CON001",
      "name": "关键字",
      "attributes": {
        "难度": "入门",
        "内容": "结点中用于比较和排序的值。可以是结点本身的值（简单类型），也可以是结点记录中的某个域（记录类型）。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON002",
      "name": "中序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树的一种遍历方式（左子树-根结点-右子树）。对二叉搜索树进行中序遍历，得到的结点序列必然是有序的。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON003",
      "name": "抽象数据类型",
      "attributes": {
        "难度": "入门",
        "内容": "定义数据对象、数据对象上关系的集合以及数据对象的基本操作集。例如二叉搜索树ADT定义了数据（BST）和操作（查找、更新、插入、删除）。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP001",
      "name": "查找 (BST)",
      "attributes": {
        "难度": "入门",
        "内容": "从二叉搜索树中查找等于给定值的元素。步骤：若树空，失败；若根等于目标，成功；若目标小于根，递归查左子树；若目标大于根，递归查右子树。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP002",
      "name": "更新 (BST)",
      "attributes": {
        "难度": "入门",
        "内容": "从二叉搜索树中查找等于给定值的元素，若查找成功则用新值更新该元素。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP003",
      "name": "插入 (BST)",
      "attributes": {
        "难度": "入门",
        "内容": "向二叉搜索树中插入一个新元素，使得插入后仍保持二叉搜索树的性质。步骤：查找插入位置（查找失败的路径终点），链接新结点。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP004",
      "name": "删除 (BST)",
      "attributes": {
        "难度": "中等",
        "内容": "从二叉搜索树中删除等于给定值的结点，并保持二叉搜索树的性质。需分情况处理：删除叶子结点、删除单分支结点、删除双分支结点（通常用中序前驱或后继替换）。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG001",
      "name": "BST查找-递归",
      "attributes": {
        "难度": "入门",
        "内容": "原理：基于二叉搜索树定义，递归地在根、左子树或右子树中查找目标值。",
        "时间复杂度": "平均 O(log n), 最坏 O(n)",
        "空间复杂度": "平均 O(log n), 最坏 O(n)"
      }
    },
    {
      "type": "概念",
      "ID": "06CON004",
      "name": "递归",
      "attributes": {
        "难度": "入门",
        "内容": "一个函数在其定义中直接或间接调用自身的过程。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON005",
      "name": "末尾递归",
      "attributes": {
        "难度": "中等",
        "内容": "递归调用是函数体中最后一条可执行语句。可以被优化，避免栈空间积累。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON006",
      "name": "数据堆栈",
      "attributes": {
        "难度": "入门",
        "内容": "程序运行时用于存储函数调用信息（如返回地址、局部变量、参数）的内存区域，递归调用会使用。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG002",
      "name": "BST查找-非递归",
      "attributes": {
        "难度": "入门",
        "内容": "原理：使用循环代替递归，维护一个指向当前比较结点的指针，根据比较结果移动指针。",
        "时间复杂度": "平均 O(log n), 最坏 O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "概念",
      "ID": "06CON007",
      "name": "时间复杂度",
      "attributes": {
        "难度": "入门",
        "内容": "衡量算法执行时间随输入规模增长的量度，通常用大O表示法表示渐进时间复杂度。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON008",
      "name": "空间复杂度",
      "attributes": {
        "难度": "入门",
        "内容": "衡量算法执行过程中所需额外存储空间随输入规模增长的量度。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON009",
      "name": "O记号",
      "attributes": {
        "难度": "入门",
        "内容": "（大O表示法）描述函数渐进上界的数学符号，用于分析算法复杂度，如O(1), O(log n), O(n), O(n log n)。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON010",
      "name": "理想平衡树",
      "attributes": {
        "难度": "中等",
        "内容": "高度尽可能小的二叉树，对于n个结点的树，高度接近log n，查找效率最高。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON011",
      "name": "单支树",
      "attributes": {
        "难度": "入门",
        "内容": "所有结点只有左子树或只有右子树的退化二叉树，形态类似链表，查找等操作效率降为O(n)。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG003",
      "name": "BST插入-递归",
      "attributes": {
        "难度": "入门",
        "内容": "原理：递归查找插入位置，若找到空链接则创建新结点插入；否则根据比较结果递归进入左子树或右子树。",
        "时间复杂度": "平均 O(log n), 最坏 O(n)",
        "空间复杂度": "平均 O(log n), 最坏 O(n)"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG004",
      "name": "BST插入-非递归",
      "attributes": {
        "难度": "入门",
        "内容": "原理：使用循环查找插入位置，需要记录父结点指针。找到合适的空链接后，链接新结点。",
        "时间复杂度": "平均 O(log n), 最坏 O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG005",
      "name": "CreateBSTree",
      "attributes": {
        "难度": "入门",
        "内容": "原理：从一个空的二叉搜索树开始，依次将数组中的n个元素通过调用插入算法添加到树中。",
        "时间复杂度": "一般 O(n log n)",
        "空间复杂度": "O(n) (树本身) + 插入算法空间"
      }
    },
    {
      "type": "概念",
      "ID": "06CON012",
      "name": "中序前驱",
      "attributes": {
        "难度": "入门",
        "内容": "在二叉树的中序遍历序列中，位于一个结点之前的那个结点。在BST删除双分支结点时，可用来替换被删结点。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG006",
      "name": "BST删除-递归",
      "attributes": {
        "难度": "中等",
        "内容": "原理：递归查找待删除结点。找到后分情况处理：(1)叶子结点：直接删除。(2)单分支结点：用其孩子替换。(3)双分支结点：用其中序前驱(左子树最右结点)或中序后继(右子树最左结点)的值替换，然后递归删除那个前驱/后继结点。",
        "时间复杂度": "平均 O(log n), 最坏 O(n)",
        "空间复杂度": "平均 O(log n), 最坏 O(n)"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS002",
      "name": "堆",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的完全二叉树。分为小根堆（父结点值 <= 子结点值）和大根堆（父结点值 >= 子结点值）。特性：堆顶元素是最小（小根堆）或最大（大根堆）元素。适用场景：优先级队列实现、堆排序。",
        "存储开销": "顺序存储 (通常使用数组)"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS003",
      "name": "完全二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "一棵深度为k、有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为完全二叉树。特点是结点按层序编号后是连续的，适合顺序存储。",
        "存储开销": "顺序存储或链式存储"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS004",
      "name": "小根堆",
      "attributes": {
        "难度": "中等",
        "内容": "堆的一种。它是一棵完全二叉树，且满足：对于树中任意结点，其值小于或等于其左右孩子结点的值。根结点的值是整个堆中的最小值。",
        "存储开销": "顺序存储"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS005",
      "name": "大根堆",
      "attributes": {
        "难度": "中等",
        "内容": "堆的一种。它是一棵完全二叉树，且满足：对于树中任意结点，其值大于或等于其左右孩子结点的值。根结点的值是整个堆中的最大值。",
        "存储开销": "顺序存储"
      }
    },
    {
      "type": "概念",
      "ID": "06CON013",
      "name": "优先级队列",
      "attributes": {
        "难度": "中等",
        "内容": "一种抽象数据类型，允许插入元素，并能从中取出具有最高（或最低）优先级的元素。堆是实现优先级队列的常用数据结构。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP005",
      "name": "初始化堆",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空堆。对于顺序存储的堆，通常涉及分配数组空间并将堆的当前大小置为0。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP006",
      "name": "清除堆",
      "attributes": {
        "难度": "入门",
        "内容": "释放堆所占用的存储空间，使其恢复到初始空状态。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP007",
      "name": "判断堆是否为空",
      "attributes": {
        "难度": "入门",
        "内容": "检查堆中当前包含的元素数量是否为0。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP008",
      "name": "插入 (Heap)",
      "attributes": {
        "难度": "中等",
        "内容": "向堆中添加一个新元素，并调整堆结构以维持堆属性。步骤：将新元素添加到堆底（数组末尾），然后执行向上调整（上滤）操作。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP009",
      "name": "删除 (Heap)",
      "attributes": {
        "难度": "中等",
        "内容": "从堆中移除并返回具有最高（大根堆）或最低（小根堆）优先级的元素（即堆顶元素），并调整堆结构以维持堆属性。步骤：保存堆顶元素，将堆底元素移至堆顶，然后执行向下调整（下滤）操作。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG007",
      "name": "堆插入调整算法",
      "attributes": {
        "难度": "中等",
        "内容": "（上滤）原理：新插入的元素（位于堆底）与其父结点比较，若违反堆序（如小根堆中子<父），则交换位置，并继续与新的父结点比较，直至满足堆序或到达堆顶。",
        "时间复杂度": "O(log n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG008",
      "name": "堆删除调整算法",
      "attributes": {
        "难度": "中等",
        "内容": "（下滤）原理：将移至堆顶的元素与其子结点比较，若违反堆序（如小根堆中父>子），则与较小（小根堆）或较大（大根堆）的孩子交换位置，并继续与新的子结点比较，直至满足堆序或到达叶子结点。",
        "时间复杂度": "O(log n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "概念",
      "ID": "06CON014",
      "name": "路径",
      "attributes": {
        "难度": "入门",
        "内容": "树中从一个结点到另一个结点的唯一结点序列 k1, k2, ..., kj，其中 ki 是 ki+1 的双亲。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON015",
      "name": "路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "树中两个结点之间路径上的分支（边）的数量，等于路径上的结点数减 1。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON016",
      "name": "结点的权",
      "attributes": {
        "难度": "入门",
        "内容": "赋予树中结点的一个具有特定意义的数值（通常是实数）。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON017",
      "name": "带权路径长度 (结点)",
      "attributes": {
        "难度": "入门",
        "内容": "从树根结点到该结点之间的路径长度与该结点上的权的乘积。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON018",
      "name": "树的带权路径长度 (WPL)",
      "attributes": {
        "难度": "中等",
        "内容": "树中所有叶子结点的带权路径长度之和，记为 WPL = Σ(wi * li)，其中 wi 是叶结点的权，li 是根到该叶结点的路径长度。"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS006",
      "name": "哈夫曼树",
      "attributes": {
        "难度": "中等",
        "内容": "又称最优二叉树。对于n个带权叶子结点，它是构成的所有二叉树中带权路径长度（WPL）最小的二叉树。特性：权值越大的叶结点离根越近；树中只有度为0（叶子）和度为2的结点。适用场景：哈夫曼编码（数据压缩）。",
        "存储开销": "链式存储"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG009",
      "name": "构造哈夫曼树算法",
      "attributes": {
        "难度": "中等",
        "内容": "原理：(1)初始化n棵只有一个带权根结点的树构成森林。(2)循环n-1次：从森林中选取权值最小的两棵树，合并成一棵新树（根权值为子树根权值之和），新树的左右子树为选出的两棵树。(3)从森林删除选出的两棵树，加入新树。(4)最终森林只剩一棵树即为哈夫曼树。",
        "时间复杂度": "O(n log n) (使用优先队列优化选择过程)",
        "空间复杂度": "O(n)"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG010",
      "name": "WeightPathLength算法",
      "attributes": {
        "难度": "中等",
        "内容": "原理：递归计算哈夫曼树的WPL。函数接收树根指针和当前深度len。若为空树返回0；若为叶子结点返回权值*len；否则递归计算左右子树的WPL并求和（传递len+1）。",
        "时间复杂度": "O(N) (N为总结点数)",
        "空间复杂度": "O(H) (H为树高)"
      }
    },
    {
      "type": "概念",
      "ID": "06CON019",
      "name": "哈夫曼编码",
      "attributes": {
        "难度": "中等",
        "内容": "利用哈夫曼树生成的一种最优前缀编码。将字符按出现频率赋予权值构造哈夫曼树，从根到各叶子结点的路径（左0右1）即为对应字符的编码。频率高的字符编码短，频率低的编码长，可用于数据压缩。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON020",
      "name": "等长编码",
      "attributes": {
        "难度": "入门",
        "内容": "为字符集中的每个字符分配相同长度的二进制码字的编码方式。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON021",
      "name": "不等长编码",
      "attributes": {
        "难度": "入门",
        "内容": "为字符集中的不同字符分配不同长度的二进制码字的编码方式。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON022",
      "name": "无前缀编码",
      "attributes": {
        "难度": "中等",
        "内容": "一种编码方案，其中没有任何码字是另一个码字的前缀。这保证了编码序列可以被唯一地、无歧义地解码。哈夫曼编码是一种无前缀编码。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG011",
      "name": "HuffManCoding算法",
      "attributes": {
        "难度": "中等",
        "内容": "原理：递归遍历哈夫曼树，使用一个数组记录从根到当前结点的路径编码（左分支记0，右分支记1）。当访问到叶子结点时，输出该叶子结点的权值和记录的路径编码。",
        "时间复杂度": "O(N) (N为总结点数)",
        "空间复杂度": "O(H) (H为树高)"
      }
    },
    {
      "type": "概念",
      "ID": "06CON023",
      "name": "前驱",
      "attributes": {
        "难度": "入门",
        "内容": "在线性序列（如遍历序列）中，位于某元素之前的那个元素。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON024",
      "name": "后继",
      "attributes": {
        "难度": "入门",
        "内容": "在线性序列（如遍历序列）中，位于某元素之后的那个元素。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON025",
      "name": "中序后继",
      "attributes": {
        "难度": "入门",
        "内容": "在二叉树的中序遍历序列中，位于一个结点之后的那个结点。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON026",
      "name": "线索",
      "attributes": {
        "难度": "中等",
        "内容": "利用二叉链表中空的指针域（原本指向NULL的left或right指针）存放指向结点在某种遍历次序下的前驱或后继结点的指针。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON027",
      "name": "左线索",
      "attributes": {
        "难度": "中等",
        "内容": "存放在结点空左指针域中，指向其（某种遍历次序下）前驱结点的线索。也称前驱线索。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON028",
      "name": "右线索",
      "attributes": {
        "难度": "中等",
        "内容": "存放在结点空右指针域中，指向其（某种遍历次序下）后继结点的线索。也称后继线索。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP010",
      "name": "线索化",
      "attributes": {
        "难度": "中等",
        "内容": "按照某种遍历次序（如先序、中序、后序），将二叉树中所有结点的空指针域改为指向其前驱或后继结点的线索的过程。"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS007",
      "name": "线索二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "将二叉树经过线索化处理后得到的二叉树。结点结构通常增加标志域以区分指针是指向孩子还是线索。优点是可以在不使用栈的情况下进行相应次序的遍历。",
        "存储开销": "链式存储 (结点增加标志域)"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS008",
      "name": "中序线索二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "进行了中序线索化的二叉树。空左指针指向中序前驱，空右指针指向中序后继。",
        "存储开销": "链式存储 (结点增加标志域)"
      }
    },
    {
      "type": "概念",
      "ID": "06CON029",
      "name": "线索标志域",
      "attributes": {
        "难度": "入门",
        "内容": "在线索二叉树的结点结构中增加的标志位（如 ltag, rtag），用于区分对应的指针域（left, right）存放的是指向孩子结点的指针还是指向前驱/后继结点的线索。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP011",
      "name": "中序线索化",
      "attributes": {
        "难度": "中等",
        "内容": "对二叉树进行中序遍历，在遍历过程中修改结点的空指针域，使其指向相应的中序前驱或中序后继。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG012",
      "name": "InThread算法",
      "attributes": {
        "难度": "中等",
        "内容": "原理：在中序遍历递归框架内实现中序线索化。维护一个指向前驱结点的全局或引用指针pre。访问当前结点时，检查pre的右指针是否为空（rtag=true），若是则令其指向当前结点；检查当前结点的左指针是否为空，若是则令其指向pre并设ltag=true；检查当前结点的右指针是否为空，若是则设rtag=true；最后更新pre为当前结点。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(H) (递归栈)"
      }
    },
    {
      "type": "操作",
      "ID": "06OP012",
      "name": "前序线索化",
      "attributes": {
        "难度": "中等",
        "内容": "对二叉树进行前序遍历，在遍历过程中修改结点的空指针域，使其指向相应的前序前驱或前序后继。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP013",
      "name": "后序线索化",
      "attributes": {
        "难度": "中等",
        "内容": "对二叉树进行后序遍历，在遍历过程中修改结点的空指针域，使其指向相应的后序前驱或后序后继。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG013",
      "name": "InsertThreed算法",
      "attributes": {
        "难度": "入门",
        "内容": "原理：向带线索标志域的二叉搜索树中插入元素，但只建立父子关系，不创建或更新线索链接，插入的新结点线索标志域默认为假（指向孩子，即使孩子为空）。",
        "时间复杂度": "未知",
        "空间复杂度": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG014",
      "name": "CreateThreed算法",
      "attributes": {
        "难度": "入门",
        "内容": "原理：初始化空树，然后循环调用InsertThreed算法，将数组中的n个元素依次插入，建立一个带线索标志域但未线索化的二叉搜索树。",
        "时间复杂度": "未知",
        "空间复杂度": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG015",
      "name": "InsertThreed1算法",
      "attributes": {
        "难度": "中等",
        "内容": "原理：向已线索化的二叉搜索树中插入新元素，并同时维护和更新线索。查找插入位置时需考虑线索标志。插入新结点（作为叶子）后，需正确设置其左右线索指向其前驱和后继，并修改其父结点的相应指针和标志域。",
        "时间复杂度": "未知",
        "空间复杂度": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG016",
      "name": "CreateThread1算法",
      "attributes": {
        "难度": "中等",
        "内容": "原理：初始化空树，然后循环调用InsertThreed1算法，将数组中的n个元素依次插入，建立一个完全线索化的二叉搜索树。",
        "时间复杂度": "未知",
        "空间复杂度": "未知"
      }
    },
    {
      "type": "操作",
      "ID": "06OP014",
      "name": "查找中序后继",
      "attributes": {
        "难度": "入门",
        "内容": "在中序线索二叉树中查找给定结点p的中序后继。步骤：(1)若p的右线索标志为真(rtag=true)，则p的右指针直接指向后继。(2)若p的右线索标志为假(rtag=false)，则其后继是其右子树中第一个被中序遍历到的结点（即右子树的最左下结点）。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG017",
      "name": "ThInorder算法",
      "attributes": {
        "难度": "中等",
        "内容": "原理：利用中序线索进行非递归的中序遍历。(1)找到整棵树中序遍历的第一个结点（沿根的左指针链一直向下直到ltag=true）。(2)循环：访问当前结点；利用查找中序后继操作找到下一个结点，直到后继为空。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS009",
      "name": "平衡二叉树",
      "attributes": {
        "难度": "高级",
        "内容": "简称平衡树，通常指AVL树。是一种自平衡的二叉搜索树。要求树中任何结点的左、右子树的高度差的绝对值不超过1（即平衡因子为-1, 0, 1）。插入和删除操作可能破坏平衡，需要通过旋转操作（LL, RR, LR, RL）来恢复平衡。优点：查找、插入、删除的平均和最坏时间复杂度都是O(log n)。缺点：插入删除操作相对复杂。",
        "存储开销": "链式存储 (结点通常需存储平衡因子或高度)"
      }
    },
    {
      "type": "概念",
      "ID": "06CON030",
      "name": "平衡因子",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树中结点的左子树高度减去其右子树高度的值。在平衡二叉树（AVL树）中，每个结点的平衡因子只能是-1、0或1。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON031",
      "name": "最小不平衡子树",
      "attributes": {
        "难度": "中等",
        "内容": "在向（或从）平衡二叉树插入（或删除）结点后，以离插入（或删除）位置最近的那个平衡因子绝对值大于1的结点作为根的子树。平衡调整操作通常针对最小不平衡子树进行。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP015",
      "name": "LL型调整",
      "attributes": {
        "难度": "高级",
        "内容": "平衡二叉树的一种旋转操作。当因在结点A的左孩子B的左子树上插入新结点，导致A的平衡因子变为2时进行。执行一次右旋转：将B提升为子树的新根，A成为B的右孩子，B原来的右子树成为A的左子树。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP016",
      "name": "RR型调整",
      "attributes": {
        "难度": "高级",
        "内容": "平衡二叉树的一种旋转操作。当因在结点A的右孩子B的右子树上插入新结点，导致A的平衡因子变为-2时进行。执行一次左旋转：将B提升为子树的新根，A成为B的左孩子，B原来的左子树成为A的右子树。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP017",
      "name": "LR型调整",
      "attributes": {
        "难度": "高级",
        "内容": "平衡二叉树的一种旋转操作。当因在结点A的左孩子B的右子树C上插入新结点，导致A的平衡因子变为2时进行。执行先左后右两次旋转：先对B进行一次左旋转（RR型），再对A进行一次右旋转（LL型）。"
      }
    },
    {
      "type": "操作",
      "ID": "06OP018",
      "name": "RL型调整",
      "attributes": {
        "难度": "高级",
        "内容": "平衡二叉树的一种旋转操作。当因在结点A的右孩子B的左子树C上插入新结点，导致A的平衡因子变为-2时进行。执行先右后左两次旋转：先对B进行一次右旋转（LL型），再对A进行一次左旋转（RR型）。"
      }
    }
  ],
  "relations": [
    {
      "type": "depends-on",
      "关系ID": "06REL001",
      "source": "06DS001",
      "target": "06CON001",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL002",
      "source": "06DS001",
      "target": "06CON002",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL003",
      "source": "06OP001",
      "target": "06DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL004",
      "source": "06OP002",
      "target": "06DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL005",
      "source": "06OP003",
      "target": "06DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL006",
      "source": "06OP004",
      "target": "06DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL007",
      "source": "06ALG001",
      "target": "06CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL008",
      "source": "06ALG001",
      "target": "06CON005",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL009",
      "source": "06ALG001",
      "target": "06CON006",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "optimizes",
      "关系ID": "06REL010",
      "source": "06ALG002",
      "target": "06ALG001",
      "attributes": {
        "优化方向": "空间复杂度"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL011",
      "source": "06ALG001",
      "target": "06CON007",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL012",
      "source": "06ALG001",
      "target": "06CON008",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL013",
      "source": "06ALG002",
      "target": "06CON007",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL014",
      "source": "06ALG002",
      "target": "06CON008",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL015",
      "source": "06DS001",
      "target": "06CON010",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL016",
      "source": "06DS001",
      "target": "06CON011",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL017",
      "source": "06ALG003",
      "target": "06CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL018",
      "source": "06ALG003",
      "target": "06CON005",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "optimizes",
      "关系ID": "06REL019",
      "source": "06ALG004",
      "target": "06ALG003",
      "attributes": {
        "优化方向": "空间复杂度"
      }
    },
    {
      "type": "uses",
      "关系ID": "06REL020",
      "source": "06ALG005",
      "target": "06ALG003",
      "attributes": {
        "使用角色": "核心步骤"
      }
    },
    {
      "type": "uses",
      "关系ID": "06REL021",
      "source": "06ALG005",
      "target": "06DS001",
      "attributes": {
        "使用角色": "创建实例"
      }
    },
    {
      "type": "uses",
      "关系ID": "06REL022",
      "source": "06ALG006",
      "target": "06CON012",
      "attributes": {
        "使用角色": "双分支处理"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL023",
      "source": "06ALG006",
      "target": "06CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "is-a",
      "关系ID": "06REL024",
      "source": "06DS002",
      "target": "06DS003",
      "attributes": {
        "父类 ID": "06DS003",
        "子类 ID": "06DS002",
        "约束条件": "满足堆序性"
      }
    },
    {
      "type": "is-a",
      "关系ID": "06REL025",
      "source": "06DS004",
      "target": "06DS002",
      "attributes": {
        "父类 ID": "06DS002",
        "子类 ID": "06DS004",
        "约束条件": "父结点值 <= 子结点值"
      }
    },
    {
      "type": "is-a",
      "关系ID": "06REL026",
      "source": "06DS005",
      "target": "06DS002",
      "attributes": {
        "父类 ID": "06DS002",
        "子类 ID": "06DS005",
        "约束条件": "父结点值 >= 子结点值"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL027",
      "source": "06DS002",
      "target": "06CON013",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL028",
      "source": "06OP005",
      "target": "06DS002",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL029",
      "source": "06OP006",
      "target": "06DS002",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL030",
      "source": "06OP007",
      "target": "06DS002",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL031",
      "source": "06OP008",
      "target": "06DS002",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL032",
      "source": "06OP009",
      "target": "06DS002",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "uses",
      "关系ID": "06REL033",
      "source": "06ALG007",
      "target": "06DS002",
      "attributes": {
        "使用角色": "维护插入时堆属性"
      }
    },
    {
      "type": "uses",
      "关系ID": "06REL034",
      "source": "06ALG008",
      "target": "06DS002",
      "attributes": {
        "使用角色": "维护删除时堆属性"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL035",
      "source": "06DS006",
      "target": "06CON016",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL036",
      "source": "06DS006",
      "target": "06CON018",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "06REL037",
      "source": "06ALG009",
      "target": "06DS006",
      "attributes": {
        "使用角色": "构建实例"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL038",
      "source": "06ALG009",
      "target": "06CON016",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "06REL039",
      "source": "06ALG010",
      "target": "06DS006",
      "attributes": {
        "使用角色": "计算属性"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL040",
      "source": "06ALG010",
      "target": "06CON018",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL041",
      "source": "06CON019",
      "target": "06DS006",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL042",
      "source": "06CON019",
      "target": "06CON022",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "06REL043",
      "source": "06ALG011",
      "target": "06DS006",
      "attributes": {
        "使用角色": "生成编码"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL044",
      "source": "06ALG011",
      "target": "06CON019",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "is-a",
      "关系ID": "06REL045",
      "source": "06CON027",
      "target": "06CON026",
      "attributes": {
          "父类 ID": "06CON026",
          "子类 ID": "06CON027"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL046",
      "source": "06CON027",
      "target": "06CON023",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "is-a",
      "关系ID": "06REL047",
      "source": "06CON028",
      "target": "06CON026",
      "attributes": {
          "父类 ID": "06CON026",
          "子类 ID": "06CON028"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL048",
      "source": "06CON028",
      "target": "06CON024",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL049",
      "source": "06DS007",
      "target": "06CON026",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "is-a",
      "关系ID": "06REL050",
      "source": "06DS008",
      "target": "06DS007",
      "attributes": {
        "父类 ID": "06DS007",
        "子类 ID": "06DS008",
        "约束条件": "中序线索"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL051",
      "source": "06DS007",
      "target": "06CON029",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "is-a",
      "关系ID": "06REL052",
      "source": "06OP011",
      "target": "06OP010",
       "attributes": {
          "父类 ID": "06OP010",
          "子类 ID": "06OP011",
          "约束条件": "中序遍历次序"
      }
    },
    {
      "type": "uses",
      "关系ID": "06REL053",
      "source": "06ALG012",
      "target": "06DS007",
      "attributes": {
        "使用角色": "修改结点结构"
      }
    },
    {
      "type": "is-a",
      "关系ID": "06REL054",
      "source": "06OP012",
      "target": "06OP010",
       "attributes": {
          "父类 ID": "06OP010",
          "子类 ID": "06OP012",
          "约束条件": "先序遍历次序"
      }
    },
    {
      "type": "is-a",
      "关系ID": "06REL055",
      "source": "06OP013",
      "target": "06OP010",
       "attributes": {
          "父类 ID": "06OP010",
          "子类 ID": "06OP013",
          "约束条件": "后序遍历次序"
      }
    },
     {
      "type": "uses",
      "关系ID": "06REL056",
      "source": "06ALG013",
      "target": "06DS007",
      "attributes": {
        "使用角色": "操作结点类型"
      }
    },
    {
      "type": "uses",
      "关系ID": "06REL057",
      "source": "06ALG014",
      "target": "06ALG013",
      "attributes": {
        "使用角色": "核心步骤"
      }
    },
     {
      "type": "uses",
      "关系ID": "06REL058",
      "source": "06ALG015",
      "target": "06DS008",
      "attributes": {
        "使用角色": "修改线索树结构"
      }
    },
     {
      "type": "uses",
      "关系ID": "06REL059",
      "source": "06ALG016",
      "target": "06ALG015",
      "attributes": {
        "使用角色": "核心步骤"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL060",
      "source": "06OP014",
      "target": "06DS008",
      "attributes": {
        "必需性": "是"
      }
    },
     {
      "type": "uses",
      "关系ID": "06REL061",
      "source": "06ALG017",
      "target": "06DS008",
      "attributes": {
        "使用角色": "遍历线索树"
      }
    },
    {
      "type": "uses",
      "关系ID": "06REL062",
      "source": "06ALG017",
      "target": "06OP014",
      "attributes": {
        "使用角色": "核心步骤"
      }
    },
    {
      "type": "is-a",
      "关系ID": "06REL063",
      "source": "06DS009",
      "target": "06DS001",
      "attributes": {
        "父类 ID": "06DS001",
        "子类 ID": "06DS009",
        "约束条件": "平衡因子为-1, 0, 或 1"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL064",
      "source": "06DS009",
      "target": "06CON030",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL065",
      "source": "06DS009",
      "target": "06CON031",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL066",
      "source": "06OP015",
      "target": "06DS009",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL067",
      "source": "06OP016",
      "target": "06DS009",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL068",
      "source": "06OP017",
      "target": "06DS009",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "06REL069",
      "source": "06OP018",
      "target": "06DS009",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL070",
      "source": "06OP015",
      "target": "06CON030",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL071",
      "source": "06OP015",
      "target": "06CON031",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL072",
      "source": "06OP016",
      "target": "06CON030",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL073",
      "source": "06OP016",
      "target": "06CON031",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL074",
      "source": "06OP017",
      "target": "06CON030",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL075",
      "source": "06OP017",
      "target": "06CON031",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL076",
      "source": "06OP018",
      "target": "06CON030",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "06REL077",
      "source": "06OP018",
      "target": "06CON031",
      "attributes": {
        "依赖强度": "强"
      }
    }
  ]
}
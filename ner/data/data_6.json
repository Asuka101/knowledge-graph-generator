{
  "entities": [
    {
      "type": "数据结构",
      "ID": "06DS001",
      "name": "二叉搜索树",
      "attributes": {
        "难度": "中等",
        "内容": "又称二叉排序树。定义：空树或具有以下特性的非空二叉树：1. 左子树所有结点关键字小于根；2. 右子树所有结点关键字大于(或大于等于)根；3. 左右子树本身也是二叉搜索树。特性：中序遍历结果为有序序列。适用场景：适用于需要高效动态查找、插入、删除的场景。",
        "存储开销": "通常采用链式存储，空间复杂度O(n)",
        "核心特性": "有序性、支持高效查找"
      }
    },
    {
      "type": "概念",
      "ID": "06CON001",
      "name": "关键字",
      "attributes": {
        "难度": "入门",
        "内容": "结点中用于比较和排序的值或域。在二叉搜索树中，关键字决定结点在树中的位置。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG001",
      "name": "二叉搜索树查找",
      "attributes": {
        "难度": "中等",
        "内容": "从根结点开始，根据比较关键字与当前结点值的大小关系，递归或迭代地在左子树或右子树中查找。非递归算法可避免栈开销。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
        "设计思想": "递归、分治",
        "适用场景": "在二叉搜索树中查找特定关键字的结点。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG002",
      "name": "二叉搜索树更新",
      "attributes": {
        "难度": "中等",
        "内容": "查找过程与查找算法类似，找到目标结点后，用新值更新该结点的值。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
        "设计思想": "查找与修改",
        "适用场景": "修改二叉搜索树中已存在结点的值（通常指非关键字部分，若修改关键字需保证BST性质）。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG003",
      "name": "二叉搜索树插入",
      "attributes": {
        "难度": "中等",
        "内容": "查找待插入位置（一个空链接），然后创建新结点并链接。递归或非递归实现。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
        "设计思想": "查找与链接",
        "适用场景": "向二叉搜索树中添加新元素，保持其有序性。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG004",
      "name": "二叉搜索树删除",
      "attributes": {
        "难度": "高级",
        "内容": "比插入复杂。分三种情况处理：删除叶子结点、删除单支结点（只有左或右子树）、删除双支结点（常用方法是用中序前驱或中序后继替换，再删除那个前驱/后继结点）。需重新调整链接以维持BST性质。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
        "设计思想": "分类讨论、递归/迭代、指针调整",
        "适用场景": "从二叉搜索树中移除元素，保持其有序性。"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS002",
      "name": "堆",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的完全二叉树。分为小根堆（父结点值≤子结点值）和大根堆（父结点值≥子结点值）。特性：堆顶元素是最小（小根堆）或最大（大根堆）元素。适用场景：优先级队列实现、堆排序、Top K问题、操作系统资源管理。",
        "存储开销": "通常采用顺序存储（数组），空间利用率高，O(n)",
        "核心特性": "部分有序（堆序性）、高效获取极值"
      }
    },
    {
      "type": "概念",
      "ID": "06CON002",
      "name": "完全二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "一棵深度为k，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为完全二叉树。特性是除最后一层外，其余层都是满的，且最后一层的结点都连续集中在最左边。适合用数组进行顺序存储。"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS003",
      "name": "小根堆",
      "attributes": {
        "难度": "中等",
        "内容": "堆的一种具体实现。任意非叶子结点的值均不大于其左右孩子结点的值。根结点是整个堆中的最小值。",
        "存储开销": "通常采用顺序存储（数组），O(n)",
        "核心特性": "父结点≤子结点、根为最小值"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS004",
      "name": "大根堆",
      "attributes": {
        "难度": "中等",
        "内容": "堆的一种具体实现。任意非叶子结点的值均不小于其左右孩子结点的值。根结点是整个堆中的最大值。",
        "存储开销": "通常采用顺序存储（数组），O(n)",
        "核心特性": "父结点≥子结点、根为最大值"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG005",
      "name": "堆插入",
      "attributes": {
        "难度": "中等",
        "内容": "将新元素添加到堆的末尾（数组末尾），然后通过与其父结点比较和交换（上滤/sift-up）来恢复堆序性，直到找到正确位置或到达堆顶。",
        "时间复杂度": "O(log n)",
        "空间复杂度": "O(1)（不考虑数组扩容）",
        "设计思想": "上滤调整",
        "适用场景": "向堆中添加一个新元素。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG006",
      "name": "堆删除顶",
      "attributes": {
        "难度": "中等",
        "内容": "移除堆顶元素（最小值或最大值）。将堆底元素移到堆顶，然后通过与子结点中较小（小根堆）或较大（大根堆）者比较和交换（下滤/sift-down）来恢复堆序性，直到叶子层或找到合适位置。",
        "时间复杂度": "O(log n)",
        "空间复杂度": "O(1)",
        "设计思想": "下滤调整",
        "适用场景": "获取并移除堆中的极值元素（通常用于优先级队列的出队操作）。"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS005",
      "name": "哈夫曼树",
      "attributes": {
        "难度": "高级",
        "内容": "又称最优二叉树。对于给定的n个带权叶子结点，构造出的带权路径长度（WPL）最小的二叉树。所有权值都在叶子结点上，非叶子结点无权值（或权值为其子树叶子权值之和）。应用：哈夫曼编码，用于数据压缩。",
        "存储开销": "通常采用链式存储，O(n)",
        "核心特性": "带权路径长度最小"
      }
    },
    {
      "type": "概念",
      "ID": "06CON003",
      "name": "路径",
      "attributes": {
        "难度": "入门",
        "内容": "树中从一个结点到另一个结点的通路，由一系列结点和连接它们的边组成。树中任意两点间路径唯一。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON004",
      "name": "路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "路径上所包含的边的数量。等于路径上的结点数减1。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON005",
      "name": "结点的权",
      "attributes": {
        "难度": "入门",
        "内容": "赋予树中结点的一个具有特定意义的数值。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON006",
      "name": "结点的带权路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "从根结点到该结点的路径长度与该结点权值的乘积。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON007",
      "name": "树的带权路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "树中所有叶子结点的带权路径长度之和，记作 WPL。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG007",
      "name": "构造哈夫曼树",
      "attributes": {
        "难度": "中等",
        "内容": "1. 初始化n棵只有一个带权根结点的树构成森林。2. 重复n-1次：从森林中选出权值最小的两棵树，合并成一棵新树（新根权值为两者之和），用新树替换原来的两棵树。3. 最终剩下一棵树即为哈夫曼树。",
        "时间复杂度": "O(n log n)（使用优先队列优化选择最小权值）",
        "空间复杂度": "O(n)",
        "设计思想": "贪心算法",
        "适用场景": "根据一组权值构建最优二叉树。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG008",
      "name": "计算哈夫曼树带权路径长度",
      "attributes": {
        "难度": "中等",
        "内容": "通过递归遍历哈夫曼树，累加所有叶子结点的（权值 * 路径长度）。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(height)",
        "设计思想": "递归遍历",
        "适用场景": "计算或验证哈夫曼树的WPL值。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG009",
      "name": "哈夫曼编码",
      "attributes": {
        "难度": "高级",
        "内容": "利用哈夫曼树进行的一种变长编码方法。约定左分支为0，右分支为1，从根到各叶子结点的路径构成的01序列即为对应叶子结点（字符）的编码。频率高的字符编码短，频率低的编码长，且满足无前缀特性，可实现数据压缩。",
        "时间复杂度": "O(n)（生成编码过程）",
        "空间复杂度": "O(n)（存储编码）",
        "设计思想": "树遍历",
        "适用场景": "无损数据压缩。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON008",
      "name": "无前缀编码",
      "attributes": {
        "难度": "中等",
        "内容": "一种编码方案，其中没有任何一个码字是另一个码字的前缀。这保证了编码序列可以被唯一地、无歧义地解码。哈夫曼编码是无前缀编码。"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS006",
      "name": "线索二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "对二叉链表表示的二叉树，利用结点中空闲的指针域（原本指向NULL的左右孩子指针）存放指向该结点在某种遍历序列（如中序）中的前驱和后继结点的指针（称为线索）。需要额外的标志域区分指针是指向孩子还是线索。优点是可以在O(1)空间复杂度下进行非递归遍历。",
        "存储开销": "链式存储，O(n)，每个结点需额外增加两个标志位。",
        "核心特性": "支持高效非递归遍历（特定顺序）"
      }
    },
    {
      "type": "概念",
      "ID": "06CON009",
      "name": "线索",
      "attributes": {
        "难度": "入门",
        "内容": "在线索二叉树中，指向结点在特定遍历序列中前驱或后继结点的指针。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON010",
      "name": "线索化",
      "attributes": {
        "难度": "入门",
        "内容": "按照某种遍历次序，将二叉树中结点的空指针域改为指向其前驱或后继线索的过程。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON011",
      "name": "线索标志域",
      "attributes": {
        "难度": "入门",
        "内容": "结点中用于指示其左右指针域是指向孩子（值为0/false）还是指向线索（值为1/true）的标志位，通常称为 ltag 和 rtag。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON012",
      "name": "中序前驱",
      "attributes": {
        "难度": "入门",
        "内容": "在中序遍历序列中，位于当前结点之前的那个结点。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON013",
      "name": "中序后继",
      "attributes": {
        "难度": "入门",
        "内容": "在中序遍历序列中，位于当前结点之后的那个结点。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG010",
      "name": "中序线索化",
      "attributes": {
        "难度": "中等",
        "内容": "在中序遍历二叉树的过程中，检查当前结点的空左指针和前驱结点的空右指针，并设置相应的线索和标志位。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(height)（递归实现）",
        "设计思想": "递归遍历与修改",
        "适用场景": "将普通二叉树转换为中序线索二叉树。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG011",
      "name": "利用线索进行中序遍历",
      "attributes": {
        "难度": "中等",
        "内容": "非递归算法。首先找到中序序列的第一个结点（最左下结点），然后反复利用右线索或右子树的最左下结点找到后续结点进行访问，直至遍历完成。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)",
        "设计思想": "迭代、利用线索查找后继",
        "适用场景": "高效地（空间上）对中序线索二叉树进行中序遍历。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG012",
      "name": "求中序后继(线索)",
      "attributes": {
        "难度": "中等",
        "内容": "在线索二叉树中查找给定结点的中序后继。若右指针是线索，则直接指向后继；若右指针是孩子，则后继是其右子树中第一个被中序遍历的结点（右子树的最左下结点）。",
        "时间复杂度": "O(height)",
        "空间复杂度": "O(1)",
        "设计思想": "分类讨论、指针跟踪",
        "适用场景": "作为线索遍历的一部分，或单独查找中序后继。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG013",
      "name": "向带线索二叉搜索树插入(带线索链接)",
      "attributes": {
        "难度": "高级",
        "内容": "在保持二叉搜索树性质的同时插入新结点，并且在插入后正确地更新相关结点（新结点、其父结点、其前驱、其后继）的线索指针和标志位。",
        "时间复杂度": "O(height)",
        "空间复杂度": "O(1)",
        "设计思想": "查找、插入、线索维护",
        "适用场景": "在动态变化的线索二叉搜索树中添加元素。"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS007",
      "name": "平衡二叉树",
      "attributes": {
        "难度": "高级",
        "内容": "也称AVL树。是一种自平衡的二叉搜索树。要求任何结点的左右子树高度差的绝对值不超过1（平衡因子为-1, 0, 或 1）。通过在插入和删除操作后进行旋转调整来维持平衡，从而保证操作的时间复杂度在最坏情况下也是O(log n)。",
        "存储开销": "链式存储，O(n)，通常结点需存储平衡因子或高度信息。",
        "核心特性": "自平衡、严格对数高度、保持BST性质"
      }
    },
    {
      "type": "概念",
      "ID": "06CON014",
      "name": "平衡因子",
      "attributes": {
        "难度": "入门",
        "内容": "结点的左子树高度减去右子树高度的值。在AVL树中，平衡因子只能是-1, 0, 或 1。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON015",
      "name": "最小不平衡子树",
      "attributes": {
        "难度": "中等",
        "内容": "在插入或删除结点导致AVL树失衡后，离插入/删除位置最近的、平衡因子绝对值大于1的结点作为根的子树。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG014",
      "name": "LL旋转",
      "attributes": {
        "难度": "高级",
        "内容": "AVL树调整操作之一。当在最小不平衡结点A的左孩子B的左子树上插入导致失衡时进行。将B提升为新的子树根，A成为B的右孩子，B的原右子树成为A的左子树。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "指针调整（右旋）",
        "适用场景": "恢复因LL型插入导致的AVL树失衡。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG015",
      "name": "RR旋转",
      "attributes": {
        "难度": "高级",
        "内容": "AVL树调整操作之一。当在最小不平衡结点A的右孩子B的右子树上插入导致失衡时进行。将B提升为新的子树根，A成为B的左孩子，B的原左子树成为A的右子树。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "指针调整（左旋）",
        "适用场景": "恢复因RR型插入导致的AVL树失衡。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG016",
      "name": "LR旋转",
      "attributes": {
        "难度": "高级",
        "内容": "AVL树调整操作之一。当在最小不平衡结点A的左孩子B的右子树C上插入导致失衡时进行。先对子树B进行RR左旋，再对结点A进行LL右旋。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "指针调整（先左旋后右旋）",
        "适用场景": "恢复因LR型插入导致的AVL树失衡。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG017",
      "name": "RL旋转",
      "attributes": {
        "难度": "高级",
        "内容": "AVL树调整操作之一。当在最小不平衡结点A的右孩子B的左子树C上插入导致失衡时进行。先对子树B进行LL右旋，再对结点A进行RR左旋。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "指针调整（先右旋后左旋）",
        "适用场景": "恢复因RL型插入导致的AVL树失衡。"
      }
    }
  ],
  "relations": [
    {
      "type": "操作绑定",
      "关系ID": "06REL001",
      "source": "06ALG001",
      "target": "06DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL002",
      "source": "06ALG002",
      "target": "06DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL003",
      "source": "06ALG003",
      "target": "06DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL004",
      "source": "06ALG004",
      "target": "06DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL005",
      "source": "06DS001",
      "target": "06CON001",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "继承",
      "关系ID": "06REL006",
      "source": "06DS003",
      "target": "06DS002",
      "attributes": {
        "父类 ID": "06DS002",
        "子类 ID": "06DS003",
        "约束条件": "父结点值 <= 子结点值"
      }
    },
    {
      "type": "继承",
      "关系ID": "06REL007",
      "source": "06DS004",
      "target": "06DS002",
      "attributes": {
        "父类 ID": "06DS002",
        "子类 ID": "06DS004",
        "约束条件": "父结点值 >= 子结点值"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL008",
      "source": "06DS002",
      "target": "06CON002",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL009",
      "source": "06ALG005",
      "target": "06DS002",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL010",
      "source": "06ALG006",
      "target": "06DS002",
      "attributes": {
        "必需性": "是"
      }
    },
        {
      "type": "操作绑定",
      "关系ID": "06REL011",
      "source": "06ALG005",
      "target": "06DS003",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL012",
      "source": "06ALG006",
      "target": "06DS003",
      "attributes": {
        "必需性": "是"
      }
    },
        {
      "type": "操作绑定",
      "关系ID": "06REL013",
      "source": "06ALG005",
      "target": "06DS004",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL014",
      "source": "06ALG006",
      "target": "06DS004",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL015",
      "source": "06DS005",
      "target": "06CON003",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL016",
      "source": "06DS005",
      "target": "06CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL017",
      "source": "06DS005",
      "target": "06CON005",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL018",
      "source": "06DS005",
      "target": "06CON006",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL019",
      "source": "06DS005",
      "target": "06CON007",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL020",
      "source": "06ALG007",
      "target": "06DS005",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL021",
      "source": "06ALG008",
      "target": "06DS005",
      "attributes": {
        "必需性": "否"
      }
    },
    {
      "type": "使用",
      "关系ID": "06REL022",
      "source": "06ALG009",
      "target": "06DS005",
      "attributes": {
        "使用方ID": "06ALG009",
        "被使用的数据结构 ID": "06DS005",
        "使用角色": "核心"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL023",
      "source": "06ALG009",
      "target": "06CON008",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL024",
      "source": "06DS006",
      "target": "06CON009",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL025",
      "source": "06DS006",
      "target": "06CON010",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL026",
      "source": "06DS006",
      "target": "06CON011",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL027",
      "source": "06DS006",
      "target": "06CON012",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL028",
      "source": "06DS006",
      "target": "06CON013",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL029",
      "source": "06ALG010",
      "target": "06DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL030",
      "source": "06ALG011",
      "target": "06DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL031",
      "source": "06ALG012",
      "target": "06DS006",
      "attributes": {
        "必需性": "否"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL032",
      "source": "06ALG013",
      "target": "06DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "继承",
      "关系ID": "06REL033",
      "source": "06DS007",
      "target": "06DS001",
      "attributes": {
        "父类 ID": "06DS001",
        "子类 ID": "06DS007",
        "约束条件": "平衡因子在[-1, 1]之间"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL034",
      "source": "06DS007",
      "target": "06CON014",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL035",
      "source": "06DS007",
      "target": "06CON015",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL036",
      "source": "06ALG014",
      "target": "06DS007",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL037",
      "source": "06ALG015",
      "target": "06DS007",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL038",
      "source": "06ALG016",
      "target": "06DS007",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL039",
      "source": "06ALG017",
      "target": "06DS007",
      "attributes": {
        "必需性": "是"
      }
    }
  ]
}
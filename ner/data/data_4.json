{
  "entities": [
    {
      "type": "数据结构",
      "ID": "04DS001",
      "name": "栈",
      "attributes": {
        "难度": "入门",
        "内容": "又称堆栈，是一种运算受限的线性表，其限制是仅允许在表的一端（栈顶）进行插入（进栈/入栈）和删除（出栈/退栈）运算。另一端称为栈底。特点是后进先出 (LIFO)。适用场景: 需要后进先出特性的场景，如函数调用栈、表达式求值、括号匹配、深度优先搜索、递归实现等。",
        "存储开销": "取决于具体实现（顺序栈O(N)固定容量或动态调整，链栈O(N)动态容量）",
        "核心特性": "后进先出 (LIFO), 运算受限 (仅限栈顶)"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS002",
      "name": "线性表",
      "attributes": {
        "难度": "入门",
        "内容": "由n(n≥0)个数据元素(结点)组成的有限序列。是最基本、最常用的一类数据结构。",
        "存储开销": "取决于具体实现（顺序表O(N)，链表O(N)）",
        "核心特性": "序列性, 有限性, 元素类型相同"
      }
    },
    {
      "type": "概念",
      "ID": "04CON001",
      "name": "栈顶",
      "attributes": {
        "难度": "入门",
        "内容": "允许对栈进行插入和删除操作的一端。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON002",
      "name": "栈底",
      "attributes": {
        "难度": "入门",
        "内容": "与栈顶相对的、不允许进行插入和删除操作的一端。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON003",
      "name": "栈顶元素",
      "attributes": {
        "难度": "入门",
        "内容": "位于栈顶位置的元素。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG001",
      "name": "进栈",
      "attributes": {
        "难度": "入门",
        "内容": "向栈顶插入新元素，使其成为新的栈顶元素。也称压栈或入栈。",
        "时间复杂度": "O(1) (链栈、静态顺序栈) / Amortized O(1) (动态顺序栈)",
        "空间复杂度": "O(1)",
        "设计思想": "-",
        "适用场景": "操作栈数据结构"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG002",
      "name": "出栈",
      "attributes": {
        "难度": "入门",
        "内容": "删除栈顶元素，使其下面的相邻元素成为新的栈顶元素（如果存在）。通常会返回被删除的元素。也称弹栈或退栈。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "-",
        "适用场景": "操作栈数据结构"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG003",
      "name": "初始化栈",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空栈。",
        "时间复杂度": "O(1) (链栈) / O(1) or O(N) (顺序栈，取决于是否需要分配空间)",
        "空间复杂度": "O(1) or O(N) (取决于实现)",
        "设计思想": "-",
        "适用场景": "使用栈之前"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG004",
      "name": "读取栈顶元素",
      "attributes": {
        "难度": "入门",
        "内容": "返回栈顶元素的值，但不改变栈的状态。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "-",
        "适用场景": "查看栈顶元素而不修改栈"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG005",
      "name": "判断栈是否为空",
      "attributes": {
        "难度": "入门",
        "内容": "检查栈中是否包含元素。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "-",
        "适用场景": "在出栈或读取栈顶元素前进行检查"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG006",
      "name": "清除栈",
      "attributes": {
        "难度": "入门",
        "内容": "删除栈中所有元素，使其成为空栈。",
        "时间复杂度": "O(1) (顺序栈，仅重置指针) / O(N) (链栈，需释放所有节点)",
        "空间复杂度": "O(1)",
        "设计思想": "-",
        "适用场景": "重置栈或释放资源"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS003",
      "name": "顺序栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用一段连续的存储单元（通常是数组）和指示栈顶位置的变量（栈顶指针，通常是下标）实现的栈。可能需要处理栈满的情况。适用场景: 需要后进先出特性，且元素数量可预估或对动态扩容开销不敏感的场景，如简单递归的非递归实现、部分表达式处理。",
        "存储开销": "O(N) (N为数组大小)，需要连续空间",
        "核心特性": "顺序存储, 随机访问(理论上可以，但栈操作不允许), 可能栈满"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS004",
      "name": "数组",
      "attributes": {
        "难度": "入门",
        "内容": "存储相同类型元素的固定大小的线性集合，元素通过索引（下标）访问。",
        "存储开销": "O(N)，需要连续空间",
        "核心特性": "随机访问 O(1), 固定大小 (静态数组)"
      }
    },
    {
      "type": "概念",
      "ID": "04CON004",
      "name": "栈顶指针",
      "attributes": {
        "难度": "入门",
        "内容": "指示栈顶元素位置的变量。在顺序栈中通常是数组下标，在链栈中通常是指向栈顶结点的指针。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON005",
      "name": "栈满",
      "attributes": {
        "难度": "入门",
        "内容": "顺序栈的存储空间已被完全占用的状态。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON006",
      "name": "栈空",
      "attributes": {
        "难度": "入门",
        "内容": "栈中不包含任何元素的状态。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS005",
      "name": "链栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用链式存储结构（通常是单链表）实现的栈。通常将链表的头结点作为栈顶，不需要担心栈满的问题（除非内存耗尽）。",
        "存储开销": "O(N) (N为元素数量)，空间不要求连续",
        "核心特性": "链式存储, 动态大小, 无栈满问题 (理论上)"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS006",
      "name": "单链表",
      "attributes": {
        "难度": "入门",
        "内容": "由一系列结点组成的线性数据结构，每个结点包含数据域和指向下一个结点的指针域。",
        "存储开销": "O(N)",
        "核心特性": "动态大小, 插入删除效率高(若知前驱), 访问需遍历 O(N)"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG007",
      "name": "括号配对检查",
      "attributes": {
        "难度": "入门",
        "内容": "扫描文本，遇到左括号（如'(', '[', '{')则进栈；遇到右括号则检查栈顶是否有对应的左括号，若匹配则出栈，否则括号不匹配；文本结束时若栈为空则匹配成功，否则不匹配。",
        "时间复杂度": "O(N) (N为文本长度)",
        "空间复杂度": "O(N) (最坏情况，如全是左括号)",
        "设计思想": "栈应用",
        "适用场景": "编译器语法检查、代码编辑器高亮等"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG008",
      "name": "进制转换 (十进制转N进制)",
      "attributes": {
        "难度": "入门",
        "内容": "将十进制整数重复除以目标进制N，每次取余数，并将余数压入栈中，直到商为0。然后依次从栈中弹出元素，即得到N进制表示。",
        "时间复杂度": "O(log_N M) (M为十进制数)",
        "空间复杂度": "O(log_N M) (栈深度)",
        "设计思想": "栈应用, 短除法",
        "适用场景": "数值的进制转换"
      }
    },
    {
      "type": "概念",
      "ID": "04CON007",
      "name": "操作数",
      "attributes": {
        "难度": "入门",
        "内容": "算术表达式中参与运算的对象或量，可以是常量、变量、函数调用结果或子表达式的结果。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON008",
      "name": "运算符",
      "attributes": {
        "难度": "入门",
        "内容": "算术表达式中表示运算操作的符号，如+、-、*、/等。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON009",
      "name": "单目运算符",
      "attributes": {
        "难度": "入门",
        "内容": "只需要一个操作数的运算符，如正号(+)、负号(-)。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON010",
      "name": "双目运算符",
      "attributes": {
        "难度": "入门",
        "内容": "需要两个操作数的运算符，如加(+)、减(-)、乘(*)、除(/)。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON011",
      "name": "中缀表达式",
      "attributes": {
        "难度": "入门",
        "内容": "人们通常书写算术表达式的方式，即运算符位于其操作数之间。计算时需要考虑运算符优先级和括号。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON012",
      "name": "后缀表达式",
      "attributes": {
        "难度": "入门",
        "内容": "也称逆波兰式(RPN)，运算符位于其操作数之后。计算时无需考虑优先级和括号，只需从左到右扫描，使用栈即可完成求值。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG009",
      "name": "后缀表达式求值",
      "attributes": {
        "难度": "中等",
        "内容": "使用栈计算后缀表达式的值。从左到右扫描表达式：遇到操作数，压入操作数栈；遇到运算符，从栈中弹出所需数量的操作数进行运算，并将结果压回栈中。表达式扫描完毕后，栈中唯一的值即为结果。",
        "时间复杂度": "O(N) (N为表达式长度)",
        "空间复杂度": "O(N) (最坏情况，操作数栈的大小)",
        "设计思想": "栈应用",
        "适用场景": "计算后缀表示的算术表达式"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG010",
      "name": "中缀转后缀表达式",
      "attributes": {
        "难度": "中等",
        "内容": "使用栈将中缀表达式转换为后缀表达式。扫描中缀表达式：遇到操作数，直接输出到后缀表达式；遇到运算符，与其栈顶运算符比较优先级，若当前运算符优先级高于栈顶或栈空，则进栈，否则弹出栈顶运算符输出到后缀表达式，再比较新的栈顶，直到满足进栈条件；遇到左括号，直接进栈；遇到右括号，将栈顶运算符弹出并输出，直到遇到左括号（左括号出栈但不输出）。中缀表达式扫描完毕后，将栈中剩余运算符依次弹出并输出。",
        "时间复杂度": "O(N) (N为表达式长度)",
        "空间复杂度": "O(N) (最坏情况，运算符栈的大小)",
        "设计思想": "栈应用, 优先级调度",
        "适用场景": "表达式转换，通常作为表达式计算的第一步"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG011",
      "name": "阶乘计算 (递归)",
      "attributes": {
        "难度": "入门",
        "内容": "通过递归定义计算非负整数n的阶乘：fact(n) = n * fact(n-1)，基准条件fact(0) = 1。执行时隐式使用系统栈存储函数调用帧。",
        "时间复杂度": "O(N)",
        "空间复杂度": "O(N) (递归深度)",
        "设计思想": "递归",
        "适用场景": "计算阶乘 (常作为递归教学示例)"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG012",
      "name": "布尔组合生成 (递归)",
      "attributes": {
        "难度": "中等",
        "内容": "递归生成n个布尔变量的所有2^n种可能组合。对于第i个变量，分别尝试置为0和1，然后递归处理第i+1个变量，直到处理完所有n个变量，输出当前组合。执行时隐式使用系统栈。",
        "时间复杂度": "O(N * 2^N) (生成并输出)",
        "空间复杂度": "O(N) (递归深度)",
        "设计思想": "递归, 回溯",
        "适用场景": "生成所有布尔组合、状态枚举"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG013",
      "name": "全排列生成 (递归)",
      "attributes": {
        "难度": "中等",
        "内容": "递归生成n个元素的所有n!种排列。对于位置i，依次将i到n-1的每个元素与位置i的元素交换，然后递归处理位置i+1之后的部分。递归返回后，将元素换回原位（回溯）。当i到达n时，输出当前排列。执行时隐式使用系统栈。",
        "时间复杂度": "O(N * N!)",
        "空间复杂度": "O(N) (递归深度)",
        "设计思想": "递归, 回溯, 交换法",
        "适用场景": "生成所有排列"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG014",
      "name": "迷宫求解 (递归)",
      "attributes": {
        "难度": "中等",
        "内容": "使用递归（深度优先搜索）寻找从迷宫入口到出口的路径。从当前位置开始，标记为已访问，然后尝试向四周（如按东南西北顺序）未访问且可通行的相邻格子移动。对可移动的格子，递归调用自身。如果递归调用返回成功，则表示找到路径，当前位置加入路径并返回成功。如果所有方向都尝试失败，则回溯，返回失败。执行时隐式使用系统栈。",
        "时间复杂度": "O(R*C) (R=行数, C=列数，每个格子最多访问一次)",
        "空间复杂度": "O(R*C) (最坏情况下的递归深度或访问标记空间)",
        "设计思想": "递归, 回溯, 深度优先搜索",
        "适用场景": "路径查找问题、图遍历"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG015",
      "name": "深度优先搜索",
      "attributes": {
        "难度": "中等",
        "内容": "图或树的一种遍历策略。从起点开始，尽可能深地探索图的分支。当路径到达尽头或已访问节点时，回溯到上一个节点，并探索其未访问过的邻接点。通常用递归或栈实现。",
        "时间复杂度": "O(V+E) (V=顶点数, E=边数)",
        "空间复杂度": "O(V) (递归栈或显式栈)",
        "设计思想": "图遍历, 回溯",
        "适用场景": "查找路径、检测环、拓扑排序、连通分量等"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG016",
      "name": "汉诺塔问题求解 (递归)",
      "attributes": {
        "难度": "中等",
        "内容": "递归解决汉诺塔问题。将n个盘子从源柱(A)移到目标柱(C)，借助辅助柱(B)的步骤：1. 将n-1个盘子从A移到B（借助C）。 2. 将第n个（最大的）盘子从A移到C。 3. 将n-1个盘子从B移到C（借助A）。基准条件是n=1时，直接将盘子从A移到C。执行时隐式使用系统栈。",
        "时间复杂度": "O(2^N)",
        "空间复杂度": "O(N) (递归深度)",
        "设计思想": "递归, 分治",
        "适用场景": "解决汉诺塔问题 (经典的递归示例)"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS007",
      "name": "队列",
      "attributes": {
        "难度": "入门",
        "内容": "简称队，是一种运算受限的线性表，允许在表的一端（队尾）进行插入（进队/入队），而在表的另一端（队首）进行删除（离队/出队）。特点是先进先出 (FIFO)。适用场景: 需要先进先出特性的场景，如消息队列、缓冲区管理、任务调度、广度优先搜索、模拟排队系统等。",
        "存储开销": "取决于具体实现（顺序队列O(N)，链队列O(N)）",
        "核心特性": "先进先出 (FIFO), 运算受限 (队首删除, 队尾插入)"
      }
    },
    {
      "type": "概念",
      "ID": "04CON013",
      "name": "队尾",
      "attributes": {
        "难度": "入门",
        "内容": "队列中允许插入新元素的一端。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON014",
      "name": "队首",
      "attributes": {
        "难度": "入门",
        "内容": "队列中允许删除元素的一端。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG017",
      "name": "进队",
      "attributes": {
        "难度": "入门",
        "内容": "向队列的队尾插入一个新元素。也称入队。",
        "时间复杂度": "O(1) (循环队列、带尾指针的链队)",
        "空间复杂度": "O(1)",
        "设计思想": "-",
        "适用场景": "操作队列数据结构"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG018",
      "name": "出队",
      "attributes": {
        "难度": "入门",
        "内容": "从队列的队首删除一个元素，通常返回被删除的元素。也称离队。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "-",
        "适用场景": "操作队列数据结构"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG019",
      "name": "初始化队列",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空队列。",
        "时间复杂度": "O(1) (链队) / O(1) or O(N) (顺序队列)",
        "空间复杂度": "O(1) or O(N)",
        "设计思想": "-",
        "适用场景": "使用队列之前"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG020",
      "name": "读取队首元素",
      "attributes": {
        "难度": "入门",
        "内容": "返回队首元素的值，但不改变队列的状态。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "-",
        "适用场景": "查看队首元素而不修改队列"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG021",
      "name": "判断队列是否为空",
      "attributes": {
        "难度": "入门",
        "内容": "检查队列中是否包含元素。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "-",
        "适用场景": "在出队或读取队首元素前进行检查"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG022",
      "name": "清除队列",
      "attributes": {
        "难度": "入门",
        "内容": "删除队列中所有元素，使其成为空队列。",
        "时间复杂度": "O(1) (顺序队列) / O(N) (链队列)",
        "空间复杂度": "O(1)",
        "设计思想": "-",
        "适用场景": "重置队列或释放资源"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS008",
      "name": "循环队列",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组实现的队列，通过取模运算将数组空间逻辑上视为一个环，以克服顺序队列的“假溢出”问题。需要队首和队尾指针，并处理队空和队满的判断条件（通常牺牲一个存储单元或使用计数器）。",
        "存储开销": "O(N) (N为数组大小)，需要连续空间",
        "核心特性": "顺序存储, 循环利用空间, FIFO, 可能队满/队空"
      }
    },
    {
      "type": "概念",
      "ID": "04CON015",
      "name": "队首指针 (顺序队列)",
      "attributes": {
        "难度": "入门",
        "内容": "在循环队列中，指示队首元素位置或队首元素前一个位置的变量（通常是数组下标）。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON016",
      "name": "队尾指针 (顺序队列)",
      "attributes": {
        "难度": "入门",
        "内容": "在循环队列中，指示队尾元素实际存储位置的变量（通常是数组下标）。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON017",
      "name": "队满",
      "attributes": {
        "难度": "入门",
        "内容": "循环队列的存储空间已被占满的状态。判断条件通常是 (rear + 1) % maxSize == front （牺牲一个单元）或 count == maxSize （使用计数器）。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON018",
      "name": "队空",
      "attributes": {
        "难度": "入门",
        "内容": "队列中不包含任何元素的状态。判断条件通常是 rear == front （牺牲一个单元）或 count == 0 （使用计数器）。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS009",
      "name": "链队",
      "attributes": {
        "难度": "入门",
        "内容": "使用链式存储结构（通常是带头尾指针的单链表）实现的队列。队首指针指向链表头结点，队尾指针指向链表尾结点。插入在队尾，删除在队首。",
        "存储开销": "O(N) (N为元素数量)，空间不要求连续",
        "核心特性": "链式存储, 动态大小, FIFO, 插入删除O(1)"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS010",
      "name": "优先级队列",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的队列，其中每个元素关联一个优先级。出队操作总是移除具有最高（或最低）优先级的元素。插入操作需要维护队列的优先级属性。",
        "存储开销": "取决于实现（如使用堆是O(N)）",
        "核心特性": "优先级排序, 非严格FIFO"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS011",
      "name": "堆",
      "attributes": {
        "难度": "中等",
        "内容": "一种基于树的特殊数据结构（通常是完全二叉树），满足堆属性：父节点的键值总是大于等于（或小于等于）任何一个子节点的键值。分为最大堆和最小堆。",
        "存储开销": "O(N)",
        "核心特性": "堆属性 (父子节点关系), 完全二叉树结构 (通常)"
      }
    }
  ],
  "relations": [
    {
      "type": "继承",
      "关系ID": "04REL001",
      "source": "04DS001",
      "target": "04DS002",
      "attributes": {
        "约束条件": "运算受限，仅限一端（栈顶）操作"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL002",
      "source": "04DS001",
      "target": "04CON001",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL003",
      "source": "04DS001",
      "target": "04CON002",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL004",
      "source": "04DS001",
      "target": "04CON003",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL005",
      "source": "04ALG001",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL006",
      "source": "04ALG002",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL007",
      "source": "04ALG003",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL008",
      "source": "04ALG004",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL009",
      "source": "04ALG005",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL010",
      "source": "04ALG006",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL011",
      "source": "04DS003",
      "target": "04DS001",
      "attributes": {
        "约束条件": "使用顺序存储（数组）实现"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL012",
      "source": "04DS003",
      "target": "04DS004",
      "attributes": {
        "使用角色": "底层存储"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL013",
      "source": "04DS003",
      "target": "04CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL014",
      "source": "04DS003",
      "target": "04CON005",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL015",
      "source": "04DS003",
      "target": "04CON006",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL016",
      "source": "04DS005",
      "target": "04DS001",
      "attributes": {
        "约束条件": "使用链式存储（单链表）实现"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL017",
      "source": "04DS005",
      "target": "04DS006",
      "attributes": {
        "使用角色": "底层存储"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL018",
      "source": "04ALG007",
      "target": "04DS001",
      "attributes": {
        "使用角色": "核心数据结构"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL019",
      "source": "04ALG008",
      "target": "04DS001",
      "attributes": {
        "使用角色": "存储中间结果"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL020",
      "source": "04ALG009",
      "target": "04DS001",
      "attributes": {
        "使用角色": "存储操作数和中间结果"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL021",
      "source": "04ALG010",
      "target": "04DS001",
      "attributes": {
        "使用角色": "存储待处理运算符"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL022",
      "source": "04ALG009",
      "target": "04CON012",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL023",
      "source": "04ALG010",
      "target": "04CON011",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL024",
      "source": "04ALG010",
      "target": "04CON012",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL025",
      "source": "04ALG014",
      "target": "04ALG015",
      "attributes": {
        "约束条件": "应用于网格迷宫路径查找"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL026",
      "source": "04DS007",
      "target": "04DS002",
      "attributes": {
        "约束条件": "运算受限，队尾插入队首删除 (FIFO)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL027",
      "source": "04DS007",
      "target": "04CON013",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL028",
      "source": "04DS007",
      "target": "04CON014",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL029",
      "source": "04ALG017",
      "target": "04DS007",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL030",
      "source": "04ALG018",
      "target": "04DS007",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL031",
      "source": "04ALG019",
      "target": "04DS007",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL032",
      "source": "04ALG020",
      "target": "04DS007",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL033",
      "source": "04ALG021",
      "target": "04DS007",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL034",
      "source": "04ALG022",
      "target": "04DS007",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL035",
      "source": "04DS008",
      "target": "04DS007",
      "attributes": {
        "约束条件": "使用顺序存储（循环数组）实现"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL036",
      "source": "04DS008",
      "target": "04DS004",
      "attributes": {
        "使用角色": "底层存储"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL037",
      "source": "04DS008",
      "target": "04CON015",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL038",
      "source": "04DS008",
      "target": "04CON016",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL039",
      "source": "04DS008",
      "target": "04CON017",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL040",
      "source": "04DS008",
      "target": "04CON018",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL041",
      "source": "04DS009",
      "target": "04DS007",
      "attributes": {
        "约束条件": "使用链式存储（单链表）实现"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL042",
      "source": "04DS009",
      "target": "04DS006",
      "attributes": {
        "使用角色": "底层存储"
      }
    },
    {
      "type": "变体",
      "关系ID": "04REL043",
      "source": "04DS007", 
      "target": "04DS010",
      "attributes": {
        "基础ID": "04DS007",
        "变体ID": "04DS010",
        "变体类型": "增加优先级概念和操作"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL044",
      "source": "04DS010",
      "target": "04DS011",
      "attributes": {
        "使用角色": "常用实现方式"
      }
    }
  ]
}
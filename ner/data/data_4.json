{
  "entities": [
    {
      "type": "概念",
      "ID": "04CON001",
      "name": "线性表",
      "attributes": {
        "难度": "入门",
        "内容": "数据元素之间存在一对一线性关系的结构。栈和队列是运算受限的线性表。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS001",
      "name": "栈",
      "attributes": {
        "难度": "入门",
        "内容": "运算受限的线性表，仅允许在表的一端（栈顶）进行插入（进栈/入栈）和删除（出栈/退栈）运算。也称堆栈。具有后进先出（LIFO）的特性。",
        "存储开销": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS002",
      "name": "队列",
      "attributes": {
        "难度": "入门",
        "内容": "运算受限的线性表，允许在一端（队尾）进行插入（进队/入队），在另一端（队首）进行删除（出队/离队）。具有先进先出（FIFO）的特性。",
        "存储开销": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON002",
      "name": "LIFO",
      "attributes": {
        "难度": "入门",
        "内容": "后进先出（Last In First Out）原则，是栈的主要特性。"
      }
    },
    {
      "type": "操作",
      "ID": "04OP001",
      "name": "Push",
      "attributes": {
        "难度": "入门",
        "内容": "向栈顶插入一个新元素，使其成为新的栈顶元素。也称进栈或入栈。顺序栈实现通常为O(1)，除非需要扩容；链栈实现为O(1)。"
      }
    },
    {
      "type": "操作",
      "ID": "04OP002",
      "name": "Pop",
      "attributes": {
        "难度": "入门",
        "内容": "删除栈顶元素，使其下面的相邻元素成为新的栈顶元素。也称出栈或退栈。顺序栈和链栈实现均为O(1)。"
      }
    },
    {
      "type": "操作",
      "ID": "04OP003",
      "name": "InitStack",
      "attributes": {
        "难度": "入门",
        "内容": "初始化一个栈，通常是将其置为空栈。"
      }
    },
    {
      "type": "操作",
      "ID": "04OP004",
      "name": "Peek",
      "attributes": {
        "难度": "入门",
        "内容": "返回栈顶元素的值，但不改变栈的状态（不删除元素）。顺序栈和链栈实现均为O(1)。"
      }
    },
    {
      "type": "操作",
      "ID": "04OP005",
      "name": "EmptyStack",
      "attributes": {
        "难度": "入门",
        "内容": "判断栈是否为空。顺序栈和链栈实现均为O(1)。"
      }
    },
    {
      "type": "操作",
      "ID": "04OP006",
      "name": "ClearStack",
      "attributes": {
        "难度": "入门",
        "内容": "清除栈中所有元素，使其成为空栈。对于动态分配的存储可能涉及释放空间。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS003",
      "name": "顺序栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组（顺序存储结构）实现的栈。需要一个整型变量（栈顶指针top）来指示栈顶元素的位置。插入和删除操作的时间复杂度为O(1)，但可能需要处理栈满（扩容）和栈空的情况。",
        "存储开销": "O(N)固定空间或动态数组开销。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS008",
      "name": "数组",
      "attributes": {
        "难度": "入门",
        "内容": "一种线性数据结构，用连续的内存空间存储相同类型的元素，可通过下标随机访问。",
        "存储开销": "O(N)"
      }
    },
    {
      "type": "概念",
      "ID": "04CON004",
      "name": "O(1)",
      "attributes": {
        "难度": "入门",
        "内容": "常数时间复杂度，表示算法或操作的执行时间不随输入数据规模增长而增长。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON005",
      "name": "时间复杂度",
      "attributes": {
        "难度": "入门",
        "内容": "衡量算法执行时间随输入数据规模增长而变化的趋势，通常使用大O表示法。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS004",
      "name": "链栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用链式存储结构（通常是单链表）实现的栈。栈顶指针指向链表的头结点。插入和删除操作仅在链表头部进行，时间复杂度为O(1)。",
        "存储开销": "O(N)，每个元素需要额外存储指针。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS009",
      "name": "单链表",
      "attributes": {
        "难度": "入门",
        "内容": "一种链式存储的线性结构，每个节点包含数据域和指向下一个节点的指针域。",
        "存储开销": "O(N)，每个节点有指针开销。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG001",
      "name": "括号配对检查",
      "attributes": {
        "难度": "入门",
        "内容": "使用栈检查 C/C++ 等语言程序中的括号（{}、[]、()）是否配对。扫描字符，遇左括号入栈，遇右括号检查栈顶是否匹配，若匹配则出栈，否则错误。文件结束时栈空则配对成功。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(n)"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG002",
      "name": "进制转换",
      "attributes": {
        "难度": "入门",
        "内容": "将十进制整数转换为其他进制（如二至九进制）数输出。采用逐次除基数取余法，将余数入栈，最后依次出栈得到转换结果。",
        "时间复杂度": "O(log_r N)",
        "空间复杂度": "O(log_r N)"
      }
    },
    {
      "type": "概念",
      "ID": "04CON007",
      "name": "中缀表达式",
      "attributes": {
        "难度": "入门",
        "内容": "运算符放在两个操作数中间的常规算术表达式表示法。计算需考虑括号和运算符优先级。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON008",
      "name": "后缀表达式",
      "attributes": {
        "难度": "入门",
        "内容": "运算符放在两个操作数之后的算术表达式表示法，也称逆波兰式（RPN）。计算时无需考虑括号和优先级，只需按运算符出现顺序计算。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON009",
      "name": "运算符优先级",
      "attributes": {
        "难度": "入门",
        "内容": "规定不同运算符计算先后顺序的规则，如乘除优先于加减。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG003",
      "name": "后缀表达式求值",
      "attributes": {
        "难度": "中等",
        "内容": "使用栈计算后缀表达式的值。从左到右扫描表达式，遇操作数入栈，遇运算符则弹出所需数量的操作数进行计算，结果再入栈。表达式结束时栈中唯一的值即为结果。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(n)"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG004",
      "name": "中缀转后缀",
      "attributes": {
        "难度": "中等",
        "内容": "使用栈将中缀表达式转换为后缀表达式。扫描中缀表达式，遇操作数直接输出；遇运算符，与栈顶运算符比较优先级，若低于或等于栈顶，则栈顶出栈输出，直至栈顶低于当前运算符或遇左括号，当前运算符再入栈；遇左括号入栈；遇右括号，将栈内运算符出栈输出直至遇左括号。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(n)"
      }
    },
    {
      "type": "概念",
      "ID": "04CON010",
      "name": "递归",
      "attributes": {
        "难度": "中等",
        "内容": "一种解决问题的方法，通过求解与原问题结构相同但规模更小的子问题来得到原问题的解。递归算法通常包含基本情况（终止条件）和递归步骤（调用自身）。系统通常使用栈来实现递归调用。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG005",
      "name": "阶乘计算(递归)",
      "attributes": {
        "难度": "入门",
        "内容": "使用递归计算n的阶乘。定义f(n) = n * f(n-1)，基本情况f(0) = 1。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(n)"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG006",
      "name": "布尔组合",
      "attributes": {
        "难度": "中等",
        "内容": "使用递归生成n个布尔量的所有可能组合（2^n种）。对第k个位置，分别尝试置0和置1，然后递归处理第k+1个位置。",
        "时间复杂度": "O(n*2^n)",
        "空间复杂度": "O(n)"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG007",
      "name": "全排列",
      "attributes": {
        "难度": "中等",
        "内容": "使用递归生成n个元素的所有排列（n!种）。对于位置k，依次将k到n-1的元素放到位置k，然后递归处理位置k+1。",
        "时间复杂度": "O(n!)",
        "空间复杂度": "O(n)"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG008",
      "name": "迷宫求解(递归)",
      "attributes": {
        "难度": "中等",
        "内容": "使用递归寻找从迷宫入口到出口的路径。从当前位置(x,y)尝试向四个方向移动到新位置(g,h)，如果(g,h)可通行且未访问过，则递归调用SeekPath(g,h)。找到出口则返回true并记录路径。",
        "时间复杂度": "O(m*n)",
        "空间复杂度": "O(m*n)"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG009",
      "name": "汉诺塔",
      "attributes": {
        "难度": "中等",
        "内容": "使用递归解决汉诺塔问题。将n个盘子从A移到C（借助B）：1. 将n-1个盘子从A移到B（借助C）；2. 将第n个盘子从A移到C；3. 将n-1个盘子从B移到C（借助A）。",
        "时间复杂度": "O(2^n)",
        "空间复杂度": "O(n)"
      }
    },
    {
      "type": "概念",
      "ID": "04CON011",
      "name": "FIFO",
      "attributes": {
        "难度": "入门",
        "内容": "先进先出（First In First Out）原则，是队列的主要特性。"
      }
    },
    {
      "type": "操作",
      "ID": "04OP007",
      "name": "Enqueue",
      "attributes": {
        "难度": "入门",
        "内容": "向队尾插入一个新元素。也称进队或入队。循环队列实现为O(1)除非需要扩容；链队实现为O(1)。"
      }
    },
    {
      "type": "操作",
      "ID": "04OP008",
      "name": "OutQueue",
      "attributes": {
        "难度": "入门",
        "内容": "删除队首元素并返回其值。也称出队或离队。循环队列和链队实现均为O(1)。"
      }
    },
    {
      "type": "操作",
      "ID": "04OP009",
      "name": "InitQueue",
      "attributes": {
        "难度": "入门",
        "内容": "初始化一个队列，通常是将其置为空队列。"
      }
    },
    {
      "type": "操作",
      "ID": "04OP010",
      "name": "PeekQueue",
      "attributes": {
        "难度": "入门",
        "内容": "返回队首元素的值，但不改变队列的状态（不删除元素）。循环队列和链队实现均为O(1)。"
      }
    },
    {
      "type": "操作",
      "ID": "04OP011",
      "name": "EmptyQueue",
      "attributes": {
        "难度": "入门",
        "内容": "判断队列是否为空。循环队列和链队实现均为O(1)。"
      }
    },
    {
      "type": "操作",
      "ID": "04OP012",
      "name": "ClearQueue",
      "attributes": {
        "难度": "入门",
        "内容": "清除队列中所有元素，使其成为空队列。对于动态分配的存储可能涉及释放空间。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS005",
      "name": "循环队列",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组（顺序存储结构）实现的队列，通过取模运算将数组空间逻辑上视为环形，以解决“假溢出”问题。通常需要队首(front)和队尾(rear)指针。判空和判满条件需要特别设计（如牺牲一个空间，或使用计数器）。",
        "存储开销": "O(N)固定空间。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS006",
      "name": "链队",
      "attributes": {
        "难度": "入门",
        "内容": "使用链式存储结构（通常是带头尾指针的单链表）实现的队列。队首指针(front)指向头结点，队尾指针(rear)指向尾结点。入队在尾部操作，出队在头部操作，时间复杂度均为O(1)。",
        "存储开销": "O(N)，每个元素需要额外存储指针。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS007",
      "name": "优先级队列",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的队列，其中每个元素关联一个优先级。出队操作总是移除优先级最高的元素。插入操作需要维护优先级顺序。常用于调度算法，通常用堆来实现。",
        "存储开销": "依赖于具体实现，如堆实现为O(N)。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON012",
      "name": "优先级",
      "attributes": {
        "难度": "入门",
        "内容": "表示元素重要性或紧急程度的值，用于优先级队列等场景。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG010",
      "name": "渡口车辆调度",
      "attributes": {
        "难度": "中等",
        "内容": "模拟轮船渡口车辆管理。使用两个队列分别存储客车和货车，根据特定规则（如客车优先，按比例上船）安排车辆上船。",
        "时间复杂度": "依赖于操作次数",
        "空间复杂度": "O(N)，N为等待车辆数"
      }
    }
  ],
  "relations": [
    {
      "type": "is-a",
      "关系ID": "04REL001",
      "source": "04DS001",
      "target": "04CON001",
      "attributes": {}
    },
    {
      "type": "is-a",
      "关系ID": "04REL002",
      "source": "04DS002",
      "target": "04CON001",
      "attributes": {}
    },
    {
      "type": "depends-on",
      "关系ID": "04REL003",
      "source": "04DS001",
      "target": "04CON002",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "has-op",
      "关系ID": "04REL004",
      "source": "04OP001",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "04REL005",
      "source": "04OP002",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "04REL006",
      "source": "04OP003",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "04REL007",
      "source": "04OP004",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "04REL008",
      "source": "04OP005",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "04REL009",
      "source": "04OP006",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "uses",
      "关系ID": "04REL010",
      "source": "04DS003",
      "target": "04DS008",
      "attributes": {
        "使用角色": "存储"
      }
    },
    {
      "type": "variant-of",
      "关系ID": "04REL011",
      "source": "04DS003",
      "target": "04DS001",
      "attributes": {
        "变体类型": "存储实现"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "04REL012",
      "source": "04DS003",
      "target": "04CON005",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "uses",
      "关系ID": "04REL013",
      "source": "04DS004",
      "target": "04DS009",
      "attributes": {
        "使用角色": "存储"
      }
    },
    {
      "type": "variant-of",
      "关系ID": "04REL014",
      "source": "04DS004",
      "target": "04DS001",
      "attributes": {
        "变体类型": "存储实现"
      }
    },
    {
      "type": "uses",
      "关系ID": "04REL015",
      "source": "04ALG001",
      "target": "04DS001",
      "attributes": {
        "使用角色": "核心"
      }
    },
    {
      "type": "uses",
      "关系ID": "04REL016",
      "source": "04ALG002",
      "target": "04DS001",
      "attributes": {
        "使用角色": "核心"
      }
    },
    {
      "type": "uses",
      "关系ID": "04REL017",
      "source": "04ALG003",
      "target": "04DS001",
      "attributes": {
        "使用角色": "核心"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "04REL018",
      "source": "04ALG003",
      "target": "04CON008",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "04REL019",
      "source": "04ALG004",
      "target": "04DS001",
      "attributes": {
        "使用角色": "核心"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "04REL020",
      "source": "04ALG004",
      "target": "04CON007",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "04REL021",
      "source": "04ALG004",
      "target": "04CON008",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "04REL022",
      "source": "04ALG004",
      "target": "04CON009",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "04REL023",
      "source": "04CON010",
      "target": "04DS001",
      "attributes": {
        "使用角色": "实现机制 (系统栈)"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "04REL024",
      "source": "04ALG005",
      "target": "04CON010",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "04REL025",
      "source": "04ALG006",
      "target": "04CON010",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "04REL026",
      "source": "04ALG007",
      "target": "04CON010",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "04REL027",
      "source": "04ALG008",
      "target": "04CON010",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "04REL028",
      "source": "04ALG009",
      "target": "04CON010",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "04REL029",
      "source": "04DS002",
      "target": "04CON011",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "has-op",
      "关系ID": "04REL030",
      "source": "04OP007",
      "target": "04DS002",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "04REL031",
      "source": "04OP008",
      "target": "04DS002",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "04REL032",
      "source": "04OP009",
      "target": "04DS002",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "04REL033",
      "source": "04OP010",
      "target": "04DS002",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "04REL034",
      "source": "04OP011",
      "target": "04DS002",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "has-op",
      "关系ID": "04REL035",
      "source": "04OP012",
      "target": "04DS002",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "uses",
      "关系ID": "04REL036",
      "source": "04DS005",
      "target": "04DS008",
      "attributes": {
        "使用角色": "存储"
      }
    },
    {
      "type": "variant-of",
      "关系ID": "04REL037",
      "source": "04DS005",
      "target": "04DS002",
      "attributes": {
        "变体类型": "存储实现 (循环)"
      }
    },
    {
      "type": "uses",
      "关系ID": "04REL038",
      "source": "04DS006",
      "target": "04DS009",
      "attributes": {
        "使用角色": "存储"
      }
    },
    {
      "type": "variant-of",
      "关系ID": "04REL039",
      "source": "04DS006",
      "target": "04DS002",
      "attributes": {
        "变体类型": "存储实现"
      }
    },
    {
      "type": "depends-on",
      "关系ID": "04REL040",
      "source": "04DS007",
      "target": "04CON012",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "04REL042",
      "source": "04ALG010",
      "target": "04DS002",
      "attributes": {
        "使用角色": "核心 (客车队列, 货车队列)"
      }
    }
  ]
}
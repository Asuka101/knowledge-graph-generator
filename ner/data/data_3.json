{
  "entities": [
    {
      "type": "数据结构",
      "ID": "03DS001",
      "name": "集合",
      "attributes": {
        "难度": "入门",
        "内容": "由具有相同属性的数据元素组合而成，数据之间没有任何前驱和后继关系。集合长度可变，元素类型任意（用ElemType表示）。不允许重复元素（由InsertSet操作体现）。",
        "存储开销": "未知 (依赖具体实现)"
      }
    },
    {
      "type": "概念",
      "ID": "03CON001",
      "name": "空集",
      "attributes": {
        "难度": "入门",
        "内容": "长度为0的集合，表示为 {} 或 Ø。"
      }
    },
    {
      "type": "概念",
      "ID": "03CON002",
      "name": "抽象数据类型",
      "attributes": {
        "难度": "入门",
        "内容": "定义数据对象、对象中元素间的关系以及对数据元素的操作集合。包括数据和操作两部分。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP001",
      "name": "InitSet",
      "attributes": {
        "难度": "入门",
        "内容": "初始化集合为空 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP002",
      "name": "ClearSet",
      "attributes": {
        "难度": "入门",
        "内容": "清除集合中的所有元素 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP003",
      "name": "LengthSet",
      "attributes": {
        "难度": "入门",
        "内容": "求出集合的长度 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP004",
      "name": "EmptySet",
      "attributes": {
        "难度": "入门",
        "内容": "判断集合是否为空 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP005",
      "name": "InSet",
      "attributes": {
        "难度": "入门",
        "内容": "判断一个元素是否属于集合 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP006",
      "name": "OutputSet",
      "attributes": {
        "难度": "入门",
        "内容": "输出集合中所有元素 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP007",
      "name": "FindSet",
      "attributes": {
        "难度": "入门",
        "内容": "从集合中查找一个元素 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP008",
      "name": "ModifySet",
      "attributes": {
        "难度": "中等",
        "内容": "修改集合中的一个指定元素 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP009",
      "name": "InsertSet",
      "attributes": {
        "难度": "入门",
        "内容": "向集合插入一个元素，不允许重复 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP010",
      "name": "DeleteSet",
      "attributes": {
        "难度": "入门",
        "内容": "从集合删除一个元素 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP011",
      "name": "UnionSet",
      "attributes": {
        "难度": "中等",
        "内容": "求两个集合的并集 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP012",
      "name": "InterseSet",
      "attributes": {
        "难度": "中等",
        "内容": "求两个集合的交集 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP013",
      "name": "DifferenceSet",
      "attributes": {
        "难度": "中等",
        "内容": "求两个集合的差集 (ADT定义)。"
      }
    },
    {
      "type": "概念",
      "ID": "03CON003",
      "name": "顺序存储",
      "attributes": {
        "难度": "入门",
        "内容": "把逻辑上相邻的数据元素存储在物理位置也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。通常使用数组实现。"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS002",
      "name": "集合的顺序存储结构",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组存储集合元素，并用整型变量存储当前长度(len)和数组容量(MaxSize)。元素存储次序任意，通常新元素加到末尾，删除元素后用末尾元素填补空位，以避免移动元素。可封装在结构体Set中。支持动态分配和调整数组大小。",
        "存储开销": "需要预分配或动态调整数组大小，可能浪费空间或需要扩容成本。空间复杂度O(MaxSize)。"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG001",
      "name": "InitSet_Sequential_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现InitSet操作。分配初始数组空间(如大小为10)，设置长度len为0。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(MaxSize)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG002",
      "name": "ClearSet_Sequential_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现ClearSet操作。释放动态分配的数组空间，重置len和MaxSize为0。",
        "时间复杂度": "O(1) 或 O(N) (取决于内存管理器)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG003",
      "name": "LengthSet_Sequential_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现LengthSet操作。返回长度变量len的值。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG004",
      "name": "EmptySet_Sequential_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现EmptySet操作。检查长度len是否为0。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG005",
      "name": "InSet_Sequential_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现InSet操作。顺序遍历数组(从0到len-1)，比较元素值，找到返回true，否则返回false。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG006",
      "name": "OutputSet_Sequential_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现OutputSet操作。使用for循环遍历数组(从0到len-1)，输出每个元素。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG007",
      "name": "简单选择排序",
      "attributes": {
        "难度": "入门",
        "内容": "排序算法原理：进行n-1趟选择，每趟在无序区中找到最小(或最大)的元素，存放到无序区的起始位置（即有序区末尾）。",
        "时间复杂度": "O(n^2)",
        "空间复杂度": "O(1) (原地排序)"
      }
    },
    {
      "type": "概念",
      "ID": "03CON004",
      "name": "时间复杂度",
      "attributes": {
        "难度": "中等",
        "内容": "算法执行时间随输入规模增长的度量，通常关注最坏情况或平均情况，使用大O表示法。"
      }
    },
    {
      "type": "概念",
      "ID": "03CON005",
      "name": "O(n^2)",
      "attributes": {
        "难度": "入门",
        "内容": "平方时间复杂度。表示算法执行时间与输入规模n的平方大致成正比。常见于嵌套循环遍历或简单排序算法。"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG008",
      "name": "OutputSet_Sorted_Sequential_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现OutputSet操作（按升序输出）。1. 创建临时数组a并复制集合元素。2. 对临时数组a使用简单选择排序。3. 遍历排序后的数组a并输出。4. 释放临时数组a。",
        "时间复杂度": "O(n^2) (主要来自排序)",
        "空间复杂度": "O(n) (临时数组)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG009",
      "name": "FindSet_Sequential_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现FindSet操作。顺序遍历数组查找值等于item（通常是关键字）的元素，若找到，则将完整元素赋给item引用参数并返回true，否则返回false。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG010",
      "name": "ModifySet_Sequential_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现ModifySet操作。顺序遍历数组查找关键字匹配的元素，若找到，则用item的完整值更新该元素，并返回true，否则返回false。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG011",
      "name": "InsertSet_Sequential_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现InsertSet操作。1. 顺序查找item是否存在，存在则返回false。2. 若集合满(len==MaxSize)，则动态扩容(如realloc * 2)，更新MaxSize。3. 将item插入数组末尾(S.set[S.len])。4. 长度len增1。5. 返回true。",
        "时间复杂度": "O(n) (最坏情况，主要来自查找和可能的扩容)",
        "空间复杂度": "O(1) (摊销)"
      }
    },
    {
      "type": "概念",
      "ID": "03CON006",
      "name": "O(n)",
      "attributes": {
        "难度": "入门",
        "内容": "线性时间复杂度。表示算法执行时间与输入规模n大致成正比。常见于单次遍历。"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG012",
      "name": "DeleteSet_Sequential_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现DeleteSet操作。1. 顺序查找待删元素item，找不到则返回false。2. 若找到(下标i)，将完整元素赋给item带回。3. 用数组最后一个元素(S.set[S.len-1])覆盖S.set[i]。4. 长度len减1。5. (可选)若空间利用率过低(如len/MaxSize < 0.4)，则缩容(如realloc / 2)，更新MaxSize。6. 返回true。",
        "时间复杂度": "O(n) (主要来自查找)",
        "空间复杂度": "O(1) (摊销)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG013",
      "name": "UnionSet_Sequential_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现UnionSet(S1, S2, S)。1. 确保S有足够空间，必要时重新分配以容纳S1。2. 将S1元素直接复制到S的数组，设置S.len = S1.len。3. 遍历S2，对S2中每个元素调用InsertSet(S, S2.set[i])将其插入结果集S。",
        "时间复杂度": "O(n*m) (n=|S1|, m=|S2|, 瓶颈在步骤3的重复插入查找)",
        "空间复杂度": "O(n+m) (结果集S的空间)"
      }
    },
    {
      "type": "概念",
      "ID": "03CON007",
      "name": "O(n*m)",
      "attributes": {
        "难度": "入门",
        "内容": "时间复杂度，表示算法执行时间与两个输入规模n和m的乘积大致成正比。常见于双重循环或嵌套查找。"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG014",
      "name": "InterseSet_Sequential_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现InterseSet(S1, S2, S)。1. 初始化结果集S为空(S.len=0)。2. 遍历S2中的每个元素x。3. 对每个x，调用FindSet(S1, x)在S1中查找。4. 若FindSet返回true，则将x插入结果集S的末尾(S.set[S.len]=x; S.len++)，并检查是否需要扩容。",
        "时间复杂度": "O(n*m) (n=|S1|, m=|S2|, 瓶颈在对S2每个元素查找S1)",
        "空间复杂度": "O(min(n,m)) (结果集S的空间)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG015",
      "name": "DifferenceSet_Sequential_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现DifferenceSet(S1, S2, S)。1. 初始化结果集S为空(S.len=0)。2. 遍历S1中的每个元素x。3. 对每个x，调用FindSet(S2, x)在S2中查找。4. 若FindSet返回false（即x不在S2中），则将x插入结果集S的末尾(S.set[S.len]=x; S.len++)，并检查是否需要扩容。",
        "时间复杂度": "O(n*m) (n=|S1|, m=|S2|, 瓶颈在对S1每个元素查找S2)",
        "空间复杂度": "O(n) (结果集S的空间)"
      }
    },
    {
      "type": "概念",
      "ID": "03CON008",
      "name": "链接存储",
      "attributes": {
        "难度": "入门",
        "内容": "数据元素的逻辑关系通过指针域链接表示。元素存储在任意物理位置。通常使用链表实现。"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS003",
      "name": "集合的链接存储结构",
      "attributes": {
        "难度": "入门",
        "内容": "通常使用单链表存储集合元素，每个元素对应链表中的一个节点。由于集合无序，节点在链表中次序任意。插入删除若不考虑查找效率，可在表头进行O(1)操作。",
        "存储开销": "每个元素需要额外存储指针域。空间复杂度O(n)。"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS004",
      "name": "单链表",
      "attributes": {
        "难度": "入门",
        "内容": "由一系列节点组成，每个节点包含数据域(data)和指向下一个节点的指针域(next)。需要一个头指针(Head)指向第一个节点。",
        "存储开销": "每个节点有指针开销。"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG016",
      "name": "InitSet_Linked_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现InitSet操作。将头指针HT置为NULL。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG017",
      "name": "ClearSet_Linked_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现ClearSet操作。遍历链表，逐个删除(delete)节点并回收空间，最后将头指针HT置为NULL。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG018",
      "name": "LengthSet_Linked_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现LengthSet操作。遍历链表，用计数器n记录节点个数，返回n。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG019",
      "name": "EmptySet_Linked_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现EmptySet操作。检查头指针HT是否为NULL。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG020",
      "name": "InSet_Linked_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现InSet操作。从头指针HT开始遍历链表，比较节点data域与item，找到返回true，遍历结束未找到则返回false。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG021",
      "name": "OutputSet_Linked_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现OutputSet操作。从头指针HT开始遍历链表，输出每个节点的data域。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG022",
      "name": "FindSet_Linked_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现FindSet操作。从头指针HT开始遍历链表查找data域等于item的节点，若找到，将节点data赋给item引用参数并返回true，否则返回false。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG023",
      "name": "ModifySet_Linked_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现ModifySet操作。从头指针HT开始遍历链表查找data域等于item关键字的节点，若找到，用item的完整值更新节点data域，并返回true，否则返回false。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG024",
      "name": "InsertSet_Linked_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现InsertSet操作。1. 遍历链表查找item是否存在，存在则返回false。2. 若不存在，创建值为item的新节点tp。3. 将新节点插入到链表头部 (tp->next = HT; HT = tp)。4. 返回true。",
        "时间复杂度": "O(n) (主要来自查找)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG025",
      "name": "DeleteSet_Linked_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现DeleteSet操作。1. 遍历链表查找值为item的节点(cp)，同时记录其前驱节点(ap)。2. 若未找到(cp==NULL)，返回false。3. 若找到，由item带回节点值。4. 修改指针删除节点：若ap为空（删除的是头节点），则HT=cp->next；否则ap->next=cp->next。5. 释放cp节点(delete cp)。6. 返回true。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG026",
      "name": "UnionSet_Linked_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现UnionSet(HT1, HT2, HT)。1. 初始化结果集HT为空。2. 遍历HT1，对每个节点创建一个新副本并头插法插入HT (深拷贝)。3. 遍历HT2，对每个元素p->data调用InsertSet(HT, p->data)将其插入结果集HT。",
        "时间复杂度": "O(n*m) (n=|HT1|, m=|HT2|, 瓶颈在步骤3的重复插入查找)",
        "空间复杂度": "O(n+m) (结果集HT的空间)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG027",
      "name": "InterseSet_Linked_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现InterseSet(HT1, HT2, HT)。1. 初始化结果集HT为空。2. 遍历HT2中的每个元素x=p->data。3. 对每个x，调用FindSet(HT1, x)在HT1中查找。4. 若FindSet返回true，则调用InsertSet(HT, x)将x插入结果集HT。",
        "时间复杂度": "O(n*m) (n=|HT1|, m=|HT2|, 瓶颈在对HT2每个元素查找HT1)",
        "空间复杂度": "O(min(n,m)) (结果集HT的空间)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG028",
      "name": "DifferenceSet_Linked_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现DifferenceSet(HT1, HT2, HT)。1. 初始化结果集HT为空。2. 遍历HT1中的每个元素x=p->data。3. 对每个x，调用FindSet(HT2, x)在HT2中查找。4. 若FindSet返回false（即x不在HT2中），则调用InsertSet(HT, x)将x插入结果集HT。",
        "时间复杂度": "O(n*m) (n=|HT1|, m=|HT2|, 瓶颈在对HT1每个元素查找HT2)",
        "空间复杂度": "O(n) (结果集HT的空间)"
      }
    },
    {
      "type": "概念",
      "ID": "03CON009",
      "name": "矩阵",
      "attributes": {
        "难度": "入门",
        "内容": "一个m行n列的数表，包含m*n个元素，每个元素由唯一的行号和列号确定。"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS005",
      "name": "稀疏矩阵",
      "attributes": {
        "难度": "中等",
        "内容": "矩阵的一种特殊情况，其非零元素的个数远小于零元素的个数。适用场景：高效存储和处理大型且大部分元素为零的矩阵。",
        "存储开销": "旨在节省空间，仅存储非零元素及其位置，相比二维数组开销小很多。"
      }
    },
    {
      "type": "概念",
      "ID": "03CON010",
      "name": "非零元素",
      "attributes": {
        "难度": "入门",
        "内容": "矩阵中值不为零的元素。"
      }
    },
    {
      "type": "概念",
      "ID": "03CON011",
      "name": "零元素",
      "attributes": {
        "难度": "入门",
        "内容": "矩阵中值为零的元素。"
      }
    },
    {
      "type": "概念",
      "ID": "03CON012",
      "name": "三元组",
      "attributes": {
        "难度": "入门",
        "内容": "表示稀疏矩阵中一个非零元素的数据结构，包含三个信息：元素所在的行号(i)、列号(j)以及元素值(value)。记为 (i, j, value)。"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS006",
      "name": "三元组线性表",
      "attributes": {
        "难度": "中等",
        "内容": "将稀疏矩阵的所有非零元素对应的三元组，按照行号为主序、列号为辅序排列构成的线性表。是稀疏矩阵的一种逻辑表示方法。",
        "存储开销": "O(t)，其中t为非零元素个数。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP014",
      "name": "Transpose",
      "attributes": {
        "难度": "中等",
        "内容": "求稀疏矩阵的转置矩阵 (ADT定义)。转置后矩阵B的(i, j)元素等于原矩阵A的(j, i)元素。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP015",
      "name": "Add",
      "attributes": {
        "难度": "中等",
        "内容": "求两个稀疏矩阵的和 (ADT定义)。要求两个矩阵行数和列数必须分别相同。结果矩阵C的(i,j)元素等于两加数矩阵对应位置元素之和。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP016",
      "name": "Multiply",
      "attributes": {
        "难度": "高级",
        "内容": "求两个稀疏矩阵的乘积 (ADT定义)。要求第一个矩阵A(m*n)的列数等于第二个矩阵B(n*p)的行数。结果矩阵C(m*p)的(i,j)元素等于A的第i行与B的第j列对应元素乘积之和。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP017",
      "name": "InitMatrix",
      "attributes": {
        "难度": "入门",
        "内容": "初始化稀疏矩阵为空矩阵，不含任何元素 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP018",
      "name": "InputMatrix",
      "attributes": {
        "难度": "中等",
        "内容": "按照特定格式（如三元组）向稀疏矩阵输入数据 (ADT定义)。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP019",
      "name": "OutputMatrix",
      "attributes": {
        "难度": "中等",
        "内容": "按照特定格式输出稀疏矩阵的内容 (ADT定义)。"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS007",
      "name": "稀疏矩阵的顺序存储结构",
      "attributes": {
        "难度": "中等",
        "内容": "使用一个结构体(SMatrix)存储，包含矩阵的行数m、列数n、非零元个数t，以及一个存储三元组(Triple)的数组sm[MaxTerms+1]。三元组在数组中通常按行主序存储。",
        "存储开销": "O(t) + O(1)。需要预定义数组最大容量MaxTerms。"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS008",
      "name": "稀疏矩阵的链接存储结构",
      "attributes": {
        "难度": "中等",
        "内容": "对稀疏矩阵对应的三元组线性表进行链接存储。有多种具体实现方式，如带行指针向量、十字链表等。",
        "存储开销": "通常为 O(t) * node_size，加上辅助指针结构的开销。"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS009",
      "name": "带行指针向量的链接存储",
      "attributes": {
        "难度": "高级",
        "内容": "将每行具有相同行号的三元组节点按列号递增顺序链接成一个单链表。使用一个行指针向量(数组vector[MaxRows+1])存储每行单链表的头指针。结构体(LMatrix)包含m, n, t和行指针向量。",
        "存储开销": "O(t) * node_size + O(m) for row pointers。"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS010",
      "name": "十字链接存储",
      "attributes": {
        "难度": "高级",
        "内容": "每个非零元素节点(CrossNode)包含row, col, val以及两个指针域：down指向同一列的下一个节点，right指向同一行的下一个节点。需要行指针向量(rv)和列指针向量(cv)分别存储行列单链表的头指针。结构体(CLMatrix)包含m, n, t, rv, cv。",
        "存储开销": "O(t) * node_size + O(m) + O(n) for pointers。"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG029",
      "name": "InitMatrix_SMatrix_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现InitMatrix for SMatrix类型。将对象M的m, n, t成员均置为0。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG030",
      "name": "InitMatrix_LMatrix_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现InitMatrix for LMatrix类型。将对象M的m, n, t置为0，并循环将行指针向量vector的所有元素(1到MaxRows)置为NULL。",
        "时间复杂度": "O(MaxRows)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG031",
      "name": "InitMatrix_CLMatrix_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现InitMatrix for CLMatrix类型。将对象M的m, n, t置为0，并循环将行指针向量rv和列指针向量cv的所有元素分别置为NULL。",
        "时间复杂度": "O(MaxRows + MaxColumns)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG032",
      "name": "InputMatrix_SMatrix_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现InputMatrix for SMatrix类型。设置M的m, n。循环读取row, col, val三元组输入，存入M.sm数组中(从下标1开始)，直到输入(0,0,0)为止。记录非零元个数k到M.t。",
        "时间复杂度": "O(t)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG033",
      "name": "InputMatrix_CLMatrix_Impl",
      "attributes": {
        "难度": "高级",
        "内容": "实现InputMatrix for CLMatrix类型。设置M.m, M.n。循环读取row, col, val三元组输入，直到(0,0,0)。对每个有效三元组：1. 创建新节点newptr。2. 将newptr链接到对应行(M.rv[row])链表的末尾。3. 将newptr链接到对应列(M.cv[col])链表的末尾。记录非零元个数k到M.t。",
        "时间复杂度": "O(t * (平均行长 + 平均列长)) (因需遍历到链表末尾)",
        "空间复杂度": "O(t) (创建t个节点)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG034",
      "name": "OutputMatrix_SMatrix_Impl",
      "attributes": {
        "难度": "入门",
        "内容": "实现OutputMatrix for SMatrix类型。遍历M.sm数组从下标1到M.t，按三元组格式 '(row, col, val)' 输出每个元素。",
        "时间复杂度": "O(t)",
        "空间复杂度": "O(1)"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG035",
      "name": "普通转置方法",
      "attributes": {
        "难度": "中等",
        "内容": "实现Transpose for SMatrix类型。创建结果矩阵S。外层循环遍历原矩阵的列(col=1 to n)。内层循环遍历M.sm数组(i=1 to t)。如果M.sm[i].col等于当前外层col，则将(col, M.sm[i].row, M.sm[i].val)存入S.sm的下一个可用位置k。",
        "时间复杂度": "O(n*t)",
        "空间复杂度": "O(t) (结果矩阵S的空间)"
      }
    },
    {
      "type": "概念",
      "ID": "03CON013",
      "name": "O(n*t)",
      "attributes": {
        "难度": "入门",
        "内容": "时间复杂度，表示算法执行时间与输入矩阵列数n和非零元素个数t的乘积大致成正比。"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG036",
      "name": "快速转置方法",
      "attributes": {
        "难度": "高级",
        "内容": "实现Transpose for SMatrix类型。利用辅助数组num[]和pot[]。1. (扫描1) 遍历M.sm，统计原矩阵每列(j=M.sm[i].col)的非零元个数num[j]++。2. 计算转置后每行(原列j)第一个元素在S.sm中的起始位置pot[j] (pot[1]=1; pot[j]=pot[j-1]+num[j-1])。3. (扫描2) 再次遍历M.sm，对于元素M.sm[i]，其列号为j=M.sm[i].col，应放入S.sm的位置为k=pot[j]。将(j, M.sm[i].row, M.sm[i].val)存入S.sm[k]，并执行pot[j]++为该列下一个元素准备位置。",
        "时间复杂度": "O(n+t)",
        "空间复杂度": "O(n+t) (结果矩阵S和辅助数组num, pot)"
      }
    },
    {
      "type": "概念",
      "ID": "03CON014",
      "name": "O(n+t)",
      "attributes": {
        "难度": "入门",
        "内容": "时间复杂度，表示算法执行时间与输入矩阵列数n和非零元素个数t之和大致成正比。"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG037",
      "name": "稀疏矩阵加法_LMatrix_Impl",
      "attributes": {
        "难度": "高级",
        "内容": "实现Add for LMatrix类型。检查M1, M2尺寸是否相同。创建结果矩阵M。逐行处理(i=1 to m)：同时遍历M1和M2的第i行链表(p1, p2)，按列号比较合并到M的第i行链表。若p1->col < p2->col，复制p1节点；若p1->col > p2->col，复制p2节点；若相等，计算和，若和不为0则创建和节点，若和为0则跳过。处理完一条链表后，将另一条链表剩余部分复制到M。记录结果非零元个数k。",
        "时间复杂度": "O(M1.t + M2.t)",
        "空间复杂度": "O(M1.t + M2.t) (结果矩阵M的空间)"
      }
    },
    {
      "type": "概念",
      "ID": "03CON015",
      "name": "O(M1.t + M2.t)",
      "attributes": {
        "难度": "入门",
        "内容": "时间复杂度，表示算法执行时间与两个输入稀疏矩阵非零元素个数之和大致成正比。"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS011",
      "name": "广义表",
      "attributes": {
        "难度": "高级",
        "内容": "线性表的推广。是n(n>=0)个元素的有限序列，元素可以是原子（单元素）或子表（本身也是广义表）。是递归定义的数据结构。表示形式如 LS=(a1, a2, ..., an)。",
        "存储开销": "通常采用链接结构，指针开销较大。"
      }
    },
    {
      "type": "概念",
      "ID": "03CON016",
      "name": "递归",
      "attributes": {
        "难度": "中等",
        "内容": "一种算法或函数定义技术，其中函数或过程直接或间接调用自身来解决问题。通常包含基本情况（终止条件）和递归步骤。"
      }
    },
    {
      "type": "概念",
      "ID": "03CON017",
      "name": "单元素",
      "attributes": {
        "难度": "入门",
        "内容": "广义表中的基本数据项，不是表类型。也称为原子。"
      }
    },
    {
      "type": "概念",
      "ID": "03CON018",
      "name": "子表",
      "attributes": {
        "难度": "入门",
        "内容": "广义表中作为元素出现的表。其本身也是一个广义表。"
      }
    },
    {
      "type": "概念",
      "ID": "03CON019",
      "name": "空表 (广义表)",
      "attributes": {
        "难度": "入门",
        "内容": "长度为0的广义表，表示为 ()。"
      }
    },
    {
      "type": "概念",
      "ID": "03CON020",
      "name": "广义表长度",
      "attributes": {
        "难度": "入门",
        "内容": "广义表最外层所包含的元素（原子或子表）的个数。"
      }
    },
    {
      "type": "概念",
      "ID": "03CON021",
      "name": "广义表深度",
      "attributes": {
        "难度": "中等",
        "内容": "广义表中括号嵌套的最大层数。空表深度为1，仅含原子的表深度为1。"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS012",
      "name": "广义表的链接存储结构",
      "attributes": {
        "难度": "高级",
        "内容": "采用动态链接结构，节点区分单元素和子表。节点结构(GLNode)通常包含: 标志域(tag, true为子表, false为原子), 联合域(union{ ElemType data; GLNode* sublist; })存储值或子表指针, 后继指针域(next)指向同层下一个元素。可能带表头附加节点以方便操作。",
        "存储开销": "每个节点包含tag、union、next指针，开销较大。"
      }
    },
    {
      "type": "操作",
      "ID": "03OP020",
      "name": "Length (广义表)",
      "attributes": {
        "难度": "中等",
        "内容": "求广义表最外层的元素个数 (ADT定义)。"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG038",
      "name": "Length_Recursive_Impl",
      "attributes": {
        "难度": "中等",
        "内容": "实现广义表Length操作。递归算法：若表GL为空(NULL)，长度为0；否则长度为 1 + Length(GL->next)。遍历顶层next指针链计数。",
        "时间复杂度": "O(n) (n为广义表长度)",
        "空间复杂度": "O(n) (递归栈深度)"
      }
    },
    {
      "type": "操作",
      "ID": "03OP021",
      "name": "Depth (广义表)",
      "attributes": {
        "难度": "高级",
        "内容": "求广义表的最大嵌套深度 (ADT定义)。"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG039",
      "name": "Depth_Recursive_Impl",
      "attributes": {
        "难度": "高级",
        "内容": "递归计算广义表深度。递归定义：若表GL为空或仅含原子，深度为1。否则，深度 = 1 + max(所有子表的深度)。算法：初始化max=0，遍历当前层节点GL，若GL->tag为true（子表），递归调用Depth(GL->sublist)得到子表深度dep，更新max = max(max, dep)。遍历完当前层后返回 max + 1。",
        "时间复杂度": "O(N) (N为广义表中总节点数)",
        "空间复杂度": "O(m) (m为广义表深度，即递归最大深度)"
      }
    },
    {
      "type": "操作",
      "ID": "03OP022",
      "name": "Create (广义表)",
      "attributes": {
        "难度": "高级",
        "内容": "根据特定格式的输入字符串，创建广义表的链接存储结构 (ADT定义)。"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG040",
      "name": "Create_Recursive_Impl",
      "attributes": {
        "难度": "高级",
        "内容": "递归实现Create操作。读入字符ch：若为'('，创建子表节点(tag=true)，递归调用Create(GL->sublist)构建子表；若为字母，创建原子节点(tag=false)，存入data；若为''（表示空表），置GL=NULL。读入下一个字符ch（逗号、右括号或分号）：若为','，递归调用Create(GL->next)构建后继；若为')'或';'，置GL->next=NULL。",
        "时间复杂度": "O(N) (N为输入字符数或总节点数)",
        "空间复杂度": "O(N) (递归栈深度可能达到N)"
      }
    },
    {
      "type": "操作",
      "ID": "03OP023",
      "name": "Print (广义表)",
      "attributes": {
        "难度": "高级",
        "内容": "按照标准括号表示法打印输出广义表 (ADT定义)。"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG041",
      "name": "Print_Recursive_Impl",
      "attributes": {
        "难度": "高级",
        "内容": "递归实现Print操作。若节点GL->tag为true（子表）：输出'('，若子表非空则递归调用Print(GL->sublist)，否则输出''，最后输出')'。若节点GL->tag为false（原子）：输出GL->data。处理完当前节点后，若GL->next非空，输出','，并递归调用Print(GL->next)。",
        "时间复杂度": "O(N) (N为广义表中总节点数)",
        "空间复杂度": "O(N) (递归栈深度可能达到N)"
      }
    }
  ],
  "relations": [
    {
      "type": "has-op",
      "关系ID": "03REL001",
      "source": "03OP001",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL002",
      "source": "03OP002",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL003",
      "source": "03OP003",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL004",
      "source": "03OP004",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL005",
      "source": "03OP005",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL006",
      "source": "03OP006",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL007",
      "source": "03OP007",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL008",
      "source": "03OP008",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL009",
      "source": "03OP009",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL010",
      "source": "03OP010",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL011",
      "source": "03OP011",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL012",
      "source": "03OP012",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL013",
      "source": "03OP013",
      "target": "03DS001",
      "attributes": {}
    },
    {
      "type": "uses",
      "关系ID": "03REL014",
      "source": "03DS002",
      "target": "03CON003",
      "attributes": {
        "使用角色": "实现基础"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL015",
      "source": "03ALG001",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL016",
      "source": "03ALG002",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL017",
      "source": "03ALG003",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL018",
      "source": "03ALG004",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL019",
      "source": "03ALG005",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL020",
      "source": "03ALG006",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL021",
      "source": "03ALG009",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL022",
      "source": "03ALG010",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL023",
      "source": "03ALG011",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL024",
      "source": "03ALG012",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL025",
      "source": "03ALG013",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL026",
      "source": "03ALG014",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL027",
      "source": "03ALG015",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL028",
      "source": "03ALG008",
      "target": "03DS002",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL029",
      "source": "03ALG008",
      "target": "03ALG007",
      "attributes": {
        "使用角色": "核心算法"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL030",
      "source": "03ALG007",
      "target": "03CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL031",
      "source": "03ALG007",
      "target": "03CON005",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL032",
      "source": "03ALG011",
      "target": "03CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL033",
      "source": "03ALG011",
      "target": "03CON006",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL034",
      "source": "03ALG012",
      "target": "03CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL035",
      "source": "03ALG012",
      "target": "03CON006",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL036",
      "source": "03ALG013",
      "target": "03CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL037",
      "source": "03ALG013",
      "target": "03CON007",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL038",
      "source": "03ALG014",
      "target": "03CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL039",
      "source": "03ALG014",
      "target": "03CON007",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL040",
      "source": "03ALG015",
      "target": "03CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL041",
      "source": "03ALG015",
      "target": "03CON007",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL042",
      "source": "03DS003",
      "target": "03CON008",
      "attributes": {
        "使用角色": "实现基础"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL043",
      "source": "03DS003",
      "target": "03DS004",
      "attributes": {
        "使用角色": "核心组件"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL044",
      "source": "03ALG016",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL045",
      "source": "03ALG017",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL046",
      "source": "03ALG018",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL047",
      "source": "03ALG019",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL048",
      "source": "03ALG020",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL049",
      "source": "03ALG021",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL050",
      "source": "03ALG022",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL051",
      "source": "03ALG023",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL052",
      "source": "03ALG024",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL053",
      "source": "03ALG025",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL054",
      "source": "03ALG026",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL055",
      "source": "03ALG027",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL056",
      "source": "03ALG028",
      "target": "03DS003",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "is-a",
      "关系ID": "03REL057",
      "source": "03DS005",
      "target": "03CON009",
      "attributes": {
        "约束条件": "非零元素远少于零元素"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL058",
      "source": "03DS005",
      "target": "03CON012",
      "attributes": {
        "使用角色": "表示方法"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL059",
      "source": "03DS005",
      "target": "03DS006",
      "attributes": {
        "使用角色": "逻辑表示"
      }
    },
    {
      "type": "has-op",
      "关系ID": "03REL060",
      "source": "03OP014",
      "target": "03DS005",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL061",
      "source": "03OP015",
      "target": "03DS005",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL062",
      "source": "03OP016",
      "target": "03DS005",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL063",
      "source": "03OP017",
      "target": "03DS005",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL064",
      "source": "03OP018",
      "target": "03DS005",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL065",
      "source": "03OP019",
      "target": "03DS005",
      "attributes": {}
    },
    {
      "type": "variant-of",
      "关系ID": "03REL066",
      "source": "03DS006",
      "target": "03DS007",
      "attributes": {
        "变体类型": "顺序存储实现"
      }
    },
    {
      "type": "variant-of",
      "关系ID": "03REL067",
      "source": "03DS006",
      "target": "03DS008",
      "attributes": {
        "变体类型": "链接存储实现"
      }
    },
    {
      "type": "variant-of",
      "关系ID": "03REL068",
      "source": "03DS008",
      "target": "03DS009",
      "attributes": {
        "变体类型": "带行指针向量"
      }
    },
    {
      "type": "variant-of",
      "关系ID": "03REL069",
      "source": "03DS008",
      "target": "03DS010",
      "attributes": {
        "变体类型": "十字链接"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL070",
      "source": "03ALG029",
      "target": "03DS007",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL071",
      "source": "03ALG030",
      "target": "03DS009",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL072",
      "source": "03ALG031",
      "target": "03DS010",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL073",
      "source": "03ALG032",
      "target": "03DS007",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL074",
      "source": "03ALG033",
      "target": "03DS010",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL075",
      "source": "03ALG034",
      "target": "03DS007",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL076",
      "source": "03ALG035",
      "target": "03DS007",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL077",
      "source": "03ALG035",
      "target": "03CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL078",
      "source": "03ALG035",
      "target": "03CON013",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL079",
      "source": "03ALG036",
      "target": "03DS007",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "优化",
      "关系ID": "03REL080",
      "source": "03ALG035",
      "target": "03ALG036",
      "attributes": {
        "优化方向": "时间复杂度"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL081",
      "source": "03ALG036",
      "target": "03CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL082",
      "source": "03ALG036",
      "target": "03CON014",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL083",
      "source": "03ALG037",
      "target": "03DS009",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL084",
      "source": "03ALG037",
      "target": "03CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL085",
      "source": "03ALG037",
      "target": "03CON015",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL086",
      "source": "03DS011",
      "target": "03CON016",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL087",
      "source": "03DS011",
      "target": "03CON017",
      "attributes": {
        "使用角色": "组成部分"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL088",
      "source": "03DS011",
      "target": "03CON018",
      "attributes": {
        "使用角色": "组成部分"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL089",
      "source": "03DS012",
      "target": "03CON008",
      "attributes": {
        "使用角色": "实现基础"
      }
    },
    {
      "type": "variant-of",
      "关系ID": "03REL090",
      "source": "03DS011",
      "target": "03DS012",
      "attributes": {
        "变体类型": "链接存储实现"
      }
    },
    {
      "type": "has-op",
      "关系ID": "03REL091",
      "source": "03OP020",
      "target": "03DS011",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL092",
      "source": "03OP021",
      "target": "03DS011",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL093",
      "source": "03OP022",
      "target": "03DS011",
      "attributes": {}
    },
    {
      "type": "has-op",
      "关系ID": "03REL094",
      "source": "03OP023",
      "target": "03DS011",
      "attributes": {}
    },
    {
      "type": "uses",
      "关系ID": "03REL095",
      "source": "03ALG038",
      "target": "03DS012",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL096",
      "source": "03ALG038",
      "target": "03CON016",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL097",
      "source": "03ALG039",
      "target": "03DS012",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL098",
      "source": "03ALG039",
      "target": "03CON016",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL099",
      "source": "03ALG040",
      "target": "03DS012",
      "attributes": {
        "使用角色": "构建对象"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL100",
      "source": "03ALG040",
      "target": "03CON016",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "uses",
      "关系ID": "03REL101",
      "source": "03ALG041",
      "target": "03DS012",
      "attributes": {
        "使用角色": "操作对象"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "03REL102",
      "source": "03ALG041",
      "target": "03CON016",
      "attributes": {
        "依赖强度": "强"
      }
    }
  ]
}
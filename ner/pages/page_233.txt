p->left=p->right=NULL;
//将新结点插入到二叉搜索树 BST 中
if(parent==NULL) BST=p;
else if(item<parent->data) parent->left=p;
else parent->right=p;

二叉搜索树插入算法的时间和空间复杂度, 与其查找和更新算法完全相同。

利用二叉搜索树的插入算法, 可以很容易地编写出生成一棵具有$n$个结点的二叉搜索树的算法, 设生成二叉搜索树的$n$个元素由数组提供, 则算法描述如下。

void CreateBSTree(BTreeNode*& BST, ElemType a[], int n)
    //利用数组中的$n$个元素建立二叉搜索树的算法
{
    BST=NULL;
    for(int i=0; i<n; i++)
        Insert(BST, a[i]);
}

在一般情况下, 此算法的时间复杂度为$O(n \times \lg n)$。

若建立二叉搜索树的一组元素的关键字为:$(38,26,62,94,35,50,28,55)$按照上述算法, 每插入一个结点后得到的二叉搜索树如图 6-2 所示。

(a) 插入 38 (b) 插入 26 (c) 插入 62 (d) 插入 94 (e) 插入 35
(f) 插入 50 (g) 插入 28 (h) 插入 55

图 6-2 二叉搜索树的生成过程

4. 删除

二叉搜索树的删除比插入要复杂一些, 因为被插入的结点都是被链接到树中的叶子结点上, 因而不会破坏树的原有结构, 也就是说, 不会破坏树中原有结点之间的链接关系。

void Coding(bool b[], int k, int n)
{
    if (k==n)
    {
        //终止递归,输出在b数组中排列好的一种组合
        for (int i=0; i<n; i++)
            cout<<b[i];
        cout<<" ";
    }
    else
    {
        //把下标为k的布尔量置0后,从下标k+1起递归调用
        b[k]=false; Coding(b, k+1, n);
        //把下标为k的布尔量置1后,从下标k+1起递归调用
        b[k]=true; Coding(b, k+1, n);
    }
}

此算法的每一次调用都要引起两次递归调用，当$k=n$时输出一种组合并结束本次调用，返回到原来调用函数的位置继续执行。若第1次非递归调用（为叙述方便，可把这次调用称为第0次递归调用）时传送给$k$的值为0，则共需要进行$2^{n+1}-1$次递归调用（含第0次递归调用）。对于$n$个布尔量共需要输出$2^n$种所有不同的组合，所以在$2^{n+1}-1$次递归调用中共有$2^n$次递归调用输出数组$b$的值。例如当$n=3$时，整个递归调用的次数为15次，输出8种不同的组合；当$n=4$时，整个递归调用的次数为31次，输出16种不同的组合。

当用户调用这个算法时，系统自动建立一个栈，该栈包含布尔型指针值参$b$的域、整型值参$k$的域和$n$的域以及返回地址$r$的域。第0次递归调用后的返回地址假定为$r1$，该算法中第1条递归调用语句执行后的返回地址（即为执行$b[k]=$true语句的地址）假定为$r2$，第2条递归调用语句执行后的返回地址（即为else语句块结束的地址，亦即算法的结束地址）假定为$r3$，若用Coding（a,0,3）去调用这个算法，其中$a$是一个元素个数大于等于3的布尔型数组，感兴趣的同学可以画出系统栈和数组$a$在算法执行过程中的变化状态，由于值参$b$和$n$的值始终不变，在栈中不用给出它们所对应的域，只用给出$k$值域和返回地址$r$即可。

此算法需要递归调用$2^{n+1}-1$次，其中有$2^n$次需要调用输出数组$b$中$n$个元素的值，所以算法的时间复杂度为$O(n\times 2^n)$，该算法所使用的系统栈的最大深度为$n+1$，所以其空间复杂度为$O(n)$，$n$为布尔量的个数。

【例4-6】编写一个递归算法，输出自然数$1\sim n$这$n$个元素的全排列。

分析：由排列组合的知识可知，$n$个元素的全排列共有$n!$种。如对于1、2、3这三个元素，其全排列为123、132、213、231、321、312，共$3!=6$种。$n!$种可分解为$n\times(n-1)!$种，而$(n-1)!$种又可分解为$(n-1)\times(n-2)!$种，以此类推。对于$n$个元素，可把它们分别放入到$n$个位置上，让第一个位置依次取每一个元素，共有$n$种不同的取法，对其后$n-1$个位置上的$n-1$个元素，共有$(n-1)!$种不同的排列，所以总共有$n\times(n-1)!$种不同的排列；同样，对于从第2个位置开始的所有元素，让第2个位置依次取除第1个位置上的元素之外的剩余$n-1$个元素，共有$n-1$种不同的取法，对其后$n-2$个位置上的$n-2$个元素，共有$(n-2)!$种不同的排列，以此类推；当进行到第$n$位置时，只有一种取法，因为前$n-1$个位置已经固定了$n-1$个元素，剩余的一个元素被放在这个位置上。

```c
//建立一个反映排序结果的新单链表并初始化为空
LNode* SL;
InitList(SL);
//从待排序的HL单链表中依次取出每个结点,按值插入到新单链表中
LNode* r=HL;                          //r指向待取出排序的一个结点,初始为HL表头结点
while(r!=NULL) {
    //为新插入的r结点在SL中顺序查找找出插入位置
    LNode* t=r->next;                 //t指向r的后继结点
    LNode* cp=SL;                     //用cp初始指向SL单链表的表头
    LNode* ap=NULL;                   //用ap指向cp的前驱结点,初始为空
    while(cp!=NULL) {
        if(r->data<cp->data) break;   //找到被插入点,退出循环
        else {
            ap=cp;                    //ap和cp指针均后移,实现顺序向后比较
            cp=cp->next;
        }
    }
    //实现插入操作
    if(ap==NULL) {
        r->next=SL;                   //把r结点插入到表头
        SL=r;
    }
    else {
        r->next=cp;                   //把r结点插入ap和cp结点之间
        ap->next=r;                   //cp可能为空,则r成为SL的表尾
    }
    //使r指向原单链表的下一个结点
    r=t;
}
//由引用参数带回新单链表的表头指针
HL=SL;
}

在上面对单链表进行的11种操作算法中，第1、4种算法的时间复杂度为$O(1)$；第2、3及5~10种算法的时间复杂度为$O(n)$；第11种算法的时间复杂度为$O(n^2)$。若只在单链表的表头插入或删除结点，其时间复杂度均为$O(1)$。上述每个算法的空间复杂度均为$O(1)$。由于对单链表的插入和删除元素的操作只进行元素的比较，不进行元素的移动，而对顺序存储的线性表操作既需要元素的比较，又需要元素的移动，所以当处理的数据量较大，同时每个数据占用的字节数较多时，在相同数量级的情况下，顺序表操作往往比单链表操作要花费更多的时间。

要上机调试上述对单链表操作的算法，只要对本章第2节的调试程序稍加修改即可。主要是把顺序表List类型定义替换为LNode结点类型定义，把主函数中的表对象t的类型List替换为LNode*。

对于由数组中元素结点构成的单链表，其操作算法与上述独立结点构成的单链表的情
```

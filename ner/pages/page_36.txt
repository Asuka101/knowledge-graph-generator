调用函数传递来的, 对于引用参数将不占有这方面的空间, 而对于值参数将占有这方面的空间。所以在允许的情况下，尽量采用引用参数或指针参数，减少使用值参数，对于数据类型长度较大的参数更应如此。

存储算法本身所占用的存储空间与算法书写的长短成正比, 要压缩这方面的存储空间, 就必须编写出较短的算法, 如编写成递归算法通常就比相应的非递归算法要短。

算法在运行过程中临时占用的存储空间随算法的不同而异, 有的算法只需要占用少量的临时工作单元, 而且不随问题规模的大小而改变, 称这种算法是 “就地” 进行的, 是节省存储的算法, 如本节中介绍过的几个算法都是如此。有的算法需要占用的临时工作单元数与解决问题的规模$n$有关, 它随着$n$的增大而增大, 当$n$较大时, 将占用较多的存储单元, 将在第 10 章中介绍的快速排序和归并排序算法就属于这种情况。

分析一个算法所占用的存储空间要从各方面综合考虑。如对于递归算法来说, 一般都比较简短, 算法本身所占用的存储空间较少, 但运行时需要一个附加的工作栈, 从而占用较多的临时工作单元; 若写成非递归算法, 一般可能比较长, 算法本身占用的存储空间较多, 但运行时将可能需要较少的存储单元。

一个算法的空间复杂度通常是考虑在运行过程中为局部变量分配的存储空间的大小, 它包括为参数表中值参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。若一个算法为递归算法, 其空间复杂度为递归所使用的工作栈空间的大小, 它等于一次调用所分配的临时存储空间的大小乘以被调用的次数 (即为递归调用的次数加 1 , 这个 1 表示开始进行的一次非递归调用) 。算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量, 即不随被处理数据量$n$的大小而改变时, 则表示为$O(1)$, 当一个算法的空间复杂度以 2 为底的$n$的对数成正比时, 则表示为$O(\log n)$, 当一个算法的空间复杂度与$n$成线性比例关系时, 则表示为$O(n)$。

注意: 若形参为数组, 则其实质上为一个指针值参数, 只需要为它分配一个存储由实参传送来的一个地址指针的空间, 即一个机器字长空间, 通常为 2 或 4 个字节。

对于一个算法, 其时间复杂度和空间复杂度往往是相互影响的, 当追求一个较好的时间复杂度时, 可能会使空间复杂度的性能变差, 即可能导致占用较多的存储空间; 反之,当追求一个较好的空间复杂度时, 可能会使时间复杂度的性能变差, 即可能导致占用较长的运行时间。另外, 算法的所有性能之间都存在着或多或少的相互影响。因此, 当设计一个算法 (特别是大型算法) 时, 要综合考虑算法的各项性能、算法的使用频率、算法处理的数据量的大小、算法描述语言的特性、算法运行的机器系统环境等诸多因素, 通过权衡利弊才能够设计出比较满意的算法。

*1.4 与算法描述有关的 C++知识

下面对 C++语言的有关内容做简要说明, 为以后各章分析和编写算法做准备, 此部分可不作为教学讲授内容, 而留给学生自学。

{
  "entities": [
    {
      "type": "数据结构",
      "ID": "05DS001",
      "name": "树",
      "attributes": {
        "难度": "入门",
        "内容": "一种重要的非线性数据结构，由n(n>=0)个结点组成。n=0时为空树；n>0时有且仅有一个称为根的结点，其余结点分为m(m>=0)棵互不相交的子树，每棵子树也是一棵树。树的定义是递归的。",
        "存储开销": "依赖具体实现，如顺序存储或链接存储",
        "核心特性": "层次结构, 递归定义",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON001",
      "name": "根",
      "attributes": {
        "难度": "入门",
        "内容": "非空树中有且仅有的一个没有前驱的结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON002",
      "name": "子树",
      "attributes": {
        "难度": "入门",
        "内容": "非空树中，根结点以外的结点被分为m(m>=0)棵互不相交的集合，每个集合本身也是一棵树，称为根的子树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON003",
      "name": "前驱",
      "attributes": {
        "难度": "入门",
        "内容": "树中一个结点是其每个子树的根结点的前驱。除根结点外，其余每个结点有且仅有一个前驱结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON004",
      "name": "后继",
      "attributes": {
        "难度": "入门",
        "内容": "树中一个结点的每个子树的根结点是该结点的后继。一个结点可以有任意多个(含0个)后继。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON005",
      "name": "度",
      "attributes": {
        "难度": "入门",
        "内容": "结点的度是指结点拥有的子树数或后继结点数。树的度是指树中所有结点的度的最大值。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON006",
      "name": "叶子结点",
      "attributes": {
        "难度": "入门",
        "内容": "度等于0的结点，也称终端结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON007",
      "name": "分支结点",
      "attributes": {
        "难度": "入门",
        "内容": "度大于0的结点，也称非终端结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON008",
      "name": "孩子结点",
      "attributes": {
        "难度": "入门",
        "内容": "一个结点的子树的根，或该结点的后继，被称为该结点的孩子（或子女、儿子）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON009",
      "name": "双亲结点",
      "attributes": {
        "难度": "入门",
        "内容": "孩子结点的直接前驱结点，被称为孩子结点的双亲（或父亲、父母）。根结点没有双亲。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON010",
      "name": "兄弟结点",
      "attributes": {
        "难度": "入门",
        "内容": "具有同一双亲的孩子结点互称兄弟。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON011",
      "name": "子孙",
      "attributes": {
        "难度": "入门",
        "内容": "一个结点的所有子树中的结点被称为该结点的子孙。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON012",
      "name": "祖先",
      "attributes": {
        "难度": "入门",
        "内容": "从树根结点到达该结点的路径上经过的所有结点被称为该结点的祖先。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON013",
      "name": "层数",
      "attributes": {
        "难度": "入门",
        "内容": "结点的层数从树根开始定义，根结点为第1层，它的孩子结点为第2层，以此类推。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON014",
      "name": "深度",
      "attributes": {
        "难度": "入门",
        "内容": "树中所有结点的最大层数，也称高度。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON015",
      "name": "有序树",
      "attributes": {
        "难度": "入门",
        "内容": "若树中各结点的子树是按照一定的次序从左向右安排的，则称之为有序树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON016",
      "name": "无序树",
      "attributes": {
        "难度": "入门",
        "内容": "若树中各结点的子树没有固定的次序，则称之为无序树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON017",
      "name": "森林",
      "attributes": {
        "难度": "入门",
        "内容": "m(m>=0)棵互不相交的树的集合。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS002",
      "name": "k叉树",
      "attributes": {
        "难度": "中等",
        "内容": "度为k的树，即每个结点最多有k个孩子。性质包括：结点数等于所有结点的度数加1；第i层至多有k^(i-1)个结点；深度为h的k叉树至多有(k^h-1)/(k-1)个结点；n个结点的k叉树最小深度为ceil(log_k(n(k-1)+1))。",
        "存储开销": "顺序存储适合满k叉树或完全k叉树，链接存储（标准方式、广义标准方式）",
        "核心特性": "度不超过k",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS003",
      "name": "二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "度为2的有序树。递归定义：空树或由一个根结点和两棵互不相交的左、右子树组成，左右子树也是二叉树。性质包括：终端结点数等于双分支结点数加1；第i层至多有2^(i-1)个结点；深度为h的二叉树至多有2^h-1个结点。",
        "存储开销": "顺序存储（适合完全二叉树）、链接存储（二叉链表，可带双亲指针）",
        "核心特性": "度<=2, 有序（区分左右子树）",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON018",
      "name": "左子树",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树根结点的左边的子树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON019",
      "name": "右子树",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树根结点的右边的子树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON020",
      "name": "左孩子",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树中一个结点的左子树的根结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON021",
      "name": "右孩子",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树中一个结点的右子树的根结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS004",
      "name": "满二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "深度为h且含有2^h-1个结点的二叉树。树中的每一层都达到最大结点数。",
        "存储开销": "非常适合顺序存储",
        "核心特性": "除叶子结点外，每个结点的度都为2",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS005",
      "name": "完全二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "深度为h，除第h层外，其他各层(1~h-1)的结点数都达到最大个数，第h层的所有结点都连续集中在最左边。性质涉及结点编号与孩子/双亲关系。",
        "存储开销": "非常适合顺序存储",
        "核心特性": "按层序编号连续，结构接近满二叉树",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "05CON022",
      "name": "二叉树抽象数据类型",
      "attributes": {
        "难度": "中等",
        "内容": "定义了二叉树的数据集合及其上的操作集合。操作通常包括初始化、创建、判空、遍历（前序、中序、后序、层序）、查找、求深度、打印、清除等。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS006",
      "name": "二叉树顺序存储结构",
      "attributes": {
        "难度": "中等",
        "内容": "使用一维数组按层序编号存储二叉树结点。下标i的结点的左孩子为2i，右孩子为2i+1，双亲为floor(i/2)。适合完全二叉树，对一般二叉树可能浪费大量空间。",
        "存储开销": "O(2^depth)，对非完全二叉树可能很高",
        "核心特性": "随机访问父子结点（通过下标计算），空间效率依赖树形态",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS007",
      "name": "二叉树链接存储结构",
      "attributes": {
        "难度": "中等",
        "内容": "每个结点包含数据域、指向左孩子的指针域和指向右孩子的指针域（二叉链表）。可以增加指向双亲结点的指针域（带双亲指针的二叉链表）。",
        "存储开销": "O(n)，n为结点数",
        "核心特性": "动态存储，空间效率较高，插入删除方便",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG001",
      "name": "前序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树遍历方法：访问根结点 -> 递归遍历左子树 -> 递归遍历右子树。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 分治",
        "适用场景": "复制树、表达式树求前缀表达式",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG002",
      "name": "中序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树遍历方法：递归遍历左子树 -> 访问根结点 -> 递归遍历右子树。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 分治",
        "适用场景": "对二叉搜索树得到有序序列",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG003",
      "name": "后序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树遍历方法：递归遍历左子树 -> 递归遍历右子树 -> 访问根结点。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 分治",
        "适用场景": "计算表达式树的值、释放树结点空间",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG004",
      "name": "按层遍历",
      "attributes": {
        "难度": "中等",
        "内容": "二叉树遍历方法：从上到下、同一层从左到右访问结点。通常使用队列实现。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(w)",
        "设计思想": "迭代, 队列",
        "适用场景": "求树的宽度、广度优先搜索",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG005",
      "name": "初始化二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "将二叉树设置为空树，通常是将根指针置为NULL。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "基本操作",
        "适用场景": "创建新二叉树前",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG006",
      "name": "建立二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "根据特定输入格式（如广义表表示）构建二叉树的链接存储结构。文本描述了使用栈辅助从广义表字符串创建的方法。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "迭代, 栈辅助",
        "适用场景": "从字符串或序列表示构造内存中的二叉树",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG007",
      "name": "判空二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "判断二叉树是否为空，通常检查根指针是否为NULL。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "基本检查",
        "适用场景": "操作前检查树状态",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG008",
      "name": "求二叉树深度",
      "attributes": {
        "难度": "入门",
        "内容": "计算二叉树的最大层数。递归定义：空树深度0，非空树深度 = max(左子树深度, 右子树深度) + 1。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 分治",
        "适用场景": "分析树的高度和平衡性",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG009",
      "name": "查找二叉树结点",
      "attributes": {
        "难度": "入门",
        "内容": "在二叉树中查找具有特定值的结点。通常采用类似前序遍历的递归方式。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 遍历",
        "适用场景": "定位、访问或修改特定结点",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG010",
      "name": "输出二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "将二叉树以某种可读形式（如广义表）打印出来。文本描述了基于前序遍历思想的广义表输出算法。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 遍历",
        "适用场景": "可视化、调试",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG011",
      "name": "清除二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "删除二叉树中的所有结点，释放占用的内存空间。通常采用类似后序遍历的递归方式。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 后序遍历",
        "适用场景": "销毁不再使用的二叉树对象",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS008",
      "name": "理想平衡二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "除最后一层外，其余各层都是满的，而最后一层上的结点可以任意分布的二叉树。包含满二叉树和完全二叉树。具有n个结点的理想平衡二叉树深度为ceil(log2(n+1))或floor(log2(n))+1。",
        "存储开销": "O(n)",
        "核心特性": "高度约为log(n)，相对平衡",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS009",
      "name": "树的顺序存储结构",
      "attributes": {
        "难度": "中等",
        "内容": "对k叉树结点按规则编号（根为1，结点i的孩子为k*i-(k-2)到k*i+1），用一维数组存储。结点j的父结点为floor((j-2)/k)+1。适合满k叉树和完全k叉树，否则浪费空间。",
        "存储开销": "依赖树的度和形态，可能很高",
        "核心特性": "通过下标计算父子关系，空间效率依赖树形态",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS010",
      "name": "树的链接存储结构",
      "attributes": {
        "难度": "中等",
        "内容": "常见方式包括：标准方式（每个结点含数据域和k个指向孩子的指针域）、广义标准方式（标准方式基础上增加指向双亲的指针域）、二叉树方式（孩子兄弟表示法）。",
        "存储开销": "标准方式O(n*k)，孩子兄弟表示法O(n)",
        "核心特性": "动态存储，灵活表示树结构",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS011",
      "name": "孩子兄弟表示法",
      "attributes": {
        "难度": "中等",
        "内容": "将任意树转换为二叉树形式存储。每个结点包含数据域、指向第一个孩子的指针（作二叉树的左孩子指针）和指向下一个兄弟的指针（作二叉树的右孩子指针）。",
        "存储开销": "O(n)",
        "核心特性": "用二叉链表存储任意树，空间效率高",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG012",
      "name": "树的先根遍历",
      "attributes": {
        "难度": "入门",
        "内容": "普通树遍历方法：先访问根结点，然后从左到右依次递归先根遍历每棵子树。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 分治",
        "适用场景": "获取树的某种线性序列",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG013",
      "name": "树的后根遍历",
      "attributes": {
        "难度": "入门",
        "内容": "普通树遍历方法：从左到右依次递归后根遍历根结点的每棵子树，然后再访问根结点。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 分治",
        "适用场景": "计算依赖子树结果的操作（如计算树的结点数）",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG014",
      "name": "树的按层遍历",
      "attributes": {
        "难度": "中等",
        "内容": "普通树遍历方法：按层访问，先访问第1层（根），再从左到右访问第2层，依次进行。通常使用队列实现。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(w)",
        "设计思想": "迭代, 队列",
        "适用场景": "广度优先搜索",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG015",
      "name": "建立树",
      "attributes": {
        "难度": "中等",
        "内容": "根据广义表表示建立k叉树的标准链接存储结构。算法使用两个栈，一个存结点指针，一个存孩子序号。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "迭代, 栈辅助",
        "适用场景": "从字符串表示构造内存中的k叉树",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG016",
      "name": "查找树结点",
      "attributes": {
        "难度": "入门",
        "内容": "在k叉树中查找具有特定值的结点。采用类似先根遍历的递归方式。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 遍历",
        "适用场景": "定位、访问或修改特定结点",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG017",
      "name": "输出树",
      "attributes": {
        "难度": "入门",
        "内容": "以广义表形式输出按标准链接方式存储的k叉树。采用类似先根遍历的递归方式。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 遍历",
        "适用场景": "可视化、调试",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG018",
      "name": "求树深度",
      "attributes": {
        "难度": "入门",
        "内容": "计算k叉树的最大层数。递归定义：空树深度0，非空树深度 = max(所有子树深度) + 1。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 分治",
        "适用场景": "分析树的高度",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG019",
      "name": "清除树",
      "attributes": {
        "难度": "入门",
        "内容": "删除k叉树中的所有结点，释放占用的内存空间。采用类似后根遍历的递归方式。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归, 后根遍历",
        "适用场景": "销毁不再使用的k叉树对象",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS012",
      "name": "队列",
      "attributes": {
        "难度": "入门",
        "内容": "一种先进先出（FIFO）的线性数据结构。在本章中用于实现树和二叉树的按层遍历算法。",
        "存储开销": "O(capacity) 或 O(n)",
        "核心特性": "FIFO（先进先出）",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS013",
      "name": "栈",
      "attributes": {
        "难度": "入门",
        "内容": "一种后进先出（LIFO）的线性数据结构。在本章中用于辅助从广义表建立二叉树和树的链接存储结构。递归遍历算法隐式使用系统调用栈。",
        "存储开销": "O(capacity) 或 O(n)",
        "核心特性": "LIFO（后进先出）",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    }
  ],
  "relations": [
    {
      "type": "继承",
      "ID": "05REL001",
      "source": "05DS003",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "ID": "05REL002",
      "source": "05DS003",
      "target": "05CON015"
    },
    {
      "type": "继承",
      "ID": "05REL003",
      "source": "05DS004",
      "target": "05DS003"
    },
    {
      "type": "继承",
      "ID": "05REL004",
      "source": "05DS005",
      "target": "05DS003"
    },
    {
      "type": "继承",
      "ID": "05REL005",
      "source": "05DS004",
      "target": "05DS005"
    },
    {
      "type": "继承",
      "ID": "05REL006",
      "source": "05DS004",
      "target": "05DS008"
    },
    {
      "type": "继承",
      "ID": "05REL007",
      "source": "05DS005",
      "target": "05DS008"
    },
    {
      "type": "操作绑定",
      "ID": "05REL008",
      "source": "05ALG001",
      "target": "05DS003"
    },
    {
      "type": "操作绑定",
      "ID": "05REL009",
      "source": "05ALG002",
      "target": "05DS003"
    },
    {
      "type": "操作绑定",
      "ID": "05REL010",
      "source": "05ALG003",
      "target": "05DS003"
    },
    {
      "type": "操作绑定",
      "ID": "05REL011",
      "source": "05ALG004",
      "target": "05DS003"
    },
    {
      "type": "使用",
      "ID": "05REL012",
      "source": "05ALG004",
      "target": "05DS012"
    },
    {
      "type": "操作绑定",
      "ID": "05REL013",
      "source": "05ALG005",
      "target": "05DS003"
    },
    {
      "type": "操作绑定",
      "ID": "05REL014",
      "source": "05ALG006",
      "target": "05DS003"
    },
    {
      "type": "使用",
      "ID": "05REL015",
      "source": "05ALG006",
      "target": "05DS013"
    },
    {
      "type": "操作绑定",
      "ID": "05REL016",
      "source": "05ALG007",
      "target": "05DS003"
    },
    {
      "type": "操作绑定",
      "ID": "05REL017",
      "source": "05ALG008",
      "target": "05DS003"
    },
    {
      "type": "操作绑定",
      "ID": "05REL018",
      "source": "05ALG009",
      "target": "05DS003"
    },
    {
      "type": "操作绑定",
      "ID": "05REL019",
      "source": "05ALG010",
      "target": "05DS003"
    },
    {
      "type": "操作绑定",
      "ID": "05REL020",
      "source": "05ALG011",
      "target": "05DS003"
    },
    {
      "type": "理论依赖",
      "ID": "05REL021",
      "source": "05DS006",
      "target": "05DS005"
    },
    {
      "type": "理论依赖",
      "ID": "05REL022",
      "source": "05DS007",
      "target": "05DS003"
    },
    {
      "type": "继承",
      "ID": "05REL023",
      "source": "05DS002",
      "target": "05DS001"
    },
    {
      "type": "操作绑定",
      "ID": "05REL024",
      "source": "05ALG012",
      "target": "05DS001"
    },
    {
      "type": "操作绑定",
      "ID": "05REL025",
      "source": "05ALG013",
      "target": "05DS001"
    },
    {
      "type": "操作绑定",
      "ID": "05REL026",
      "source": "05ALG014",
      "target": "05DS001"
    },
    {
      "type": "使用",
      "ID": "05REL027",
      "source": "05ALG014",
      "target": "05DS012"
    },
    {
      "type": "操作绑定",
      "ID": "05REL028",
      "source": "05ALG015",
      "target": "05DS001"
    },
    {
      "type": "使用",
      "ID": "05REL029",
      "source": "05ALG015",
      "target": "05DS013"
    },
    {
      "type": "操作绑定",
      "ID": "05REL030",
      "source": "05ALG016",
      "target": "05DS001"
    },
    {
      "type": "操作绑定",
      "ID": "05REL031",
      "source": "05ALG017",
      "target": "05DS001"
    },
    {
      "type": "操作绑定",
      "ID": "05REL032",
      "source": "05ALG018",
      "target": "05DS001"
    },
    {
      "type": "操作绑定",
      "ID": "05REL033",
      "source": "05ALG019",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "ID": "05REL034",
      "source": "05DS011",
      "target": "05DS001"
    },
    {
      "type": "使用",
      "ID": "05REL035",
      "source": "05DS011",
      "target": "05DS003"
    },
    {
      "type": "理论依赖",
      "ID": "05REL036",
      "source": "05DS009",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "ID": "05REL037",
      "source": "05DS010",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "ID": "05REL038",
      "source": "05DS001",
      "target": "05CON001"
    },
    {
      "type": "理论依赖",
      "ID": "05REL039",
      "source": "05DS001",
      "target": "05CON002"
    },
    {
      "type": "理论依赖",
      "ID": "05REL040",
      "source": "05DS001",
      "target": "05CON005"
    },
    {
      "type": "理论依赖",
      "ID": "05REL041",
      "source": "05DS001",
      "target": "05CON006"
    },
    {
      "type": "理论依赖",
      "ID": "05REL042",
      "source": "05DS001",
      "target": "05CON007"
    },
    {
      "type": "理论依赖",
      "ID": "05REL043",
      "source": "05DS001",
      "target": "05CON008"
    },
    {
      "type": "理论依赖",
      "ID": "05REL044",
      "source": "05DS001",
      "target": "05CON009"
    },
    {
      "type": "理论依赖",
      "ID": "05REL045",
      "source": "05DS001",
      "target": "05CON010"
    },
    {
      "type": "理论依赖",
      "ID": "05REL046",
      "source": "05DS001",
      "target": "05CON013"
    },
    {
      "type": "理论依赖",
      "ID": "05REL047",
      "source": "05DS001",
      "target": "05CON014"
    },
    {
      "type": "理论依赖",
      "ID": "05REL048",
      "source": "05CON015",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "ID": "05REL049",
      "source": "05CON016",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "ID": "05REL050",
      "source": "05CON017",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "ID": "05REL051",
      "source": "05DS003",
      "target": "05CON018"
    },
    {
      "type": "理论依赖",
      "ID": "05REL052",
      "source": "05DS003",
      "target": "05CON019"
    },
    {
      "type": "理论依赖",
      "ID": "05REL053",
      "source": "05DS003",
      "target": "05CON020"
    },
    {
      "type": "理论依赖",
      "ID": "05REL054",
      "source": "05DS003",
      "target": "05CON021"
    },
    {
      "type": "理论依赖",
      "ID": "05REL055",
      "source": "05ALG001",
      "target": "05CON022"
    },
    {
      "type": "理论依赖",
      "ID": "05REL056",
      "source": "05ALG002",
      "target": "05CON022"
    },
    {
      "type": "理论依赖",
      "ID": "05REL057",
      "source": "05ALG003",
      "target": "05CON022"
    },
    {
      "type": "理论依赖",
      "ID": "05REL058",
      "source": "05ALG004",
      "target": "05CON022"
    },
    {
      "type": "理论依赖",
      "ID": "05REL059",
      "source": "05ALG005",
      "target": "05CON022"
    },
    {
      "type": "理论依赖",
      "ID": "05REL060",
      "source": "05ALG006",
      "target": "05CON022"
    },
    {
      "type": "理论依赖",
      "ID": "05REL061",
      "source": "05ALG007",
      "target": "05CON022"
    },
    {
      "type": "理论依赖",
      "ID": "05REL062",
      "source": "05ALG008",
      "target": "05CON022"
    },
    {
      "type": "理论依赖",
      "ID": "05REL063",
      "source": "05ALG009",
      "target": "05CON022"
    },
    {
      "type": "理论依赖",
      "ID": "05REL064",
      "source": "05ALG010",
      "target": "05CON022"
    },
    {
      "type": "理论依赖",
      "ID": "05REL065",
      "source": "05ALG011",
      "target": "05CON022"
    },
    {
      "type": "理论依赖",
      "ID": "05REL066",
      "source": "05DS001",
      "target": "05CON003"
    },
    {
      "type": "理论依赖",
      "ID": "05REL067",
      "source": "05DS001",
      "target": "05CON004"
    },
    {
      "type": "理论依赖",
      "ID": "05REL068",
      "source": "05DS001",
      "target": "05CON011"
    },
    {
      "type": "理论依赖",
      "ID": "05REL069",
      "source": "05DS001",
      "target": "05CON012"
    }
  ]
}
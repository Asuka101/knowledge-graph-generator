{
  "entities": [
    {
      "type": "数据结构",
      "ID": "04DS001",
      "name": "栈",
      "attributes": {
        "难度": "入门",
        "内容": "一种运算受限的线性表，仅允许在表的一端（栈顶）进行插入（入栈）和删除（出栈）运算。具有后进先出（LIFO）的特性。也称堆栈。",
        "存储开销": "顺序存储需要预分配空间或动态扩展，链式存储需要额外指针开销。",
        "核心特性": "后进先出 (LIFO)"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS002",
      "name": "队列",
      "attributes": {
        "难度": "入门",
        "内容": "一种运算受限的线性表，允许在表的一端（队尾）进行插入（入队），在另一端（队首）进行删除（出队）。具有先进先出（FIFO）的特性。",
        "存储开销": "顺序存储（循环队列）需要预分配空间或动态扩展，链式存储需要额外指针开销。",
        "核心特性": "先进先出 (FIFO)"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS003",
      "name": "线性表",
      "attributes": {
        "难度": "入门",
        "内容": "由n（n≥0）个数据特性相同的元素构成的有限序列。是栈和队列的基础逻辑结构。",
        "存储开销": "取决于具体实现（顺序或链式）。",
        "核心特性": "序列性、有限性"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS004",
      "name": "循环队列",
      "attributes": {
        "难度": "入门",
        "内容": "利用取模运算将顺序存储的队列空间视为一个环状空间，以解决顺序队列的“假溢出”问题。",
        "存储开销": "固定大小数组，可能牺牲一个存储单元以区分队空和队满，或使用计数器。",
        "核心特性": "先进先出 (FIFO)、空间循环利用"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS005",
      "name": "优先级队列",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的队列，其中的元素带有优先级。出队时，优先级最高的元素最先出队。通常使用堆实现。",
        "存储开销": "通常基于堆实现，存储开销类似堆。",
        "核心特性": "按优先级出队"
      }
    },
    {
      "type": "概念",
      "ID": "04CON001",
      "name": "栈顶",
      "attributes": {
        "难度": "入门",
        "内容": "栈允许进行插入和删除操作的一端。栈顶元素是最后插入且最先被删除的元素。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON002",
      "name": "栈底",
      "attributes": {
        "难度": "入门",
        "内容": "栈不允许进行插入和删除操作的一端，与栈顶相对。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON003",
      "name": "队首",
      "attributes": {
        "难度": "入门",
        "内容": "队列允许进行删除操作的一端。队首元素是最先进入队列且最先被删除的元素。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON004",
      "name": "队尾",
      "attributes": {
        "难度": "入门",
        "内容": "队列允许进行插入操作的一端。新元素总是插入到队尾。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON005",
      "name": "后进先出",
      "attributes": {
        "难度": "入门",
        "内容": "Last-In, First-Out (LIFO)。描述了栈的操作特性，即最后进入栈的元素最先离开栈。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON006",
      "name": "先进先出",
      "attributes": {
        "难度": "入门",
        "内容": "First-In, First-Out (FIFO)。描述了队列的操作特性，即最先进入队列的元素最先离开队列。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON007",
      "name": "递归",
      "attributes": {
        "难度": "中等",
        "内容": "一种解决问题的方法，其中函数的定义包含对自身的调用。需要有明确的终止条件以防止无限调用。常用于解决可以分解为同类子问题的问题，系统通常使用栈来实现递归调用。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON008",
      "name": "中缀表示",
      "attributes": {
        "难度": "入门",
        "内容": "一种常见的算术表达式表示法，其中运算符位于其操作数之间。计算时需要考虑运算符优先级和括号。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON009",
      "name": "后缀表示",
      "attributes": {
        "难度": "入门",
        "内容": "也称为逆波兰表示法（Reverse Polish Notation, RPN）。一种算术表达式表示法，其中运算符位于其操作数之后。计算时无需考虑优先级和括号，通常使用栈进行求值。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON011",
      "name": "顺序存储结构",
      "attributes": {
        "难度": "入门",
        "内容": "用一组地址连续的存储单元依次存储数据元素的存储结构。逻辑上相邻的元素在物理位置上通常也相邻。主要指数组实现。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON012",
      "name": "链式存储结构",
      "attributes": {
        "难度": "入门",
        "内容": "用一组任意的存储单元存储数据元素（可以不连续），每个存储单元包含数据域和指针域，通过指针域将逻辑上相邻的元素链接起来。主要指链表实现。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG001",
      "name": "入栈",
      "attributes": {
        "难度": "入门",
        "内容": "将元素添加到栈顶的操作。顺序栈中top指针加1并赋值，链栈中创建新节点并修改头指针。",
        "时间复杂度": "O(1)（顺序栈不考虑扩容）",
        "空间复杂度": "O(1)",
        "设计思想": "栈的基本操作",
        "适用场景": "向栈中添加元素"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG002",
      "name": "出栈",
      "attributes": {
        "难度": "入门",
        "内容": "删除并（可选地）返回栈顶元素的操作。顺序栈中取值并top指针减1，链栈中取值、修改头指针并释放原头结点。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "栈的基本操作",
        "适用场景": "从栈中移除并获取元素"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG003",
      "name": "读取栈顶元素",
      "attributes": {
        "难度": "入门",
        "内容": "返回栈顶元素的值，但不删除它。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "栈的基本操作",
        "适用场景": "查看栈顶元素而不修改栈"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG004",
      "name": "判断栈空",
      "attributes": {
        "难度": "入门",
        "内容": "检查栈中是否包含元素。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "栈的基本操作",
        "适用场景": "执行出栈或读取栈顶前的检查"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG005",
      "name": "初始化栈",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空栈。顺序栈中设置top为-1或0（取决于实现），链栈中设置头指针为NULL。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)（不计存储空间本身）",
        "设计思想": "栈的构造",
        "适用场景": "使用栈之前"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG006",
      "name": "清空栈",
      "attributes": {
        "难度": "入门",
        "内容": "移除栈中所有元素，使其变为空栈，并可能释放相关资源。",
        "时间复杂度": "O(1)（顺序栈），O(n)（链栈，需遍历释放节点）",
        "空间复杂度": "O(1)",
        "设计思想": "栈的重置或销毁",
        "适用场景": "重用栈或释放内存"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG007",
      "name": "入队",
      "attributes": {
        "难度": "入门",
        "内容": "将元素添加到队尾的操作。",
        "时间复杂度": "O(1)（循环队列不考虑扩容，链队需要维护尾指针）",
        "空间复杂度": "O(1)",
        "设计思想": "队列的基本操作",
        "适用场景": "向队列中添加元素"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG008",
      "name": "出队",
      "attributes": {
        "难度": "入门",
        "内容": "删除并（可选地）返回队首元素的操作。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "队列的基本操作",
        "适用场景": "从队列中移除并获取元素"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG009",
      "name": "读取队首元素",
      "attributes": {
        "难度": "入门",
        "内容": "返回队首元素的值，但不删除它。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "队列的基本操作",
        "适用场景": "查看队首元素而不修改队列"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG010",
      "name": "判断队列空",
      "attributes": {
        "难度": "入门",
        "内容": "检查队列中是否包含元素。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "队列的基本操作",
        "适用场景": "执行出队或读取队首前的检查"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG011",
      "name": "初始化队列",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空队列。循环队列中设置front=rear=0，链队中设置front=rear=NULL。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)（不计存储空间本身）",
        "设计思想": "队列的构造",
        "适用场景": "使用队列之前"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG012",
      "name": "清空队列",
      "attributes": {
        "难度": "入门",
        "内容": "移除队列中所有元素，使其变为空队列，并可能释放相关资源。",
        "时间复杂度": "O(1)（循环队列），O(n)（链队，需遍历释放节点）",
        "空间复杂度": "O(1)",
        "设计思想": "队列的重置或销毁",
        "适用场景": "重用队列或释放内存"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG013",
      "name": "后缀表达式求值",
      "attributes": {
        "难度": "中等",
        "内容": "使用栈计算后缀表示（逆波兰表示）的算术表达式的值。遇到操作数则入栈，遇到运算符则弹出所需操作数进行计算，结果再入栈。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(n)（栈空间）",
        "设计思想": "栈应用",
        "适用场景": "计算无需括号和优先级的表达式"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG014",
      "name": "中缀转后缀",
      "attributes": {
        "难度": "中等",
        "内容": "将中缀表示的算术表达式转换为等价的后缀表示。使用栈来暂存运算符，根据运算符优先级和括号规则进行转换。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(n)（栈空间）",
        "设计思想": "栈应用",
        "适用场景": "表达式求值预处理"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG015",
      "name": "括号配对检查",
      "attributes": {
        "难度": "入门",
        "内容": "检查一个包含括号（如(), [], {}）的字符串中的括号是否正确配对。使用栈，遇到左括号入栈，遇到右括号检查栈顶是否匹配，若匹配则出栈，否则错误。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(n)（栈空间）",
        "设计思想": "栈应用",
        "适用场景": "语法检查、代码编辑"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG016",
      "name": "进制转换",
      "attributes": {
        "难度": "入门",
        "内容": "将一个十进制数转换为其他进制（如二进制、八进制、十六进制）的表示。通常使用除基取余法，将余数依次入栈，最后依次出栈得到结果。",
        "时间复杂度": "O(log_r N)，r为目标基数，N为数值",
        "空间复杂度": "O(log_r N)（栈空间）",
        "设计思想": "栈应用",
        "适用场景": "数值表示转换"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG017",
      "name": "递归阶乘",
      "attributes": {
        "难度": "入门",
        "内容": "使用递归方法计算非负整数n的阶乘 (n!)。递归关系为 f(n) = n * f(n-1)，基本情况为 f(0) = 1。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(n)（递归栈深度）",
        "设计思想": "递归",
        "适用场景": "教学示例、简单递归问题"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG018",
      "name": "布尔量组合输出",
      "attributes": {
        "难度": "中等",
        "内容": "输出n个布尔变量所有可能的2^n种取值组合。通常使用递归实现，每次递归决定一位是0还是1。",
        "时间复杂度": "O(n * 2^n)（包含输出时间）",
        "空间复杂度": "O(n)（递归栈深度）",
        "设计思想": "递归、回溯",
        "适用场景": "组合生成、状态枚举"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG019",
      "name": "全排列",
      "attributes": {
        "难度": "中等",
        "内容": "生成n个不同元素的所有n!种排列顺序。通常使用递归和交换策略实现。",
        "时间复杂度": "O(n * n!)（包含输出时间）",
        "空间复杂度": "O(n)（递归栈深度）",
        "设计思想": "递归、回溯",
        "适用场景": "排列生成、组合优化问题探索"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG020",
      "name": "迷宫求解",
      "attributes": {
        "难度": "中等",
        "内容": "寻找从迷宫入口到出口的一条路径。可以使用递归（深度优先搜索）或队列（广度优先搜索）实现。递归方法中系统隐式使用栈，非递归DFS显式使用栈。",
        "时间复杂度": "O(m*n)（m, n为迷宫维度）",
        "空间复杂度": "O(m*n)（递归栈深度或辅助空间）",
        "设计思想": "递归、回溯、深度优先搜索、栈应用",
        "适用场景": "路径查找、图搜索"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG021",
      "name": "汉诺塔",
      "attributes": {
        "难度": "中等",
        "内容": "解决经典的汉诺塔问题，将n个盘子从源柱借助辅助柱移动到目标柱。标准的解决方案是递归的。",
        "时间复杂度": "O(2^n)",
        "空间复杂度": "O(n)（递归栈深度）",
        "设计思想": "递归、分治",
        "适用场景": "教学示例、递归思维训练"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG022",
      "name": "渡口管理模拟",
      "attributes": {
        "难度": "中等",
        "内容": "模拟轮船渡口的车辆管理，根据特定规则（车辆类型、到达顺序、装载限制）安排车辆上船。通常使用队列来管理等待的车辆。",
        "时间复杂度": "取决于模拟的复杂度和事件数量",
        "空间复杂度": "O(N)（N为等待车辆数，队列空间）",
        "设计思想": "队列应用、模拟",
        "适用场景": "事件驱动模拟、资源调度"
      }
    }
  ],
  "relations": [
    {
      "type": "继承",
      "source": "04DS001",
      "target": "04DS003"
    },
    {
      "type": "继承",
      "source": "04DS002",
      "target": "04DS003"
    },
    {
      "type": "变体",
      "source": "04DS004",
      "target": "04DS002"
    },
    {
      "type": "变体",
      "source": "04DS005",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "source": "04ALG001",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "source": "04ALG002",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "source": "04ALG003",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "source": "04ALG004",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "source": "04ALG005",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "source": "04ALG006",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "source": "04ALG007",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "source": "04ALG008",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "source": "04ALG009",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "source": "04ALG010",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "source": "04ALG011",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "source": "04ALG012",
      "target": "04DS002"
    },
    {
      "type": "理论依赖",
      "source": "04DS001",
      "target": "04CON001"
    },
    {
      "type": "理论依赖",
      "source": "04DS001",
      "target": "04CON002"
    },
    {
      "type": "理论依赖",
      "source": "04DS001",
      "target": "04CON005"
    },
    {
      "type": "理论依赖",
      "source": "04DS002",
      "target": "04CON003"
    },
    {
      "type": "理论依赖",
      "source": "04DS002",
      "target": "04CON004"
    },
    {
      "type": "理论依赖",
      "source": "04DS002",
      "target": "04CON006"
    },
    {
      "type": "使用",
      "source": "04ALG013",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "source": "04ALG014",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "source": "04ALG015",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "source": "04ALG016",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "source": "04ALG020",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "source": "04ALG022",
      "target": "04DS002"
    },
    {
      "type": "理论依赖",
      "source": "04ALG017",
      "target": "04CON007"
    },
    {
      "type": "理论依赖",
      "source": "04ALG018",
      "target": "04CON007"
    },
    {
      "type": "理论依赖",
      "source": "04ALG019",
      "target": "04CON007"
    },
    {
      "type": "理论依赖",
      "source": "04ALG020",
      "target": "04CON007"
    },
    {
      "type": "理论依赖",
      "source": "04ALG021",
      "target": "04CON007"
    },
    {
      "type": "理论依赖",
      "source": "04ALG013",
      "target": "04CON009"
    },
    {
      "type": "理论依赖",
      "source": "04ALG014",
      "target": "04CON008"
    },
    {
      "type": "理论依赖",
      "source": "04ALG014",
      "target": "04CON009"
    },
    {
      "type": "使用",
      "source": "04DS001",
      "target": "04CON011"
    },
    {
      "type": "使用",
      "source": "04DS001",
      "target": "04CON012"
    },
    {
      "type": "使用",
      "source": "04DS002",
      "target": "04CON011"
    },
    {
      "type": "使用",
      "source": "04DS002",
      "target": "04CON012"
    },
    {
      "type": "使用",
      "source": "04DS004",
      "target": "04CON011"
    }
  ]
}
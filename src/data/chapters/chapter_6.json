{
  "entities": [
    {
      "type": "数据结构",
      "ID": "06DS001",
      "name": "二叉搜索树",
      "attributes": {
        "难度": "中等",
        "内容": "又称二叉排序树，它或是一棵空树，或者是一棵具有如下特性的非空二叉树：(1) 若它的左子树非空，则左子树上所有结点的关键字均小于根结点的关键字；(2) 若它的右子树非空，则右子树上所有结点的关键字均大于（或大于等于）根结点的关键字；(3) 左、右子树本身又各是一棵二叉搜索树。中序遍历结果为有序序列。适用于需要高效查找、插入、删除有序数据的场景。",
        "存储开销": "通常采用链式存储，空间复杂度与节点数成正比 O(n)。",
        "核心特性": "有序性（中序遍历）、可查找性"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS002",
      "name": "堆",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的完全二叉树。分为小根堆（父节点值小于等于子节点值）和大根堆（父节点值大于等于子节点值）。堆顶元素分别是最小值或最大值。常用于实现优先队列。",
        "存储开销": "通常采用顺序存储（数组），空间效率高 O(n)。",
        "核心特性": "堆序性（父子节点关系）、完全二叉树结构"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS003",
      "name": "哈夫曼树",
      "attributes": {
        "难度": "中等",
        "内容": "又称最优二叉树，指n个带权叶子结点构成的所有二叉树中，带权路径长度（WPL）最小的二叉树。构造算法基于贪心策略，权值越大的叶子离根越近。常用于哈夫曼编码。",
        "存储开销": "通常采用链式存储，空间复杂度与节点数（叶子+内部）成正比 O(n)。",
        "核心特性": "最优性（WPL最小）、带权特性"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS004",
      "name": "线索二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "利用二叉链表中的空指针域（线索）指向结点在某种遍历次序下的前驱或后继的二叉树。增加了ltag和rtag标志位。目的是为了快速查找前驱/后继，实现非递归遍历。",
        "存储开销": "链式存储，每个节点增加两个标志位，空间复杂度略高于普通二叉链表 O(n)。",
        "核心特性": "线索化、便于查找前驱/后继"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS005",
      "name": "平衡二叉树",
      "attributes": {
        "难度": "高级",
        "内容": "又称AVL树，是一种自平衡的二叉搜索树。其任何节点的左、右子树高度差的绝对值不超过1（平衡因子为-1, 0, 1）。通过旋转操作（LL, RR, LR, RL）在插入/删除后维持平衡，保证操作的时间复杂度。",
        "存储开销": "链式存储，每个节点需要额外存储平衡因子，空间复杂度 O(n)。",
        "核心特性": "平衡性、自调整性"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG001",
      "name": "二叉搜索树查找",
      "attributes": {
        "难度": "中等",
        "内容": "根据二叉搜索树的性质，比较目标值与当前节点值，决定向左子树或右子树递归查找。有递归和非递归实现。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
        "设计思想": "分治",
        "适用场景": "在二叉搜索树中定位特定值的节点。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG002",
      "name": "二叉搜索树更新",
      "attributes": {
        "难度": "中等",
        "内容": "首先执行查找操作定位到目标节点，若找到则修改节点的值。实现与查找类似。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
        "设计思想": "查找与修改",
        "适用场景": "修改二叉搜索树中已存在节点的值。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG003",
      "name": "二叉搜索树插入",
      "attributes": {
        "难度": "中等",
        "内容": "查找合适的插入位置（一个空链接），然后创建新节点并链接。保持二叉搜索树性质。有递归和非递归实现。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
        "设计思想": "查找与链接",
        "适用场景": "向二叉搜索树添加新节点，同时保持其有序性。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG004",
      "name": "二叉搜索树删除",
      "attributes": {
        "难度": "中等",
        "内容": "查找待删除节点，分情况处理：叶子节点、单分支节点、双分支节点（通常用中序前驱或后继替换）。需要维护二叉搜索树性质。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
        "设计思想": "查找与替换/链接调整",
        "适用场景": "从二叉搜索树移除节点，同时保持其有序性。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON001",
      "name": "完全二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "一棵深度为k，具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。除最后一层外，其余层都是满的，且最后一层的节点都连续集中在最左边。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG005",
      "name": "堆插入",
      "attributes": {
        "难度": "中等",
        "内容": "将新元素添加到堆的末尾（数组末尾），然后通过比较和交换操作（上滤/sift-up），将其调整到合适位置以维持堆性质。",
        "时间复杂度": "O(log n)",
        "空间复杂度": "O(1)",
        "设计思想": "上滤调整",
        "适用场景": "向堆中添加元素并保持堆序性。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG006",
      "name": "堆删除",
      "attributes": {
        "难度": "中等",
        "内容": "通常指删除堆顶元素（最大或最小值）。将堆尾元素移到堆顶，然后通过比较和交换操作（下滤/sift-down），将其调整到合适位置以恢复堆性质。",
        "时间复杂度": "O(log n)",
        "空间复杂度": "O(1)",
        "设计思想": "下滤调整",
        "适用场景": "获取并移除堆中的最值元素，同时保持堆序性。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON002",
      "name": "路径",
      "attributes": {
        "难度": "入门",
        "内容": "在一棵树中，从一个结点到另一个结点所经过的结点序列。树中任意两点间的路径是唯一的。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON003",
      "name": "路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "一条路径上所经过的分支（边）的数量。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON004",
      "name": "结点的权",
      "attributes": {
        "难度": "入门",
        "内容": "赋予树中结点的一个具有某种意义的数值。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON005",
      "name": "带权路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "从树根结点到某一结点之间的路径长度与该结点上权的乘积。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON006",
      "name": "树的带权路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "树中所有叶子结点的带权路径长度之和，记为WPL。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG007",
      "name": "构造哈夫曼树",
      "attributes": {
        "难度": "中等",
        "内容": "基于贪心策略的算法：(1) 初始化n棵单节点树；(2) 重复n-1次：选取权值最小的两棵树合并为一棵新树，新树权值为两者之和；(3) 直到只剩一棵树。通常规定左子树权值小于等于右子树权值。",
        "时间复杂度": "O(n log n)（使用优先队列优化选择最小权值）",
        "空间复杂度": "O(n)",
        "设计思想": "贪心",
        "适用场景": "构建最优二叉树，用于哈夫曼编码等。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG008",
      "name": "哈夫曼编码",
      "attributes": {
        "难度": "中等",
        "内容": "利用哈夫曼树为字符生成变长、无前缀的二进制编码。从根节点出发，向左分支记为0，向右分支记为1，到达叶子节点的路径即为该叶子对应字符的编码。出现频率高的字符编码短。",
        "时间复杂度": "取决于哈夫曼树的构建和遍历",
        "空间复杂度": "取决于存储编码和树的结构",
        "设计思想": "贪心、树遍历",
        "适用场景": "数据压缩，减少传输或存储的数据量。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON007",
      "name": "线索",
      "attributes": {
        "难度": "入门",
        "内容": "在线索二叉树中，利用结点的空指针域存放的指向该结点在某种遍历次序下的前驱或后继结点的指针。分为左线索（前驱）和右线索（后继）。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG009",
      "name": "二叉树线索化",
      "attributes": {
        "难度": "中等",
        "内容": "对二叉树进行某种遍历（如中序），在遍历过程中修改结点的空指针域，使其指向前驱或后继结点，并设置线索标志位。例如中序线索化，在访问节点时处理其左线索（指向前驱）和前驱节点的右线索（指向当前节点）。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)（若递归则为O(h)，h为树高）",
        "设计思想": "树遍历、指针修改",
        "适用场景": "为二叉树添加线索，以便进行非递归、快速的前驱/后继查找和遍历。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG010",
      "name": "中序线索二叉树遍历",
      "attributes": {
        "难度": "中等",
        "内容": "利用线索进行非递归的中序遍历。首先找到中序序列的第一个节点（最左下节点），然后反复查找当前节点的后继节点（通过右线索或右子树的最左下节点）并访问，直至遍历完成。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)",
        "设计思想": "指针跟踪、利用线索",
        "适用场景": "高效地、非递归地按中序访问线索二叉树的所有节点。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON008",
      "name": "平衡因子",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树中某个结点的左子树高度减去右子树高度的值。在平衡二叉树（AVL树）中，平衡因子只能是-1、0或1。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG011",
      "name": "LL型调整",
      "attributes": {
        "难度": "高级",
        "内容": "平衡二叉树的一种旋转操作。当在根结点A的左孩子B的左子树上插入导致A失衡（平衡因子变为2）时进行。将B提升为新的根，A成为B的右孩子，B原来的右子树成为A的左子树。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "旋转操作",
        "适用场景": "恢复平衡二叉树因LL型插入导致的失衡。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG012",
      "name": "RR型调整",
      "attributes": {
        "难度": "高级",
        "内容": "平衡二叉树的一种旋转操作。当在根结点A的右孩子B的右子树上插入导致A失衡（平衡因子变为-2）时进行。将B提升为新的根，A成为B的左孩子，B原来的左子树成为A的右子树。与LL型对称。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "旋转操作",
        "适用场景": "恢复平衡二叉树因RR型插入导致的失衡。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG013",
      "name": "LR型调整",
      "attributes": {
        "难度": "高级",
        "内容": "平衡二叉树的一种双旋转操作。当在根结点A的左孩子B的右子树（根为C）上插入导致A失衡（平衡因子变为2）时进行。先对B进行RR旋转，再对A进行LL旋转。最终C成为新的根。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "双旋转操作",
        "适用场景": "恢复平衡二叉树因LR型插入导致的失衡。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG014",
      "name": "RL型调整",
      "attributes": {
        "难度": "高级",
        "内容": "平衡二叉树的一种双旋转操作。当在根结点A的右孩子B的左子树（根为C）上插入导致A失衡（平衡因子变为-2）时进行。先对B进行LL旋转，再对A进行RR旋转。最终C成为新的根。与LR型对称。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "双旋转操作",
        "适用场景": "恢复平衡二叉树因RL型插入导致的失衡。"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS006",
      "name": "二叉树",
      "attributes": {
          "难度": "入门",
          "内容": "n(n>=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。是许多特殊二叉树的基础结构。",
          "存储开销": "通常采用链式存储 O(n)，或顺序存储（特定情况下如完全二叉树）。",
          "核心特性": "每个结点最多有两个子结点、区分左右子树"
      }
    }
  ],
  "relations": [
    {
      "type": "继承",
      "source": "06DS001",
      "target": "06DS006"
    },
    {
      "type": "继承",
      "source": "06DS003",
      "target": "06DS006"
    },
    {
      "type": "继承",
      "source": "06DS004",
      "target": "06DS006"
    },
    {
      "type": "继承",
      "source": "06DS005",
      "target": "06DS001"
    },
    {
      "type": "理论依赖",
      "source": "06DS002",
      "target": "06CON001"
    },
    {
        "type": "继承",
        "source": "06CON001",
        "target": "06DS006"
    },
    {
      "type": "操作绑定",
      "source": "06ALG001",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "source": "06ALG002",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "source": "06ALG003",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "source": "06ALG004",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "source": "06ALG005",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "source": "06ALG006",
      "target": "06DS002"
    },
    {
      "type": "理论依赖",
      "source": "06ALG007",
      "target": "06CON006"
    },
     {
      "type": "使用",
      "source": "06ALG007",
      "target": "06DS003"
    },
    {
      "type": "使用",
      "source": "06ALG008",
      "target": "06DS003"
    },
    {
      "type": "理论依赖",
      "source": "06DS004",
      "target": "06CON007"
    },
     {
      "type": "操作绑定",
      "source": "06ALG009",
      "target": "06DS004"
    },
     {
      "type": "操作绑定",
      "source": "06ALG010",
      "target": "06DS004"
    },
    {
      "type": "理论依赖",
      "source": "06DS005",
      "target": "06CON008"
    },
    {
      "type": "操作绑定",
      "source": "06ALG011",
      "target": "06DS005"
    },
    {
      "type": "操作绑定",
      "source": "06ALG012",
      "target": "06DS005"
    },
    {
      "type": "操作绑定",
      "source": "06ALG013",
      "target": "06DS005"
    },
    {
      "type": "操作绑定",
      "source": "06ALG014",
      "target": "06DS005"
    },
    {
      "type": "理论依赖",
      "source": "06CON003",
      "target": "06CON002"
    },
    {
      "type": "理论依赖",
      "source": "06CON005",
      "target": "06CON003"
    },
    {
      "type": "理论依赖",
      "source": "06CON005",
      "target": "06CON004"
    },
    {
      "type": "理论依赖",
      "source": "06CON006",
      "target": "06CON005"
    },
    {
        "type": "理论依赖",
        "source": "06DS003",
        "target": "06CON006"
    }
  ]
}
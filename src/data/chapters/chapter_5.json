{
  "entities": [
    {
      "type": "数据结构",
      "ID": "05DS001",
      "name": "树",
      "attributes": {
        "难度": "入门",
        "内容": "重要的非线性数据结构，由n(n>=0)个有限结点组成一个具有层次关系的集合。递归定义：空树或由一个根结点及m(m>=0)棵互不相交的子树构成。",
        "存储开销": "依赖于具体存储方式（顺序、链式）",
        "核心特性": "层次结构、递归定义、非线性"
      }
    },
    {
      "type": "概念",
      "ID": "05CON001",
      "name": "根",
      "attributes": {
        "难度": "入门",
        "内容": "树中唯一没有前驱的结点。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON002",
      "name": "子树",
      "attributes": {
        "难度": "入门",
        "内容": "非空树中除根结点外，其余结点按关系划分成的m(m>=0)棵互不相交的树，每棵子树本身也是一棵树。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON003",
      "name": "结点",
      "attributes": {
        "难度": "入门",
        "内容": "树的基本组成单元，包含数据元素及指向子树的分支。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON004",
      "name": "度",
      "attributes": {
        "难度": "入门",
        "内容": "结点的度指结点拥有的子树（或后继结点）的个数。树的度指树中所有结点度的最大值。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON005",
      "name": "叶子结点",
      "attributes": {
        "难度": "入门",
        "内容": "度为0的结点，也称为终端结点。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON006",
      "name": "分支结点",
      "attributes": {
        "难度": "入门",
        "内容": "度大于0的结点，也称为非终端结点。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON007",
      "name": "孩子结点",
      "attributes": {
        "难度": "入门",
        "内容": "一个结点的子树的根结点，也称为该结点的子女或后继。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON008",
      "name": "双亲结点",
      "attributes": {
        "难度": "入门",
        "内容": "孩子结点的前驱结点，也称为父结点。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON009",
      "name": "兄弟结点",
      "attributes": {
        "难度": "入门",
        "内容": "具有相同双亲结点的孩子结点。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON010",
      "name": "层数",
      "attributes": {
        "难度": "入门",
        "内容": "结点在树中的层次，根结点为第1层，其孩子为第2层，以此类推。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON011",
      "name": "深度",
      "attributes": {
        "难度": "入门",
        "内容": "树中所有结点的最大层数，也称为树的高度。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON012",
      "name": "有序树",
      "attributes": {
        "难度": "入门",
        "内容": "树中任意结点的各子树是按一定次序从左到右排列的，不能互换次序。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON013",
      "name": "无序树",
      "attributes": {
        "难度": "入门",
        "内容": "树中任意结点的各子树之间没有次序关系，可以任意交换位置。"
      }
    },
    {
      "type": "概念",
      "ID": "05CON014",
      "name": "森林",
      "attributes": {
        "难度": "入门",
        "内容": "m(m>=0)棵互不相交的树的集合。"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS002",
      "name": "二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "度不超过2的有序树。递归定义：空树或由一个根结点和两棵互不相交的左、右子树组成，左右子树也都是二叉树。",
        "存储开销": "依赖顺序或链式存储",
        "核心特性": "有序性、度最多为2、左右子树不能任意互换"
      }
    },
    {
      "type": "概念",
      "ID": "05CON015",
      "name": "k叉树",
      "attributes": {
        "难度": "中等",
        "内容": "树的度为k的树，即每个结点的度最多为k。"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS003",
      "name": "满二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "深度为h且具有2^h-1个结点的二叉树。除叶子结点外，每个结点的度都为2。",
        "存储开销": "若用顺序存储则无空间浪费",
        "核心特性": "结构规整、每层结点数满"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS004",
      "name": "完全二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "深度为h，具有n个结点的二叉树，其结点编号与深度为h的满二叉树中编号1到n的结点一一对应。特性是除最后一层外，其余各层均是满的，且最后一层的结点都连续集中在最左边。",
        "存储开销": "适合顺序存储，空间利用率高",
        "核心特性": "结点编号与数组下标有对应关系、堆的基础结构"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS005",
      "name": "理想平衡二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "除最后一层外，其余各层都是满的二叉树，最后一层结点可以任意分布。包含满二叉树和完全二叉树。",
        "存储开销": "依赖具体实现",
        "核心特性": "层数尽可能少，深度接近log2(n)"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS006",
      "name": "二叉树顺序存储",
      "attributes": {
        "难度": "入门",
        "内容": "使用一维数组存储二叉树结点，通常按层序遍历的顺序将结点存入数组，空结点用特定值表示。通过下标计算父子关系。",
        "存储开销": "对于完全二叉树空间效率高，对于一般二叉树（尤其单支树）可能浪费大量空间。",
        "核心特性": "利用数组下标隐式表示结点关系、适合完全二叉树"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS007",
      "name": "二叉链表",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树的链式存储结构，每个结点包含数据域、指向左孩子的指针域和指向右孩子的指针域。",
        "存储开销": "每个结点需要额外存储两个指针的空间",
        "核心特性": "灵活表示任意形态二叉树、插入删除操作相对方便"
      }
    },
    {
      "type": "概念",
      "ID": "05CON016",
      "name": "树根指针",
      "attributes": {
        "难度": "入门",
        "内容": "在树的链式存储结构中，指向树的根结点的指针。"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG001",
      "name": "二叉树遍历",
      "attributes": {
        "难度": "入门",
        "内容": "按照特定规则访问二叉树中的所有结点，且每个结点仅被访问一次。常见的有前序、中序、后序、层序遍历。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) 或 O(w)",
        "设计思想": "递归或迭代（使用栈或队列）",
        "适用场景": "访问、处理、查找、复制、销毁树中所有结点"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG002",
      "name": "前序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树遍历的一种方式：先访问根结点，然后前序遍历左子树，再前序遍历右子树 (DLR)。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) (递归栈)",
        "设计思想": "递归",
        "适用场景": "构建表达式树的前缀表示、树的复制"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG003",
      "name": "中序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树遍历的一种方式：先中序遍历左子树，然后访问根结点，再中序遍历右子树 (LDR)。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) (递归栈)",
        "设计思想": "递归",
        "适用场景": "对二叉搜索树进行排序输出"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG004",
      "name": "后序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树遍历的一种方式：先后序遍历左子树，再后序遍历右子树，最后访问根结点 (LRD)。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) (递归栈)",
        "设计思想": "递归",
        "适用场景": "计算表达式树的值、释放树结点空间"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG005",
      "name": "层序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树遍历的一种方式：从上到下、从左到右逐层访问结点。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(w) (w为树的最大宽度，使用队列)",
        "设计思想": "迭代 (使用队列)",
        "适用场景": "求树的宽度、图的广度优先搜索"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS008",
      "name": "队列",
      "attributes": {
        "难度": "入门",
        "内容": "一种先进先出 (FIFO) 的线性数据结构，允许在表的一端进行插入（入队），在另一端进行删除（出队）。",
        "存储开销": "依赖顺序或链式实现",
        "核心特性": "FIFO"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS009",
      "name": "栈",
      "attributes": {
        "难度": "入门",
        "内容": "一种后进先出 (LIFO) 的线性数据结构，所有插入和删除操作都在表的同一端（栈顶）进行。",
        "存储开销": "依赖顺序或链式实现",
        "核心特性": "LIFO"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG006",
      "name": "初始化二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空的二叉树，通常是将根指针置为NULL。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "赋值",
        "适用场景": "开始构建新树之前"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG007",
      "name": "建立二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "根据给定的输入序列（如广义表、前序+中序序列等）构造二叉树的内存表示（通常是二叉链表）。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) (递归或栈)",
        "设计思想": "递归或迭代（栈辅助）",
        "适用场景": "从外部数据源恢复或构建二叉树结构"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG008",
      "name": "判空二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "检查二叉树是否为空树。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "判断根指针是否为NULL",
        "适用场景": "在对树进行操作前进行检查"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG009",
      "name": "求二叉树深度",
      "attributes": {
        "难度": "入门",
        "内容": "计算二叉树的最大层数。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) (递归栈)",
        "设计思想": "递归（深度 = max(左子树深度, 右子树深度) + 1）",
        "适用场景": "分析树的平衡性、评估算法空间复杂度"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG010",
      "name": "查找二叉树结点",
      "attributes": {
        "难度": "入门",
        "内容": "在二叉树中搜索具有特定值的结点。",
        "时间复杂度": "O(n) (最坏情况，对于非搜索树)",
        "空间复杂度": "O(h) (递归栈)",
        "设计思想": "递归遍历（类似前序）",
        "适用场景": "定位树中特定数据"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG011",
      "name": "输出二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "将二叉树的结构以某种人类可读的格式（如广义表）打印出来。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) (递归栈)",
        "设计思想": "递归遍历（类似前序）",
        "适用场景": "调试、可视化树结构"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG012",
      "name": "清除二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "释放二叉树中所有结点占用的内存空间，使树变为空树。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) (递归栈)",
        "设计思想": "递归（类似后序遍历）",
        "适用场景": "程序结束前或不再需要树时回收资源"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS010",
      "name": "树的顺序存储",
      "attributes": {
        "难度": "中等",
        "内容": "使用一维数组存储k叉树结点，结点按特定规则编号，通过下标计算父子关系。适合满k叉树或完全k叉树。",
        "存储开销": "对于非满/完全树空间浪费严重",
        "核心特性": "通过下标计算关系，结构固定"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS011",
      "name": "树的标准链接存储",
      "attributes": {
        "难度": "中等",
        "内容": "树的链式存储方式，每个结点包含数据域和k个指针域，分别指向k个孩子结点（k为树的度）。",
        "存储开销": "指针开销大，尤其当k大且结点度不一时存储密度低。",
        "核心特性": "直接表示父子关系，结构灵活"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS012",
      "name": "树的广义标准链接存储",
      "attributes": {
        "难度": "中等",
        "内容": "在标准链接存储的基础上，为每个结点增加一个指向其双亲结点的指针域。",
        "存储开销": "比标准方式需要更多指针空间",
        "核心特性": "方便查找孩子和双亲结点"
      }
    },
    {
      "type": "数据结构",
      "ID": "05DS013",
      "name": "树的二叉树表示法",
      "attributes": {
        "难度": "中等",
        "内容": "也称孩子兄弟表示法。将任意树转换为二叉树进行存储。结点的左指针指向其第一个孩子，右指针指向其下一个兄弟。",
        "存储开销": "与二叉链表相同",
        "核心特性": "将多叉树问题转化为二叉树问题处理，存储结构统一"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG013",
      "name": "树遍历",
      "attributes": {
        "难度": "入门",
        "内容": "按照特定规则访问树中的所有结点，且每个结点仅被访问一次。常见有先根、后根、层序遍历。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) 或 O(w)",
        "设计思想": "递归或迭代",
        "适用场景": "访问、处理树中所有结点"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG014",
      "name": "先根遍历",
      "attributes": {
        "难度": "入门",
        "内容": "树遍历的一种方式：先访问根结点，然后从左到右依次先根遍历根的各棵子树。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归",
        "适用场景": "树的结构性操作"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG015",
      "name": "后根遍历",
      "attributes": {
        "难度": "入门",
        "内容": "树遍历的一种方式：先从左到右依次后根遍历根的各棵子树，最后访问根结点。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归",
        "适用场景": "计算依赖子树结果的操作、销毁树"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG016",
      "name": "树的层序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "树遍历的一种方式：按照从上到下、同一层从左到右的次序访问结点。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(w)",
        "设计思想": "迭代（使用队列）",
        "适用场景": "广度优先搜索相关问题"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG017",
      "name": "建立树",
      "attributes": {
        "难度": "中等",
        "内容": "根据给定的输入序列（如广义表）构造树的内存表示（如k叉链表）。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "迭代（栈辅助）",
        "适用场景": "从外部数据源构建树结构"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG018",
      "name": "查找树结点",
      "attributes": {
        "难度": "入门",
        "内容": "在（普通）树中搜索具有特定值的结点。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归（类似先根遍历）",
        "适用场景": "定位树中特定数据"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG019",
      "name": "输出树",
      "attributes": {
        "难度": "入门",
        "内容": "将（普通）树的结构以某种人类可读的格式（如广义表）打印出来。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归（类似先根遍历）",
        "适用场景": "调试、可视化树结构"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG020",
      "name": "求树深度",
      "attributes": {
        "难度": "入门",
        "内容": "计算（普通）树的最大层数。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归",
        "适用场景": "分析树的高度相关特性"
      }
    },
    {
      "type": "算法",
      "ID": "05ALG021",
      "name": "清除树",
      "attributes": {
        "难度": "入门",
        "内容": "释放（普通）树中所有结点占用的内存空间，使树变为空树。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)",
        "设计思想": "递归（类似后根遍历）",
        "适用场景": "回收树占用的资源"
      }
    }
  ],
  "relations": [
    {
      "type": "理论依赖",
      "source": "05DS001",
      "target": "05CON001"
    },
    {
      "type": "理论依赖",
      "source": "05DS001",
      "target": "05CON002"
    },
    {
      "type": "理论依赖",
      "source": "05DS001",
      "target": "05CON003"
    },
    {
      "type": "理论依赖",
      "source": "05CON003",
      "target": "05CON004"
    },
    {
      "type": "理论依赖",
      "source": "05DS001",
      "target": "05CON004"
    },
    {
      "type": "理论依赖",
      "source": "05CON005",
      "target": "05CON003"
    },
    {
      "type": "理论依赖",
      "source": "05CON005",
      "target": "05CON004"
    },
    {
      "type": "理论依赖",
      "source": "05CON006",
      "target": "05CON003"
    },
    {
      "type": "理论依赖",
      "source": "05CON006",
      "target": "05CON004"
    },
    {
      "type": "理论依赖",
      "source": "05CON007",
      "target": "05CON003"
    },
    {
      "type": "理论依赖",
      "source": "05CON008",
      "target": "05CON003"
    },
    {
      "type": "理论依赖",
      "source": "05CON007",
      "target": "05CON008"
    },
    {
      "type": "理论依赖",
      "source": "05CON009",
      "target": "05CON007"
    },
    {
      "type": "理论依赖",
      "source": "05CON009",
      "target": "05CON008"
    },
    {
      "type": "理论依赖",
      "source": "05CON003",
      "target": "05CON010"
    },
    {
      "type": "理论依赖",
      "source": "05DS001",
      "target": "05CON011"
    },
    {
      "type": "理论依赖",
      "source": "05CON011",
      "target": "05CON010"
    },
    {
      "type": "理论依赖",
      "source": "05CON012",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "source": "05CON013",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "source": "05CON014",
      "target": "05DS001"
    },
    {
      "type": "继承",
      "source": "05DS002",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "source": "05DS002",
      "target": "05CON012"
    },
    {
      "type": "理论依赖",
      "source": "05CON015",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "source": "05CON015",
      "target": "05CON004"
    },
    {
      "type": "继承",
      "source": "05DS003",
      "target": "05DS002"
    },
    {
      "type": "继承",
      "source": "05DS004",
      "target": "05DS002"
    },
    {
      "type": "继承",
      "source": "05DS003",
      "target": "05DS004"
    },
    {
      "type": "继承",
      "source": "05DS005",
      "target": "05DS002"
    },
    {
      "type": "继承",
      "source": "05DS004",
      "target": "05DS005"
    },
    {
      "type": "使用",
      "source": "05DS006",
      "target": "05DS002"
    },
    {
      "type": "理论依赖",
      "source": "05DS006",
      "target": "05DS004"
    },
    {
      "type": "使用",
      "source": "05DS007",
      "target": "05DS002"
    },
    {
      "type": "理论依赖",
      "source": "05DS007",
      "target": "05CON016"
    },
    {
      "type": "操作绑定",
      "source": "05ALG001",
      "target": "05DS002"
    },
    {
      "type": "继承",
      "source": "05ALG002",
      "target": "05ALG001"
    },
    {
      "type": "使用",
      "source": "05ALG002",
      "target": "05DS009"
    },
    {
      "type": "继承",
      "source": "05ALG003",
      "target": "05ALG001"
    },
    {
      "type": "使用",
      "source": "05ALG003",
      "target": "05DS009"
    },
    {
      "type": "继承",
      "source": "05ALG004",
      "target": "05ALG001"
    },
    {
      "type": "使用",
      "source": "05ALG004",
      "target": "05DS009"
    },
    {
      "type": "继承",
      "source": "05ALG005",
      "target": "05ALG001"
    },
    {
      "type": "使用",
      "source": "05ALG005",
      "target": "05DS008"
    },
    {
      "type": "操作绑定",
      "source": "05ALG006",
      "target": "05DS002"
    },
    {
      "type": "操作绑定",
      "source": "05ALG007",
      "target": "05DS002"
    },
    {
      "type": "使用",
      "source": "05ALG007",
      "target": "05DS007"
    },
    {
      "type": "使用",
      "source": "05ALG007",
      "target": "05DS009"
    },
    {
      "type": "操作绑定",
      "source": "05ALG008",
      "target": "05DS002"
    },
    {
      "type": "操作绑定",
      "source": "05ALG009",
      "target": "05DS002"
    },
    {
      "type": "理论依赖",
      "source": "05ALG009",
      "target": "05CON011"
    },
    {
      "type": "操作绑定",
      "source": "05ALG010",
      "target": "05DS002"
    },
    {
      "type": "操作绑定",
      "source": "05ALG011",
      "target": "05DS002"
    },
    {
      "type": "操作绑定",
      "source": "05ALG012",
      "target": "05DS002"
    },
    {
      "type": "理论依赖",
      "source": "05ALG012",
      "target": "05ALG004"
    },
    {
      "type": "使用",
      "source": "05DS010",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "source": "05DS010",
      "target": "05CON015"
    },
    {
      "type": "使用",
      "source": "05DS011",
      "target": "05DS001"
    },
    {
      "type": "变体",
      "source": "05DS012",
      "target": "05DS011"
    },
    {
      "type": "使用",
      "source": "05DS013",
      "target": "05DS001"
    },
    {
      "type": "使用",
      "source": "05DS013",
      "target": "05DS007"
    },
    {
      "type": "理论依赖",
      "source": "05DS013",
      "target": "05CON009"
    },
    {
      "type": "操作绑定",
      "source": "05ALG013",
      "target": "05DS001"
    },
    {
      "type": "继承",
      "source": "05ALG014",
      "target": "05ALG013"
    },
    {
      "type": "继承",
      "source": "05ALG015",
      "target": "05ALG013"
    },
    {
      "type": "继承",
      "source": "05ALG016",
      "target": "05ALG013"
    },
    {
      "type": "使用",
      "source": "05ALG016",
      "target": "05DS008"
    },
    {
      "type": "操作绑定",
      "source": "05ALG017",
      "target": "05DS001"
    },
    {
      "type": "使用",
      "source": "05ALG017",
      "target": "05DS011"
    },
    {
      "type": "使用",
      "source": "05ALG017",
      "target": "05DS009"
    },
    {
      "type": "操作绑定",
      "source": "05ALG018",
      "target": "05DS001"
    },
    {
      "type": "操作绑定",
      "source": "05ALG019",
      "target": "05DS001"
    },
    {
      "type": "操作绑定",
      "source": "05ALG020",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "source": "05ALG020",
      "target": "05CON011"
    },
    {
      "type": "操作绑定",
      "source": "05ALG021",
      "target": "05DS001"
    },
    {
      "type": "理论依赖",
      "source": "05ALG021",
      "target": "05ALG015"
    }
  ]
}
{
  "entities": [
    {
      "type": "数据结构",
      "ID": "03DS001",
      "name": "集合",
      "attributes": {
        "难度": "入门",
        "内容": "由具有相同属性的数据元素组合而成的数据结构，数据元素之间没有前驱和后继关系，元素唯一且无序。支持初始化、清空、求长度、判空、判断元素归属、插入、删除、并集、交集、差集等操作。",
        "存储开销": "依赖具体实现。顺序存储可能预分配过多空间或需要动态扩容；链式存储按需分配但有指针开销。",
        "核心特性": "元素唯一性、无序性",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS002",
      "name": "集合的顺序存储",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组存储集合元素的一种实现方式。通常需要额外变量记录当前长度和数组最大容量。插入和删除操作通常作用于逻辑末尾，或通过移动元素来填补空位。",
        "存储开销": "需要连续内存空间，大小固定或动态调整。可能存在空间浪费或需要动态扩容的开销。",
        "核心特性": "基于数组实现，逻辑结构与物理结构可能不一致（删除操作后）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS003",
      "name": "集合的链式存储",
      "attributes": {
        "难度": "入门",
        "内容": "使用链表（通常是单链表）存储集合元素的一种实现方式。每个元素对应一个结点。插入通常在表头进行以简化操作。",
        "存储开销": "结点按需动态分配，存在指针开销。",
        "核心特性": "基于链表实现，动态大小，非连续内存。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS004",
      "name": "稀疏矩阵",
      "attributes": {
        "难度": "中等",
        "内容": "非零元素个数远小于零元素个数的矩阵。通常只存储非零元素及其行号、列号以节省空间。",
        "存储开销": "远小于标准二维数组，具体取决于非零元素数量和存储方式（如三元组表）。",
        "核心特性": "空间高效存储，针对非零元素进行操作。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS005",
      "name": "三元组线性表",
      "attributes": {
        "难度": "入门",
        "内容": "用于表示稀疏矩阵的一种线性数据结构。表中每个元素是一个三元组，包含非零元素的行号、列号和值。通常按行号主序、列号辅序排列。",
        "存储开销": "与非零元素个数成正比，具体取决于其顺序或链式实现。",
        "核心特性": "紧凑存储非零元素信息，逻辑有序（按行列）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS006",
      "name": "稀疏矩阵的顺序存储",
      "attributes": {
        "难度": "中等",
        "内容": "使用数组存储稀疏矩阵对应的三元组线性表。通常还需存储矩阵的行数、列数和非零元总数。",
        "存储开销": "主要是存储三元组的数组开销，与非零元素个数成正比，需要预估最大元素数量。",
        "核心特性": "基于数组实现三元组表，结构相对简单。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS007",
      "name": "带行指针向量的链接存储",
      "attributes": {
        "难度": "中等",
        "内容": "稀疏矩阵的一种链式存储结构。使用一个指针数组（行指针向量），其下标对应行号，每个指针指向该行非零元素（按列号排序）构成的单链表的头结点。",
        "存储开销": "结点动态分配开销加上行指针向量数组的开销。",
        "核心特性": "便于按行处理稀疏矩阵，结点按需分配。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS008",
      "name": "十字链表存储",
      "attributes": {
        "难度": "高级",
        "内容": "稀疏矩阵的一种链式存储结构。每个非零元素结点包含行、列、值以及指向同行下一个元素和同列下一个元素的指针。同时维护行指针向量和列指针向量。",
        "存储开销": "每个结点需要两个指针域，外加行、列指针向量的开销。",
        "核心特性": "便于按行和按列双向处理稀疏矩阵。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS009",
      "name": "广义表",
      "attributes": {
        "难度": "中等",
        "内容": "线性表的推广，是n(n>=0)个元素（单元素或子表）的有限序列。是一种递归定义的数据结构。",
        "存储开销": "通常采用动态链式存储，开销与结点总数和结构复杂度有关。",
        "核心特性": "递归结构，元素可以是原子或列表，可表示复杂层次关系。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS010",
      "name": "广义表的链式存储",
      "attributes": {
        "难度": "中等",
        "内容": "使用带标志域的结点来存储广义表。结点分为单元素结点（存储值）和子表结点（存储指向子表的指针），通过next指针链接同一层次的元素。",
        "存储开销": "结点按需动态分配，每个结点包含标志域、联合数据域和后继指针域。",
        "核心特性": "能够表示广义表的递归和层次结构，动态存储。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "03DS011",
      "name": "矩阵",
      "attributes": {
        "难度": "入门",
        "内容": "一个m行n列的数表，共包含m*n个数（元素），每个元素由唯一的行号和列号确定位置。",
        "存储开销": "标准实现通常使用二维数组，空间复杂度为O(m*n)。",
        "核心特性": "二维结构，通过行、列索引访问元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG001",
      "name": "集合初始化",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空集合。对于顺序存储，将长度置为0；对于链式存储，将头指针置为NULL。可能涉及初始空间的分配。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "基本初始化",
        "适用场景": "创建新的集合实例时。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG002",
      "name": "清除集合",
      "attributes": {
        "难度": "入门",
        "内容": "移除集合中的所有元素，使其变为空集。对于动态分配的存储结构（如链式存储或动态数组），需要释放占用的内存空间。",
        "时间复杂度": "顺序存储(仅重置长度) O(1)，链式存储(需遍历释放) O(n)。",
        "空间复杂度": "O(1)",
        "设计思想": "资源回收，重置状态",
        "适用场景": "需要清空集合内容或释放资源时。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG003",
      "name": "求集合长度",
      "attributes": {
        "难度": "入门",
        "内容": "返回集合中当前元素的数量。",
        "时间复杂度": "顺序存储 O(1)，链式存储 O(n)。",
        "空间复杂度": "O(1)",
        "设计思想": "计数或读取长度属性",
        "适用场景": "查询集合的大小。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG004",
      "name": "判断集合为空",
      "attributes": {
        "难度": "入门",
        "内容": "检查集合中是否包含任何元素。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "检查长度或头指针",
        "适用场景": "在进行插入、删除等操作前或作为逻辑判断条件。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG005",
      "name": "判断元素是否属于集合",
      "attributes": {
        "难度": "入门",
        "内容": "检查给定元素是否存在于集合中。通常需要遍历集合进行查找。",
        "时间复杂度": "O(n) (对于无序存储)",
        "空间复杂度": "O(1)",
        "设计思想": "顺序查找",
        "适用场景": "验证元素的成员资格，集合插入操作前的检查。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG006",
      "name": "输出集合元素",
      "attributes": {
        "难度": "入门",
        "内容": "遍历集合并按任意顺序（取决于存储）输出所有元素。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)",
        "设计思想": "遍历",
        "适用场景": "显示集合内容。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG007",
      "name": "查找集合元素",
      "attributes": {
        "难度": "入门",
        "内容": "在集合中查找与给定关键字匹配的元素，若找到则返回该元素的完整信息。",
        "时间复杂度": "O(n) (对于无序存储)",
        "空间复杂度": "O(1)",
        "设计思想": "顺序查找",
        "适用场景": "根据关键字获取集合中元素的详细数据。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG008",
      "name": "修改集合元素",
      "attributes": {
        "难度": "入门",
        "内容": "在集合中查找与给定关键字匹配的元素，若找到则用提供的新值更新该元素。",
        "时间复杂度": "O(n) (对于无序存储)",
        "空间复杂度": "O(1)",
        "设计思想": "查找与更新",
        "适用场景": "更新集合中已存在元素的信息。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG009",
      "name": "向集合插入元素",
      "attributes": {
        "难度": "入门",
        "内容": "将一个元素添加到集合中。首先检查元素是否已存在，若不存在则添加。顺序存储可能需检查空间并扩容，通常添加到末尾；链式存储通常添加到表头。",
        "时间复杂度": "O(n) (查找开销)",
        "空间复杂度": "O(1) (不计可能的扩容)",
        "设计思想": "查找与添加",
        "适用场景": "向集合增加新元素，保持元素唯一性。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG010",
      "name": "从集合删除元素",
      "attributes": {
        "难度": "入门",
        "内容": "在集合中查找给定元素，若找到则将其移除。顺序存储通常用末尾元素填补空位；链式存储需修改前驱结点的指针。可能涉及动态空间的收缩。",
        "时间复杂度": "O(n) (查找开销)",
        "空间复杂度": "O(1)",
        "设计思想": "查找与移除",
        "适用场景": "从集合中移除指定元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG011",
      "name": "求集合并集",
      "attributes": {
        "难度": "入门",
        "内容": "计算两个集合S1和S2的并集，结果包含所有出现在S1或S2中的元素（唯一）。实现方法：将S1复制到结果集S，然后遍历S2，将S2中不在S中的元素插入S。",
        "时间复杂度": "O(n*m) (基于简单查找和插入)",
        "空间复杂度": "O(n+m) (存储结果集)",
        "设计思想": "集合论运算，遍历与条件插入",
        "适用场景": "合并两个集合的所有不重复元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG012",
      "name": "求集合交集",
      "attributes": {
        "难度": "入门",
        "内容": "计算两个集合S1和S2的交集，结果包含所有同时出现在S1和S2中的元素。实现方法：遍历S2（或S1），检查每个元素是否存在于S1（或S2）中，若存在则加入结果集。",
        "时间复杂度": "O(n*m) (基于简单查找)",
        "空间复杂度": "O(min(n,m)) (存储结果集)",
        "设计思想": "集合论运算，遍历与查找",
        "适用场景": "找出两个集合共有的元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG013",
      "name": "求集合差集",
      "attributes": {
        "难度": "入门",
        "内容": "计算两个集合S1和S2的差集 (S1 - S2)，结果包含所有属于S1但不属于S2的元素。实现方法：遍历S1，检查每个元素是否不存在于S2中，若不存在则加入结果集。",
        "时间复杂度": "O(n*m) (基于简单查找)",
        "空间复杂度": "O(n) (存储结果集)",
        "设计思想": "集合论运算，遍历与查找",
        "适用场景": "找出只存在于第一个集合而不存在于第二个集合的元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG014",
      "name": "简单选择排序",
      "attributes": {
        "难度": "入门",
        "内容": "一种基础排序算法。在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。",
        "时间复杂度": "O(n^2)",
        "空间复杂度": "O(1)",
        "设计思想": "选择最小/最大元素",
        "适用场景": "小规模数据排序，教学演示。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG015",
      "name": "稀疏矩阵初始化",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空的稀疏矩阵表示。将行数、列数、非零元素个数置为0。对于链式存储，还需初始化指针向量。",
        "时间复杂度": "O(1) 或 O(MaxRows+MaxCols) 取决于存储结构初始化需求。",
        "空间复杂度": "O(1)",
        "设计思想": "基本初始化",
        "适用场景": "创建新的稀疏矩阵实例。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG016",
      "name": "稀疏矩阵转置",
      "attributes": {
        "难度": "中等",
        "内容": "计算稀疏矩阵的转置矩阵。将原矩阵M的(i, j)处的非零元素放到转置矩阵S的(j, i)处。普通方法逐列扫描原矩阵构建转置矩阵。",
        "时间复杂度": "普通转置O(列数 * 非零元数)",
        "空间复杂度": "O(非零元数) (存储转置结果)",
        "设计思想": "矩阵运算，行列互换",
        "适用场景": "需要获得矩阵转置形式时。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG017",
      "name": "快速转置",
      "attributes": {
        "难度": "中等",
        "内容": "一种优化的稀疏矩阵转置算法。通过两次扫描三元组表：第一次统计原矩阵每列的非零元个数，计算转置后每行第一个元素在目标数组中的位置；第二次扫描将元素直接放到计算好的位置。",
        "时间复杂度": "O(列数 + 非零元数)",
        "空间复杂度": "O(列数 + 非零元数) (结果存储+辅助数组)",
        "设计思想": "空间换时间，预计算位置",
        "适用场景": "高效计算稀疏矩阵转置，尤其当非零元较多时。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG018",
      "name": "稀疏矩阵加法",
      "attributes": {
        "难度": "中等",
        "内容": "计算两个维度相同的稀疏矩阵M1和M2的和。按行（或其他顺序）遍历两个矩阵的非零元素，对相同位置的非零元素值相加，只存储和不为零的结果元素。",
        "时间复杂度": "O(t1 + t2) (t1, t2为两个矩阵的非零元数)",
        "空间复杂度": "O(t1 + t2) (最坏情况，结果矩阵存储)",
        "设计思想": "矩阵运算，同步遍历或合并",
        "适用场景": "对稀疏矩阵进行加法运算。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG019",
      "name": "稀疏矩阵乘法",
      "attributes": {
        "难度": "高级",
        "内容": "计算两个稀疏矩阵M1(m*n)和M2(n*p)的乘积M(m*p)。需要高效地找到M1第i行和M2第j列对应的非零元素对并进行乘积累加，计算M的每个非零元素M[i][j]。",
        "时间复杂度": "依赖具体实现和矩阵结构，通常优于稠密矩阵乘法。",
        "空间复杂度": "O(t_result) (结果矩阵存储)",
        "设计思想": "矩阵运算，优化查找和累加",
        "适用场景": "对稀疏矩阵进行乘法运算。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG020",
      "name": "稀疏矩阵输入",
      "attributes": {
        "难度": "入门",
        "内容": "根据用户输入的行数、列数以及一系列非零元素的三元组（行号、列号、值），构建稀疏矩阵的内部存储结构（如顺序三元组表、十字链表等）。",
        "时间复杂度": "O(t) (t为非零元数，假设输入和单次插入为O(1))",
        "空间复杂度": "O(t) 或 O(MaxTerms) (存储结构)",
        "设计思想": "数据读取与结构构建",
        "适用场景": "从外部源创建稀疏矩阵实例。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG021",
      "name": "稀疏矩阵输出",
      "attributes": {
        "难度": "入门",
        "内容": "将稀疏矩阵的内部存储表示转换为可读格式（通常是三元组列表）并输出。",
        "时间复杂度": "O(t) (t为非零元数)",
        "空间复杂度": "O(1)",
        "设计思想": "遍历与格式化输出",
        "适用场景": "展示稀疏矩阵的内容。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG022",
      "name": "求广义表长度",
      "attributes": {
        "难度": "入门",
        "内容": "计算广义表顶层元素的个数。遍历顶层结点的next指针链即可。",
        "时间复杂度": "O(n) (n为顶层元素个数)",
        "空间复杂度": "O(n) (递归实现) 或 O(1) (迭代实现)",
        "设计思想": "遍历顶层链表",
        "适用场景": "获取广义表第一层的元素数量。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG023",
      "name": "求广义表深度",
      "attributes": {
        "难度": "中等",
        "内容": "计算广义表中括号嵌套的最大层数。递归定义：深度 = 1 + max(所有子表深度)，空表或原子表深度为1。通过递归遍历实现。",
        "时间复杂度": "O(N) (N为广义表中结点总数)",
        "空间复杂度": "O(m) (m为广义表深度，递归栈深度)",
        "设计思想": "递归遍历，深度优先",
        "适用场景": "衡量广义表的嵌套复杂度。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG024",
      "name": "创建广义表",
      "attributes": {
        "难度": "中等",
        "内容": "根据特定格式的输入字符串（如包含括号、逗号、原子元素）递归地构建广义表的链式存储结构。",
        "时间复杂度": "O(N) (N为输入长度或结点数)",
        "空间复杂度": "O(N) (存储结构和递归栈)",
        "设计思想": "递归下降解析与构建",
        "适用场景": "从文本表示生成内存中的广义表对象。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG025",
      "name": "打印广义表",
      "attributes": {
        "难度": "中等",
        "内容": "将广义表的链式存储结构递归地转换回其标准的文本表示格式（包含括号、逗号）并输出。",
        "时间复杂度": "O(N) (N为结点总数)",
        "空间复杂度": "O(m) (m为广义表深度，递归栈深度)",
        "设计思想": "递归遍历与格式化输出",
        "适用场景": "以可读形式展示广义表内容。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "03ALG026",
      "name": "有序输出集合元素",
      "attributes": {
        "难度": "入门",
        "内容": "输出集合中所有元素，并保证输出顺序按元素值的升序排列。通常需要借助辅助空间（如临时数组）和排序算法（如简单选择排序）实现。",
        "时间复杂度": "O(n^2) (若使用简单排序)",
        "空间复杂度": "O(n) (需要临时数组)",
        "设计思想": "复制、排序、输出",
        "适用场景": "需要按特定顺序（如有序）展示集合内容时。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "03CON001",
      "name": "抽象数据类型",
      "attributes": {
        "难度": "入门",
        "内容": "一个数学模型以及定义在该模型上的一组操作。它强调数据对象、关系和操作的定义，与具体的计算机内部表示和实现算法分离。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "03CON003",
      "name": "三元组",
      "attributes": {
        "难度": "入门",
        "内容": "由三个相关部分组成的数据单元。在稀疏矩阵上下文中，特指用于表示非零元素的（行号, 列号, 值）组合。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "03CON004",
      "name": "单元素",
      "attributes": {
        "难度": "入门",
        "内容": "广义表中的基本、不可再分的元素，也称为原子。与子表相对。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "03CON005",
      "name": "子表",
      "attributes": {
        "难度": "入门",
        "内容": "广义表中的一个元素，其本身也是一个广义表。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "03CON006",
      "name": "递归",
      "attributes": {
        "难度": "中等",
        "内容": "一种定义或解决问题的方法，其中函数或过程直接或间接调用自身。在数据结构中，指结构（如广义表）的定义包含自身；在算法中，指算法步骤中包含对自身的调用。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    }
  ],
  "relations": [
    {
      "type": "操作绑定",
      "ID": "03REL001",
      "source": "03ALG001",
      "target": "03DS001"
    },
    {
      "type": "操作绑定",
      "ID": "03REL002",
      "source": "03ALG002",
      "target": "03DS001"
    },
    {
      "type": "操作绑定",
      "ID": "03REL003",
      "source": "03ALG003",
      "target": "03DS001"
    },
    {
      "type": "操作绑定",
      "ID": "03REL004",
      "source": "03ALG004",
      "target": "03DS001"
    },
    {
      "type": "操作绑定",
      "ID": "03REL005",
      "source": "03ALG005",
      "target": "03DS001"
    },
    {
      "type": "操作绑定",
      "ID": "03REL006",
      "source": "03ALG006",
      "target": "03DS001"
    },
    {
      "type": "操作绑定",
      "ID": "03REL007",
      "source": "03ALG007",
      "target": "03DS001"
    },
    {
      "type": "操作绑定",
      "ID": "03REL008",
      "source": "03ALG008",
      "target": "03DS001"
    },
    {
      "type": "操作绑定",
      "ID": "03REL009",
      "source": "03ALG009",
      "target": "03DS001"
    },
    {
      "type": "操作绑定",
      "ID": "03REL010",
      "source": "03ALG010",
      "target": "03DS001"
    },
    {
      "type": "操作绑定",
      "ID": "03REL011",
      "source": "03ALG011",
      "target": "03DS001"
    },
    {
      "type": "操作绑定",
      "ID": "03REL012",
      "source": "03ALG012",
      "target": "03DS001"
    },
    {
      "type": "操作绑定",
      "ID": "03REL013",
      "source": "03ALG013",
      "target": "03DS001"
    },
    {
      "type": "变体",
      "ID": "03REL014",
      "source": "03DS002",
      "target": "03DS001"
    },
    {
      "type": "变体",
      "ID": "03REL015",
      "source": "03DS003",
      "target": "03DS001"
    },
    {
      "type": "继承",
      "ID": "03REL016",
      "source": "03DS004",
      "target": "03DS011"
    },
    {
      "type": "理论依赖",
      "ID": "03REL017",
      "source": "03DS005",
      "target": "03CON003"
    },
    {
      "type": "使用",
      "ID": "03REL018",
      "source": "03DS004",
      "target": "03DS005"
    },
    {
      "type": "使用",
      "ID": "03REL019",
      "source": "03DS006",
      "target": "03DS005"
    },
    {
      "type": "变体",
      "ID": "03REL020",
      "source": "03DS006",
      "target": "03DS004"
    },
    {
      "type": "变体",
      "ID": "03REL021",
      "source": "03DS007",
      "target": "03DS004"
    },
    {
      "type": "变体",
      "ID": "03REL022",
      "source": "03DS008",
      "target": "03DS004"
    },
    {
      "type": "操作绑定",
      "ID": "03REL023",
      "source": "03ALG015",
      "target": "03DS004"
    },
    {
      "type": "操作绑定",
      "ID": "03REL024",
      "source": "03ALG016",
      "target": "03DS004"
    },
    {
      "type": "优化",
      "ID": "03REL025",
      "source": "03ALG017",
      "target": "03ALG016"
    },
    {
      "type": "操作绑定",
      "ID": "03REL026",
      "source": "03ALG018",
      "target": "03DS004"
    },
    {
      "type": "操作绑定",
      "ID": "03REL027",
      "source": "03ALG019",
      "target": "03DS004"
    },
    {
      "type": "操作绑定",
      "ID": "03REL028",
      "source": "03ALG020",
      "target": "03DS004"
    },
    {
      "type": "操作绑定",
      "ID": "03REL029",
      "source": "03ALG021",
      "target": "03DS004"
    },
    {
      "type": "理论依赖",
      "ID": "03REL030",
      "source": "03DS009",
      "target": "03CON006"
    },
    {
      "type": "使用",
      "ID": "03REL031",
      "source": "03DS009",
      "target": "03CON004"
    },
    {
      "type": "使用",
      "ID": "03REL032",
      "source": "03DS009",
      "target": "03CON005"
    },
    {
      "type": "变体",
      "ID": "03REL034",
      "source": "03DS010",
      "target": "03DS009"
    },
    {
      "type": "操作绑定",
      "ID": "03REL035",
      "source": "03ALG022",
      "target": "03DS009"
    },
    {
      "type": "操作绑定",
      "ID": "03REL036",
      "source": "03ALG023",
      "target": "03DS009"
    },
    {
      "type": "操作绑定",
      "ID": "03REL037",
      "source": "03ALG024",
      "target": "03DS009"
    },
    {
      "type": "操作绑定",
      "ID": "03REL038",
      "source": "03ALG025",
      "target": "03DS009"
    },
    {
      "type": "理论依赖",
      "ID": "03REL039",
      "source": "03ALG022",
      "target": "03CON006"
    },
    {
      "type": "理论依赖",
      "ID": "03REL040",
      "source": "03ALG023",
      "target": "03CON006"
    },
    {
      "type": "理论依赖",
      "ID": "03REL041",
      "source": "03ALG024",
      "target": "03CON006"
    },
    {
      "type": "理论依赖",
      "ID": "03REL042",
      "source": "03ALG025",
      "target": "03CON006"
    },
    {
      "type": "使用",
      "ID": "03REL043",
      "source": "03ALG026",
      "target": "03ALG014"
    },
    {
      "type": "操作绑定",
      "ID": "03REL044",
      "source": "03ALG026",
      "target": "03DS001"
    },
    {
      "type": "理论依赖",
      "ID": "03REL045",
      "source": "03DS001",
      "target": "03CON001"
    },
    {
      "type": "理论依赖",
      "ID": "03REL046",
      "source": "03DS004",
      "target": "03CON001"
    }
  ]
}
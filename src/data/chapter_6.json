{
  "entities": [
    {
      "type": "数据结构",
      "ID": "06DS001",
      "name": "二叉搜索树",
      "attributes": {
        "难度": "中等",
        "内容": "定义: 又称二叉排序树，它或是一棵空树，或者是一棵具有如下特性的非空二叉树：(1)若左子树非空，则左子树上所有结点的关键字均小于根结点的关键字；(2)若右子树非空，则右子树上所有结点的关键字均大于等于根结点的关键字；(3)左、右子树本身又各是一棵二叉搜索树。特性: 中序遍历结果为有序序列。适用场景: 需要高效查找、插入、删除有序数据的场景。",
        "存储开销": "O(n)，通常采用链式存储结构。",
        "核心特性": "有序性（中序遍历）、支持高效查找",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS002",
      "name": "堆",
      "attributes": {
        "难度": "中等",
        "内容": "定义: 具有特定性质的完全二叉树，分为小根堆（父结点值<=子结点值）和大根堆（父结点值>=子结点值）。特性: 根结点是整个堆中的最小值（小根堆）或最大值（大根堆）。适用场景: 优先队列实现、堆排序。",
        "存储开销": "O(n)，通常采用顺序存储结构（数组）。",
        "核心特性": "部分有序（堆性质）、根为极值、完全二叉树结构",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS003",
      "name": "小根堆",
      "attributes": {
        "难度": "中等",
        "内容": "定义: 堆的一种，满足特性：(1)若根存在左孩子，则根结点值<=左孩子值；(2)若根存在右孩子，则根结点值<=右孩子值；(3)左右子树也分别为小根堆。特性: 堆顶（根结点）存放的是整个堆中的最小值。适用场景: 高效获取最小值、优先队列（小顶）。",
        "存储开销": "O(n)，通常采用顺序存储结构。",
        "核心特性": "根为最小值",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS004",
      "name": "大根堆",
      "attributes": {
        "难度": "中等",
        "内容": "定义: 堆的一种，满足特性：(1)若根存在左孩子，则根结点值>=左孩子值；(2)若根存在右孩子，则根结点值>=右孩子值；(3)左右子树也分别为大根堆。特性: 堆顶（根结点）存放的是整个堆中的最大值。适用场景: 高效获取最大值、优先队列（大顶）。",
        "存储开销": "O(n)，通常采用顺序存储结构。",
        "核心特性": "根为最大值",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS005",
      "name": "哈夫曼树",
      "attributes": {
        "难度": "中等",
        "内容": "定义: 又称最优二叉树，指对于n个带权叶子结点构成的所有二叉树中，带权路径长度(WPL)最小的二叉树。特性: 权值越大的叶子结点离根越近，树中只有度为0（叶子）和度为2（分支）的结点。适用场景: 数据压缩（哈夫曼编码）。",
        "存储开销": "O(n)，通常采用链式存储结构。",
        "核心特性": "带权路径长度最小",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS006",
      "name": "线索二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "定义: 利用二叉树结点中的空指针域（原本指向NULL的指针）存放指向该结点在某种遍历次序下的前驱或后继结点的指针（线索）。特性: 便于快速查找结点的直接前驱和后继，实现非递归遍历。适用场景: 需要频繁查找前驱/后继或进行非递归遍历的二叉树应用。",
        "存储开销": "O(n)，链式存储，每个结点增加两个标志位以区分指针是孩子还是线索。",
        "核心特性": "利用空指针域存储前驱/后继信息",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS007",
      "name": "平衡二叉树",
      "attributes": {
        "难度": "高级",
        "内容": "定义: 又称AVL树，它或者是一棵空树，或者是一棵左右子树的高度差的绝对值不超过1，并且左右两棵子树也都是平衡二叉树的二叉搜索树。特性: 通过旋转操作（LL, RR, LR, RL）维持树的平衡，确保查找、插入、删除操作的时间复杂度稳定在O(log n)。适用场景: 对查找性能要求较高且数据动态变化的场景。",
        "存储开销": "O(n)，链式存储，结点通常需要额外存储平衡因子。",
        "核心特性": "自平衡性、高效稳定的查找性能",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG001",
      "name": "查找 (二叉搜索树)",
      "attributes": {
        "难度": "入门",
        "内容": "原理: 从根结点开始，若查找值等于当前结点值，则成功；若小于，则在左子树中查找；若大于，则在右子树中查找。递归或迭代实现。伪代码: 见教材 bool Find(BST, item) 和 bool Find1(BST, item)。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归: 平均O(log n)，最坏O(n); 非递归: O(1)",
        "设计思想": "比较、分治",
        "适用场景": "在二叉搜索树中定位特定值的结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG002",
      "name": "更新 (二叉搜索树)",
      "attributes": {
        "难度": "入门",
        "内容": "原理: 首先执行查找操作定位到目标结点，若找到，则用新值更新该结点的数据域。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归: 平均O(log n)，最坏O(n); 非递归: O(1)",
        "设计思想": "查找与修改",
        "适用场景": "修改二叉搜索树中已存在结点的值。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG003",
      "name": "插入 (二叉搜索树)",
      "attributes": {
        "难度": "入门",
        "内容": "原理: 从根结点开始查找待插入值的位置，直到找到一个空链接，将新结点插入此处。递归或迭代实现。伪代码: 见教材 void Insert(BST, item) 和 void Insert1(BST, item)。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归: 平均O(log n)，最坏O(n); 非递归: O(1)",
        "设计思想": "查找插入点、链接",
        "适用场景": "向二叉搜索树中添加新元素，保持其性质。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG004",
      "name": "删除 (二叉搜索树)",
      "attributes": {
        "难度": "中等",
        "内容": "原理: 查找到待删除结点后，分三种情况处理：(1) 叶子结点：直接删除。(2) 单分支结点：用其子结点替换。(3) 双分支结点：用其右子树的最小结点（中序后继）或左子树的最大结点（中序前驱）替换，然后删除那个替换结点。伪代码: 见教材 bool Delete(BST, item)。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归: 平均O(log n)，最坏O(n); 非递归: O(1)",
        "设计思想": "分情况讨论、替换",
        "适用场景": "从二叉搜索树中移除指定元素，保持其性质。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG005",
      "name": "插入 (堆)",
      "attributes": {
        "难度": "入门",
        "内容": "原理: 将新元素添加到堆的末尾（数组末尾），然后通过与其父结点比较并交换（向上调整或sift-up），直到满足堆性质或到达根结点。伪代码: 见教材 void InsertHeap(HBT, item)。",
        "时间复杂度": "O(log n)",
        "空间复杂度": "O(1)",
        "设计思想": "添加、向上调整",
        "适用场景": "向堆中添加元素，维持堆结构。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG006",
      "name": "删除 (堆)",
      "attributes": {
        "难度": "入门",
        "内容": "原理: 删除堆顶元素（通常是最大或最小值）。将堆底元素移到堆顶，然后通过与子结点比较并交换（向下调整或sift-down），恢复堆性质。伪代码: 见教材 ElemType DeleteHeap(HBT)。",
        "时间复杂度": "O(log n)",
        "空间复杂度": "O(1)",
        "设计思想": "替换、向下调整",
        "适用场景": "从堆中移除并获取极值元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG007",
      "name": "中序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "原理: 按照“左子树-根结点-右子树”的顺序访问二叉树的每个结点。对于二叉搜索树，中序遍历得到有序序列。对于线索二叉树，可以利用线索进行高效非递归遍历。",
        "时间复杂度": "O(n)",
        "空间复杂度": "递归O(h)，迭代O(h)或O(1)(线索化)",
        "设计思想": "递归、栈或线索",
        "适用场景": "遍历二叉树，获取BST有序序列，遍历线索二叉树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG008",
      "name": "线索化",
      "attributes": {
        "难度": "中等",
        "内容": "原理: 在对二叉树进行某种遍历（如中序）的过程中，检查结点的空左/右指针域，将其设置为指向该结点在此遍历序列中的前驱/后继结点的线索，并设置相应的标志位。伪代码: 见教材 void InThread(HBT, pre)。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)（递归栈）",
        "设计思想": "遍历、指针修改",
        "适用场景": "将普通二叉树转换为线索二叉树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG009",
      "name": "CreateHuffman",
      "attributes": {
        "难度": "中等",
        "内容": "原理: (1) 初始化n棵只有一个带权根结点的二叉树森林。(2) 重复n-1次：选取森林中权值最小的两棵树，合并成一棵新树（新根权值为两者之和），用新树替换原来的两棵树。(3) 最终得到唯一的哈夫曼树。伪代码: 见教材 BTreeNode CreateHuffman(a, n)。",
        "时间复杂度": "O(n log n)（使用优先队列优化选择）或 O(n^2)（简单查找）",
        "空间复杂度": "O(n)",
        "设计思想": "贪心算法",
        "适用场景": "根据给定的权值构造哈夫曼树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG010",
      "name": "WeightPathLength",
      "attributes": {
        "难度": "入门",
        "内容": "原理: 递归计算哈夫曼树的带权路径长度。若当前结点是叶子，返回其权值乘以其深度；否则，返回左右子树的WPL之和。伪代码: 见教材 ElemType WeightPathLength(FBT, len)。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)，h为树高",
        "设计思想": "递归",
        "适用场景": "计算哈夫曼树的总权值（WPL）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG011",
      "name": "HuffmanCoding",
      "attributes": {
        "难度": "中等",
        "内容": "原理: 从哈夫曼树的根结点开始递归遍历，向左子树走路径编码加'0'，向右子树走加'1'。到达叶子结点时，记录下的路径编码即为该叶子结点代表字符的哈夫曼编码。伪代码: 见教材 void HuffManCoding(FBT, len)。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)，h为树高",
        "设计思想": "递归、回溯",
        "适用场景": "根据哈夫曼树生成各字符的哈夫曼编码。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG012",
      "name": "LL型调整",
      "attributes": {
        "难度": "中等",
        "内容": "原理: 当在平衡二叉树的某个结点(A)的左孩子(B)的左子树上插入新结点导致A失衡时进行。执行一次右旋转操作：B提升为新的根，A成为B的右孩子，B原来的右子树成为A的左子树。伪代码: 见教材图6-16。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "单旋转（右旋）",
        "适用场景": "恢复平衡二叉树因LL型插入导致的失衡。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG013",
      "name": "RR型调整",
      "attributes": {
        "难度": "中等",
        "内容": "原理: 当在平衡二叉树的某个结点(A)的右孩子(B)的右子树上插入新结点导致A失衡时进行。执行一次左旋转操作：B提升为新的根，A成为B的左孩子，B原来的左子树成为A的右子树。伪代码: 见教材图6-18。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "单旋转（左旋）",
        "适用场景": "恢复平衡二叉树因RR型插入导致的失衡。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG014",
      "name": "LR型调整",
      "attributes": {
        "难度": "中等",
        "内容": "原理: 当在平衡二叉树的某个结点(A)的左孩子(B)的右子树(根为C)上插入新结点导致A失衡时进行。先对B执行一次左旋转（RR型），再对A执行一次右旋转（LL型）。伪代码: 见教材图6-19。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "双旋转（先左后右）",
        "适用场景": "恢复平衡二叉树因LR型插入导致的失衡。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG015",
      "name": "RL型调整",
      "attributes": {
        "难度": "中等",
        "内容": "原理: 当在平衡二叉树的某个结点(A)的右孩子(B)的左子树(根为C)上插入新结点导致A失衡时进行。先对B执行一次右旋转（LL型），再对A执行一次左旋转（RR型）。伪代码: 见教材图6-21。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "双旋转（先右后左）",
        "适用场景": "恢复平衡二叉树因RL型插入导致的失衡。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG016",
      "name": "CreateBSTree",
      "attributes": {
        "难度": "入门",
        "内容": "原理: 初始化一个空二叉搜索树，然后遍历给定的元素数组，依次调用二叉搜索树的插入算法将每个元素插入树中。伪代码: 见教材 void CreateBSTree(BST, a, n)。",
        "时间复杂度": "平均O(n log n)，最坏O(n^2)",
        "空间复杂度": "取决于插入算法（递归或非递归）",
        "设计思想": "迭代调用插入",
        "适用场景": "根据一组初始数据构建二叉搜索树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG017",
      "name": "CreateThread1",
      "attributes": {
        "难度": "中等",
        "内容": "原理: 初始化一个空树，然后遍历给定的元素数组，依次调用专门的带线索链接的插入算法（如InsertThread1）将每个元素插入，构建带线索的二叉搜索树。伪代码: 见教材 void CreateThread1(HBT, a, n)。",
        "时间复杂度": "平均O(n log n)，最坏O(n^2)",
        "空间复杂度": "O(1)（若插入非递归）",
        "设计思想": "迭代调用带线索插入",
        "适用场景": "根据一组初始数据直接构建线索二叉搜索树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG018",
      "name": "ThInorder",
      "attributes": {
        "难度": "入门",
        "内容": "原理: 利用中序线索进行非递归中序遍历。(1)找到中序序列的第一个结点（最左下结点）。(2)循环：访问当前结点，然后利用InorderNext算法找到下一个中序后继结点，直到后继为空。伪代码: 见教材 void ThInorder(HBT)。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)",
        "设计思想": "利用线索迭代",
        "适用场景": "高效、无栈的中序遍历线索二叉树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG019",
      "name": "InThread",
      "attributes": {
        "难度": "中等",
        "内容": "原理: 通过递归中序遍历二叉树，在访问结点V时：(1)如果V的左指针为空，则将其指向其中序前驱。(2)如果其中序前驱的右指针为空，则将其指向V。同时更新线索标志。伪代码: 见教材 void InThread(HBT, pre)。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h)，h为树高（递归栈）",
        "设计思想": "递归遍历，线索链接",
        "适用场景": "将普通二叉树转换为中序线索二叉树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON001",
      "name": "二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "定义: 每个结点最多只有两个子结点（称为左孩子和右孩子）的树结构。是本章讨论的多种特殊树的基础。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON002",
      "name": "完全二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "定义: 一种特殊的二叉树，除最后一层外，其余各层结点数均达到最大值，且最后一层的结点都连续集中在最左边。堆是基于完全二叉树定义的。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON003",
      "name": "路径",
      "attributes": {
        "难度": "入门",
        "内容": "定义: 树中从一个结点到另一个结点的结点序列。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON004",
      "name": "路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "定义: 路径上所包含的分支（边）的数量。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON005",
      "name": "结点的权",
      "attributes": {
        "难度": "入门",
        "内容": "定义: 赋予树中结点的具有特定含义的数值。在哈夫曼树中通常代表字符频率或重要性。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON006",
      "name": "带权路径长度",
      "attributes": {
        "难度": "中等",
        "内容": "定义: 树中所有叶子结点的带权路径长度之和，记为WPL。其中，叶子结点的带权路径长度 = 该叶子结点的权值 × 根到该叶子的路径长度。哈夫曼树的目标是最小化WPL。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON007",
      "name": "线索",
      "attributes": {
        "难度": "中等",
        "内容": "定义: 在线索二叉树中，利用空闲指针域存储的指向结点在特定遍历序列中的前驱或后继结点的指针。分为左线索（指向前驱）和右线索（指向后继）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON008",
      "name": "平衡因子",
      "attributes": {
        "难度": "中等",
        "内容": "定义: 二叉树中结点的左子树高度减去右子树高度的值。在平衡二叉树（AVL树）中，每个结点的平衡因子只能是-1、0或1。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON009",
      "name": "最小不平衡子树",
      "attributes": {
        "难度": "中等",
        "内容": "定义: 在向平衡二叉树插入或删除结点导致失衡后，以距离插入/删除点最近的那个平衡因子绝对值大于1的结点为根的子树。是进行平衡调整的目标。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON010",
      "name": "森林",
      "attributes": {
        "难度": "入门",
        "内容": "定义: 零棵或多棵互不相交的树的集合。在哈夫曼树的构造算法初始阶段使用。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON011",
      "name": "前驱",
      "attributes": {
        "难度": "入门",
        "内容": "定义: 在某个线性序列（如遍历序列）中，紧邻于某结点之前的那个结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON012",
      "name": "后继",
      "attributes": {
        "难度": "入门",
        "内容": "定义: 在某个线性序列（如遍历序列）中，紧邻于某结点之后的那个结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON013",
      "name": "中序前驱",
      "attributes": {
        "难度": "入门",
        "内容": "定义: 在二叉树的中序遍历序列中，某结点的前驱结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON014",
      "name": "中序后继",
      "attributes": {
        "难度": "入门",
        "内容": "定义: 在二叉树的中序遍历序列中，某结点的后继结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    }
  ],
  "relations": [
    {
      "type": "继承",
      "ID": "06REL001",
      "source": "06DS001",
      "target": "06CON001"
    },
    {
      "type": "继承",
      "ID": "06REL002",
      "source": "06DS002",
      "target": "06CON002"
    },
    {
      "type": "变体",
      "ID": "06REL003",
      "source": "06DS003",
      "target": "06DS002"
    },
    {
      "type": "变体",
      "ID": "06REL004",
      "source": "06DS004",
      "target": "06DS002"
    },
    {
      "type": "继承",
      "ID": "06REL005",
      "source": "06DS005",
      "target": "06CON001"
    },
    {
      "type": "变体",
      "ID": "06REL006",
      "source": "06DS006",
      "target": "06CON001"
    },
    {
      "type": "继承",
      "ID": "06REL007",
      "source": "06DS007",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL008",
      "source": "06ALG001",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL009",
      "source": "06ALG002",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL010",
      "source": "06ALG003",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL011",
      "source": "06ALG004",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL012",
      "source": "06ALG005",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL013",
      "source": "06ALG006",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL014",
      "source": "06ALG007",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL015",
      "source": "06ALG007",
      "target": "06DS006"
    },
    {
      "type": "操作绑定",
      "ID": "06REL016",
      "source": "06ALG008",
      "target": "06DS006"
    },
    {
      "type": "操作绑定",
      "ID": "06REL017",
      "source": "06ALG009",
      "target": "06DS005"
    },
    {
      "type": "操作绑定",
      "ID": "06REL018",
      "source": "06ALG010",
      "target": "06DS005"
    },
    {
      "type": "操作绑定",
      "ID": "06REL019",
      "source": "06ALG011",
      "target": "06DS005"
    },
    {
      "type": "操作绑定",
      "ID": "06REL020",
      "source": "06ALG012",
      "target": "06DS007"
    },
    {
      "type": "操作绑定",
      "ID": "06REL021",
      "source": "06ALG013",
      "target": "06DS007"
    },
    {
      "type": "操作绑定",
      "ID": "06REL022",
      "source": "06ALG014",
      "target": "06DS007"
    },
    {
      "type": "操作绑定",
      "ID": "06REL023",
      "source": "06ALG015",
      "target": "06DS007"
    },
    {
      "type": "使用",
      "ID": "06REL024",
      "source": "06ALG016",
      "target": "06ALG003"
    },
    {
      "type": "使用",
      "ID": "06REL025",
      "source": "06ALG017",
      "target": "06DS006"
    },
    {
      "type": "使用",
      "ID": "06REL026",
      "source": "06ALG018",
      "target": "06CON007"
    },
    {
      "type": "使用",
      "ID": "06REL027",
      "source": "06ALG019",
      "target": "06CON007"
    },
    {
      "type": "使用",
      "ID": "06REL028",
      "source": "06ALG009",
      "target": "06CON010"
    },
    {
      "type": "使用",
      "ID": "06REL029",
      "source": "06ALG009",
      "target": "06CON005"
    },
    {
      "type": "使用",
      "ID": "06REL030",
      "source": "06ALG011",
      "target": "06DS005"
    },
    {
      "type": "理论依赖",
      "ID": "06REL031",
      "source": "06ALG010",
      "target": "06CON006"
    },
    {
      "type": "理论依赖",
      "ID": "06REL032",
      "source": "06DS005",
      "target": "06CON005"
    },
    {
      "type": "理论依赖",
      "ID": "06REL033",
      "source": "06DS005",
      "target": "06CON006"
    },
    {
      "type": "理论依赖",
      "ID": "06REL034",
      "source": "06DS006",
      "target": "06CON007"
    },
    {
      "type": "理论依赖",
      "ID": "06REL035",
      "source": "06DS006",
      "target": "06CON011"
    },
    {
      "type": "理论依赖",
      "ID": "06REL036",
      "source": "06DS006",
      "target": "06CON012"
    },
    {
      "type": "理论依赖",
      "ID": "06REL037",
      "source": "06DS007",
      "target": "06CON008"
    },
    {
      "type": "理论依赖",
      "ID": "06REL038",
      "source": "06DS007",
      "target": "06CON009"
    },
    {
      "type": "理论依赖",
      "ID": "06REL039",
      "source": "06ALG012",
      "target": "06CON008"
    },
    {
      "type": "理论依赖",
      "ID": "06REL040",
      "source": "06ALG013",
      "target": "06CON008"
    },
    {
      "type": "理论依赖",
      "ID": "06REL041",
      "source": "06ALG014",
      "target": "06CON008"
    },
    {
      "type": "理论依赖",
      "ID": "06REL042",
      "source": "06ALG015",
      "target": "06CON008"
    },
    {
      "type": "理论依赖",
      "ID": "06REL043",
      "source": "06ALG012",
      "target": "06CON009"
    },
    {
      "type": "理论依赖",
      "ID": "06REL044",
      "source": "06ALG013",
      "target": "06CON009"
    },
    {
      "type": "理论依赖",
      "ID": "06REL045",
      "source": "06ALG014",
      "target": "06CON009"
    },
    {
      "type": "理论依赖",
      "ID": "06REL046",
      "source": "06ALG015",
      "target": "06CON009"
    },
    {
      "type": "理论依赖",
      "ID": "06REL047",
      "source": "06CON006",
      "target": "06CON003"
    },
    {
      "type": "理论依赖",
      "ID": "06REL048",
      "source": "06CON006",
      "target": "06CON004"
    },
    {
      "type": "理论依赖",
      "ID": "06REL049",
      "source": "06CON006",
      "target": "06CON005"
    },
    {
      "type": "理论依赖",
      "ID": "06REL050",
      "source": "06CON007",
      "target": "06CON011"
    },
    {
      "type": "理论依赖",
      "ID": "06REL051",
      "source": "06CON007",
      "target": "06CON012"
    },
    {
      "type": "继承",
      "ID": "06REL052",
      "source": "06CON013",
      "target": "06CON011"
    },
    {
      "type": "继承",
      "ID": "06REL053",
      "source": "06CON014",
      "target": "06CON012"
    },
    {
      "type": "使用",
      "ID": "06REL054",
      "source": "06ALG004",
      "target": "06CON013"
    },
    {
      "type": "使用",
      "ID": "06REL055",
      "source": "06ALG018",
      "target": "06CON014"
    },
    {
      "type": "操作绑定",
      "ID": "06REL056",
      "source": "06ALG016",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL057",
      "source": "06ALG017",
      "target": "06DS006"
    },
    {
      "type": "操作绑定",
      "ID": "06REL058",
      "source": "06ALG018",
      "target": "06DS006"
    },
    {
      "type": "操作绑定",
      "ID": "06REL059",
      "source": "06ALG019",
      "target": "06DS006"
    }
  ]
}
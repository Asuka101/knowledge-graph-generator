{
  "entities": [
    {
      "type": "数据结构",
      "ID": "06DS001",
      "name": "二叉搜索树",
      "attributes": {
        "难度": "中等",
        "内容": "又称二叉排序树，它或是一棵空树，或者是一棵具有如下特性的非空二叉树：（1）若它的左子树非空，则左子树上所有结点的关键字均小于根结点的关键字。（2）若它的右子树非空，则右子树上所有结点的关键字均大于（或等于）根结点的关键字。（3）左、右子树本身又各是一棵二叉搜索树。中序遍历结果为有序序列。主要用于元素的查找、插入和删除。",
        "存储开销": "通常采用链式存储，每个结点包含数据域和两个指针域，空间复杂度为O(n)。",
        "核心特性": "有序性（中序遍历），左<根<右。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG001",
      "name": "二叉搜索树查找",
      "attributes": {
        "难度": "入门",
        "内容": "从根结点开始，若查找值等于根结点值，则成功；若小于根结点值，则在左子树中递归查找；若大于根结点值，则在右子树中递归查找。直至找到或子树为空（查找失败）。有递归和非递归两种实现方式。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
        "设计思想": "比较、递归/迭代",
        "适用场景": "在二叉搜索树中定位特定值的结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG002",
      "name": "二叉搜索树更新",
      "attributes": {
        "难度": "入门",
        "内容": "首先执行查找操作定位到目标结点，若找到，则用新的值更新该结点的数据域。更新操作通常不改变结点的关键字，若关键字改变可能需要重新调整树结构。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
        "设计思想": "查找与修改",
        "适用场景": "修改二叉搜索树中已存在结点的数据信息（通常非关键字部分）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG003",
      "name": "二叉搜索树插入",
      "attributes": {
        "难度": "入门",
        "内容": "从根结点开始比较，若插入值小于结点值，则向左子树查找；若大于等于结点值，则向右子树查找，直到找到一个空位置，将新值作为新结点插入。保持二叉搜索树的性质。有递归和非递归实现。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
        "设计思想": "查找插入位置、链接新结点",
        "适用场景": "向二叉搜索树中添加新的元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG004",
      "name": "二叉搜索树删除",
      "attributes": {
        "难度": "中等",
        "内容": "查找待删除结点。分情况处理：（1）叶子结点：直接删除。（2）单分支结点：用其子结点替换它。（3）双分支结点：用其直接前驱（左子树最右结点）或直接后继（右子树最左结点）替换它，然后删除该前驱或后继结点（转化为情况1或2）。保持二叉搜索树性质。",
        "时间复杂度": "平均O(log n)，最坏O(n)",
        "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
        "设计思想": "查找、分类讨论、替换、递归/迭代",
        "适用场景": "从二叉搜索树中移除指定值的结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS002",
      "name": "堆",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的完全二叉树。分为小根堆（父结点值小于等于子结点值）和大根堆（父结点值大于等于子结点值）。根结点是堆中的最小（小根堆）或最大（大根堆）元素。",
        "存储开销": "通常使用数组进行顺序存储，空间利用率高，空间复杂度O(n)。",
        "核心特性": "完全二叉树结构，根结点为最值。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON001",
      "name": "完全二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "一棵深度为k，具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为完全二叉树。特点是叶子结点只可能在层次最大的两层上出现，且最大层次上的叶子结点都依次排列在该层最左边的位置上。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG005",
      "name": "堆插入",
      "attributes": {
        "难度": "中等",
        "内容": "将新元素添加到堆的末尾（数组末尾），然后将其与其父结点比较，若不满足堆性质（如小根堆中子结点小于父结点），则交换两者。重复此过程向上调整（Sift-up），直到满足堆性质或到达根结点。",
        "时间复杂度": "O(log n)",
        "空间复杂度": "O(1)",
        "设计思想": "末尾添加、向上调整",
        "适用场景": "向堆中添加一个新元素并维持堆结构。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG006",
      "name": "堆删除",
      "attributes": {
        "难度": "中等",
        "内容": "通常指删除堆顶元素（最值）。将堆顶元素与堆底元素交换，然后移除堆底元素（缩小堆大小）。将新的堆顶元素与其子结点比较，若不满足堆性质，则与合适的子结点（小根堆中较小的子结点，大根堆中较大的子结点）交换。重复此过程向下调整（Sift-down），直到满足堆性质或到达叶子结点。",
        "时间复杂度": "O(log n)",
        "空间复杂度": "O(1)",
        "设计思想": "替换堆顶、向下调整",
        "适用场景": "获取并移除堆中的最值元素，并维持堆结构。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS003",
      "name": "优先级队列",
      "attributes": {
        "难度": "中等",
        "内容": "一种抽象数据类型，其中的元素带有优先级。支持插入元素和删除最高（或最低）优先级的元素。与普通队列的先进先出不同，优先级队列是优先级最高的先出。",
        "存储开销": "依赖于具体实现，常用堆实现，空间复杂度为O(n)。",
        "核心特性": "按优先级出队。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS004",
      "name": "哈夫曼树",
      "attributes": {
        "难度": "中等",
        "内容": "又称最优二叉树，指对于一组带有确定权值的叶子结点，构造的带权路径长度（WPL）最小的二叉树。树中所有叶子结点都带有权值，非叶子结点没有权值（或其权值为子树叶子权值之和）。权值越大的叶子结点离根越近。",
        "存储开销": "通常采用链式存储，空间复杂度与结点数成正比，约为O(n)（n为叶子结点数）。",
        "核心特性": "带权路径长度最小。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON002",
      "name": "路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "在一棵树中，从一个结点到另一个结点所经过的分支（边）的数目。通常指从根结点到目标结点的路径长度。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON003",
      "name": "带权路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "结点的带权路径长度定义为从树根到该结点之间的路径长度与该结点上权值的乘积。树的带权路径长度（WPL）定义为树中所有叶子结点的带权路径长度之和。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG007",
      "name": "构造哈夫曼树",
      "attributes": {
        "难度": "中等",
        "内容": "给定n个权值，看作n棵只有根结点的二叉树森林。重复以下步骤n-1次：在森林中选取两棵根结点权值最小的树，合并成一棵新树，新树的根结点权值为两棵子树根权值之和。从森林中删除选取的两棵树，并将新树加入森林。最终森林中只剩一棵树，即为哈夫曼树。",
        "时间复杂度": "O(n log n)（使用优先队列优化选择过程）",
        "空间复杂度": "O(n)",
        "设计思想": "贪心算法",
        "适用场景": "构建最优二叉树，用于哈夫曼编码等。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG008",
      "name": "哈夫曼编码",
      "attributes": {
        "难度": "中等",
        "内容": "一种基于哈夫曼树的变长编码方法，属于无前缀编码。将待编码的字符作为叶子结点，字符频率作为权值构造哈夫曼树。约定左分支代表0，右分支代表1（或反之），从根到每个叶子结点的路径构成的01序列即为该叶子结点对应字符的哈夫曼编码。频率高的字符编码短，频率低的编码长。",
        "时间复杂度": "构造树O(n log n)，生成编码O(n)",
        "空间复杂度": "O(n)",
        "设计思想": "贪心、树遍历",
        "适用场景": "数据压缩，减少数据传输或存储的总长度。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON004",
      "name": "无前缀编码",
      "attributes": {
        "难度": "入门",
        "内容": "一种编码方案，其中没有任何一个码字是另一个码字的前缀。这种性质保证了编码序列可以被唯一地、无歧义地解码。哈夫曼编码是无前缀编码的一种。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS005",
      "name": "线索二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "利用二叉链表中的空指针域（原本指向NULL的指针）来存放指向结点在特定遍历次序（如中序）下的前驱和后继结点的指针（称为线索）。为了区分指针域是指向孩子还是线索，结点结构中需要增加两个标志域（ltag, rtag）。",
        "存储开销": "链式存储，每个结点除了数据域和两个指针域外，还需额外存储两个布尔类型的标志域，空间复杂度O(n)。",
        "核心特性": "利用空指针域加速特定遍历（如中序）的前驱和后继查找，便于非递归遍历。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON005",
      "name": "线索",
      "attributes": {
        "难度": "入门",
        "内容": "在线索二叉树中，存放在结点空指针域中的、指向该结点在特定遍历序列中前驱或后继结点的指针。指向前驱的为空左指针域存放，称为左线索或前驱线索；指向后继的为空右指针域存放，称为右线索或后继线索。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG009",
      "name": "线索化",
      "attributes": {
        "难度": "中等",
        "内容": "对普通二叉树按照某种遍历次序（如中序）进行遍历，在遍历过程中修改结点的空指针域，使其指向该结点在此遍历序列中的前驱或后继，并设置相应的线索标志位的过程。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(H)（递归实现）或 O(1)（非递归实现）",
        "设计思想": "树遍历、指针修改",
        "适用场景": "将普通二叉树转换为线索二叉树，以便后续快速查找前驱/后继或进行非递归遍历。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG010",
      "name": "中序线索遍历",
      "attributes": {
        "难度": "中等",
        "内容": "在中序线索二叉树上进行中序遍历的非递归算法。首先找到中序序列的第一个结点（最左下结点），然后重复访问当前结点并利用线索或右子树查找下一个中序后继结点，直到遍历完所有结点。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)",
        "设计思想": "利用线索指针进行迭代",
        "适用场景": "高效地（无需栈）对中序线索二叉树进行中序遍历。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS006",
      "name": "平衡二叉树",
      "attributes": {
        "难度": "高级",
        "内容": "又称AVL树，是一种自平衡的二叉搜索树。其任意结点的左、右子树高度差的绝对值不超过1。通过在插入或删除结点后进行旋转操作（LL、RR、LR、RL型调整）来维持平衡，保证查找、插入、删除操作的时间复杂度稳定在O(log n)。",
        "存储开销": "链式存储，每个结点除了数据域和两个指针域外，通常还需要额外存储平衡因子（或子树高度），空间复杂度O(n)。",
        "核心特性": "自平衡，保持二叉搜索树性质，高效的动态操作。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON006",
      "name": "平衡因子",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树中一个结点的左子树高度减去其右子树高度的值。在平衡二叉树（AVL树）中，每个结点的平衡因子只能是-1、0或1。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON007",
      "name": "最小不平衡子树",
      "attributes": {
        "难度": "入门",
        "内容": "在向（或从）平衡二叉树插入（或删除）一个结点后，导致树失衡。从插入（或删除）结点向上回溯，遇到的第一个平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树。平衡调整操作通常针对该子树进行。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG011",
      "name": "LL型调整",
      "attributes": {
        "难度": "中等",
        "内容": "平衡二叉树（AVL树）的一种旋转调整操作。当因在结点A的左孩子B的左子树上插入新结点导致A失衡（平衡因子变为2）时执行。对A进行一次右旋操作：B提升为新的根，A成为B的右孩子，B原来的右子树成为A的左孩子。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "单次右旋转",
        "适用场景": "恢复因在左子树的左子树插入导致的AVL树失衡。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG012",
      "name": "RR型调整",
      "attributes": {
        "难度": "中等",
        "内容": "平衡二叉树（AVL树）的一种旋转调整操作。当因在结点A的右孩子B的右子树上插入新结点导致A失衡（平衡因子变为-2）时执行。对A进行一次左旋操作：B提升为新的根，A成为B的左孩子，B原来的左子树成为A的右孩子。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "单次左旋转",
        "适用场景": "恢复因在右子树的右子树插入导致的AVL树失衡。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG013",
      "name": "LR型调整",
      "attributes": {
        "难度": "中等",
        "内容": "平衡二叉树（AVL树）的一种旋转调整操作。当因在结点A的左孩子B的右子树上插入新结点导致A失衡（平衡因子变为2）时执行。先对A的左孩子B进行一次RR型调整（左旋），然后对A进行一次LL型调整（右旋）。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "先左旋后右旋（双旋转）",
        "适用场景": "恢复因在左子树的右子树插入导致的AVL树失衡。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG014",
      "name": "RL型调整",
      "attributes": {
        "难度": "中等",
        "内容": "平衡二叉树（AVL树）的一种旋转调整操作。当因在结点A的右孩子B的左子树上插入新结点导致A失衡（平衡因子变为-2）时执行。先对A的右孩子B进行一次LL型调整（右旋），然后对A进行一次RR型调整（左旋）。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "先右旋后左旋（双旋转）",
        "适用场景": "恢复因在右子树的左子树插入导致的AVL树失衡。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG015",
      "name": "中序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树的一种遍历方式，遵循“左-根-右”的顺序访问结点。即先递归遍历左子树，然后访问根结点，最后递归遍历右子树。对于二叉搜索树，中序遍历的结果是一个递增（或非递减）的有序序列。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(H)（递归栈深度，H为树高）",
        "设计思想": "递归",
        "适用场景": "获取二叉搜索树的有序序列，作为线索化、某些算法的基础。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    }
  ],
  "relations": [
    {
      "type": "操作绑定",
      "ID": "06REL001",
      "source": "06ALG001",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL002",
      "source": "06ALG002",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL003",
      "source": "06ALG003",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL004",
      "source": "06ALG004",
      "target": "06DS001"
    },
    {
      "type": "继承",
      "ID": "06REL005",
      "source": "06DS002",
      "target": "06CON001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL006",
      "source": "06ALG005",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL007",
      "source": "06ALG006",
      "target": "06DS002"
    },
    {
      "type": "使用",
      "ID": "06REL008",
      "source": "06DS003",
      "target": "06DS002"
    },
    {
      "type": "理论依赖",
      "ID": "06REL009",
      "source": "06DS004",
      "target": "06CON003"
    },
    {
      "type": "理论依赖",
      "ID": "06REL010",
      "source": "06CON003",
      "target": "06CON002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL011",
      "source": "06ALG007",
      "target": "06DS004"
    },
    {
      "type": "使用",
      "ID": "06REL012",
      "source": "06ALG008",
      "target": "06DS004"
    },
    {
      "type": "理论依赖",
      "ID": "06REL013",
      "source": "06ALG008",
      "target": "06CON004"
    },
    {
      "type": "理论依赖",
      "ID": "06REL014",
      "source": "06DS005",
      "target": "06CON005"
    },
    {
      "type": "操作绑定",
      "ID": "06REL015",
      "source": "06ALG009",
      "target": "06DS005"
    },
    {
      "type": "使用",
      "ID": "06REL016",
      "source": "06ALG009",
      "target": "06CON005"
    },
    {
      "type": "操作绑定",
      "ID": "06REL017",
      "source": "06ALG010",
      "target": "06DS005"
    },
    {
      "type": "使用",
      "ID": "06REL018",
      "source": "06ALG010",
      "target": "06CON005"
    },
    {
      "type": "继承",
      "ID": "06REL019",
      "source": "06DS006",
      "target": "06DS001"
    },
    {
      "type": "理论依赖",
      "ID": "06REL020",
      "source": "06DS006",
      "target": "06CON006"
    },
    {
      "type": "操作绑定",
      "ID": "06REL021",
      "source": "06ALG011",
      "target": "06DS006"
    },
    {
      "type": "操作绑定",
      "ID": "06REL022",
      "source": "06ALG012",
      "target": "06DS006"
    },
    {
      "type": "操作绑定",
      "ID": "06REL023",
      "source": "06ALG013",
      "target": "06DS006"
    },
    {
      "type": "操作绑定",
      "ID": "06REL024",
      "source": "06ALG014",
      "target": "06DS006"
    },
    {
      "type": "使用",
      "ID": "06REL025",
      "source": "06ALG011",
      "target": "06CON007"
    },
    {
      "type": "使用",
      "ID": "06REL026",
      "source": "06ALG012",
      "target": "06CON007"
    },
    {
      "type": "使用",
      "ID": "06REL027",
      "source": "06ALG013",
      "target": "06CON007"
    },
    {
      "type": "使用",
      "ID": "06REL028",
      "source": "06ALG014",
      "target": "06CON007"
    },
    {
      "type": "操作绑定",
      "ID": "06REL029",
      "source": "06ALG015",
      "target": "06DS001"
    },
    {
      "type": "理论依赖",
      "ID": "06REL030",
      "source": "06ALG009",
      "target": "06ALG015"
    }
  ]
}
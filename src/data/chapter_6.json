{
  "entities": [
    {
      "type": "数据结构",
      "ID": "06DS001",
      "name": "二叉搜索树",
      "attributes": {
        "难度": "中等",
        "内容": "又称二叉排序树，它或是一棵空树，或者是一棵具有如下特性的非空二叉树：（1）若它的左子树非空，则左子树上所有结点的关键字均小于根结点的关键字。（2）若它的右子树非空，则右子树上所有结点的关键字均大于（或大于等于）根结点的关键字。（3）左、右子树本身又各是一棵二叉搜索树。中序遍历结果为有序序列。适用于需要高效查找、插入、删除的有序数据集。",
        "存储开销": "链式存储O(n)",
        "核心特性": "有序性，左<根<右",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG001",
      "name": "二叉搜索树查找",
      "attributes": {
        "难度": "入门",
        "内容": "从根结点开始，若查找值等于当前结点值，则成功；若小于，则在左子树中查找；若大于，则在右子树中查找。直到找到或子树为空（失败）。有递归和非递归实现。",
        "时间复杂度": "平均O(logn)，最坏O(n)",
        "空间复杂度": "递归平均O(logn)/最坏O(n)，非递归O(1)",
        "设计思想": "比较、递归/迭代",
        "适用场景": "在二叉搜索树中定位特定关键字的结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG002",
      "name": "二叉搜索树更新",
      "attributes": {
        "难度": "入门",
        "内容": "算法与查找类似，首先在二叉搜索树中查找目标元素，若查找成功，则用新值更新该结点的值。",
        "时间复杂度": "平均O(logn)，最坏O(n)",
        "空间复杂度": "递归平均O(logn)/最坏O(n)，非递归O(1)",
        "设计思想": "查找与修改",
        "适用场景": "修改二叉搜索树中已存在结点的值。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG003",
      "name": "二叉搜索树插入",
      "attributes": {
        "难度": "入门",
        "内容": "从根结点开始查找插入位置，若插入值小于当前结点，则向左子树查找；若大于等于，则向右子树查找，直到找到一个空位置插入新结点。有递归和非递归实现。",
        "时间复杂度": "平均O(logn)，最坏O(n)",
        "空间复杂度": "递归平均O(logn)/最坏O(n)，非递归O(1)",
        "设计思想": "比较、递归/迭代",
        "适用场景": "向二叉搜索树中添加新元素并保持其性质。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG004",
      "name": "二叉搜索树删除",
      "attributes": {
        "难度": "中等",
        "内容": "首先查找要删除的结点。分三种情况处理：(1) 删除叶子结点：直接删除。(2) 删除单支结点：用其子结点替换。(3) 删除双支结点：用其中序前驱（或后继）替换该结点，然后删除中序前驱（或后继）结点。",
        "时间复杂度": "平均O(logn)，最坏O(n)",
        "空间复杂度": "递归平均O(logn)/最坏O(n)，非递归O(1)",
        "设计思想": "分类讨论、递归/迭代、替换",
        "适用场景": "从二叉搜索树中移除元素并保持其性质。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG005",
      "name": "创建二叉搜索树",
      "attributes": {
        "难度": "入门",
        "内容": "初始化一个空树，然后遍历输入元素（如数组），对每个元素调用二叉搜索树插入算法，将其插入到树中。",
        "时间复杂度": "一般O(nlogn)，最坏O(n^2)",
        "空间复杂度": "O(n)（存储树结点）",
        "设计思想": "迭代调用插入操作",
        "适用场景": "根据一组初始值构建一棵二叉搜索树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON001",
      "name": "关键字",
      "attributes": {
        "难度": "入门",
        "内容": "在数据结构中，结点内用于比较、排序或查找的特定值或域。在二叉搜索树中，关键字决定了结点在树中的位置。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON002",
      "name": "中序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树的一种遍历方式，顺序为：访问左子树 -> 访问根结点 -> 访问右子树。对二叉搜索树进行中序遍历会得到一个按关键字排序的结点序列。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON003",
      "name": "树的深度",
      "attributes": {
        "难度": "入门",
        "内容": "树中结点的最大层次数（根结点为第1层或第0层）。它影响基于树的操作（如查找、插入、删除）的性能。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON007",
      "name": "中序前驱",
      "attributes": {
        "难度": "入门",
        "内容": "在一个结点的中序遍历序列中，紧邻它之前的那个结点。在二叉搜索树中，是其左子树中关键字最大的结点。用于双支结点的删除操作和线索化。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS002",
      "name": "堆",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的完全二叉树，满足堆属性：父结点的关键字总是大于等于（大根堆）或小于等于（小根堆）其子结点的关键字。常用于实现优先级队列和堆排序。",
        "存储开销": "顺序存储O(n)",
        "核心特性": "完全二叉树结构，堆序性（父子关系）",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS003",
      "name": "小根堆",
      "attributes": {
        "难度": "中等",
        "内容": "堆的一种，其中每个父结点的值都小于或等于其子结点的值。因此，堆顶元素（根结点）是整个堆中的最小值。",
        "存储开销": "顺序存储O(n)",
        "核心特性": "父结点 <= 子结点，完全二叉树",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS004",
      "name": "大根堆",
      "attributes": {
        "难度": "中等",
        "内容": "堆的一种，其中每个父结点的值都大于或等于其子结点的值。因此，堆顶元素（根结点）是整个堆中的最大值。",
        "存储开销": "顺序存储O(n)",
        "核心特性": "父结点 >= 子结点，完全二叉树",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON008",
      "name": "完全二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "一棵深度为k，具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为完全二叉树。性质是除了最后一层，其他层都是满的，且最后一层的结点都连续集中在最左边。适合用顺序存储结构表示。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG006",
      "name": "堆初始化",
      "attributes": {
        "难度": "入门",
        "内容": "为堆分配存储空间（通常是数组），并将堆的当前大小（长度）设置为0，表示一个空堆。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(MaxSize) 或 O(1)（取决于是否包含分配空间）",
        "设计思想": "内存分配与状态设置",
        "适用场景": "在使用堆之前创建和准备堆结构。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG007",
      "name": "堆清除",
      "attributes": {
        "难度": "入门",
        "内容": "释放堆所占用的存储空间，并将相关状态（如长度、最大容量）重置，使其变回空堆或无效状态。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "内存释放与状态重置",
        "适用场景": "当不再需要堆时，回收其资源。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG008",
      "name": "堆判空",
      "attributes": {
        "难度": "入门",
        "内容": "检查堆的当前长度是否为0。如果是，则堆为空；否则，堆不为空。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "状态检查",
        "适用场景": "在执行插入、删除等操作前判断堆的状态。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG009",
      "name": "堆插入",
      "attributes": {
        "难度": "中等",
        "内容": "将新元素添加到堆的末尾（保持完全二叉树结构），然后通过与其父结点比较并交换（向上调整或sift-up），直到满足堆属性或到达根结点。",
        "时间复杂度": "O(logn)",
        "空间复杂度": "O(1)",
        "设计思想": "向上调整（sift-up）",
        "适用场景": "向堆中添加一个新元素并维持堆的性质。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG010",
      "name": "堆删除",
      "attributes": {
        "难度": "中等",
        "内容": "通常指删除堆顶元素（最大或最小值）。将堆顶元素与堆底元素交换，然后移除堆底元素（缩小堆的大小）。将新的堆顶元素通过与其子结点比较并交换（向下调整或sift-down），直到满足堆属性或到达叶子结点。",
        "时间复杂度": "O(logn)",
        "空间复杂度": "O(1)",
        "设计思想": "向下调整（sift-down）",
        "适用场景": "从堆中获取并移除具有最高（或最低）优先级的元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS005",
      "name": "优先级队列",
      "attributes": {
        "难度": "中等",
        "内容": "一种抽象数据类型，类似于常规队列或栈，但每个元素都有一个关联的“优先级”。元素按优先级出队，优先级最高的元素最先出队。常用堆来实现。",
        "存储开销": "依赖实现，基于堆为O(n)",
        "核心特性": "按优先级出队",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS006",
      "name": "哈夫曼树",
      "attributes": {
        "难度": "中等",
        "内容": "又称最优二叉树，是n个带权叶子结点构成的所有二叉树中带权路径长度（WPL）最小的二叉树。构造算法基于贪心策略。常用于哈夫曼编码。",
        "存储开销": "链式存储O(n)",
        "核心特性": "带权路径长度最小，无度为1的结点",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON009",
      "name": "路径",
      "attributes": {
        "难度": "入门",
        "内容": "在树结构中，从一个结点到另一个结点所经过的结点序列。树中任意两个结点之间存在唯一路径。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON010",
      "name": "路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "一条路径上所包含边的数量（或结点数减1）。根结点的路径长度为0。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON011",
      "name": "结点的权",
      "attributes": {
        "难度": "入门",
        "内容": "赋予树中结点的一个数值，通常表示某种度量或重要性，如字符出现的频率。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON012",
      "name": "结点的带权路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "从树根到该结点的路径长度与该结点权值的乘积。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON013",
      "name": "树的带权路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "树中所有叶子结点的带权路径长度之和，记作WPL (Weighted Path Length)。哈夫曼树旨在最小化WPL。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG011",
      "name": "构造哈夫曼树",
      "attributes": {
        "难度": "中等",
        "内容": "基于贪心算法：(1) 初始化n棵只有一个带权根结点的树组成的森林。(2) 重复n-1次：选取森林中权值最小的两棵树合并成一棵新树，新树权值为两者之和，并将新树放回森林，移除原来的两棵树。(3) 直到森林只剩一棵树，即为哈夫曼树。",
        "时间复杂度": "O(nlogn)（使用优先队列优化选择最小权值过程）",
        "空间复杂度": "O(n)",
        "设计思想": "贪心",
        "适用场景": "构建最优二叉树，用于数据压缩（哈夫曼编码）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG012",
      "name": "计算带权路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "递归计算哈夫曼树的WPL。对于叶子结点，返回其权值乘以其深度；对于非叶子结点，返回其左子树WPL与右子树WPL之和。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(H)，H为树高",
        "设计思想": "递归",
        "适用场景": "计算给定哈夫曼树的WPL值。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG013",
      "name": "哈夫曼编码",
      "attributes": {
        "难度": "中等",
        "内容": "利用已构造的哈夫曼树为字符生成最优前缀编码。从根结点开始，约定向左子树走代表0，向右子树走代表1。从根到每个叶子结点的路径所形成的01序列即为该叶子结点代表字符的哈夫曼编码。",
        "时间复杂度": "O(n)（遍历树生成编码）",
        "空间复杂度": "O(H)，H为树高",
        "设计思想": "树遍历",
        "适用场景": "无损数据压缩，根据字符频率生成高效编码。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON014",
      "name": "等长编码",
      "attributes": {
        "难度": "入门",
        "内容": "为字符集中的所有字符分配相同长度的二进制编码。实现简单，但通常效率不高。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON015",
      "name": "不等长编码",
      "attributes": {
        "难度": "入门",
        "内容": "为字符集中的不同字符分配可能不同长度的二进制编码。可以通过给频率高的字符分配短编码来提高效率，如哈夫曼编码。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON016",
      "name": "前缀编码",
      "attributes": {
        "难度": "入门",
        "内容": "一种编码方案，其中没有任何一个码字是另一个码字的前缀。这保证了编码序列可以被唯一地解码，不会产生歧义。哈夫曼编码是一种最优前缀编码。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS007",
      "name": "编码二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "一种用于表示字符编码方案的二叉树。通常，从根到叶子结点的路径表示一个字符的编码（例如，左分支为0，右分支为1），叶子结点代表被编码的字符。",
        "存储开销": "链式存储O(n)",
        "核心特性": "表示编码与字符的对应关系",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS008",
      "name": "线索二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "利用二叉树中空的左右孩子指针域，存放指向该结点在某种遍历序列（如中序）下的前驱和后继结点的指针（线索）。需要额外的标志位区分指针是孩子还是线索。可以实现高效的非递归遍历和查找前驱/后继。",
        "存储开销": "链式存储O(n)，每个结点增加两个标志位",
        "核心特性": "利用空指针，快速查找前驱/后继",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON017",
      "name": "线索",
      "attributes": {
        "难度": "入门",
        "内容": "在线索二叉树中，存储在原本为空的指针域中的、指向结点按某种遍历次序的前驱或后继结点的指针。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON018",
      "name": "前驱线索",
      "attributes": {
        "难度": "入门",
        "内容": "指向结点按特定遍历次序的前驱结点的线索，通常存储在结点的空左指针域。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON019",
      "name": "后继线索",
      "attributes": {
        "难度": "入门",
        "内容": "指向结点按特定遍历次序的后继结点的线索，通常存储在结点的空右指针域。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON020",
      "name": "线索化",
      "attributes": {
        "难度": "入门",
        "内容": "对二叉树进行遍历，并将其所有空指针域根据遍历顺序填充为指向前驱或后继结点的线索的过程。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON021",
      "name": "中序后继",
      "attributes": {
        "难度": "入门",
        "内容": "在一个结点的中序遍历序列中，紧邻它之后的那个结点。在二叉搜索树中，是其右子树中关键字最小的结点。用于线索化和线索遍历。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON022",
      "name": "线索标志域",
      "attributes": {
        "难度": "入门",
        "内容": "在线索二叉树的结点结构中增加的标志位（如ltag, rtag），用于区分对应的指针域（left, right）是指向孩子结点还是指向线索（前驱或后继）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG014",
      "name": "中序线索化",
      "attributes": {
        "难度": "中等",
        "内容": "在中序遍历二叉树的过程中，为每个结点的空左指针添加指向其中序前驱的线索，为空右指针添加指向其中序后继的线索，并设置相应的线索标志位。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(H)（递归栈）或 O(1)（非递归）",
        "设计思想": "中序遍历 + 线索链接",
        "适用场景": "将普通二叉树转换为中序线索二叉树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG015",
      "name": "查找中序后继",
      "attributes": {
        "难度": "入门",
        "内容": "在中序线索二叉树中查找给定结点的中序后继。若右指针是线索，则直接返回；若右指针是孩子指针，则后继是其右子树中最左下的结点。",
        "时间复杂度": "最坏O(H)，平均O(1)（若大部分为空指针）",
        "空间复杂度": "O(1)",
        "设计思想": "利用线索标志判断路径",
        "适用场景": "在线索二叉树中高效地找到下一个遍历结点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG016",
      "name": "线索中序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "利用中序线索二叉树的线索，实现非递归的中序遍历。首先找到中序序列的第一个结点（最左下结点），然后反复查找当前结点的中序后继并访问，直至遍历完成。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)",
        "设计思想": "利用线索指针进行迭代",
        "适用场景": "对线索二叉树进行高效的非递归中序遍历。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG017",
      "name": "带线索标志二叉搜索树插入",
      "attributes": {
        "难度": "中等",
        "内容": "向带线索标志的二叉搜索树中插入新结点。首先按BST规则找到插入位置，然后插入新结点，并正确设置新结点及其父结点的线索和线索标志。需要区分仅插入结点和插入并链接线索两种情况。",
        "时间复杂度": "平均O(logn)，最坏O(n)",
        "空间复杂度": "O(1)（非递归实现）",
        "设计思想": "BST插入 + 线索维护",
        "适用场景": "构建或动态维护线索二叉搜索树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG018",
      "name": "创建带线索标志二叉搜索树",
      "attributes": {
        "难度": "中等",
        "内容": "初始化空树，然后遍历输入元素（如数组），对每个元素调用带线索标志的二叉搜索树插入算法，将元素插入并维护线索结构。",
        "时间复杂度": "一般O(nlogn)，最坏O(n^2)",
        "空间复杂度": "O(n)",
        "设计思想": "迭代调用插入操作（含线索维护）",
        "适用场景": "根据一组初始值构建一棵完整的线索二叉搜索树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS009",
      "name": "平衡二叉树",
      "attributes": {
        "难度": "高级",
        "内容": "也称AVL树，是一种自平衡的二叉搜索树。其特性是任何结点的左右两个子树的高度差的绝对值不超过1。通过旋转操作（LL, RR, LR, RL）在插入和删除后维持平衡，保证了操作的时间复杂度为O(logn)。",
        "存储开销": "链式存储O(n)，每个结点增加平衡因子存储",
        "核心特性": "自平衡，左右子树高度差<=1，保持BST性质",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON023",
      "name": "平衡因子",
      "attributes": {
        "难度": "入门",
        "内容": "定义为结点的左子树高度减去右子树高度的值。在平衡二叉树（AVL树）中，每个结点的平衡因子只能是-1, 0, 或 1。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON024",
      "name": "最小不平衡子树",
      "attributes": {
        "难度": "入门",
        "内容": "在向AVL树插入或删除结点后，距离插入/删除位置最近的、平衡因子绝对值大于1的结点为根的子树。调整操作通常针对最小不平衡子树进行。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG019",
      "name": "LL型调整",
      "attributes": {
        "难度": "中等",
        "内容": "当在最小不平衡子树根结点(A)的左孩子(B)的左子树上插入导致不平衡时（A的平衡因子变为2），执行一次右旋转操作。B提升为新的根，A成为B的右孩子，B原来的右子树成为A的左子树。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "右旋转",
        "适用场景": "恢复AVL树因LL型插入导致的不平衡。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG020",
      "name": "RR型调整",
      "attributes": {
        "难度": "中等",
        "内容": "当在最小不平衡子树根结点(A)的右孩子(B)的右子树上插入导致不平衡时（A的平衡因子变为-2），执行一次左旋转操作。B提升为新的根，A成为B的左孩子，B原来的左子树成为A的右子树。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "左旋转",
        "适用场景": "恢复AVL树因RR型插入导致的不平衡。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG021",
      "name": "LR型调整",
      "attributes": {
        "难度": "中等",
        "内容": "当在最小不平衡子树根结点(A)的左孩子(B)的右子树(根为C)上插入导致不平衡时（A的平衡因子变为2），执行先左旋转（绕B）再右旋转（绕A）的操作。C提升为新的根，B成为C的左孩子，A成为C的右孩子。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "双旋转（先左后右）",
        "适用场景": "恢复AVL树因LR型插入导致的不平衡。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG022",
      "name": "RL型调整",
      "attributes": {
        "难度": "中等",
        "内容": "当在最小不平衡子树根结点(A)的右孩子(B)的左子树(根为C)上插入导致不平衡时（A的平衡因子变为-2），执行先右旋转（绕B）再左旋转（绕A）的操作。C提升为新的根，A成为C的左孩子，B成为C的右孩子。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "双旋转（先右后左）",
        "适用场景": "恢复AVL树因RL型插入导致的不平衡。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS010",
      "name": "二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "一种基本的树形数据结构，其中每个结点最多有两个子结点，分别称为左孩子和右孩子。子树有左右之分，次序不能颠倒。",
        "存储开销": "链式存储O(n)，顺序存储（用于完全二叉树）O(n)",
        "核心特性": "每个结点最多两个孩子，区分左右子树",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    }
  ],
  "relations": [
    {
      "type": "继承",
      "ID": "06REL001",
      "source": "06DS001",
      "target": "06DS010"
    },
    {
      "type": "继承",
      "ID": "06REL002",
      "source": "06DS002",
      "target": "06DS010"
    },
    {
      "type": "继承",
      "ID": "06REL003",
      "source": "06DS006",
      "target": "06DS010"
    },
    {
      "type": "继承",
      "ID": "06REL004",
      "source": "06DS008",
      "target": "06DS010"
    },
    {
      "type": "继承",
      "ID": "06REL005",
      "source": "06DS009",
      "target": "06DS001"
    },
    {
      "type": "继承",
      "ID": "06REL006",
      "source": "06DS003",
      "target": "06DS002"
    },
    {
      "type": "继承",
      "ID": "06REL007",
      "source": "06DS004",
      "target": "06DS002"
    },
    {
      "type": "继承",
      "ID": "06REL008",
      "source": "06DS007",
      "target": "06DS010"
    },
    {
      "type": "操作绑定",
      "ID": "06REL009",
      "source": "06ALG001",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL010",
      "source": "06ALG002",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL011",
      "source": "06ALG003",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL012",
      "source": "06ALG004",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL013",
      "source": "06ALG005",
      "target": "06DS001"
    },
    {
      "type": "操作绑定",
      "ID": "06REL014",
      "source": "06ALG006",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL015",
      "source": "06ALG007",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL016",
      "source": "06ALG008",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL017",
      "source": "06ALG009",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL018",
      "source": "06ALG010",
      "target": "06DS002"
    },
    {
      "type": "使用",
      "ID": "06REL019",
      "source": "06DS005",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL020",
      "source": "06ALG011",
      "target": "06DS006"
    },
    {
      "type": "操作绑定",
      "ID": "06REL021",
      "source": "06ALG012",
      "target": "06DS006"
    },
    {
      "type": "使用",
      "ID": "06REL022",
      "source": "06ALG013",
      "target": "06DS006"
    },
    {
      "type": "理论依赖",
      "ID": "06REL023",
      "source": "06ALG013",
      "target": "06CON016"
    },
    {
      "type": "理论依赖",
      "ID": "06REL024",
      "source": "06ALG013",
      "target": "06CON013"
    },
    {
      "type": "理论依赖",
      "ID": "06REL025",
      "source": "06DS006",
      "target": "06CON013"
    },
    {
      "type": "理论依赖",
      "ID": "06REL026",
      "source": "06DS006",
      "target": "06CON011"
    },
    {
      "type": "使用",
      "ID": "06REL027",
      "source": "06ALG013",
      "target": "06DS007"
    },
    {
      "type": "操作绑定",
      "ID": "06REL028",
      "source": "06ALG014",
      "target": "06DS008"
    },
    {
      "type": "操作绑定",
      "ID": "06REL029",
      "source": "06ALG015",
      "target": "06DS008"
    },
    {
      "type": "操作绑定",
      "ID": "06REL030",
      "source": "06ALG016",
      "target": "06DS008"
    },
    {
      "type": "操作绑定",
      "ID": "06REL031",
      "source": "06ALG017",
      "target": "06DS008"
    },
    {
      "type": "操作绑定",
      "ID": "06REL032",
      "source": "06ALG018",
      "target": "06DS008"
    },
    {
      "type": "理论依赖",
      "ID": "06REL033",
      "source": "06DS008",
      "target": "06CON017"
    },
    {
      "type": "理论依赖",
      "ID": "06REL034",
      "source": "06DS008",
      "target": "06CON007"
    },
    {
      "type": "理论依赖",
      "ID": "06REL035",
      "source": "06DS008",
      "target": "06CON021"
    },
    {
      "type": "理论依赖",
      "ID": "06REL036",
      "source": "06DS009",
      "target": "06CON023"
    },
    {
      "type": "操作绑定",
      "ID": "06REL037",
      "source": "06ALG019",
      "target": "06DS009"
    },
    {
      "type": "操作绑定",
      "ID": "06REL038",
      "source": "06ALG020",
      "target": "06DS009"
    },
    {
      "type": "操作绑定",
      "ID": "06REL039",
      "source": "06ALG021",
      "target": "06DS009"
    },
    {
      "type": "操作绑定",
      "ID": "06REL040",
      "source": "06ALG022",
      "target": "06DS009"
    },
    {
      "type": "理论依赖",
      "ID": "06REL041",
      "source": "06ALG019",
      "target": "06CON024"
    },
    {
      "type": "理论依赖",
      "ID": "06REL042",
      "source": "06ALG020",
      "target": "06CON024"
    },
    {
      "type": "理论依赖",
      "ID": "06REL043",
      "source": "06ALG021",
      "target": "06CON024"
    },
    {
      "type": "理论依赖",
      "ID": "06REL044",
      "source": "06ALG022",
      "target": "06CON024"
    },
    {
      "type": "理论依赖",
      "ID": "06REL045",
      "source": "06DS001",
      "target": "06CON001"
    },
    {
      "type": "理论依赖",
      "ID": "06REL046",
      "source": "06DS001",
      "target": "06CON002"
    },
    {
      "type": "理论依赖",
      "ID": "06REL047",
      "source": "06ALG004",
      "target": "06CON007"
    },
    {
      "type": "理论依赖",
      "ID": "06REL048",
      "source": "06DS002",
      "target": "06CON008"
    }
  ]
}
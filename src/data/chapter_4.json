{
  "entities": [
    {
      "type": "数据结构",
      "ID": "04DS001",
      "name": "线性表",
      "attributes": {
        "难度": "入门",
        "内容": "线性表是具有相同数据类型的n(n≥0)个数据元素的有限序列，是最基本、最简单、也是最常用的一种数据结构。数据元素之间存在一对一的线性关系。",
        "存储开销": "取决于具体实现（顺序或链式）",
        "核心特性": "序列性、元素类型一致性",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS002",
      "name": "栈",
      "attributes": {
        "难度": "入门",
        "内容": "又称堆栈，是一种运算受限的线性表。其限制是仅允许在表的一端（称为栈顶）进行插入（入栈）和删除（出栈）运算，另一端称为栈底。特点是后进先出（LIFO）。常用于表达式求值、括号匹配、递归实现等。",
        "存储开销": "O(n)，n为元素个数",
        "核心特性": "后进先出（LIFO）、单端操作",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS003",
      "name": "队列",
      "attributes": {
        "难度": "入门",
        "内容": "简称队，是一种运算受限的线性表。其限制是仅允许在表的一端（称为队尾）进行插入（入队），而在表的另一端（称为队首）进行删除（出队）。特点是先进先出（FIFO）。常用于广度优先搜索、任务调度、缓冲区管理等。",
        "存储开销": "O(n)，n为元素个数",
        "核心特性": "先进先出（FIFO）、双端操作（一端入、一端出）",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS004",
      "name": "顺序栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组（顺序存储结构）实现的栈。通常需要一个数组和一个栈顶指针（top）来指示栈顶元素的位置。插入和删除操作的时间复杂度为O(1)，但可能存在空间溢出问题（栈满）或需要动态扩容。",
        "存储开销": "O(N)，N为预分配数组大小",
        "核心特性": "顺序存储、O(1)操作（无扩容时）、可能栈满",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS005",
      "name": "链栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用链表（链接存储结构）实现的栈。通常使用单链表实现，栈顶指针指向链表头结点。插入和删除操作的时间复杂度为O(1)，空间可以动态增长，理论上不存在栈满问题（受限于内存）。",
        "存储开销": "O(n)，n为元素个数",
        "核心特性": "链式存储、O(1)操作、动态空间",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS006",
      "name": "顺序队列",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组（顺序存储结构）实现的队列。通常需要一个数组以及队首（front）和队尾（rear）两个指针。为了有效利用空间，常实现为循环队列，通过取模运算处理边界。入队和出队操作的时间复杂度为O(1)，但可能存在“假溢出”问题（通过循环队列解决）或队列满需要扩容。",
        "存储开销": "O(N)，N为预分配数组大小",
        "核心特性": "顺序存储、循环利用空间、O(1)操作（无扩容时）、可能队满",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS007",
      "name": "链队",
      "attributes": {
        "难度": "入门",
        "内容": "使用链表（链接存储结构）实现的队列。通常使用带头尾指针的单链表实现，队首指针指向头结点，队尾指针指向尾结点。入队和出队操作的时间复杂度为O(1)，空间可以动态增长。",
        "存储开销": "O(n)，n为元素个数",
        "核心特性": "链式存储、O(1)操作、动态空间",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS008",
      "name": "优先级队列",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的队列，队列中的每个元素都关联一个优先级。出队时，总是优先级最高的元素先出队。插入元素时需要维护优先级顺序。通常使用堆来实现。",
        "存储开销": "通常O(n)，取决于实现",
        "核心特性": "按优先级出队",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG001",
      "name": "初始化栈",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空栈。对于顺序栈，通常是将栈顶指针设为-1或特定初始值，并可能分配存储空间；对于链栈，是将栈顶指针设为NULL。",
        "时间复杂度": "O(1) 或 O(MaxSize)（如果涉及初始化数组）",
        "空间复杂度": "O(1) 或 O(MaxSize)",
        "设计思想": "初始化",
        "适用场景": "使用栈之前",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG002",
      "name": "进栈",
      "attributes": {
        "难度": "入门",
        "内容": "将一个新元素添加到栈顶。对于顺序栈，是将栈顶指针加1，然后将元素存入指针指向的位置（需检查栈满）；对于链栈，是创建一个新结点，使其指向原栈顶结点，然后更新栈顶指针。",
        "时间复杂度": "O(1) （顺序栈不考虑扩容时）",
        "空间复杂度": "O(1)",
        "设计思想": "插入",
        "适用场景": "向栈中添加元素",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG003",
      "name": "出栈",
      "attributes": {
        "难度": "入门",
        "内容": "删除栈顶元素并返回其值。对于顺序栈，是先获取栈顶元素值，然后将栈顶指针减1（需检查栈空）；对于链栈，是获取头结点数据，更新栈顶指针指向下一个结点，并释放原头结点（需检查栈空）。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "删除",
        "适用场景": "从栈中移除并获取元素",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG004",
      "name": "读取栈顶元素",
      "attributes": {
        "难度": "入门",
        "内容": "返回栈顶元素的值，但不删除它。对于顺序栈，是直接返回栈顶指针指向位置的元素；对于链栈，是返回头结点的数据（需检查栈空）。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "访问",
        "适用场景": "查看栈顶元素而不修改栈",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG005",
      "name": "判断栈空",
      "attributes": {
        "难度": "入门",
        "内容": "检查栈是否包含任何元素。对于顺序栈，通常是检查栈顶指针是否等于-1或特定初始值；对于链栈，是检查栈顶指针是否为NULL。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "状态检查",
        "适用场景": "执行出栈或读取栈顶元素前的安全检查",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG006",
      "name": "清空栈",
      "attributes": {
        "难度": "入门",
        "内容": "移除栈中所有元素，使其变为空栈。对于顺序栈，只需重置栈顶指针；对于链栈，需要遍历并释放所有结点。",
        "时间复杂度": "O(1) (顺序栈) 或 O(n) (链栈)",
        "空间复杂度": "O(1)",
        "设计思想": "重置/清理",
        "适用场景": "重用栈结构或释放资源",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG007",
      "name": "初始化队列",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空队列。对于顺序队列，通常是将队首和队尾指针设为相同值（如0），并可能分配存储空间；对于链队，是将队首和队尾指针都设为NULL。",
        "时间复杂度": "O(1) 或 O(MaxSize)",
        "空间复杂度": "O(1) 或 O(MaxSize)",
        "设计思想": "初始化",
        "适用场景": "使用队列之前",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG008",
      "name": "进队",
      "attributes": {
        "难度": "入门",
        "内容": "将一个新元素添加到队尾。对于顺序（循环）队列，是将元素存入队尾指针指向的位置，然后队尾指针加1（取模）（需检查队满）；对于链队，是创建新结点，链接到队尾，并更新队尾指针。",
        "时间复杂度": "O(1) （顺序队列不考虑扩容时）",
        "空间复杂度": "O(1)",
        "设计思想": "插入",
        "适用场景": "向队列中添加元素",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG009",
      "name": "出队",
      "attributes": {
        "难度": "入门",
        "内容": "删除队首元素并返回其值。对于顺序（循环）队列，是获取队首指针加1（取模）位置的元素，然后队首指针加1（取模）（需检查队空）；对于链队，是获取头结点数据，更新队首指针指向下一个结点，并释放原头结点（若删除后队列为空，需更新队尾指针）。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "删除",
        "适用场景": "从队列中移除并获取元素",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG010",
      "name": "读取队首元素",
      "attributes": {
        "难度": "入门",
        "内容": "返回队首元素的值，但不删除它。对于顺序（循环）队列，是返回队首指针加1（取模）位置的元素；对于链队，是返回头结点的数据（需检查队空）。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "访问",
        "适用场景": "查看队首元素而不修改队列",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG011",
      "name": "判断队空",
      "attributes": {
        "难度": "入门",
        "内容": "检查队列是否包含任何元素。对于顺序（循环）队列，通常是检查队首和队尾指针是否相等；对于链队，是检查队首（或队尾）指针是否为NULL。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "状态检查",
        "适用场景": "执行出队或读取队首元素前的安全检查",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG012",
      "name": "清空队列",
      "attributes": {
        "难度": "入门",
        "内容": "移除队列中所有元素，使其变为空队列。对于顺序队列，只需重置队首和队尾指针；对于链队，需要遍历并释放所有结点。",
        "时间复杂度": "O(1) (顺序队列) 或 O(n) (链队)",
        "空间复杂度": "O(1)",
        "设计思想": "重置/清理",
        "适用场景": "重用队列结构或释放资源",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG013",
      "name": "括号配对检查",
      "attributes": {
        "难度": "入门",
        "内容": "检查一个表达式或代码段中的括号（如(), [], {}）是否正确配对。算法通常遍历字符串，遇到左括号则入栈，遇到右括号则检查栈顶是否为对应左括号，若是则出栈，否则配对失败。结束后若栈为空则配对成功。",
        "时间复杂度": "O(n)，n为字符串长度",
        "空间复杂度": "O(n)，最坏情况下所有左括号入栈",
        "设计思想": "栈应用、匹配",
        "适用场景": "编译器语法分析、代码编辑器检查",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG014",
      "name": "进制转换",
      "attributes": {
        "难度": "入门",
        "内容": "将一个十进制数转换为其他进制（如二进制、八进制、十六进制）的数。常用方法是“除基取余法”，将每次得到的余数入栈，转换完成后依次出栈即可得到正确顺序的转换结果。",
        "时间复杂度": "O(log_r N)，N为十进制数，r为目标进制基数",
        "空间复杂度": "O(log_r N)，栈的深度",
        "设计思想": "栈应用、数制转换",
        "适用场景": "数值表示转换",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG015",
      "name": "后缀表达式求值",
      "attributes": {
        "难度": "中等",
        "内容": "计算后缀表达式（逆波兰表示法）的值。算法从左到右扫描表达式，遇到操作数则入栈，遇到运算符则从栈中弹出所需数量的操作数进行运算，并将结果压回栈中。表达式扫描完毕后，栈中唯一的值即为结果。",
        "时间复杂度": "O(n)，n为表达式长度",
        "空间复杂度": "O(n)，最坏情况下操作数栈的大小",
        "设计思想": "栈应用、表达式求值",
        "适用场景": "计算器实现、编译器中间代码执行",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG016",
      "name": "中缀转后缀",
      "attributes": {
        "难度": "中等",
        "内容": "将普通的中缀算术表达式转换为后缀表达式（逆波兰表示法）。算法使用一个栈来暂存运算符，根据运算符优先级和括号来决定运算符的出栈顺序并添加到后缀表达式中，操作数则直接添加到后缀表达式。",
        "时间复杂度": "O(n)，n为表达式长度",
        "空间复杂度": "O(n)，最坏情况下运算符栈的大小",
        "设计思想": "栈应用、表达式转换、优先级处理",
        "适用场景": "编译器语法分析、后缀表达式求值的前置步骤",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG017",
      "name": "求n阶乘",
      "attributes": {
        "难度": "入门",
        "内容": "计算非负整数n的阶乘（n! = 1 * 2 * ... * n，0! = 1）。可以使用循环或递归实现。递归定义为 f(n) = n * f(n-1) 当 n>0，f(0) = 1。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)（循环）或 O(n)（递归栈深度）",
        "设计思想": "循环、递归",
        "适用场景": "数学计算、组合问题",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG018",
      "name": "输出布尔组合",
      "attributes": {
        "难度": "中等",
        "内容": "生成n个布尔变量所有可能的真/假组合（共2^n种）。通常使用递归实现，每次递归决定一个变量的取值（0或1），递归到第n层时输出当前组合。",
        "时间复杂度": "O(n * 2^n)，因为有2^n种组合，每种组合输出需要O(n)",
        "空间复杂度": "O(n)，递归栈深度",
        "设计思想": "递归、回溯",
        "适用场景": "枚举所有可能性、真值表生成",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG019",
      "name": "全排列",
      "attributes": {
        "难度": "中等",
        "内容": "生成n个不同元素的所有排列（共n!种）。常用递归实现，通过交换元素来确定每个位置的元素，并对剩余元素进行递归排列。",
        "时间复杂度": "O(n * n!)，因为有n!种排列，每种排列输出或生成需要O(n)",
        "空间复杂度": "O(n)，递归栈深度",
        "设计思想": "递归、回溯、交换",
        "适用场景": "组合优化问题、枚举所有排列",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG020",
      "name": "迷宫问题求解",
      "attributes": {
        "难度": "中等",
        "内容": "寻找从迷宫入口到出口的一条路径。可以使用深度优先搜索（DFS，通常用递归或栈实现）或广度优先搜索（BFS，通常用队列实现）。DFS找到的是任意一条路径，BFS找到的是最短路径（按步数）。",
        "时间复杂度": "O(m*n)，m,n为迷宫尺寸",
        "空间复杂度": "O(m*n)，最坏情况下访问所有格子",
        "设计思想": "搜索（DFS/BFS）、回溯、栈/队列应用",
        "适用场景": "路径查找、图搜索",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG021",
      "name": "汉诺塔问题求解",
      "attributes": {
        "难度": "中等",
        "内容": "将n个大小不同的圆盘从起始柱借助辅助柱移动到目标柱，每次只能移动一个，且大盘不能在小盘之上。这是一个经典的递归问题。将n个盘从A移到C（B为辅助）：1. 将n-1个盘从A移到B（C为辅助）；2. 将第n个盘从A移到C；3. 将n-1个盘从B移到C（A为辅助）。",
        "时间复杂度": "O(2^n)",
        "空间复杂度": "O(n)，递归栈深度",
        "设计思想": "递归、分治",
        "适用场景": "递归教学示例、理解递归思想",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON001",
      "name": "后进先出",
      "attributes": {
        "难度": "入门",
        "内容": "Last-In, First-Out (LIFO)。一种数据访问顺序原则，最后存入的数据最先被取出。栈是典型的LIFO结构。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON002",
      "name": "先进先出",
      "attributes": {
        "难度": "入门",
        "内容": "First-In, First-Out (FIFO)。一种数据访问顺序原则，最先存入的数据最先被取出。队列是典型的FIFO结构。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON003",
      "name": "中缀表达式",
      "attributes": {
        "难度": "入门",
        "内容": "一种常见的算术表达式表示法，其中运算符位于其操作数之间（例如 a + b）。计算时需要考虑运算符优先级和括号。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON004",
      "name": "后缀表达式",
      "attributes": {
        "难度": "中等",
        "内容": "也称为逆波兰表示法（Reverse Polish Notation, RPN）。一种算术表达式表示法，其中运算符位于其操作数之后（例如 a b +）。计算时不需要考虑优先级或括号，只需从左到右扫描，使用栈即可方便求值。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON005",
      "name": "运算符优先级",
      "attributes": {
        "难度": "入门",
        "内容": "在算术表达式中，不同运算符具有不同的计算优先顺序。例如，乘除通常优先于加减。括号可以改变运算顺序。在中缀表达式求值和转换中必须考虑优先级。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON006",
      "name": "递归",
      "attributes": {
        "难度": "中等",
        "内容": "一种解决问题的方法，其中函数直接或间接调用自身来解决规模更小的相同问题。递归需要包含基本情况（终止条件）以防止无限调用。系统通常使用栈来管理递归调用的上下文。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    }
  ],
  "relations": [
    {
      "type": "继承",
      "ID": "04REL001",
      "source": "04DS002",
      "target": "04DS001"
    },
    {
      "type": "继承",
      "ID": "04REL002",
      "source": "04DS003",
      "target": "04DS001"
    },
    {
      "type": "继承",
      "ID": "04REL003",
      "source": "04DS004",
      "target": "04DS002"
    },
    {
      "type": "继承",
      "ID": "04REL004",
      "source": "04DS005",
      "target": "04DS002"
    },
    {
      "type": "继承",
      "ID": "04REL005",
      "source": "04DS006",
      "target": "04DS003"
    },
    {
      "type": "继承",
      "ID": "04REL006",
      "source": "04DS007",
      "target": "04DS003"
    },
    {
      "type": "变体",
      "ID": "04REL007",
      "source": "04DS008",
      "target": "04DS003"
    },
    {
      "type": "操作绑定",
      "ID": "04REL008",
      "source": "04ALG001",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "ID": "04REL009",
      "source": "04ALG002",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "ID": "04REL010",
      "source": "04ALG003",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "ID": "04REL011",
      "source": "04ALG004",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "ID": "04REL012",
      "source": "04ALG005",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "ID": "04REL013",
      "source": "04ALG006",
      "target": "04DS002"
    },
        {
      "type": "操作绑定",
      "ID": "04REL014",
      "source": "04ALG007",
      "target": "04DS003"
    },
    {
      "type": "操作绑定",
      "ID": "04REL015",
      "source": "04ALG008",
      "target": "04DS003"
    },
    {
      "type": "操作绑定",
      "ID": "04REL016",
      "source": "04ALG009",
      "target": "04DS003"
    },
    {
      "type": "操作绑定",
      "ID": "04REL017",
      "source": "04ALG010",
      "target": "04DS003"
    },
    {
      "type": "操作绑定",
      "ID": "04REL018",
      "source": "04ALG011",
      "target": "04DS003"
    },
    {
      "type": "操作绑定",
      "ID": "04REL019",
      "source": "04ALG012",
      "target": "04DS003"
    },
    {
      "type": "使用",
      "ID": "04REL020",
      "source": "04ALG013",
      "target": "04DS002"
    },
    {
      "type": "使用",
      "ID": "04REL021",
      "source": "04ALG014",
      "target": "04DS002"
    },
    {
      "type": "使用",
      "ID": "04REL022",
      "source": "04ALG015",
      "target": "04DS002"
    },
    {
      "type": "理论依赖",
      "ID": "04REL023",
      "source": "04ALG015",
      "target": "04CON004"
    },
    {
      "type": "使用",
      "ID": "04REL024",
      "source": "04ALG016",
      "target": "04DS002"
    },
    {
      "type": "理论依赖",
      "ID": "04REL025",
      "source": "04ALG016",
      "target": "04CON003"
    },
    {
      "type": "理论依赖",
      "ID": "04REL026",
      "source": "04ALG016",
      "target": "04CON004"
    },
    {
      "type": "理论依赖",
      "ID": "04REL027",
      "source": "04ALG016",
      "target": "04CON005"
    },
    {
      "type": "理论依赖",
      "ID": "04REL028",
      "source": "04ALG017",
      "target": "04CON006"
    },
    {
      "type": "理论依赖",
      "ID": "04REL029",
      "source": "04ALG018",
      "target": "04CON006"
    },
    {
      "type": "理论依赖",
      "ID": "04REL030",
      "source": "04ALG019",
      "target": "04CON006"
    },
    {
      "type": "理论依赖",
      "ID": "04REL031",
      "source": "04ALG020",
      "target": "04CON006"
    },
     {
      "type": "使用",
      "ID": "04REL032",
      "source": "04ALG020",
      "target": "04DS002"
    },
    {
      "type": "使用",
      "ID": "04REL033",
      "source": "04ALG020",
      "target": "04DS003"
    },
    {
      "type": "理论依赖",
      "ID": "04REL034",
      "source": "04ALG021",
      "target": "04CON006"
    },
    {
      "type": "理论依赖",
      "ID": "04REL035",
      "source": "04DS002",
      "target": "04CON001"
    },
    {
      "type": "理论依赖",
      "ID": "04REL036",
      "source": "04DS003",
      "target": "04CON002"
    },
    {
      "type": "理论依赖",
      "ID": "04REL037",
      "source": "04CON006",
      "target": "04DS002"
    }
  ]
}
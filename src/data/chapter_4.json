{
  "entities": [
    {
      "type": "数据结构",
      "ID": "04DS001",
      "name": "栈",
      "attributes": {
        "难度": "入门",
        "内容": "又称堆栈，是一种运算受限的线性表，仅允许在表的一端（栈顶）进行插入（入栈）和删除（出栈）运算。具有后进先出（LIFO）的特性。栈顶是允许操作的一端，另一端为栈底。栈顶元素是栈顶的第一个元素。",
        "存储开销": "顺序存储需要预分配空间（可能浪费或不足），链式存储需要额外指针开销。",
        "核心特性": "后进先出（LIFO）",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS002",
      "name": "队列",
      "attributes": {
        "难度": "入门",
        "内容": "简称队，是一种运算受限的线性表，允许在表的一端（队尾）进行插入（入队），在另一端（队首）进行删除（出队）。具有先进先出（FIFO）的特性。",
        "存储开销": "顺序存储（循环队列）需要预分配空间并可能牺牲一个单元以区分空/满，链式存储需要额外指针开销。",
        "核心特性": "先进先出（FIFO）",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS003",
      "name": "线性表",
      "attributes": {
        "难度": "入门",
        "内容": "数据元素之间存在一对一线性关系的数据结构。栈和队列是两种特殊的线性表，限制了操作的位置。",
        "存储开销": "取决于具体实现（顺序或链式）。",
        "核心特性": "元素间一对一关系，逻辑结构线性。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON001",
      "name": "栈顶",
      "attributes": {
        "难度": "入门",
        "内容": "栈允许进行插入和删除操作的一端。栈顶的第一个元素称为栈顶元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON002",
      "name": "栈底",
      "attributes": {
        "难度": "入门",
        "内容": "栈不允许进行插入和删除操作的一端，与栈顶相对。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG001",
      "name": "进栈",
      "attributes": {
        "难度": "入门",
        "内容": "也称入栈。在栈顶插入一个新元素，使其成为新的栈顶元素。顺序栈实现时需移动栈顶指针并存入元素，链栈实现时需创建新节点并修改头指针。",
        "时间复杂度": "O(1)（顺序栈空间足够或链栈）",
        "空间复杂度": "O(1)",
        "设计思想": "栈的基本操作",
        "适用场景": "向栈中添加数据。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG002",
      "name": "出栈",
      "attributes": {
        "难度": "入门",
        "内容": "也称退栈。删除栈顶元素，使其下面的相邻元素成为新的栈顶元素。顺序栈实现时移动栈顶指针，链栈实现时修改头指针并释放节点。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "栈的基本操作",
        "适用场景": "从栈中移除并（可选地）获取数据。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON003",
      "name": "后进先出",
      "attributes": {
        "难度": "入门",
        "内容": "Last In First Out (LIFO)。描述栈的操作特性，最后进入栈的元素最先被移出。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG003",
      "name": "读取栈顶元素",
      "attributes": {
        "难度": "入门",
        "内容": "查看栈顶元素的值，但不删除它，栈的状态不改变。对应 ADT 中的 Peek 操作。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "栈的访问操作",
        "适用场景": "需要知道栈顶元素但暂时不移除它时。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG004",
      "name": "判断栈空",
      "attributes": {
        "难度": "入门",
        "内容": "检查栈中是否包含任何元素。对应 ADT 中的 EmptyStack 操作。顺序栈通常检查 top 是否为 -1，链栈检查头指针是否为 NULL。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "栈的状态检查",
        "适用场景": "执行出栈或读取栈顶元素前进行检查，或作为算法终止条件。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG005",
      "name": "清空栈",
      "attributes": {
        "难度": "入门",
        "内容": "移除栈中所有元素，使其变为空栈。对应 ADT 中的 ClearStack 操作。顺序栈重置 top 指针，链栈需遍历释放所有节点。",
        "时间复杂度": "O(1)（顺序栈），O(n)（链栈）",
        "空间复杂度": "O(1)",
        "设计思想": "栈的重置操作",
        "适用场景": "需要复用栈结构或释放资源时。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG006",
      "name": "初始化栈",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空栈。对应 ADT 中的 InitStack 操作。顺序栈可能分配数组空间并将 top 置为 -1，链栈将头指针置为 NULL。",
        "时间复杂度": "O(1) 或 O(MaxSize)（若涉及分配）",
        "空间复杂度": "O(MaxSize)（顺序栈预分配）或 O(1)（链栈）",
        "设计思想": "栈的创建操作",
        "适用场景": "开始使用栈之前。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS004",
      "name": "顺序栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组（顺序存储结构）实现的栈。通过数组下标（栈顶指针 top）来管理栈顶。存在栈满的可能。",
        "存储开销": "固定大小数组，可能空间浪费或不足。需要一个额外的整型变量存储 top。",
        "核心特性": "顺序存储，随机访问（理论上，但栈操作只访问栈顶），可能有容量限制。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS005",
      "name": "链栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用链表（链接存储结构）实现的栈。通常用单链表实现，表头作为栈顶。插入和删除操作在链表头部进行。",
        "存储开销": "每个元素需要额外空间存储指针。动态分配，按需使用空间。",
        "核心特性": "链式存储，动态大小，无栈满问题（理论上受内存限制）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG018",
      "name": "括号配对检查",
      "attributes": {
        "难度": "中等",
        "内容": "利用栈检查表达式（如 C/C++ 代码）中的括号（圆括号、方括号、大括号）是否正确配对。遇到左括号入栈，遇到右括号检查栈顶是否匹配，匹配则出栈，不匹配则错误。扫描结束时栈应为空。",
        "时间复杂度": "O(n)，n 为表达式长度",
        "空间复杂度": "O(n)，最坏情况所有左括号入栈",
        "设计思想": "利用栈的 LIFO 特性匹配最近的未闭合括号",
        "适用场景": "编译器语法分析、代码编辑器语法高亮/检查。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG019",
      "name": "进制转换",
      "attributes": {
        "难度": "入门",
        "内容": "将一个十进制整数转换为其他进制（如二至九进制）的表示。利用“除基取余法”，将每次得到的余数入栈，转换完成后依次出栈即可得到正确顺序的转换结果。",
        "时间复杂度": "O(log_r n)，n 为待转换数，r 为目标进制基数",
        "空间复杂度": "O(log_r n)，存储余数",
        "设计思想": "利用栈的 LIFO 特性逆转余数产生的顺序",
        "适用场景": "数值表示转换。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON004",
      "name": "中缀表达式",
      "attributes": {
        "难度": "入门",
        "内容": "运算符位于其操作数之间的算术表达式表示法。如 `a + b`。计算时需要考虑运算符优先级和括号。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON005",
      "name": "后缀表达式",
      "attributes": {
        "难度": "入门",
        "内容": "也称逆波兰式。运算符位于其操作数之后的算术表达式表示法。如 `a b +`。计算时无需考虑优先级和括号，只需从左到右扫描，遇到操作数入栈，遇到运算符则弹出所需操作数计算并将结果入栈。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG007",
      "name": "后缀表达式求值",
      "attributes": {
        "难度": "中等",
        "内容": "计算后缀表达式的值。使用一个栈存储操作数。从左到右扫描表达式，遇到操作数压入栈，遇到运算符弹出相应数量的操作数进行计算，并将结果压回栈。表达式扫描完毕后，栈中唯一的值即为结果。",
        "时间复杂度": "O(n)，n 为表达式长度",
        "空间复杂度": "O(n)，最坏情况存储所有操作数",
        "设计思想": "利用栈处理运算顺序",
        "适用场景": "计算器、编译器中间代码执行。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG008",
      "name": "中缀转后缀",
      "attributes": {
        "难度": "中等",
        "内容": "将中缀表达式转换为等价的后缀表达式。使用一个栈存储运算符。扫描中缀表达式，遇到操作数直接输出；遇到运算符，与栈顶运算符比较优先级，若当前运算符优先级低或等于栈顶（且栈顶非左括号），则弹出栈顶运算符输出，重复此过程直到栈顶优先级低或栈空，再将当前运算符入栈；遇到左括号入栈；遇到右括号，弹出栈中运算符直至遇到左括号。",
        "时间复杂度": "O(n)，n 为表达式长度",
        "空间复杂度": "O(n)，最坏情况存储所有运算符",
        "设计思想": "利用栈管理运算符优先级和括号",
        "适用场景": "编译器语法分析、表达式求值预处理。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON006",
      "name": "递归",
      "attributes": {
        "难度": "中等",
        "内容": "一种解决问题的方法，其中函数直接或间接调用自身来解决规模更小的同类子问题。必须包含基本情况（终止条件）以结束递归。系统通常使用栈来管理递归调用的状态（参数、局部变量、返回地址）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "分而治之，化繁为简的哲学思想。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG009",
      "name": "递归阶乘",
      "attributes": {
        "难度": "入门",
        "内容": "使用递归方法计算非负整数 n 的阶乘。定义 f(n) = n * f(n-1)，基本情况 f(0) = 1。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(n)（递归栈深度）",
        "设计思想": "递归",
        "适用场景": "教学示例，理解递归概念。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG010",
      "name": "递归迷宫求解",
      "attributes": {
        "难度": "高级",
        "内容": "使用递归（深度优先搜索）寻找迷宫中从入口到出口的路径。从当前位置尝试向四周（如东、南、西、北）未访问过的可通行方格移动，并递归调用自身。若递归调用返回成功，则当前路径有效；若所有方向尝试失败，则回溯。",
        "时间复杂度": "O(m*n)，m, n 为迷宫尺寸（最坏情况访问所有格子）",
        "空间复杂度": "O(m*n)（递归栈深度，最坏情况路径覆盖所有格子）",
        "设计思想": "递归、回溯、深度优先搜索",
        "适用场景": "路径查找问题。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "探索与回溯，体现解决复杂问题的策略性思考。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG011",
      "name": "递归汉诺塔",
      "attributes": {
        "难度": "中等",
        "内容": "使用递归解决汉诺塔问题。将 n 个盘子从 A 移动到 C（借助 B）分解为：1. 将 n-1 个盘子从 A 移动到 B（借助 C）；2. 将第 n 个盘子从 A 移动到 C；3. 将 n-1 个盘子从 B 移动到 C（借助 A）。基本情况是 n=1 时直接移动。",
        "时间复杂度": "O(2^n)",
        "空间复杂度": "O(n)（递归栈深度）",
        "设计思想": "递归、分治",
        "适用场景": "教学示例，理解递归和分治思想。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "化繁为简，体现解决复杂问题的分解思想。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON007",
      "name": "队尾",
      "attributes": {
        "难度": "入门",
        "内容": "队列允许插入元素的一端。新元素入队后成为新的队尾元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON008",
      "name": "队首",
      "attributes": {
        "难度": "入门",
        "内容": "队列允许删除元素的一端。元素出队后，其后继元素成为新的队首元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG012",
      "name": "进队",
      "attributes": {
        "难度": "入门",
        "内容": "也称入队。在队尾插入一个新元素。循环队列实现时需移动队尾指针（考虑取模），链队实现时需修改尾指针并可能修改头指针（若原队列为空）。",
        "时间复杂度": "O(1)（循环队列空间足够或链队）",
        "空间复杂度": "O(1)",
        "设计思想": "队列的基本操作",
        "适用场景": "向队列中添加数据。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG013",
      "name": "出队",
      "attributes": {
        "难度": "入门",
        "内容": "也称离队。删除队首元素。循环队列实现时移动队首指针（考虑取模），链队实现时修改头指针并释放节点，可能修改尾指针（若删除后队列为空）。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "队列的基本操作",
        "适用场景": "从队列中移除并（可选地）获取数据。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON009",
      "name": "先进先出",
      "attributes": {
        "难度": "入门",
        "内容": "First In First Out (FIFO)。描述队列的操作特性，最先进入队列的元素最先被移出。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "公平排队原则的体现。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG014",
      "name": "读取队首元素",
      "attributes": {
        "难度": "入门",
        "内容": "查看队首元素的值，但不删除它，队列的状态不改变。对应 ADT 中的 PeekQueue 操作。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "队列的访问操作",
        "适用场景": "需要知道下一个将要处理的元素但暂时不处理它时。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG015",
      "name": "判断队空",
      "attributes": {
        "难度": "入门",
        "内容": "检查队列中是否包含任何元素。对应 ADT 中的 EmptyQueue 操作。循环队列比较 front 和 rear 指针，链队检查头指针是否为 NULL。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "队列的状态检查",
        "适用场景": "执行出队或读取队首元素前进行检查，或作为算法终止条件。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG016",
      "name": "清空队列",
      "attributes": {
        "难度": "入门",
        "内容": "移除队列中所有元素，使其变为空队。对应 ADT 中的 ClearQueue 操作。循环队列重置 front 和 rear 指针，链队需遍历释放所有节点。",
        "时间复杂度": "O(1)（循环队列），O(n)（链队）",
        "空间复杂度": "O(1)",
        "设计思想": "队列的重置操作",
        "适用场景": "需要复用队列结构或释放资源时。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG017",
      "name": "初始化队列",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空队列。对应 ADT 中的 InitQueue 操作。循环队列可能分配数组空间并将 front 和 rear 置为相同值，链队将头尾指针置为 NULL。",
        "时间复杂度": "O(1) 或 O(MaxSize)（若涉及分配）",
        "空间复杂度": "O(MaxSize)（循环队列预分配）或 O(1)（链队）",
        "设计思想": "队列的创建操作",
        "适用场景": "开始使用队列之前。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS006",
      "name": "顺序队列",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组（顺序存储结构）实现的队列。通常实现为循环队列，利用取模运算处理边界，解决“假溢出”问题。需要队首(front)和队尾(rear)两个指针。",
        "存储开销": "固定大小数组，为区分队空和队满可能牺牲一个存储单元或使用额外计数变量。需要两个整型变量存储 front 和 rear。",
        "核心特性": "顺序存储，循环利用空间，可能有容量限制。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "循环利用资源的思想。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS007",
      "name": "链队",
      "attributes": {
        "难度": "入门",
        "内容": "使用链表（链接存储结构）实现的队列。需要队首(front)和队尾(rear)两个指针，分别指向链表的头结点和尾结点。入队在链表尾部进行，出队在链表头部进行。",
        "存储开销": "每个元素需要额外空间存储指针。动态分配，按需使用空间。",
        "核心特性": "链式存储，动态大小，无队列满问题（理论上受内存限制）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS008",
      "name": "优先级队列",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的队列，其中每个元素关联一个优先级。出队操作总是移除优先级最高的元素。入队操作可能需要调整结构以维持优先级顺序。常用于调度。",
        "存储开销": "取决于具体实现（如堆）。",
        "核心特性": "按优先级出队，而非 FIFO。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "区分重要性，优先处理关键任务的策略。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG020",
      "name": "渡口管理模拟",
      "attributes": {
        "难度": "中等",
        "内容": "模拟轮船渡口车辆管理。使用两个队列分别管理客车和货车，根据特定规则（如客车优先、按比例上船）安排车辆上渡轮。",
        "时间复杂度": "与车辆到达和渡轮调度次数相关",
        "空间复杂度": "O(N)，N 为等待车辆总数",
        "设计思想": "队列应用，模拟",
        "适用场景": "模拟排队系统、资源调度。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "模拟现实场景，体现公平与效率的结合。"
      }
    }
  ],
  "relations": [
    {
      "type": "继承",
      "ID": "04REL001",
      "source": "04DS001",
      "target": "04DS003"
    },
    {
      "type": "继承",
      "ID": "04REL002",
      "source": "04DS002",
      "target": "04DS003"
    },
    {
      "type": "操作绑定",
      "ID": "04REL003",
      "source": "04ALG001",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "ID": "04REL004",
      "source": "04ALG002",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "ID": "04REL005",
      "source": "04ALG003",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "ID": "04REL006",
      "source": "04ALG004",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "ID": "04REL007",
      "source": "04ALG005",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "ID": "04REL008",
      "source": "04ALG006",
      "target": "04DS001"
    },
    {
      "type": "理论依赖",
      "ID": "04REL009",
      "source": "04DS001",
      "target": "04CON001"
    },
    {
      "type": "理论依赖",
      "ID": "04REL010",
      "source": "04DS001",
      "target": "04CON002"
    },
    {
      "type": "理论依赖",
      "ID": "04REL011",
      "source": "04DS001",
      "target": "04CON003"
    },
    {
      "type": "变体",
      "ID": "04REL012",
      "source": "04DS004",
      "target": "04DS001"
    },
    {
      "type": "变体",
      "ID": "04REL013",
      "source": "04DS005",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "ID": "04REL014",
      "source": "04ALG018",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "ID": "04REL015",
      "source": "04ALG019",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "ID": "04REL016",
      "source": "04ALG007",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "ID": "04REL017",
      "source": "04ALG008",
      "target": "04DS001"
    },
    {
      "type": "理论依赖",
      "ID": "04REL018",
      "source": "04ALG007",
      "target": "04CON005"
    },
    {
      "type": "理论依赖",
      "ID": "04REL019",
      "source": "04ALG008",
      "target": "04CON004"
    },
    {
      "type": "理论依赖",
      "ID": "04REL020",
      "source": "04ALG008",
      "target": "04CON005"
    },
    {
      "type": "理论依赖",
      "ID": "04REL021",
      "source": "04ALG009",
      "target": "04CON006"
    },
    {
      "type": "理论依赖",
      "ID": "04REL022",
      "source": "04ALG010",
      "target": "04CON006"
    },
    {
      "type": "理论依赖",
      "ID": "04REL023",
      "source": "04ALG011",
      "target": "04CON006"
    },
    {
      "type": "理论依赖",
      "ID": "04REL024",
      "source": "04CON006",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "ID": "04REL025",
      "source": "04ALG012",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "ID": "04REL026",
      "source": "04ALG013",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "ID": "04REL027",
      "source": "04ALG014",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "ID": "04REL028",
      "source": "04ALG015",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "ID": "04REL029",
      "source": "04ALG016",
      "target": "04DS002"
    },
    {
      "type": "操作绑定",
      "ID": "04REL030",
      "source": "04ALG017",
      "target": "04DS002"
    },
    {
      "type": "理论依赖",
      "ID": "04REL031",
      "source": "04DS002",
      "target": "04CON007"
    },
    {
      "type": "理论依赖",
      "ID": "04REL032",
      "source": "04DS002",
      "target": "04CON008"
    },
    {
      "type": "理论依赖",
      "ID": "04REL033",
      "source": "04DS002",
      "target": "04CON009"
    },
    {
      "type": "变体",
      "ID": "04REL034",
      "source": "04DS006",
      "target": "04DS002"
    },
    {
      "type": "变体",
      "ID": "04REL035",
      "source": "04DS007",
      "target": "04DS002"
    },
    {
      "type": "变体",
      "ID": "04REL036",
      "source": "04DS008",
      "target": "04DS002"
    },
    {
      "type": "使用",
      "ID": "04REL037",
      "source": "04ALG020",
      "target": "04DS002"
    }
  ]
}
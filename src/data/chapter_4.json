{
  "entities": [
    {
      "type": "数据结构",
      "ID": "04DS001",
      "name": "栈",
      "attributes": {
        "难度": "入门",
        "内容": "又称堆栈，是一种运算受限的线性表，其限制是仅允许在表的一端（栈顶）进行插入（入栈/进栈）和删除（出栈/退栈）运算。另一端称为栈底。具有后进先出（LIFO）特性。",
        "存储开销": "顺序实现为O(MaxSize)，链式实现为O(N)，N为元素个数，链式有额外指针开销。",
        "核心特性": "后进先出（LIFO）、仅限栈顶操作",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "规则意识、有序处理（例如函数调用栈体现的程序执行顺序与嵌套关系）。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS002",
      "name": "线性表",
      "attributes": {
        "难度": "入门",
        "内容": "数据元素之间存在一对一线性关系的结构。每个元素（除首尾外）有且仅有一个直接前驱和一个直接后继。",
        "存储开销": "顺序存储O(MaxSize)，链式存储O(N)。",
        "核心特性": "元素间线性关系、逻辑有序",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "体现事物发展的顺序性、逻辑性，理解抽象与具体实现的关系。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON001",
      "name": "栈顶",
      "attributes": {
        "难度": "入门",
        "内容": "栈中允许进行插入和删除操作的一端。栈顶的第一个元素被称为栈顶元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON002",
      "name": "栈底",
      "attributes": {
        "难度": "入门",
        "内容": "栈中与栈顶相对的另一端，不允许进行插入和删除操作。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG001",
      "name": "入栈",
      "attributes": {
        "难度": "入门",
        "内容": "向栈顶插入一个新元素，使其成为新的栈顶元素。也称进栈。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "栈基本操作",
        "适用场景": "向栈中添加数据",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG002",
      "name": "出栈",
      "attributes": {
        "难度": "入门",
        "内容": "删除栈顶元素，使其下面的相邻元素成为新的栈顶元素。通常会返回被删除的元素。也称退栈。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "栈基本操作",
        "适用场景": "从栈中移除并获取数据",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON003",
      "name": "后进先出",
      "attributes": {
        "难度": "入门",
        "内容": "Last-In, First-Out (LIFO)。描述了栈的操作特性，即最后进入栈的元素最先被移出。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "理解特定规则下的处理顺序，如生活中的盘子堆叠、软件中的撤销操作。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON004",
      "name": "栈的抽象数据类型",
      "attributes": {
        "难度": "入门",
        "内容": "定义了栈的数据对象（具有LIFO性质的元素集合）、数据关系以及基本操作集合（如初始化、入栈、出栈、判空、取栈顶元素等），独立于具体实现。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "抽象思维，区分逻辑结构与物理实现。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG003",
      "name": "初始化栈",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空栈，为其分配必要的存储空间（如果是动态分配）。",
        "时间复杂度": "O(1) 或 O(MaxSize)",
        "空间复杂度": "O(1) 或 O(MaxSize)",
        "设计思想": "结构初始化",
        "适用场景": "在首次使用栈之前进行准备",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG004",
      "name": "读取栈顶元素",
      "attributes": {
        "难度": "入门",
        "内容": "返回栈顶元素的值，但不改变栈的状态（不删除元素）。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "栈状态访问",
        "适用场景": "查看栈顶数据而不修改栈",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG005",
      "name": "判断栈是否为空",
      "attributes": {
        "难度": "入门",
        "内容": "检查栈中是否包含元素，返回布尔值。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "状态检查",
        "适用场景": "在执行出栈或读取栈顶操作前进行检查，防止对空栈操作。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "严谨性，操作前的条件检查。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG006",
      "name": "清除栈",
      "attributes": {
        "难度": "入门",
        "内容": "移除栈中所有元素，使其变为空栈，并可能释放占用的动态存储空间。",
        "时间复杂度": "O(1) 或 O(N)",
        "空间复杂度": "O(1)",
        "设计思想": "资源回收与重置",
        "适用场景": "栈不再需要时释放资源或重新使用栈。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "资源管理意识。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS003",
      "name": "顺序栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组（顺序存储结构）实现的栈。通常需要一个数组存储元素和一个整型变量（栈顶指针）指示栈顶位置。插入和删除操作通常在数组的一端进行，时间复杂度为O(1)。存在栈满溢出的问题，可能需要动态扩容。",
        "存储开销": "O(MaxSize)，MaxSize为数组容量。",
        "核心特性": "顺序存储、随机访问（理论上，但栈限制了访问）、可能栈满",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "资源预分配的优缺点，空间与效率的权衡。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON005",
      "name": "栈顶指针",
      "attributes": {
        "难度": "入门",
        "内容": "在顺序栈中，用于指示栈顶元素在数组中下标位置的整型变量。其值通常为-1表示栈空，或指向栈顶元素/下一个可插入位置。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON006",
      "name": "栈空",
      "attributes": {
        "难度": "入门",
        "内容": "栈中不包含任何元素的状态。在顺序栈中通常通过栈顶指针`top == -1`判断；在链栈中通过栈顶指针是否为NULL判断。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON007",
      "name": "栈满",
      "attributes": {
        "难度": "入门",
        "内容": "顺序栈的存储空间已完全占满，无法再插入新元素的状态。通常通过`top == MaxSize - 1`判断。链栈理论上不存在栈满问题（受限于总内存）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "理解资源限制与处理机制（报错或扩容）。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS004",
      "name": "链栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用单链表实现的栈。栈顶指针指向链表的头结点。入栈和出栈操作在链表头部进行，时间复杂度为O(1)。理论上不存在栈满问题（受限于内存）。",
        "存储开销": "O(N)，N为元素个数，每个元素有额外指针开销。",
        "核心特性": "链式存储、动态大小、无栈满问题（理论上）",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "动态资源管理的灵活性与开销。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS005",
      "name": "单链表",
      "attributes": {
        "难度": "入门",
        "内容": "由一系列结点组成的线性数据结构，每个结点包含数据域和指向下一个结点的指针域。通过指针将逻辑上相邻的元素链接起来。",
        "存储开销": "O(N)，N为结点数，每个结点有指针开销。",
        "核心特性": "链式存储、动态大小、非连续内存、插入删除（指定位置前）O(1)",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "理解指针和间接访问，链接与协作构成整体。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON008",
      "name": "结点",
      "attributes": {
        "难度": "入门",
        "内容": "链式存储结构中的基本单元，通常包含数据域（存储元素信息）和（一个或多个）指针域（存储后继或前驱结点的地址）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "模块化思想，基本单元构成复杂结构。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON009",
      "name": "链栈栈顶指针",
      "attributes": {
        "难度": "入门",
        "内容": "在链栈中，指向栈顶结点（通常是链表的头结点）的指针。栈空时通常为NULL。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG007",
      "name": "整数序列反转",
      "attributes": {
        "难度": "入门",
        "内容": "利用栈的LIFO特性，将输入整数依次入栈，然后依次出栈，实现反序输出。",
        "时间复杂度": "O(N)",
        "空间复杂度": "O(N)",
        "设计思想": "栈应用",
        "适用场景": "需要反转序列顺序的场景，如逆序打印数字、字符串反转等。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG008",
      "name": "括号匹配检查",
      "attributes": {
        "难度": "入门",
        "内容": "扫描表达式字符串，遇到左括号（如'(', '[', '{')则入栈；遇到右括号，检查栈是否为空以及栈顶元素是否为对应的左括号，若匹配则出栈，否则匹配失败。扫描结束后，若栈为空则匹配成功，否则失败。",
        "时间复杂度": "O(N)",
        "空间复杂度": "O(N)",
        "设计思想": "栈应用",
        "适用场景": "编译器语法检查、编辑器代码高亮、数学表达式验证等。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "规则与配对的重要性，结构化验证的思路。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG009",
      "name": "进制转换 (十进制转R进制)",
      "attributes": {
        "难度": "入门",
        "内容": "通过逐次对十进制数除以目标基数R取余数，将余数入栈。当商为0时停止。之后依次将栈中元素（余数）出栈，即可得到R进制表示（高位先出）。",
        "时间复杂度": "O(log_R N)",
        "空间复杂度": "O(log_R N)",
        "设计思想": "栈应用、除基取余法",
        "适用场景": "将十进制数转换为其他（如二、八、十六）进制表示。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "不同计数系统间的转换逻辑。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON010",
      "name": "中缀表达式",
      "attributes": {
        "难度": "入门",
        "内容": "操作符位于其操作数之间的算术表达式表示法，符合人类阅读习惯。例如 `a + b * c`。计算时需要考虑运算符优先级和括号。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON011",
      "name": "后缀表达式",
      "attributes": {
        "难度": "入门",
        "内容": "又称逆波兰式（Reverse Polish Notation, RPN），操作符位于其操作数之后的算术表达式表示法。例如 `a b c * +`。计算时无需考虑优先级和括号，只需从左到右扫描处理。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "简化计算逻辑，便于计算机处理。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON012",
      "name": "运算符优先级",
      "attributes": {
        "难度": "入门",
        "内容": "定义不同运算符在表达式计算中执行先后顺序的规则。例如，乘法和除法的优先级通常高于加法和减法。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "规则在计算和逻辑中的重要性。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG010",
      "name": "后缀表达式求值",
      "attributes": {
        "难度": "中等",
        "内容": "使用栈计算后缀表达式的值。从左到右扫描表达式：遇到操作数，将其压入栈中；遇到操作符，从栈中弹出所需数量的操作数（例如双目运算符弹出两个），执行运算，并将结果压回栈中。表达式扫描完毕后，栈中唯一的值即为最终结果。",
        "时间复杂度": "O(N)",
        "空间复杂度": "O(N)",
        "设计思想": "栈应用",
        "适用场景": "计算器实现、脚本语言解释器等需要对表达式求值的场景。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG011",
      "name": "中缀转后缀转换",
      "attributes": {
        "难度": "中等",
        "内容": "使用栈（通常称为运算符栈）将中缀表达式转换为等价的后缀表达式。扫描中缀表达式：遇到操作数，直接输出到后缀表达式；遇到运算符，与栈顶运算符比较优先级，若当前运算符优先级低于或等于栈顶（特殊情况除外，如左括号），则弹出栈顶运算符并输出，重复此过程，最后将当前运算符入栈；遇到左括号，直接入栈；遇到右括号，弹出栈中运算符并输出，直到遇到左括号（左括号弹出但不输出）。扫描结束后，弹出栈中所有剩余运算符并输出。",
        "时间复杂度": "O(N)",
        "空间复杂度": "O(N)",
        "设计思想": "栈应用、调度场算法变种",
        "适用场景": "编译器或解释器中，在计算表达式之前将其转换为更易处理的后缀形式。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "算法设计中利用辅助数据结构（栈）处理优先级和嵌套关系。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON013",
      "name": "递归",
      "attributes": {
        "难度": "中等",
        "内容": "一种解决问题的方法，其中函数或过程直接或间接地调用自身。递归算法通常包含两部分：基本情况（终止条件）和递归步骤（将问题分解为规模更小的同类子问题）。系统通常使用调用栈来管理递归调用的状态（参数、局部变量、返回地址）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "分而治之的思想，将复杂问题分解为简单子问题。理解自我参照和终止条件的重要性。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG012",
      "name": "阶乘计算 (递归)",
      "attributes": {
        "难度": "入门",
        "内容": "使用递归方式计算n!。定义f(n) = n * f(n-1)，基本情况f(0) = 1。",
        "时间复杂度": "O(N)",
        "空间复杂度": "O(N)",
        "设计思想": "递归",
        "适用场景": "教学示例、理解递归定义",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG013",
      "name": "布尔量组合生成 (递归)",
      "attributes": {
        "难度": "中等",
        "内容": "使用递归生成n个布尔变量的所有2^n种可能组合。对于第k个位置，分别尝试将其设置为false和true，然后递归处理第k+1个位置，直到处理完所有n个位置（达到基本情况），此时输出一种组合。",
        "时间复杂度": "O(N * 2^N)",
        "空间复杂度": "O(N)",
        "设计思想": "递归、回溯",
        "适用场景": "需要枚举所有布尔组合的情况，如真值表生成。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "系统性枚举所有可能性，回溯思想的应用。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG014",
      "name": "全排列生成 (递归)",
      "attributes": {
        "难度": "中等",
        "内容": "使用递归生成n个元素的所有n!种排列。对于从位置k开始的子序列，依次将位置k的元素与后面（包括自身）的每个元素交换，然后递归生成从位置k+1开始的子序列的全排列。递归返回后，需要将元素交换回来（回溯），以保证不影响其他分支的生成。",
        "时间复杂度": "O(N * N!)",
        "空间复杂度": "O(N)",
        "设计思想": "递归、回溯、交换法",
        "适用场景": "需要枚举所有排列顺序的情况。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "系统性探索所有排列可能性，理解回溯恢复状态的重要性。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG015",
      "name": "迷宫求解 (递归)",
      "attributes": {
        "难度": "中等",
        "内容": "使用递归（深度优先搜索）寻找从迷宫入口到出口的一条路径。从当前点(x,y)出发，标记为已访问。检查是否到达出口，是则成功。否则，按预定顺序（如东、南、西、北）尝试移动到相邻的未访问过的可通行点(nx, ny)，并递归调用SeekPath(nx, ny)。若递归调用返回true，则表示找到路径，当前点(x,y)是路径的一部分，返回true。若所有方向尝试失败，说明从当前点无法到达出口，返回false（进行回溯）。",
        "时间复杂度": "O(M*N)",
        "空间复杂度": "O(M*N)",
        "设计思想": "递归、回溯、深度优先搜索",
        "适用场景": "图或网格中的路径查找问题。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "探索精神，面对失败（死路）的回溯调整能力，系统化解决问题。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG016",
      "name": "汉诺塔问题求解 (递归)",
      "attributes": {
        "难度": "中等",
        "内容": "使用递归解决汉诺塔问题。将n个盘子从源柱(A)移到目标柱(C)（借助辅助柱(B)）的步骤分解为：1. 将n-1个盘子从A移到B（借助C）；2. 将第n个（最大的）盘子从A移到C；3. 将n-1个盘子从B移到C（借助A）。基本情况是n=1时，直接将盘子从源柱移到目标柱。",
        "时间复杂度": "O(2^N)",
        "空间复杂度": "O(N)",
        "设计思想": "递归、分治",
        "适用场景": "经典的递归问题教学示例。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "化繁为简的智慧，分步解决复杂问题的策略。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS006",
      "name": "队列",
      "attributes": {
        "难度": "入门",
        "内容": "简称队，是一种运算受限的线性表，其限制是仅允许在表的一端（队尾）进行插入（入队），而在表的另一端（队首）进行删除（出队）。具有先进先出（FIFO）特性。",
        "存储开销": "顺序实现O(MaxSize)，链式实现O(N)。",
        "核心特性": "先进先出（FIFO）、队首出队、队尾入队",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "公平原则的体现，按序处理任务的模型，如排队、消息队列。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON014",
      "name": "队尾",
      "attributes": {
        "难度": "入门",
        "内容": "队列中允许插入元素的一端。新入队的元素成为新的队尾元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON015",
      "name": "队首",
      "attributes": {
        "难度": "入门",
        "内容": "队列中允许删除元素的一端。出队操作移除队首元素，其后继成为新的队首。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG017",
      "name": "入队",
      "attributes": {
        "难度": "入门",
        "内容": "向队尾插入一个新元素，使其成为新的队尾元素。也称进队。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "队列基本操作",
        "适用场景": "向队列添加数据或任务",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG018",
      "name": "出队",
      "attributes": {
        "难度": "入门",
        "内容": "删除队首元素，使其后继元素成为新的队首元素。通常返回被删除的元素。也称离队。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "队列基本操作",
        "适用场景": "从队列获取并移除数据或任务",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON016",
      "name": "先进先出",
      "attributes": {
        "难度": "入门",
        "内容": "First-In, First-Out (FIFO)。描述了队列的操作特性，即最先进入队列的元素最先被移出。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "公平性原则在数据处理中的应用，如服务请求处理。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON017",
      "name": "队列的抽象数据类型",
      "attributes": {
        "难度": "入门",
        "内容": "定义了队列的数据对象（具有FIFO性质的元素集合）、数据关系以及基本操作集合（如初始化、入队、出队、判空、取队首元素等），独立于具体实现。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "抽象思维，区分逻辑结构与物理实现。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG019",
      "name": "初始化队列",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空队列，为其分配必要的存储空间（如数组）或初始化指针（如链队）。",
        "时间复杂度": "O(1) 或 O(MaxSize)",
        "空间复杂度": "O(1) 或 O(MaxSize)",
        "设计思想": "结构初始化",
        "适用场景": "在首次使用队列之前进行准备",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG020",
      "name": "读取队首元素",
      "attributes": {
        "难度": "入门",
        "内容": "返回队首元素的值，但不改变队列的状态（不删除元素）。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "队列状态访问",
        "适用场景": "查看下一个待处理元素而不处理它",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG021",
      "name": "判断队列是否为空",
      "attributes": {
        "难度": "入门",
        "内容": "检查队列中是否包含元素，返回布尔值。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "状态检查",
        "适用场景": "在执行出队或读取队首操作前进行检查，防止对空队列操作。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "严谨性，操作前的条件检查。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG022",
      "name": "清除队列",
      "attributes": {
        "难度": "入门",
        "内容": "移除队列中所有元素，使其变为空队列，并可能释放占用的动态存储空间。",
        "时间复杂度": "O(1) 或 O(N)",
        "空间复杂度": "O(1)",
        "设计思想": "资源回收与重置",
        "适用场景": "队列不再需要时释放资源或重新使用队列。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "资源管理意识。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS007",
      "name": "循环队列",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组实现的队列，通过取模运算将数组的线性空间在逻辑上视为环形，有效利用空间，解决了普通顺序队列可能出现的“假溢出”问题。需要队首(front)和队尾(rear)指针来管理队列。判空和判满条件需要特别设计（如牺牲一个单元、使用计数器或标志位）。",
        "存储开销": "O(MaxSize)，MaxSize为数组容量。",
        "核心特性": "顺序存储、环形空间利用、解决假溢出、O(1)操作",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "资源循环利用的智慧，通过设计优化解决局限性。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON018",
      "name": "顺序队首指针",
      "attributes": {
        "难度": "入门",
        "内容": "在顺序（循环）队列中，指示队首元素或队首元素前一个位置的数组下标。移动时需考虑循环（通常使用取模运算）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON019",
      "name": "顺序队尾指针",
      "attributes": {
        "难度": "入门",
        "内容": "在顺序（循环）队列中，指示队尾元素实际存储位置的数组下标。移动时需考虑循环（通常使用取模运算）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON020",
      "name": "队空 (循环队列)",
      "attributes": {
        "难度": "入门",
        "内容": "循环队列中不包含任何元素的状态。判断条件通常为 `front == rear`。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON021",
      "name": "队满 (循环队列)",
      "attributes": {
        "难度": "入门",
        "内容": "循环队列的存储空间已满，无法再插入新元素的状态。判断条件取决于具体实现，例如牺牲一个单元时为 `(rear + 1) % MaxSize == front`，或通过计数器判断队列长度是否达到MaxSize。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "理解资源限制与不同判断策略。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON022",
      "name": "假溢出",
      "attributes": {
        "难度": "入门",
        "内容": "在非循环的顺序队列中，当队尾指针`rear`到达数组末端（MaxSize-1）后，即使数组前面（`front`之前）还有空闲空间，也无法再进行入队操作，好像队列已满，但实际上并未占满所有空间，这种现象称为假溢出。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "认识设计局限性，激发优化思考（如循环队列）。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS008",
      "name": "链队",
      "attributes": {
        "难度": "入门",
        "内容": "使用单链表实现的队列。通常需要队首(front)和队尾(rear)两个指针，分别指向链表的头结点和尾结点，以便在O(1)时间内完成出队（删除头结点）和入队（在尾结点后插入新结点）操作。理论上无空间限制（受限于总内存）。",
        "存储开销": "O(N)，N为元素个数，每个元素有额外指针开销。",
        "核心特性": "链式存储、动态大小、O(1)入队出队",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "动态管理的优势与指针操作的复杂性。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON023",
      "name": "链队队首指针",
      "attributes": {
        "难度": "入门",
        "内容": "在链队中，指向队首结点（链表头结点）的指针。用于执行出队操作。队空时通常为NULL。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON024",
      "name": "链队队尾指针",
      "attributes": {
        "难度": "入门",
        "内容": "在链队中，指向队尾结点（链表尾结点）的指针。用于在O(1)时间内执行入队操作（在队尾添加新结点）。队空时通常为NULL。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS009",
      "name": "优先级队列",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的抽象数据类型，类似于队列，但每个元素都有一个关联的“优先级”。当访问元素时（例如出队），具有最高优先级的元素首先被移除。插入元素时需要维护优先级顺序。常用堆结构来实现。",
        "存储开销": "通常为O(N)，如使用堆实现。",
        "核心特性": "按优先级出队、非严格FIFO",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "重要性区分原则，资源按需优先分配的策略。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG023",
      "name": "渡口车辆调度模拟",
      "attributes": {
        "难度": "中等",
        "内容": "使用两个队列（一个客车队列，一个货车队列）来模拟渡口车辆排队和上船的过程。根据特定规则（如同类汽车先到先上、客车优先于货车、按比例上船、船满或等待超时发船等）从队列中取出车辆安排上渡轮。",
        "时间复杂度": "O(N)，N为处理的总车辆数。",
        "空间复杂度": "O(N)，N为排队车辆总数峰值。",
        "设计思想": "队列应用、模拟",
        "适用场景": "模拟排队系统、资源调度问题、事件驱动模拟。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "公平与效率的平衡，规则在系统调度中的作用，模拟现实世界问题的计算思维。"
      }
    }
  ],
  "relations": [
    {
      "type": "继承",
      "ID": "04REL001",
      "source": "04DS001",
      "target": "04DS002"
    },
    {
      "type": "理论依赖",
      "ID": "04REL002",
      "source": "04DS001",
      "target": "04CON003"
    },
    {
      "type": "理论依赖",
      "ID": "04REL003",
      "source": "04DS001",
      "target": "04CON001"
    },
    {
      "type": "理论依赖",
      "ID": "04REL004",
      "source": "04DS001",
      "target": "04CON002"
    },
    {
      "type": "操作绑定",
      "ID": "04REL005",
      "source": "04ALG001",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "ID": "04REL006",
      "source": "04ALG002",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "ID": "04REL007",
      "source": "04ALG003",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "ID": "04REL008",
      "source": "04ALG004",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "ID": "04REL009",
      "source": "04ALG005",
      "target": "04DS001"
    },
    {
      "type": "操作绑定",
      "ID": "04REL010",
      "source": "04ALG006",
      "target": "04DS001"
    },
    {
      "type": "理论依赖",
      "ID": "04REL011",
      "source": "04CON004",
      "target": "04DS001"
    },
    {
      "type": "继承",
      "ID": "04REL012",
      "source": "04DS003",
      "target": "04DS001"
    },
    {
      "type": "理论依赖",
      "ID": "04REL013",
      "source": "04DS003",
      "target": "04CON005"
    },
    {
      "type": "理论依赖",
      "ID": "04REL014",
      "source": "04DS003",
      "target": "04CON006"
    },
    {
      "type": "理论依赖",
      "ID": "04REL015",
      "source": "04DS003",
      "target": "04CON007"
    },
    {
      "type": "继承",
      "ID": "04REL016",
      "source": "04DS004",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "ID": "04REL017",
      "source": "04DS004",
      "target": "04DS005"
    },
    {
      "type": "理论依赖",
      "ID": "04REL018",
      "source": "04DS005",
      "target": "04CON008"
    },
    {
      "type": "理论依赖",
      "ID": "04REL019",
      "source": "04DS004",
      "target": "04CON009"
    },
    {
      "type": "使用",
      "ID": "04REL020",
      "source": "04ALG007",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "ID": "04REL021",
      "source": "04ALG008",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "ID": "04REL022",
      "source": "04ALG009",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "ID": "04REL023",
      "source": "04ALG010",
      "target": "04DS001"
    },
    {
      "type": "使用",
      "ID": "04REL024",
      "source": "04ALG011",
      "target": "04DS001"
    },
    {
      "type": "理论依赖",
      "ID": "04REL025",
      "source": "04ALG011",
      "target": "04CON010"
    },
    {
      "type": "理论依赖",
      "ID": "04REL026",
      "source": "04ALG011",
      "target": "04CON011"
    },
    {
      "type": "理论依赖",
      "ID": "04REL027",
      "source": "04ALG011",
      "target": "04CON012"
    },
    {
      "type": "理论依赖",
      "ID": "04REL028",
      "source": "04CON010",
      "target": "04CON012"
    },
    {
      "type": "理论依赖",
      "ID": "04REL029",
      "source": "04CON013",
      "target": "04DS001"
    },
    {
      "type": "理论依赖",
      "ID": "04REL030",
      "source": "04ALG012",
      "target": "04CON013"
    },
    {
      "type": "理论依赖",
      "ID": "04REL031",
      "source": "04ALG013",
      "target": "04CON013"
    },
    {
      "type": "理论依赖",
      "ID": "04REL032",
      "source": "04ALG014",
      "target": "04CON013"
    },
    {
      "type": "理论依赖",
      "ID": "04REL033",
      "source": "04ALG015",
      "target": "04CON013"
    },
    {
      "type": "理论依赖",
      "ID": "04REL034",
      "source": "04ALG016",
      "target": "04CON013"
    },
    {
      "type": "继承",
      "ID": "04REL035",
      "source": "04DS006",
      "target": "04DS002"
    },
    {
      "type": "理论依赖",
      "ID": "04REL036",
      "source": "04DS006",
      "target": "04CON016"
    },
    {
      "type": "理论依赖",
      "ID": "04REL037",
      "source": "04DS006",
      "target": "04CON014"
    },
    {
      "type": "理论依赖",
      "ID": "04REL038",
      "source": "04DS006",
      "target": "04CON015"
    },
    {
      "type": "操作绑定",
      "ID": "04REL039",
      "source": "04ALG017",
      "target": "04DS006"
    },
    {
      "type": "操作绑定",
      "ID": "04REL040",
      "source": "04ALG018",
      "target": "04DS006"
    },
    {
      "type": "操作绑定",
      "ID": "04REL041",
      "source": "04ALG019",
      "target": "04DS006"
    },
    {
      "type": "操作绑定",
      "ID": "04REL042",
      "source": "04ALG020",
      "target": "04DS006"
    },
    {
      "type": "操作绑定",
      "ID": "04REL043",
      "source": "04ALG021",
      "target": "04DS006"
    },
    {
      "type": "操作绑定",
      "ID": "04REL044",
      "source": "04ALG022",
      "target": "04DS006"
    },
    {
      "type": "理论依赖",
      "ID": "04REL045",
      "source": "04CON017",
      "target": "04DS006"
    },
    {
      "type": "继承",
      "ID": "04REL046",
      "source": "04DS007",
      "target": "04DS006"
    },
    {
      "type": "理论依赖",
      "ID": "04REL047",
      "source": "04DS007",
      "target": "04CON018"
    },
    {
      "type": "理论依赖",
      "ID": "04REL048",
      "source": "04DS007",
      "target": "04CON019"
    },
    {
      "type": "理论依赖",
      "ID": "04REL049",
      "source": "04DS007",
      "target": "04CON020"
    },
    {
      "type": "理论依赖",
      "ID": "04REL050",
      "source": "04DS007",
      "target": "04CON021"
    },
    {
      "type": "理论依赖",
      "ID": "04REL051",
      "source": "04DS007",
      "target": "04CON022"
    },
    {
      "type": "继承",
      "ID": "04REL052",
      "source": "04DS008",
      "target": "04DS006"
    },
    {
      "type": "使用",
      "ID": "04REL053",
      "source": "04DS008",
      "target": "04DS005"
    },
    {
      "type": "理论依赖",
      "ID": "04REL054",
      "source": "04DS008",
      "target": "04CON023"
    },
    {
      "type": "理论依赖",
      "ID": "04REL055",
      "source": "04DS008",
      "target": "04CON024"
    },
    {
      "type": "变体",
      "ID": "04REL056",
      "source": "04DS009",
      "target": "04DS006"
    },
    {
      "type": "使用",
      "ID": "04REL057",
      "source": "04ALG023",
      "target": "04DS006"
    }
  ]
}
{
    "entities": [
        {
            "type": "概念",
            "ID": "01CON001",
            "name": "数据",
            "attributes": {
                "难度": "入门",
                "内容": "对现实世界事物及其活动的符号记录，如数值、单词、图像等。在计算机中需编码为二进制形式。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON002",
            "name": "数据元素",
            "attributes": {
                "难度": "入门",
                "内容": "数据的基本单位，是数据整体中相对独立的单位。例如表格中的一行、字符串中的一个字符。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON003",
            "name": "数据记录",
            "attributes": {
                "难度": "入门",
                "内容": "数据处理领域组织数据的基本单位，通常由一个或多个数据项组成。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON004",
            "name": "数据项",
            "attributes": {
                "难度": "入门",
                "内容": "组成数据记录的成分，可以是不可再分的简单数据项（如数值、字符）或可再分的组合数据项（如字符串、数组）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON005",
            "name": "关键项",
            "attributes": {
                "难度": "入门",
                "内容": "在表或文件中，其值能唯一标识一个记录的数据项。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON006",
            "name": "关键字",
            "attributes": {
                "难度": "入门",
                "内容": "关键项中的具体值，用于唯一标识其所在的记录。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON007",
            "name": "数据处理",
            "attributes": {
                "难度": "入门",
                "内容": "利用计算机对数据进行存储、检索、插入、删除、排序等操作的过程。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "01DS001",
            "name": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "指数据以及数据元素之间的相互联系（逻辑结构），以及数据在计算机中的存储方式（存储结构）。逻辑结构包括集合、线性结构、树形结构、图形结构等。通常用二元组 B=(K,R) 表示。",
                "存储开销": "取决于具体的逻辑结构和选用的存储结构。",
                "核心特性": "描述数据元素间的逻辑关系和存储方式。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON008",
            "name": "逻辑结构",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素之间抽象化的相互关系，与具体存储无关。基本类型包括集合、线性结构、树形结构、图形结构。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON009",
            "name": "存储结构",
            "attributes": {
                "难度": "入门",
                "内容": "数据的逻辑结构在计算机存储器中的表示方式，也称物理结构。基本方法有顺序存储、链接存储、索引存储、散列存储。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON020",
            "name": "结点",
            "attributes": {
                "难度": "入门",
                "内容": "在数据结构的图形表示中，代表一个数据元素的图形单元，也称顶点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON021",
            "name": "边",
            "attributes": {
                "难度": "入门",
                "内容": "在数据结构的图形表示中，连接两个结点的线，表示它们之间的关系。可以是有向边（弧）或无向边。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON022",
            "name": "前驱",
            "attributes": {
                "难度": "入门",
                "内容": "在具有顺序关系的数据结构中，一个元素之前的直接相邻元素。在序偶<x,y>中，x是y的前驱。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON023",
            "name": "后继",
            "attributes": {
                "难度": "入门",
                "内容": "在具有顺序关系的数据结构中，一个元素之后的直接相邻元素。在序偶<x,y>中，y是x的后继。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "01DS002",
            "name": "集合",
            "attributes": {
                "难度": "入门",
                "内容": "一种逻辑结构，其中数据元素之间除了同属一个集合外，没有其他特定关系。",
                "存储开销": "取决于存储方式。",
                "核心特性": "元素间无特定关系。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "01DS003",
            "name": "线性结构",
            "attributes": {
                "难度": "入门",
                "内容": "一种逻辑结构，其中数据元素之间存在一对一的线性关系。除首尾元素外，每个元素有且仅有一个直接前驱和一个直接后继。",
                "存储开销": "顺序存储通常为O(n)，链式存储通常为O(n)。",
                "核心特性": "元素间一对一关系，有序。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "01DS004",
            "name": "树形结构",
            "attributes": {
                "难度": "入门",
                "内容": "一种逻辑结构，其中数据元素之间存在一对多的层次关系。除根结点外，每个元素有且仅有一个直接前驱，但可以有零个或多个直接后继。",
                "存储开销": "通常为O(n)。",
                "核心特性": "元素间一对多关系，层次性。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "01DS005",
            "name": "图形结构",
            "attributes": {
                "难度": "入门",
                "内容": "一种逻辑结构，其中数据元素之间存在多对多的关系。每个元素可以有任意多个直接前驱和任意多个直接后继。",
                "存储开销": "邻接矩阵O(n^2)，邻接表O(n+e)。",
                "核心特性": "元素间多对多关系，网状。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON010",
            "name": "非线性结构",
            "attributes": {
                "难度": "入门",
                "内容": "相对于线性结构而言，指数据元素之间存在一对多或多对多关系的逻辑结构，主要包括树形结构和图形结构。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON011",
            "name": "数据类型",
            "attributes": {
                "难度": "入门",
                "内容": "对数据的取值范围、数据元素之间的结构以及允许施加操作的一种总体描述。分为简单类型和结构类型。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON012",
            "name": "抽象数据类型",
            "attributes": {
                "难度": "入门",
                "内容": "由一种数据结构和在其上定义的一组操作所组成。强调逻辑结构和操作说明，不关注具体实现细节，体现信息隐藏和封装思想。通常通过类来实现。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON013",
            "name": "数据对象",
            "attributes": {
                "难度": "入门",
                "内容": "属于某种数据类型的特定实例。例如，整数25是一个整型数据对象。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "01ALG001",
            "name": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "解决特定问题的方法或一系列步骤。具有有穷性、确定性、可行性、输入、输出五个特性。可分为数值算法和非数值算法，递归算法和非递归算法。",
                "时间复杂度": "衡量算法运行时间效率的度量。",
                "空间复杂度": "衡量算法运行所需存储空间的度量。",
                "设计思想": "解决问题的策略，如递归、迭代等。",
                "适用场景": "解决特定类型的数值或非数值问题。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON014",
            "name": "时间复杂度",
            "attributes": {
                "难度": "入门",
                "内容": "算法运行时间的相对度量，通常表示为问题规模n的函数，常用大O表示法（数量级）来描述，如O(1), O(logn), O(n), O(nlogn), O(n^2), O(2^n), O(n!)等。分析时可考虑最好、最差、平均情况。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON015",
            "name": "空间复杂度",
            "attributes": {
                "难度": "入门",
                "内容": "算法在运行过程中临时占用存储空间大小的量度。包括算法本身、输入输出数据和临时工作单元所占空间。常用大O表示法描述，如O(1), O(logn), O(n)。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "01ALG004",
            "name": "累加求和",
            "attributes": {
                "难度": "入门",
                "内容": "计算一组数（如数组元素）总和的算法。通常使用循环实现。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "迭代",
                "适用场景": "求和计算。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "01ALG005",
            "name": "矩阵相加",
            "attributes": {
                "难度": "入门",
                "内容": "将两个相同维度的矩阵对应位置的元素相加得到结果矩阵的算法。通常使用嵌套循环实现。",
                "时间复杂度": "O(n^2) (对于n x n矩阵)",
                "空间复杂度": "O(n^2) (若需存储结果矩阵) 或 O(1) (若原地修改)",
                "设计思想": "迭代",
                "适用场景": "线性代数计算。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "01ALG002",
            "name": "简单选择排序",
            "attributes": {
                "难度": "入门",
                "内容": "一种基本的排序算法。在每一轮中从未排序的部分选择最小（或最大）的元素，放到已排序部分的末尾。",
                "时间复杂度": "O(n^2)",
                "空间复杂度": "O(1)",
                "设计思想": "选择",
                "适用场景": "数据量较小或对空间复杂度要求高的场景。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "01ALG003",
            "name": "顺序查找",
            "attributes": {
                "难度": "入门",
                "内容": "一种基本的查找算法。从数据列表的一端开始，逐个检查元素，直到找到目标元素或检查完所有元素。",
                "时间复杂度": "最好O(1)，最差O(n)，平均O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "迭代/线性扫描",
                "适用场景": "无序列表或列表较小的情况。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON016",
            "name": "顺序存储",
            "attributes": {
                "难度": "入门",
                "内容": "一种基本的存储结构，将逻辑上相邻的数据元素存储在物理位置也相邻的存储单元中。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON017",
            "name": "链接存储",
            "attributes": {
                "难度": "入门",
                "内容": "一种基本的存储结构，数据元素的存储单元不一定连续，通过指针将逻辑上相邻的元素链接起来。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON018",
            "name": "索引存储",
            "attributes": {
                "难度": "入门",
                "内容": "一种存储结构，在存储数据元素的同时，建立附加的索引表来指示元素的存储位置。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON019",
            "name": "散列存储",
            "attributes": {
                "难度": "入门",
                "内容": "一种存储结构，根据元素的关键字通过散列函数直接计算出其存储地址。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "01CON024",
            "name": "递归",
            "attributes": {
                "难度": "中等",
                "内容": "一种算法设计技术，函数或过程直接或间接调用自身来解决问题。通常将大问题分解为相似的子问题。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "02DS001",
            "name": "线性表",
            "attributes": {
                "难度": "入门",
                "内容": "具有相同属性的数据元素的一个有限序列。元素之间是线性有序的，即每个元素（除首尾外）有唯一前驱和唯一后继。支持初始化、清空、求长、判空、取值、遍历、查找、更新、插入、删除、排序等操作。",
                "存储开销": "取决于存储结构，顺序存储为O(n)，链式存储为O(n)但常数因子更大。",
                "核心特性": "元素间线性有序、长度可变。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "02DS002",
            "name": "单链表",
            "attributes": {
                "难度": "入门",
                "内容": "线性表的链式存储实现，每个结点包含一个数据域和一个指向其直接后继结点的指针域。",
                "存储开销": "O(n)，每个元素需要额外存储一个指针。",
                "核心特性": "动态存储、插入删除效率高（O(1)如果知道前驱）、仅支持顺序访问。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "02DS003",
            "name": "双向链表",
            "attributes": {
                "难度": "中等",
                "内容": "线性表的链式存储实现，每个结点包含一个数据域、一个指向其直接前驱结点的指针域和一个指向其直接后继结点的指针域。",
                "存储开销": "O(n)，每个元素需要额外存储两个指针。",
                "核心特性": "动态存储、支持双向遍历、插入删除效率高（O(1)如果知道待操作结点）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "02DS004",
            "name": "循环链表",
            "attributes": {
                "难度": "中等",
                "内容": "一种链式存储结构，表中最后一个结点的指针域指向头结点（或表头附加结点），形成一个环。可以是循环单链表或循环双向链表。",
                "存储开销": "与单链表或双向链表相同。",
                "核心特性": "从任一结点出发可遍历整个链表。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "02CON005",
            "name": "表头指针",
            "attributes": {
                "难度": "入门",
                "内容": "指向链表中第一个结点的指针。若链表为空，则头指针为NULL。",
                "核心特性": "标识链表的起始位置。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "02CON006",
            "name": "表头附加结点",
            "attributes": {
                "难度": "中等",
                "内容": "在链表的第一个元素结点之前附加的一个结点，其数据域可以为空或存放链表长度等信息。表头指针指向该附加结点。",
                "核心特性": "简化链表操作（尤其是插入/删除首元素和空表处理）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG001",
            "name": "顺序表查找",
            "attributes": {
                "难度": "入门",
                "内容": "在线性表的顺序存储结构（顺序表）中，从头到尾依次比较元素，查找第一个值与给定值相等的元素。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "顺序比较",
                "适用场景": "顺序存储的线性表查找。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG002",
            "name": "顺序表插入",
            "attributes": {
                "难度": "入门",
                "内容": "在线性表的顺序存储结构（顺序表）中指定位置插入一个新元素。需要将插入位置之后的所有元素后移一位。支持按位置插入、按值有序插入、表尾插入。可能需要扩展存储空间。",
                "时间复杂度": "O(n)（按位置或按值插入），O(1)（表尾插入，不考虑扩容）",
                "空间复杂度": "O(1)（不考虑扩容）",
                "设计思想": "元素后移、动态扩容",
                "适用场景": "顺序存储的线性表插入。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG003",
            "name": "顺序表删除",
            "attributes": {
                "难度": "入门",
                "内容": "在线性表的顺序存储结构（顺序表）中删除指定位置或指定值的元素。需要将删除位置之后的所有元素前移一位。支持按位置删除、按值删除、表尾删除。可能需要缩减存储空间。",
                "时间复杂度": "O(n)（按位置或按值删除），O(1)（表尾删除）",
                "空间复杂度": "O(1)",
                "设计思想": "元素前移、动态缩容",
                "适用场景": "顺序存储的线性表删除。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG004",
            "name": "顺序表排序(插入排序)",
            "attributes": {
                "难度": "入门",
                "内容": "对顺序存储的线性表（数组）进行排序，使其成为有序表。插入排序方法：将列表分为有序和无序两部分，每次从无序部分取第一个元素插入到有序部分的合适位置。",
                "时间复杂度": "O(n^2)（平均/最差），O(n)（最好）",
                "空间复杂度": "O(1)",
                "设计思想": "插入排序",
                "适用场景": "对顺序存储的线性表进行排序，尤其适用于部分有序或小规模数据。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "02DS005",
            "name": "顺序表",
            "attributes": {
                "难度": "入门",
                "内容": "线性表的顺序存储实现，通常使用数组来存储数据元素。",
                "存储开销": "O(n)，存储密度高。",
                "核心特性": "支持随机访问（O(1)），插入删除操作平均时间复杂度为O(n)。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "02CON007",
            "name": "多项式",
            "attributes": {
                "难度": "入门",
                "内容": "数学概念，形如 P(x) = a0 + a1*x + a2*x^2 + ... + an*x^n 的表达式。可以用线性表来表示和存储，常见表示法有：系数数组法（存储所有系数，包括0）和非零项结点法（只存储非零项的系数和指数）。",
                "核心特性": "由系数和指数定义。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG005",
            "name": "顺序表初始化",
            "attributes": {
                "难度": "入门",
                "内容": "创建空的顺序表。对于动态数组实现的顺序表，需要分配初始存储空间，并将长度置为0。",
                "时间复杂度": "O(1) 或 O(MaxSize)（取决于是否需要初始化数组空间）",
                "空间复杂度": "O(MaxSize)",
                "设计思想": "空间分配、长度置零",
                "适用场景": "创建新的顺序表实例。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG006",
            "name": "顺序表清空",
            "attributes": {
                "难度": "入门",
                "内容": "删除顺序表中的所有元素，使其成为空表。对于动态数组实现的顺序表，需要释放存储空间并将指针、长度、容量置零或NULL。",
                "时间复杂度": "O(1) 或 O(n)（取决于是否需要逐个清除元素或仅释放空间）",
                "空间复杂度": "O(1)",
                "设计思想": "空间释放、状态重置",
                "适用场景": "重用或销毁顺序表实例。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG007",
            "name": "顺序表长度",
            "attributes": {
                "难度": "入门",
                "内容": "返回顺序表中当前的元素个数。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "直接返回长度变量值",
                "适用场景": "获取顺序表大小。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG008",
            "name": "顺序表判空",
            "attributes": {
                "难度": "入门",
                "内容": "判断顺序表是否包含任何元素。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "检查长度是否为0",
                "适用场景": "在操作前检查顺序表状态。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG009",
            "name": "顺序表获取元素",
            "attributes": {
                "难度": "入门",
                "内容": "返回顺序表中指定位置（序号）的元素值。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "通过数组下标直接访问",
                "适用场景": "访问顺序表中特定位置的元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG010",
            "name": "顺序表遍历",
            "attributes": {
                "难度": "入门",
                "内容": "按照元素的逻辑顺序（即数组下标顺序）依次访问顺序表中的每一个元素。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "循环访问数组元素",
                "适用场景": "处理顺序表中所有元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG011",
            "name": "顺序表更新",
            "attributes": {
                "难度": "入门",
                "内容": "查找顺序表中第一个值与给定值相等的元素，并用新的值替换它。",
                "时间复杂度": "O(n)（主要耗时在查找）",
                "空间复杂度": "O(1)",
                "设计思想": "顺序查找 + 赋值",
                "适用场景": "修改顺序表中特定元素的值。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG012",
            "name": "多项式求值(系数数组表示)",
            "attributes": {
                "难度": "入门",
                "内容": "计算用系数数组表示的多项式在给定点x处的值。遍历系数数组，累加每一项 a_i * x^i 的值。",
                "时间复杂度": "O(n)（n为多项式最高次数+1）",
                "空间复杂度": "O(1)",
                "设计思想": "累加求和、幂运算",
                "适用场景": "计算系数数组表示的多项式的值。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG013",
            "name": "多项式求值(结点表示)",
            "attributes": {
                "难度": "入门",
                "内容": "计算用(系数, 指数)结点链表或数组表示的多项式在给定点x处的值。遍历结点，累加每一项 coef * x^exp 的值。",
                "时间复杂度": "O(m*log(max_exp)) 或 O(m*max_exp)（取决于幂运算实现，m为非零项数）",
                "空间复杂度": "O(1)",
                "设计思想": "遍历结点、累加求和、幂运算",
                "适用场景": "计算稀疏多项式的值。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG014",
            "name": "多项式加法1",
            "attributes": {
                "难度": "中等",
                "内容": "将两个用(系数, 指数)结点链表表示的多项式相加，生成一个新的表示和的多项式链表。通过调用InsertList插入到结果链表。",
                "时间复杂度": "O((m+n)^2)（m, n分别为两多项式项数，因InsertList插入到有序链表尾部实际为O(length)）",
                "空间复杂度": "O(m+n)",
                "设计思想": "归并思想、调用插入操作",
                "适用场景": "两个稀疏多项式相加。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG015",
            "name": "多项式加法2",
            "attributes": {
                "难度": "中等",
                "内容": "将两个用(系数, 指数)结点链表表示的多项式相加，生成一个新的表示和的多项式链表。通过维护尾指针直接在结果链表尾部链接新结点。",
                "时间复杂度": "O(m+n)（m, n分别为两多项式项数）",
                "空间复杂度": "O(m+n)",
                "设计思想": "归并思想、尾插法优化",
                "适用场景": "高效地进行两个稀疏多项式相加。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG016",
            "name": "单链表插入",
            "attributes": {
                "难度": "入门",
                "内容": "在单链表中指定条件（按位置、按值有序、表尾）插入一个新元素结点。需要查找插入位置并修改相关结点的指针。",
                "时间复杂度": "O(n)（查找位置），O(1)（表头插入）",
                "空间复杂度": "O(1)",
                "设计思想": "指针修改、查找插入点",
                "适用场景": "单链表插入操作。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG017",
            "name": "单链表删除",
            "attributes": {
                "难度": "入门",
                "内容": "从单链表中删除满足指定条件（按位置、按值、表尾）的第一个元素结点。需要查找被删结点及其前驱，并修改指针，释放结点空间。",
                "时间复杂度": "O(n)（查找位置），O(1)（表头删除）",
                "空间复杂度": "O(1)",
                "设计思想": "指针修改、查找删除点、内存回收",
                "适用场景": "单链表删除操作。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG018",
            "name": "单链表排序(插入排序)",
            "attributes": {
                "难度": "中等",
                "内容": "对单链表进行插入排序。建立一个新的空链表，依次将原链表的结点按值插入到新链表的有序位置。",
                "时间复杂度": "O(n^2)",
                "空间复杂度": "O(1)（原地排序）或 O(n)（创建新链表）",
                "设计思想": "插入排序、链表操作",
                "适用场景": "对单链表进行排序。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG019",
            "name": "单链表初始化",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空的单链表，通常是将头指针置为NULL。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "头指针置空",
                "适用场景": "创建新的单链表实例。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG020",
            "name": "单链表清空",
            "attributes": {
                "难度": "入门",
                "内容": "删除单链表中的所有结点，释放它们的存储空间，并将头指针置为NULL。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "遍历、结点释放、头指针置空",
                "适用场景": "重用或销毁单链表实例。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG021",
            "name": "单链表长度",
            "attributes": {
                "难度": "入门",
                "内容": "计算单链表中结点的数量。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "遍历计数",
                "适用场景": "获取单链表大小。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG022",
            "name": "单链表判空",
            "attributes": {
                "难度": "入门",
                "内容": "判断单链表是否包含任何结点。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "检查头指针是否为NULL",
                "适用场景": "在操作前检查单链表状态。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG023",
            "name": "单链表获取元素",
            "attributes": {
                "难度": "入门",
                "内容": "返回单链表中指定位置（序号）的结点中的元素值。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "按序号遍历查找",
                "适用场景": "访问单链表中特定位置的元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG024",
            "name": "单链表遍历",
            "attributes": {
                "难度": "入门",
                "内容": "从头指针开始，沿着next指针依次访问单链表中的每一个结点。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "循指针访问",
                "适用场景": "处理单链表中所有元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG025",
            "name": "单链表查找",
            "attributes": {
                "难度": "入门",
                "内容": "在单链表中，从头到尾依次比较结点的数据域，查找第一个值与给定值相等的元素。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "顺序遍历比较",
                "适用场景": "单链表查找操作。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG026",
            "name": "单链表更新",
            "attributes": {
                "难度": "入门",
                "内容": "查找单链表中第一个值与给定值相等的结点，并用新的值更新该结点的数据域。",
                "时间复杂度": "O(n)（主要耗时在查找）",
                "空间复杂度": "O(1)",
                "设计思想": "顺序查找 + 赋值",
                "适用场景": "修改单链表中特定元素的值。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "02CON008",
            "name": "有序表",
            "attributes": {
                "难度": "入门",
                "内容": "线性表中的元素按照某个关键字段的值递增或递减排列。插入、查找操作可以利用其有序性进行优化（如下标查找或二分查找，尽管文本主要描述顺序查找）。",
                "核心特性": "元素按关键字有序。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "02CON009",
            "name": "指针域",
            "attributes": {
                "难度": "入门",
                "内容": "链表结点中用于存储下一个（或上一个）结点地址的部分。",
                "核心特性": "建立结点间的链接关系。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "02CON010",
            "name": "值域",
            "attributes": {
                "难度": "入门",
                "内容": "链表结点中用于存储数据元素本身的部分。",
                "核心特性": "存储结点的数据。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "02CON011",
            "name": "随机存取",
            "attributes": {
                "难度": "入门",
                "内容": "访问数据结构中任何元素的时间都是常数，与元素位置无关。例如数组。",
                "核心特性": "O(1)时间访问任意元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "02CON012",
            "name": "顺序存取",
            "attributes": {
                "难度": "入门",
                "内容": "访问数据结构中某个元素需要从头开始或者从已知位置开始，按顺序查找。例如链表。",
                "核心特性": "访问时间与元素位置有关。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "03DS002",
            "name": "稀疏矩阵",
            "attributes": {
                "难度": "中等",
                "内容": "矩阵中非零元素的个数远小于零元素个数的特殊矩阵。为了节省存储空间，通常只存储非零元素及其位置（行号、列号）。",
                "存储开销": "依赖于存储方式，如三元组顺序表O(t)，三元组链表O(t)，行指针向量O(m+t)，十字链表O(m+n+t)，其中t为非零元个数，m为行数，n为列数。",
                "核心特性": "稀疏性, 空间优化",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "03DS003",
            "name": "广义表",
            "attributes": {
                "难度": "中等",
                "内容": "n(n>=0)个元素的一个有限序列，元素可以是原子（单元素）或子表（本身也是广义表）。是线性表的推广，具有递归定义。",
                "存储开销": "通常采用链式存储，空间复杂度与结点总数（原子+子表）成正比。",
                "核心特性": "递归结构, 异质元素（原子或列表）",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "03DS004",
            "name": "数组",
            "attributes": {
                "难度": "入门",
                "内容": "一种线性数据结构，用于存储固定大小的相同类型元素的集合。元素通过索引访问，物理存储通常是连续的。",
                "存储开销": "O(N)，N为数组大小。",
                "核心特性": "定长, 可索引, 连续存储",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "03DS006",
            "name": "三元组线性表",
            "attributes": {
                "难度": "入门",
                "内容": "用于表示稀疏矩阵的一种线性结构，表中每个元素是一个三元组(行号, 列号, 值)，代表矩阵中的一个非零元素。可以采用顺序或链式存储。",
                "存储开销": "O(t)，t为非零元素个数。",
                "核心特性": "紧凑存储稀疏数据",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "03DS007",
            "name": "行指针向量",
            "attributes": {
                "难度": "中等",
                "内容": "在稀疏矩阵的某种链式存储中使用的辅助结构，是一个数组（向量），其第i个元素存储指向矩阵第i行第一个非零元素结点的指针。",
                "存储开销": "O(m)，m为矩阵行数。",
                "核心特性": "辅助索引",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "03CON007",
            "name": "十字链接存储",
            "attributes": {
                "难度": "中等",
                "内容": "稀疏矩阵的一种链式存储方法。每个非零元素结点同时处于所在行的链表和所在列的链表中，结点包含指向同行下一个结点和同列下一个结点的指针。需要行、列两个指针向量。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG002",
            "name": "集合初始化",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空集合。对于顺序存储，设置长度为0；对于动态数组，分配初始空间并将长度置0；对于链式存储，将头指针置空。",
                "时间复杂度": "O(1) 或 O(初始大小)（动态分配）",
                "空间复杂度": "O(1) 或 O(初始大小)",
                "设计思想": "初始化",
                "适用场景": "使用集合前的准备。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG003",
            "name": "清除集合",
            "attributes": {
                "难度": "入门",
                "内容": "删除集合中的所有元素，使其变为空集。对于动态存储，需要释放分配的空间。",
                "时间复杂度": "O(1) 或 O(n)（释放链表结点）",
                "空间复杂度": "O(1)",
                "设计思想": "资源管理",
                "适用场景": "重置集合或释放资源。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG004",
            "name": "求集合长度",
            "attributes": {
                "难度": "入门",
                "内容": "返回集合中元素的个数。对于顺序存储，返回长度变量的值；对于链式存储，遍历链表计数。",
                "时间复杂度": "O(1)（顺序）或 O(n)（链式）",
                "空间复杂度": "O(1)",
                "设计思想": "计数",
                "适用场景": "获取集合大小信息。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG005",
            "name": "判断集合是否为空",
            "attributes": {
                "难度": "入门",
                "内容": "检查集合中是否包含元素。通常通过判断长度是否为0或头指针是否为空实现。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "状态检查",
                "适用场景": "在进行某些操作（如删除）前检查集合状态。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG006",
            "name": "判断元素是否属于集合",
            "attributes": {
                "难度": "入门",
                "内容": "检查给定元素是否存在于集合中。通常需要遍历集合进行查找。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "查找",
                "适用场景": "确认元素成员资格。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG007",
            "name": "输出集合",
            "attributes": {
                "难度": "入门",
                "内容": "将集合中的所有元素按某种方式（如任意顺序或排序后）显示出来。",
                "时间复杂度": "O(n) 或 O(n^2)（若需要排序）",
                "空间复杂度": "O(1) 或 O(n)（若排序需要额外空间）",
                "设计思想": "遍历, 输出",
                "适用场景": "查看集合内容。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG008",
            "name": "查找集合元素",
            "attributes": {
                "难度": "入门",
                "内容": "在集合中查找特定元素（通常基于关键字），若找到则返回该元素的完整信息。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "查找",
                "适用场景": "获取集合中特定元素的信息。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG009",
            "name": "修改集合元素",
            "attributes": {
                "难度": "入门",
                "内容": "在集合中查找特定元素（通常基于关键字），若找到则用新值更新该元素。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "查找, 更新",
                "适用场景": "更新集合中元素的数据。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG010",
            "name": "向集合插入元素",
            "attributes": {
                "难度": "入门",
                "内容": "将一个新元素添加到集合中。需要先检查元素是否已存在（保证唯一性），若不存在则添加。顺序存储可能涉及空间扩展。",
                "时间复杂度": "O(n)（查找）+ O(1)或O(n)（插入/扩展）",
                "空间复杂度": "O(1)（平均）",
                "设计思想": "查找, 插入, 唯一性约束",
                "适用场景": "向集合添加新成员。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG011",
            "name": "从集合删除元素",
            "attributes": {
                "难度": "入门",
                "内容": "从集合中移除指定的元素。需要先查找元素，找到后执行删除操作（顺序存储可能用末尾元素填补，链式存储修改指针）。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "查找, 删除",
                "适用场景": "从集合移除成员。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG012",
            "name": "求集合并集",
            "attributes": {
                "难度": "入门",
                "内容": "计算两个集合的并集，结果包含所有出现在至少一个集合中的元素。",
                "时间复杂度": "O(n*m)（基于查找插入）",
                "空间复杂度": "O(n+m)（结果集）",
                "设计思想": "合并, 去重",
                "适用场景": "合并两个集合的信息。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG013",
            "name": "求集合交集",
            "attributes": {
                "难度": "入门",
                "内容": "计算两个集合的交集，结果包含所有同时出现在两个集合中的元素。",
                "时间复杂度": "O(n*m)（基于查找）",
                "空间复杂度": "O(min(n,m))（结果集）",
                "设计思想": "查找共同元素",
                "适用场景": "找出两个集合的共同部分。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG014",
            "name": "求集合差集",
            "attributes": {
                "难度": "入门",
                "内容": "计算两个集合S1和S2的差集 (S1 - S2)，结果包含所有属于S1但不属于S2的元素。",
                "时间复杂度": "O(n*m)（基于查找）",
                "空间复杂度": "O(n)（结果集）",
                "设计思想": "查找并排除",
                "适用场景": "找出第一个集合独有的元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG015",
            "name": "稀疏矩阵初始化",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空的稀疏矩阵表示结构。设置行数、列数、非零元个数为0，初始化存储结构（如清空三元组表或指针向量）。",
                "时间复杂度": "O(1) 或 O(m+n)（初始化指针向量）",
                "空间复杂度": "O(1) 或 O(m+n)",
                "设计思想": "初始化",
                "适用场景": "使用稀疏矩阵前的准备。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG016",
            "name": "稀疏矩阵转置",
            "attributes": {
                "难度": "中等",
                "内容": "计算稀疏矩阵的转置矩阵。普通方法逐列扫描原矩阵三元组表生成新表，时间复杂度O(n*t)。",
                "时间复杂度": "O(n*t) (普通方法)",
                "空间复杂度": "O(t) (结果矩阵)",
                "设计思想": "行列互换",
                "适用场景": "需要矩阵转置形式时。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG017",
            "name": "快速稀疏矩阵转置",
            "attributes": {
                "难度": "中等",
                "内容": "一种优化的稀疏矩阵转置算法。通过预先计算每列（转置后的行）的非零元个数和起始位置，一次遍历即可完成转置。",
                "时间复杂度": "O(n+t)",
                "空间复杂度": "O(n+t) (需要辅助数组和结果矩阵)",
                "设计思想": "空间换时间, 预计算",
                "适用场景": "高效计算稀疏矩阵转置。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG018",
            "name": "稀疏矩阵加法",
            "attributes": {
                "难度": "中等",
                "内容": "计算两个相同维度的稀疏矩阵的和。通常按行（或按三元组顺序）合并两个矩阵的非零元素，对应位置元素相加，若和非零则加入结果矩阵。",
                "时间复杂度": "O(t1+t2) (对于有序链式存储)",
                "空间复杂度": "O(t1+t2) (结果矩阵)",
                "设计思想": "合并, 对应相加",
                "适用场景": "稀疏矩阵相加运算。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG019",
            "name": "稀疏矩阵乘法",
            "attributes": {
                "难度": "高级",
                "内容": "计算两个稀疏矩阵的乘积。需要满足第一个矩阵的列数等于第二个矩阵的行数。实现通常比密集矩阵乘法复杂，需有效利用稀疏性。",
                "时间复杂度": "依赖具体实现，通常优于密集矩阵的O(m*n*p)",
                "空间复杂度": "依赖结果矩阵的稀疏度",
                "设计思想": "点积, 稀疏优化",
                "适用场景": "大型稀疏矩阵相乘。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG020",
            "name": "稀疏矩阵输入",
            "attributes": {
                "难度": "入门",
                "内容": "从外部（如键盘）读取数据并构建稀疏矩阵的存储结构。通常按三元组格式输入。",
                "时间复杂度": "O(t) 或 O(t*logt)（若需排序）或 O(t*m)（链表尾插）",
                "空间复杂度": "O(t)",
                "设计思想": "数据读取, 结构构建",
                "适用场景": "从外部源创建稀疏矩阵。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG021",
            "name": "稀疏矩阵输出",
            "attributes": {
                "难度": "入门",
                "内容": "将稀疏矩阵的内容（通常是三元组线性表）按指定格式输出。",
                "时间复杂度": "O(t)",
                "空间复杂度": "O(1)",
                "设计思想": "遍历, 格式化输出",
                "适用场景": "展示稀疏矩阵内容。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG022",
            "name": "求广义表长度",
            "attributes": {
                "难度": "入门",
                "内容": "计算广义表顶层元素的个数。可以通过遍历顶层链表实现，递归或非递归均可。",
                "时间复杂度": "O(n) (n为顶层元素个数)",
                "空间复杂度": "O(1) (非递归) 或 O(n) (递归)",
                "设计思想": "遍历计数",
                "适用场景": "获取广义表顶层大小。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG023",
            "name": "求广义表深度",
            "attributes": {
                "难度": "中等",
                "内容": "计算广义表中括号嵌套的最大层数。通常使用递归实现，深度等于所有子表最大深度加1，空表或原子表深度为1。",
                "时间复杂度": "O(N) (N为结点总数)",
                "空间复杂度": "O(m) (m为广义表深度，递归栈开销)",
                "设计思想": "递归遍历",
                "适用场景": "分析广义表的嵌套层级。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG024",
            "name": "建立广义表",
            "attributes": {
                "难度": "中等",
                "内容": "根据输入的字符串表示（如'(a,(b,c))'）构建广义表的链式存储结构。通常使用递归实现。",
                "时间复杂度": "O(L) (L为输入字符串长度或结点数)",
                "空间复杂度": "O(L) (递归栈开销)",
                "设计思想": "递归解析, 结构构建",
                "适用场景": "从字符串表示创建广义表。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG025",
            "name": "打印广义表",
            "attributes": {
                "难度": "中等",
                "内容": "将广义表的链式存储结构转换回其字符串表示形式并输出。通常使用递归实现。",
                "时间复杂度": "O(N) (N为结点总数)",
                "空间复杂度": "O(m) (m为广义表深度，递归栈开销)",
                "设计思想": "递归遍历, 格式化输出",
                "适用场景": "可视化广义表结构。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "03CON005",
            "name": "矩阵",
            "attributes": {
                "难度": "入门",
                "内容": "一个m行n列的二维数表，包含m*n个元素，每个元素由其行号和列号唯一确定。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "03CON006",
            "name": "三元组",
            "attributes": {
                "难度": "入门",
                "内容": "由三个部分组成的数据单元。在稀疏矩阵中特指(行号, 列号, 值)结构，用于表示一个非零元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "03DS010",
            "name": "动态数组",
            "attributes": {
                "难度": "入门",
                "内容": "一种大小可变的数组。在容量不足时能自动扩展存储空间（通常是重新分配更大空间并复制元素）。",
                "存储开销": "O(n)，n为当前元素个数，但可能预留额外空间。",
                "核心特性": "动态大小, 可索引",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "04DS001",
            "name": "栈",
            "attributes": {
                "难度": "入门",
                "内容": "又称堆栈，是一种运算受限的线性表，其限制是仅允许在表的一端（栈顶）进行插入（入栈/进栈）和删除（出栈/退栈）运算。另一端称为栈底。具有后进先出（LIFO）特性。",
                "存储开销": "顺序实现为O(MaxSize)，链式实现为O(N)，N为元素个数，链式有额外指针开销。",
                "核心特性": "后进先出（LIFO）、仅限栈顶操作",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "规则意识、有序处理（例如函数调用栈体现的程序执行顺序与嵌套关系）。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON001",
            "name": "栈顶",
            "attributes": {
                "难度": "入门",
                "内容": "栈中允许进行插入和删除操作的一端。栈顶的第一个元素被称为栈顶元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "04CON002",
            "name": "栈底",
            "attributes": {
                "难度": "入门",
                "内容": "栈中与栈顶相对的另一端，不允许进行插入和删除操作。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG001",
            "name": "入栈",
            "attributes": {
                "难度": "入门",
                "内容": "向栈顶插入一个新元素，使其成为新的栈顶元素。也称进栈。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "栈基本操作",
                "适用场景": "向栈中添加数据",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG002",
            "name": "出栈",
            "attributes": {
                "难度": "入门",
                "内容": "删除栈顶元素，使其下面的相邻元素成为新的栈顶元素。通常会返回被删除的元素。也称退栈。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "栈基本操作",
                "适用场景": "从栈中移除并获取数据",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "04CON003",
            "name": "后进先出",
            "attributes": {
                "难度": "入门",
                "内容": "Last-In, First-Out (LIFO)。描述了栈的操作特性，即最后进入栈的元素最先被移出。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "理解特定规则下的处理顺序，如生活中的盘子堆叠、软件中的撤销操作。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON004",
            "name": "栈的抽象数据类型",
            "attributes": {
                "难度": "入门",
                "内容": "定义了栈的数据对象（具有LIFO性质的元素集合）、数据关系以及基本操作集合（如初始化、入栈、出栈、判空、取栈顶元素等），独立于具体实现。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "抽象思维，区分逻辑结构与物理实现。"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG003",
            "name": "初始化栈",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空栈，为其分配必要的存储空间（如果是动态分配）。",
                "时间复杂度": "O(1) 或 O(MaxSize)",
                "空间复杂度": "O(1) 或 O(MaxSize)",
                "设计思想": "结构初始化",
                "适用场景": "在首次使用栈之前进行准备",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG004",
            "name": "读取栈顶元素",
            "attributes": {
                "难度": "入门",
                "内容": "返回栈顶元素的值，但不改变栈的状态（不删除元素）。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "栈状态访问",
                "适用场景": "查看栈顶数据而不修改栈",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG005",
            "name": "判断栈是否为空",
            "attributes": {
                "难度": "入门",
                "内容": "检查栈中是否包含元素，返回布尔值。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "状态检查",
                "适用场景": "在执行出栈或读取栈顶操作前进行检查，防止对空栈操作。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "严谨性，操作前的条件检查。"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG006",
            "name": "清除栈",
            "attributes": {
                "难度": "入门",
                "内容": "移除栈中所有元素，使其变为空栈，并可能释放占用的动态存储空间。",
                "时间复杂度": "O(1) 或 O(N)",
                "空间复杂度": "O(1)",
                "设计思想": "资源回收与重置",
                "适用场景": "栈不再需要时释放资源或重新使用栈。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "资源管理意识。"
            }
        },
        {
            "type": "数据结构",
            "ID": "04DS003",
            "name": "顺序栈",
            "attributes": {
                "难度": "入门",
                "内容": "使用数组（顺序存储结构）实现的栈。通常需要一个数组存储元素和一个整型变量（栈顶指针）指示栈顶位置。插入和删除操作通常在数组的一端进行，时间复杂度为O(1)。存在栈满溢出的问题，可能需要动态扩容。",
                "存储开销": "O(MaxSize)，MaxSize为数组容量。",
                "核心特性": "顺序存储、随机访问（理论上，但栈限制了访问）、可能栈满",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "资源预分配的优缺点，空间与效率的权衡。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON005",
            "name": "栈顶指针",
            "attributes": {
                "难度": "入门",
                "内容": "在顺序栈中，用于指示栈顶元素在数组中下标位置的整型变量。其值通常为-1表示栈空，或指向栈顶元素/下一个可插入位置。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "04CON006",
            "name": "栈空",
            "attributes": {
                "难度": "入门",
                "内容": "栈中不包含任何元素的状态。在顺序栈中通常通过栈顶指针`top == -1`判断；在链栈中通过栈顶指针是否为NULL判断。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "04CON007",
            "name": "栈满",
            "attributes": {
                "难度": "入门",
                "内容": "顺序栈的存储空间已完全占满，无法再插入新元素的状态。通常通过`top == MaxSize - 1`判断。链栈理论上不存在栈满问题（受限于总内存）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "理解资源限制与处理机制（报错或扩容）。"
            }
        },
        {
            "type": "数据结构",
            "ID": "04DS004",
            "name": "链栈",
            "attributes": {
                "难度": "入门",
                "内容": "使用单链表实现的栈。栈顶指针指向链表的头结点。入栈和出栈操作在链表头部进行，时间复杂度为O(1)。理论上不存在栈满问题（受限于内存）。",
                "存储开销": "O(N)，N为元素个数，每个元素有额外指针开销。",
                "核心特性": "链式存储、动态大小、无栈满问题（理论上）",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "动态资源管理的灵活性与开销。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON009",
            "name": "链栈栈顶指针",
            "attributes": {
                "难度": "入门",
                "内容": "在链栈中，指向栈顶结点（通常是链表的头结点）的指针。栈空时通常为NULL。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG007",
            "name": "整数序列反转",
            "attributes": {
                "难度": "入门",
                "内容": "利用栈的LIFO特性，将输入整数依次入栈，然后依次出栈，实现反序输出。",
                "时间复杂度": "O(N)",
                "空间复杂度": "O(N)",
                "设计思想": "栈应用",
                "适用场景": "需要反转序列顺序的场景，如逆序打印数字、字符串反转等。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG008",
            "name": "括号匹配检查",
            "attributes": {
                "难度": "入门",
                "内容": "扫描表达式字符串，遇到左括号（如'(', '[', '{')则入栈；遇到右括号，检查栈是否为空以及栈顶元素是否为对应的左括号，若匹配则出栈，否则匹配失败。扫描结束后，若栈为空则匹配成功，否则失败。",
                "时间复杂度": "O(N)",
                "空间复杂度": "O(N)",
                "设计思想": "栈应用",
                "适用场景": "编译器语法检查、编辑器代码高亮、数学表达式验证等。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "规则与配对的重要性，结构化验证的思路。"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG009",
            "name": "进制转换 (十进制转R进制)",
            "attributes": {
                "难度": "入门",
                "内容": "通过逐次对十进制数除以目标基数R取余数，将余数入栈。当商为0时停止。之后依次将栈中元素（余数）出栈，即可得到R进制表示（高位先出）。",
                "时间复杂度": "O(log_R N)",
                "空间复杂度": "O(log_R N)",
                "设计思想": "栈应用、除基取余法",
                "适用场景": "将十进制数转换为其他（如二、八、十六）进制表示。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "不同计数系统间的转换逻辑。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON010",
            "name": "中缀表达式",
            "attributes": {
                "难度": "入门",
                "内容": "操作符位于其操作数之间的算术表达式表示法，符合人类阅读习惯。例如 `a + b * c`。计算时需要考虑运算符优先级和括号。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "04CON011",
            "name": "后缀表达式",
            "attributes": {
                "难度": "入门",
                "内容": "又称逆波兰式（Reverse Polish Notation, RPN），操作符位于其操作数之后的算术表达式表示法。例如 `a b c * +`。计算时无需考虑优先级和括号，只需从左到右扫描处理。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "简化计算逻辑，便于计算机处理。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON012",
            "name": "运算符优先级",
            "attributes": {
                "难度": "入门",
                "内容": "定义不同运算符在表达式计算中执行先后顺序的规则。例如，乘法和除法的优先级通常高于加法和减法。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "规则在计算和逻辑中的重要性。"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG010",
            "name": "后缀表达式求值",
            "attributes": {
                "难度": "中等",
                "内容": "使用栈计算后缀表达式的值。从左到右扫描表达式：遇到操作数，将其压入栈中；遇到操作符，从栈中弹出所需数量的操作数（例如双目运算符弹出两个），执行运算，并将结果压回栈中。表达式扫描完毕后，栈中唯一的值即为最终结果。",
                "时间复杂度": "O(N)",
                "空间复杂度": "O(N)",
                "设计思想": "栈应用",
                "适用场景": "计算器实现、脚本语言解释器等需要对表达式求值的场景。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG011",
            "name": "中缀转后缀转换",
            "attributes": {
                "难度": "中等",
                "内容": "使用栈（通常称为运算符栈）将中缀表达式转换为等价的后缀表达式。扫描中缀表达式：遇到操作数，直接输出到后缀表达式；遇到运算符，与栈顶运算符比较优先级，若当前运算符优先级低于或等于栈顶（特殊情况除外，如左括号），则弹出栈顶运算符并输出，重复此过程，最后将当前运算符入栈；遇到左括号，直接入栈；遇到右括号，弹出栈中运算符并输出，直到遇到左括号（左括号弹出但不输出）。扫描结束后，弹出栈中所有剩余运算符并输出。",
                "时间复杂度": "O(N)",
                "空间复杂度": "O(N)",
                "设计思想": "栈应用、调度场算法变种",
                "适用场景": "编译器或解释器中，在计算表达式之前将其转换为更易处理的后缀形式。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "算法设计中利用辅助数据结构（栈）处理优先级和嵌套关系。"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG012",
            "name": "阶乘计算 (递归)",
            "attributes": {
                "难度": "入门",
                "内容": "使用递归方式计算n!。定义f(n) = n * f(n-1)，基本情况f(0) = 1。",
                "时间复杂度": "O(N)",
                "空间复杂度": "O(N)",
                "设计思想": "递归",
                "适用场景": "教学示例、理解递归定义",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG013",
            "name": "布尔量组合生成 (递归)",
            "attributes": {
                "难度": "中等",
                "内容": "使用递归生成n个布尔变量的所有2^n种可能组合。对于第k个位置，分别尝试将其设置为false和true，然后递归处理第k+1个位置，直到处理完所有n个位置（达到基本情况），此时输出一种组合。",
                "时间复杂度": "O(N * 2^N)",
                "空间复杂度": "O(N)",
                "设计思想": "递归、回溯",
                "适用场景": "需要枚举所有布尔组合的情况，如真值表生成。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "系统性枚举所有可能性，回溯思想的应用。"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG014",
            "name": "全排列生成 (递归)",
            "attributes": {
                "难度": "中等",
                "内容": "使用递归生成n个元素的所有n!种排列。对于从位置k开始的子序列，依次将位置k的元素与后面（包括自身）的每个元素交换，然后递归生成从位置k+1开始的子序列的全排列。递归返回后，需要将元素交换回来（回溯），以保证不影响其他分支的生成。",
                "时间复杂度": "O(N * N!)",
                "空间复杂度": "O(N)",
                "设计思想": "递归、回溯、交换法",
                "适用场景": "需要枚举所有排列顺序的情况。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "系统性探索所有排列可能性，理解回溯恢复状态的重要性。"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG015",
            "name": "迷宫求解 (递归)",
            "attributes": {
                "难度": "中等",
                "内容": "使用递归（深度优先搜索）寻找从迷宫入口到出口的一条路径。从当前点(x,y)出发，标记为已访问。检查是否到达出口，是则成功。否则，按预定顺序（如东、南、西、北）尝试移动到相邻的未访问过的可通行点(nx, ny)，并递归调用SeekPath(nx, ny)。若递归调用返回true，则表示找到路径，当前点(x,y)是路径的一部分，返回true。若所有方向尝试失败，说明从当前点无法到达出口，返回false（进行回溯）。",
                "时间复杂度": "O(M*N)",
                "空间复杂度": "O(M*N)",
                "设计思想": "递归、回溯、深度优先搜索",
                "适用场景": "图或网格中的路径查找问题。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "探索精神，面对失败（死路）的回溯调整能力，系统化解决问题。"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG016",
            "name": "汉诺塔问题求解 (递归)",
            "attributes": {
                "难度": "中等",
                "内容": "使用递归解决汉诺塔问题。将n个盘子从源柱(A)移到目标柱(C)（借助辅助柱(B)）的步骤分解为：1. 将n-1个盘子从A移到B（借助C）；2. 将第n个（最大的）盘子从A移到C；3. 将n-1个盘子从B移到C（借助A）。基本情况是n=1时，直接将盘子从源柱移到目标柱。",
                "时间复杂度": "O(2^N)",
                "空间复杂度": "O(N)",
                "设计思想": "递归、分治",
                "适用场景": "经典的递归问题教学示例。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "化繁为简的智慧，分步解决复杂问题的策略。"
            }
        },
        {
            "type": "数据结构",
            "ID": "04DS006",
            "name": "队列",
            "attributes": {
                "难度": "入门",
                "内容": "简称队，是一种运算受限的线性表，其限制是仅允许在表的一端（队尾）进行插入（入队），而在表的另一端（队首）进行删除（出队）。具有先进先出（FIFO）特性。",
                "存储开销": "顺序实现O(MaxSize)，链式实现O(N)。",
                "核心特性": "先进先出（FIFO）、队首出队、队尾入队",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "公平原则的体现，按序处理任务的模型，如排队、消息队列。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON014",
            "name": "队尾",
            "attributes": {
                "难度": "入门",
                "内容": "队列中允许插入元素的一端。新入队的元素成为新的队尾元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "04CON015",
            "name": "队首",
            "attributes": {
                "难度": "入门",
                "内容": "队列中允许删除元素的一端。出队操作移除队首元素，其后继成为新的队首。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG017",
            "name": "入队",
            "attributes": {
                "难度": "入门",
                "内容": "向队尾插入一个新元素，使其成为新的队尾元素。也称进队。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "队列基本操作",
                "适用场景": "向队列添加数据或任务",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG018",
            "name": "出队",
            "attributes": {
                "难度": "入门",
                "内容": "删除队首元素，使其后继元素成为新的队首元素。通常返回被删除的元素。也称离队。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "队列基本操作",
                "适用场景": "从队列获取并移除数据或任务",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "04CON016",
            "name": "先进先出",
            "attributes": {
                "难度": "入门",
                "内容": "First-In, First-Out (FIFO)。描述了队列的操作特性，即最先进入队列的元素最先被移出。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "公平性原则在数据处理中的应用，如服务请求处理。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON017",
            "name": "队列的抽象数据类型",
            "attributes": {
                "难度": "入门",
                "内容": "定义了队列的数据对象（具有FIFO性质的元素集合）、数据关系以及基本操作集合（如初始化、入队、出队、判空、取队首元素等），独立于具体实现。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "抽象思维，区分逻辑结构与物理实现。"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG019",
            "name": "初始化队列",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空队列，为其分配必要的存储空间（如数组）或初始化指针（如链队）。",
                "时间复杂度": "O(1) 或 O(MaxSize)",
                "空间复杂度": "O(1) 或 O(MaxSize)",
                "设计思想": "结构初始化",
                "适用场景": "在首次使用队列之前进行准备",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG020",
            "name": "读取队首元素",
            "attributes": {
                "难度": "入门",
                "内容": "返回队首元素的值，但不改变队列的状态（不删除元素）。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "队列状态访问",
                "适用场景": "查看下一个待处理元素而不处理它",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG021",
            "name": "判断队列是否为空",
            "attributes": {
                "难度": "入门",
                "内容": "检查队列中是否包含元素，返回布尔值。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "状态检查",
                "适用场景": "在执行出队或读取队首操作前进行检查，防止对空队列操作。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "严谨性，操作前的条件检查。"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG022",
            "name": "清除队列",
            "attributes": {
                "难度": "入门",
                "内容": "移除队列中所有元素，使其变为空队列，并可能释放占用的动态存储空间。",
                "时间复杂度": "O(1) 或 O(N)",
                "空间复杂度": "O(1)",
                "设计思想": "资源回收与重置",
                "适用场景": "队列不再需要时释放资源或重新使用队列。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "资源管理意识。"
            }
        },
        {
            "type": "数据结构",
            "ID": "04DS007",
            "name": "循环队列",
            "attributes": {
                "难度": "入门",
                "内容": "使用数组实现的队列，通过取模运算将数组的线性空间在逻辑上视为环形，有效利用空间，解决了普通顺序队列可能出现的“假溢出”问题。需要队首(front)和队尾(rear)指针来管理队列。判空和判满条件需要特别设计（如牺牲一个单元、使用计数器或标志位）。",
                "存储开销": "O(MaxSize)，MaxSize为数组容量。",
                "核心特性": "顺序存储、环形空间利用、解决假溢出、O(1)操作",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "资源循环利用的智慧，通过设计优化解决局限性。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON018",
            "name": "顺序队首指针",
            "attributes": {
                "难度": "入门",
                "内容": "在顺序（循环）队列中，指示队首元素或队首元素前一个位置的数组下标。移动时需考虑循环（通常使用取模运算）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "04CON019",
            "name": "顺序队尾指针",
            "attributes": {
                "难度": "入门",
                "内容": "在顺序（循环）队列中，指示队尾元素实际存储位置的数组下标。移动时需考虑循环（通常使用取模运算）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "04CON020",
            "name": "队空 (循环队列)",
            "attributes": {
                "难度": "入门",
                "内容": "循环队列中不包含任何元素的状态。判断条件通常为 `front == rear`。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "04CON021",
            "name": "队满 (循环队列)",
            "attributes": {
                "难度": "入门",
                "内容": "循环队列的存储空间已满，无法再插入新元素的状态。判断条件取决于具体实现，例如牺牲一个单元时为 `(rear + 1) % MaxSize == front`，或通过计数器判断队列长度是否达到MaxSize。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "理解资源限制与不同判断策略。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON022",
            "name": "假溢出",
            "attributes": {
                "难度": "入门",
                "内容": "在非循环的顺序队列中，当队尾指针`rear`到达数组末端（MaxSize-1）后，即使数组前面（`front`之前）还有空闲空间，也无法再进行入队操作，好像队列已满，但实际上并未占满所有空间，这种现象称为假溢出。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "认识设计局限性，激发优化思考（如循环队列）。"
            }
        },
        {
            "type": "数据结构",
            "ID": "04DS008",
            "name": "链队",
            "attributes": {
                "难度": "入门",
                "内容": "使用单链表实现的队列。通常需要队首(front)和队尾(rear)两个指针，分别指向链表的头结点和尾结点，以便在O(1)时间内完成出队（删除头结点）和入队（在尾结点后插入新结点）操作。理论上无空间限制（受限于总内存）。",
                "存储开销": "O(N)，N为元素个数，每个元素有额外指针开销。",
                "核心特性": "链式存储、动态大小、O(1)入队出队",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "动态管理的优势与指针操作的复杂性。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON023",
            "name": "链队队首指针",
            "attributes": {
                "难度": "入门",
                "内容": "在链队中，指向队首结点（链表头结点）的指针。用于执行出队操作。队空时通常为NULL。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "04CON024",
            "name": "链队队尾指针",
            "attributes": {
                "难度": "入门",
                "内容": "在链队中，指向队尾结点（链表尾结点）的指针。用于在O(1)时间内执行入队操作（在队尾添加新结点）。队空时通常为NULL。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "04DS009",
            "name": "优先级队列",
            "attributes": {
                "难度": "中等",
                "内容": "一种特殊的抽象数据类型，类似于队列，但每个元素都有一个关联的“优先级”。当访问元素时（例如出队），具有最高优先级的元素首先被移除。插入元素时需要维护优先级顺序。常用堆结构来实现。",
                "存储开销": "通常为O(N)，如使用堆实现。",
                "核心特性": "按优先级出队、非严格FIFO",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "重要性区分原则，资源按需优先分配的策略。"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG023",
            "name": "渡口车辆调度模拟",
            "attributes": {
                "难度": "中等",
                "内容": "使用两个队列（一个客车队列，一个货车队列）来模拟渡口车辆排队和上船的过程。根据特定规则（如同类汽车先到先上、客车优先于货车、按比例上船、船满或等待超时发船等）从队列中取出车辆安排上渡轮。",
                "时间复杂度": "O(N)，N为处理的总车辆数。",
                "空间复杂度": "O(N)，N为排队车辆总数峰值。",
                "设计思想": "队列应用、模拟",
                "适用场景": "模拟排队系统、资源调度问题、事件驱动模拟。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "公平与效率的平衡，规则在系统调度中的作用，模拟现实世界问题的计算思维。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS001",
            "name": "树",
            "attributes": {
                "难度": "入门",
                "内容": "树是n(n>=0)个结点的有限集。n=0时称为空树。在任意一棵非空树中：(1)有且仅有一个特定的称为根(Root)的结点；(2)当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1, T2,..., Tm，其中每一个集合本身又是一棵树，并且称为根的子树(Subtree)。树是一种重要的非线性、递归定义的数据结构，广泛用于表示层次关系。",
                "存储开销": "取决于存储方式（顺序或链接）和树的形态。",
                "核心特性": "层次性、递归性",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了分层管理、逐级展开的组织思想，如同社会结构、知识体系。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON002",
            "name": "根",
            "attributes": {
                "难度": "入门",
                "内容": "树中唯一没有前驱的结点，是树的起始点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "万物皆有源，根是基础和核心。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON003",
            "name": "子树",
            "attributes": {
                "难度": "入门",
                "内容": "非空树中，除根结点外，其余结点按照定义构成的独立的树结构，是根结点的后继集合。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "整体由部分组成，部分体现整体特征，体现了系统思维。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON006",
            "name": "度",
            "attributes": {
                "难度": "入门",
                "内容": "结点拥有的子树数目（或后继结点数）称为结点的度。树中所有结点度的最大值称为树的度。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "衡量结点的分支能力和树的复杂度。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON007",
            "name": "叶子结点",
            "attributes": {
                "难度": "入门",
                "内容": "度为0的结点，也称为终端结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "代表了结构的基础单元或最终状态。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON008",
            "name": "分支结点",
            "attributes": {
                "难度": "入门",
                "内容": "度大于0的结点，也称为非终端结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "承担着连接和扩展结构的功能。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON009",
            "name": "孩子结点",
            "attributes": {
                "难度": "入门",
                "内容": "一个结点的子树的根结点，即该结点的直接后继。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了层级关系中的下一级。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON010",
            "name": "双亲结点",
            "attributes": {
                "难度": "入门",
                "内容": "一个结点的直接前驱结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了层级关系中的上一级。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON011",
            "name": "兄弟结点",
            "attributes": {
                "难度": "入门",
                "内容": "具有相同双亲结点的结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了同一层级、同一来源的并列关系。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON012",
            "name": "祖先",
            "attributes": {
                "难度": "入门",
                "内容": "从根结点到某结点路径上的所有结点（不含该结点本身）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "追溯事物的起源和发展脉络。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON013",
            "name": "子孙",
            "attributes": {
                "难度": "入门",
                "内容": "一个结点的所有子树中的所有结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "表示由某一点衍生出的所有后续部分。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON014",
            "name": "层数",
            "attributes": {
                "难度": "入门",
                "内容": "结点的层数从根开始定义，根为第1层，根的孩子为第2层，以此类推。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "清晰地表示了结构的层次深度。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON015",
            "name": "深度",
            "attributes": {
                "难度": "入门",
                "内容": "树中结点的最大层数，也称为树的高度。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "衡量树的整体规模和复杂度。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS002",
            "name": "有序树",
            "attributes": {
                "难度": "入门",
                "内容": "树中任意结点的各子树按一定次序从左至右排列，不可互换位置的树。例如，家族树中兄弟按长幼排序。",
                "存储开销": "同一般树，取决于存储方式。",
                "核心特性": "子树有序",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "强调了顺序和规则在组织结构中的重要性。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS003",
            "name": "无序树",
            "attributes": {
                "难度": "入门",
                "内容": "树中任意结点的各子树之间没有顺序关系，可以任意交换位置。",
                "存储开销": "同一般树，取决于存储方式。",
                "核心特性": "子树无序",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "关注集合关系而非顺序。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON016",
            "name": "森林",
            "attributes": {
                "难度": "入门",
                "内容": "m(m>=0)棵互不相交的树的集合。删除树的根结点，其各子树即构成森林。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了从单一到多元，从整体到部分集合的视角转换。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS004",
            "name": "k叉树",
            "attributes": {
                "难度": "中等",
                "内容": "树中所有结点的度都不超过k的树，也称多叉树或多元树。是树的一种推广形式。",
                "存储开销": "顺序存储可能浪费空间，链接存储根据k值确定指针域数量。",
                "核心特性": "结点度数受限",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "模型化了分支数量受限的层级结构。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS005",
            "name": "二叉树",
            "attributes": {
                "难度": "入门",
                "内容": "度为2的有序树。每个结点最多有两个孩子，分别称为左孩子和右孩子，且左右次序不能颠倒。二叉树可以是空树，或者由一个根结点加上左子树和右子树组成，左右子树也都是二叉树。是计算机科学中应用最广泛的树结构之一。",
                "存储开销": "顺序存储对完全二叉树效率高，链接存储（二叉链表）通用性强。",
                "核心特性": "有序性、结点度最大为2、左右子树区分",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了二分思想，是许多高效算法和数据结构的基础。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS006",
            "name": "满二叉树",
            "attributes": {
                "难度": "中等",
                "内容": "一棵深度为h，且含有2^h - 1个结点的二叉树。即树中的每一层都含有最多的结点。",
                "存储开销": "非常适合顺序存储。",
                "核心特性": "结构规整、结点满层",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "代表了理想化的、完全对称的二叉结构。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS007",
            "name": "完全二叉树",
            "attributes": {
                "难度": "中等",
                "内容": "深度为h、有n个结点的二叉树，当且仅当其每一个结点都与深度为h的满二叉树中编号为1至n的结点一一对应时，称为完全二叉树。特点是叶子结点只可能在层次最大的两层上出现，且最大层次上的叶子结点都集中在最左边的若干位置。",
                "存储开销": "适合顺序存储，空间利用率高。",
                "核心特性": "层序编号连续、叶子结点靠左集中",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "在保持树的平衡性和存储效率方面做了很好的折衷，是堆的基础结构。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS008",
            "name": "理想平衡二叉树",
            "attributes": {
                "难度": "中等",
                "内容": "除最后一层外，其余各层都是满的，而最后一层上的结点可以任意分布的二叉树。完全二叉树是其特例。",
                "存储开销": "链接存储较常见。",
                "核心特性": "除最后一层外均满层",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "放宽了完全二叉树的限制，关注整体的层级满度。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS009",
            "name": "二叉链表",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树的一种链式存储结构。每个结点包含一个数据域和两个指针域，分别指向其左孩子和右孩子结点。",
                "存储开销": "每个结点需要额外存储两个指针。",
                "核心特性": "通过指针表示父子关系",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "是实现二叉树各种操作的基础物理结构。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS010",
            "name": "带双亲指针的二叉链表",
            "attributes": {
                "难度": "中等",
                "内容": "在二叉链表的基础上，为每个结点增加一个指向其双亲结点的指针域。方便查找双亲结点。",
                "存储开销": "每个结点需要额外存储三个指针。",
                "核心特性": "方便向上查找",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "通过增加冗余信息提升特定操作的效率，体现了时空权衡。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG001",
            "name": "前序遍历",
            "attributes": {
                "难度": "中等",
                "内容": "二叉树遍历算法之一。访问顺序：根结点 -> 左子树 -> 右子树。递归定义。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、深度优先",
                "适用场景": "复制二叉树、输出树的结构（带括号表示法）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了先总后分的处理逻辑。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG002",
            "name": "中序遍历",
            "attributes": {
                "难度": "中等",
                "内容": "二叉树遍历算法之一。访问顺序：左子树 -> 根结点 -> 右子树。递归定义。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、深度优先",
                "适用场景": "对二叉排序树进行中序遍历可得到有序序列。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了对称、有序的处理逻辑。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG003",
            "name": "后序遍历",
            "attributes": {
                "难度": "中等",
                "内容": "二叉树遍历算法之一。访问顺序：左子树 -> 右子树 -> 根结点。递归定义。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、深度优先",
                "适用场景": "计算表达式树的值、删除（释放）树结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了先细后总、自底向上的处理逻辑。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG004",
            "name": "按层遍历",
            "attributes": {
                "难度": "中等",
                "内容": "树/二叉树遍历算法之一。按照从上到下、同一层从左到右的次序访问结点。非递归算法，通常借助队列实现。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(w)，w为树的最大宽度（队列最大长度）",
                "设计思想": "广度优先、队列辅助",
                "适用场景": "求解最短路径问题（如树的层数）、按层输出。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了逐层推进、广度探索的策略。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG005",
            "name": "初始化二叉树",
            "attributes": {
                "难度": "入门",
                "内容": "将二叉树设置为空树的操作，通常是将根指针置为NULL。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "基本操作",
                "适用场景": "创建新的二叉树实例前。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "万事开头难，初始化是规范操作的起点。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG006",
            "name": "建立二叉树",
            "attributes": {
                "难度": "中等",
                "内容": "根据给定的输入（如广义表表示、前序+中序序列等）构造二叉树的链接存储结构。广义表法常使用栈辅助实现。",
                "时间复杂度": "O(n)，n为结点数或输入字符串长度",
                "空间复杂度": "O(h)，h为树高（递归或栈深度）",
                "设计思想": "递归或栈辅助、解析输入",
                "适用场景": "从外部表示恢复二叉树结构。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "将抽象表示转化为具体实现，体现了建模和构造能力。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG007",
            "name": "判断二叉树是否为空",
            "attributes": {
                "难度": "入门",
                "内容": "检查二叉树是否为空的操作，通常是判断根指针是否为NULL。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "基本操作",
                "适用场景": "在执行其他操作前进行边界检查。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "严谨性要求，处理边界情况是程序健壮性的保证。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG008",
            "name": "求二叉树深度",
            "attributes": {
                "难度": "中等",
                "内容": "计算二叉树的最大层数。通常使用递归实现：空树深度为0，非空树深度 = max(左子树深度, 右子树深度) + 1。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、分治",
                "适用场景": "分析树的规模和平衡性。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "将复杂问题分解为子问题求解，体现了分治思想。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG009",
            "name": "查找二叉树结点",
            "attributes": {
                "难度": "中等",
                "内容": "在二叉树中查找具有特定值的结点。通常采用类似遍历的方式（如前序）进行递归查找。",
                "时间复杂度": "O(n)（最坏情况）",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、遍历",
                "适用场景": "数据检索。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "系统性搜索是解决查找问题的基本方法。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG010",
            "name": "输出二叉树",
            "attributes": {
                "难度": "中等",
                "内容": "将二叉树的结构以某种形式（如广义表）打印输出。通常基于遍历算法（如前序）修改实现。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、遍历",
                "适用场景": "可视化树结构、调试。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "将内部结构以易于理解的方式呈现出来。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG011",
            "name": "清除二叉树",
            "attributes": {
                "难度": "中等",
                "内容": "释放二叉树占用的所有内存空间，使其变为空树。通常采用后序遍历的递归思想，先释放子树再释放根结点。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、后序遍历",
                "适用场景": "程序结束前或不再需要该树时回收资源。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "资源管理的重要性，有借有还，保持系统清洁。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG012",
            "name": "初始化树",
            "attributes": {
                "难度": "入门",
                "内容": "将普通树（k叉树）设置为空树的操作。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "基本操作",
                "适用场景": "创建新的树实例前。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "同初始化二叉树。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG013",
            "name": "建立树",
            "attributes": {
                "难度": "中等",
                "内容": "根据给定的输入（如广义表表示）构造普通树（k叉树）的链接存储结构。广义表法常使用两个栈（一个存结点指针，一个存孩子序号）辅助实现。",
                "时间复杂度": "O(n)，n为结点数或输入字符串长度",
                "空间复杂度": "O(h)，h为树高（栈深度）",
                "设计思想": "栈辅助、解析输入",
                "适用场景": "从外部表示恢复树结构。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "处理更一般化的树结构构造。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG014",
            "name": "先根遍历",
            "attributes": {
                "难度": "中等",
                "内容": "普通树（k叉树）的遍历算法之一。访问顺序：根结点 -> 从左到右依次遍历各子树。递归定义。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、深度优先",
                "适用场景": "类似二叉树前序遍历。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "处理多分枝情况下的先总后分逻辑。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG015",
            "name": "后根遍历",
            "attributes": {
                "难度": "中等",
                "内容": "普通树（k叉树）的遍历算法之一。访问顺序：从左到右依次遍历各子树 -> 根结点。递归定义。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、深度优先",
                "适用场景": "计算依赖子结点结果的操作、释放树空间。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "处理多分枝情况下的先细后总逻辑。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG016",
            "name": "查找树结点",
            "attributes": {
                "难度": "中等",
                "内容": "在普通树（k叉树）中查找具有特定值的结点。通常采用类似先根遍历的方式进行递归查找。",
                "时间复杂度": "O(n)（最坏情况）",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、遍历",
                "适用场景": "数据检索。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "在更一般化的树结构中进行搜索。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG017",
            "name": "输出树",
            "attributes": {
                "难度": "中等",
                "内容": "将普通树（k叉树）的结构以某种形式（如广义表）打印输出。通常基于先根遍历算法修改实现。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、遍历",
                "适用场景": "可视化树结构、调试。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "将复杂的多叉结构清晰呈现。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG018",
            "name": "求树深度",
            "attributes": {
                "难度": "中等",
                "内容": "计算普通树（k叉树）的最大层数。递归实现：空树深度为0，非空树深度 = max(所有子树深度) + 1。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、分治",
                "适用场景": "分析树的规模。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "处理多分枝情况下的深度计算。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG019",
            "name": "清除树",
            "attributes": {
                "难度": "中等",
                "内容": "释放普通树（k叉树）占用的所有内存空间。通常采用后根遍历的递归思想，先释放所有子树再释放根结点。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)，h为树高（递归栈深度）",
                "设计思想": "递归、后根遍历",
                "适用场景": "资源回收。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "在更复杂的结构中进行彻底的资源清理。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG020",
            "name": "判空树",
            "attributes": {
                "难度": "入门",
                "内容": "检查普通树（k叉树）是否为空的操作。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "基本操作",
                "适用场景": "操作前边界检查。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "同判断二叉树是否为空。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS011",
            "name": "满k叉树",
            "attributes": {
                "难度": "中等",
                "内容": "深度为h的k叉树，其结点总数达到最大值 (k^h - 1) / (k - 1)。即每一层都达到了最大结点数。",
                "存储开销": "适合顺序存储。",
                "核心特性": "结构规整、结点满层",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "k叉树的理想化、完全对称形态。"
            }
        },
        {
            "type": "数据结构",
            "ID": "06DS001",
            "name": "二叉搜索树",
            "attributes": {
                "难度": "中等",
                "内容": "又称二叉排序树，它或是一棵空树，或者是一棵具有如下特性的非空二叉树：（1）若它的左子树非空，则左子树上所有结点的关键字均小于根结点的关键字。（2）若它的右子树非空，则右子树上所有结点的关键字均大于（或等于）根结点的关键字。（3）左、右子树本身又各是一棵二叉搜索树。中序遍历结果为有序序列。主要用于元素的查找、插入和删除。",
                "存储开销": "通常采用链式存储，每个结点包含数据域和两个指针域，空间复杂度为O(n)。",
                "核心特性": "有序性（中序遍历），左<根<右。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG001",
            "name": "二叉搜索树查找",
            "attributes": {
                "难度": "入门",
                "内容": "从根结点开始，若查找值等于根结点值，则成功；若小于根结点值，则在左子树中递归查找；若大于根结点值，则在右子树中递归查找。直至找到或子树为空（查找失败）。有递归和非递归两种实现方式。",
                "时间复杂度": "平均O(log n)，最坏O(n)",
                "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
                "设计思想": "比较、递归/迭代",
                "适用场景": "在二叉搜索树中定位特定值的结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG002",
            "name": "二叉搜索树更新",
            "attributes": {
                "难度": "入门",
                "内容": "首先执行查找操作定位到目标结点，若找到，则用新的值更新该结点的数据域。更新操作通常不改变结点的关键字，若关键字改变可能需要重新调整树结构。",
                "时间复杂度": "平均O(log n)，最坏O(n)",
                "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
                "设计思想": "查找与修改",
                "适用场景": "修改二叉搜索树中已存在结点的数据信息（通常非关键字部分）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG003",
            "name": "二叉搜索树插入",
            "attributes": {
                "难度": "入门",
                "内容": "从根结点开始比较，若插入值小于结点值，则向左子树查找；若大于等于结点值，则向右子树查找，直到找到一个空位置，将新值作为新结点插入。保持二叉搜索树的性质。有递归和非递归实现。",
                "时间复杂度": "平均O(log n)，最坏O(n)",
                "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
                "设计思想": "查找插入位置、链接新结点",
                "适用场景": "向二叉搜索树中添加新的元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG004",
            "name": "二叉搜索树删除",
            "attributes": {
                "难度": "中等",
                "内容": "查找待删除结点。分情况处理：（1）叶子结点：直接删除。（2）单分支结点：用其子结点替换它。（3）双分支结点：用其直接前驱（左子树最右结点）或直接后继（右子树最左结点）替换它，然后删除该前驱或后继结点（转化为情况1或2）。保持二叉搜索树性质。",
                "时间复杂度": "平均O(log n)，最坏O(n)",
                "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
                "设计思想": "查找、分类讨论、替换、递归/迭代",
                "适用场景": "从二叉搜索树中移除指定值的结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "06DS002",
            "name": "堆",
            "attributes": {
                "难度": "中等",
                "内容": "一种特殊的完全二叉树。分为小根堆（父结点值小于等于子结点值）和大根堆（父结点值大于等于子结点值）。根结点是堆中的最小（小根堆）或最大（大根堆）元素。",
                "存储开销": "通常使用数组进行顺序存储，空间利用率高，空间复杂度O(n)。",
                "核心特性": "完全二叉树结构，根结点为最值。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "06CON001",
            "name": "完全二叉树",
            "attributes": {
                "难度": "入门",
                "内容": "一棵深度为k，具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为完全二叉树。特点是叶子结点只可能在层次最大的两层上出现，且最大层次上的叶子结点都依次排列在该层最左边的位置上。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG005",
            "name": "堆插入",
            "attributes": {
                "难度": "中等",
                "内容": "将新元素添加到堆的末尾（数组末尾），然后将其与其父结点比较，若不满足堆性质（如小根堆中子结点小于父结点），则交换两者。重复此过程向上调整（Sift-up），直到满足堆性质或到达根结点。",
                "时间复杂度": "O(log n)",
                "空间复杂度": "O(1)",
                "设计思想": "末尾添加、向上调整",
                "适用场景": "向堆中添加一个新元素并维持堆结构。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG006",
            "name": "堆删除",
            "attributes": {
                "难度": "中等",
                "内容": "通常指删除堆顶元素（最值）。将堆顶元素与堆底元素交换，然后移除堆底元素（缩小堆大小）。将新的堆顶元素与其子结点比较，若不满足堆性质，则与合适的子结点（小根堆中较小的子结点，大根堆中较大的子结点）交换。重复此过程向下调整（Sift-down），直到满足堆性质或到达叶子结点。",
                "时间复杂度": "O(log n)",
                "空间复杂度": "O(1)",
                "设计思想": "替换堆顶、向下调整",
                "适用场景": "获取并移除堆中的最值元素，并维持堆结构。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "06DS004",
            "name": "哈夫曼树",
            "attributes": {
                "难度": "中等",
                "内容": "又称最优二叉树，指对于一组带有确定权值的叶子结点，构造的带权路径长度（WPL）最小的二叉树。树中所有叶子结点都带有权值，非叶子结点没有权值（或其权值为子树叶子权值之和）。权值越大的叶子结点离根越近。",
                "存储开销": "通常采用链式存储，空间复杂度与结点数成正比，约为O(n)（n为叶子结点数）。",
                "核心特性": "带权路径长度最小。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "06CON002",
            "name": "路径长度",
            "attributes": {
                "难度": "入门",
                "内容": "在一棵树中，从一个结点到另一个结点所经过的分支（边）的数目。通常指从根结点到目标结点的路径长度。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "06CON003",
            "name": "带权路径长度",
            "attributes": {
                "难度": "入门",
                "内容": "结点的带权路径长度定义为从树根到该结点之间的路径长度与该结点上权值的乘积。树的带权路径长度（WPL）定义为树中所有叶子结点的带权路径长度之和。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG007",
            "name": "构造哈夫曼树",
            "attributes": {
                "难度": "中等",
                "内容": "给定n个权值，看作n棵只有根结点的二叉树森林。重复以下步骤n-1次：在森林中选取两棵根结点权值最小的树，合并成一棵新树，新树的根结点权值为两棵子树根权值之和。从森林中删除选取的两棵树，并将新树加入森林。最终森林中只剩一棵树，即为哈夫曼树。",
                "时间复杂度": "O(n log n)（使用优先队列优化选择过程）",
                "空间复杂度": "O(n)",
                "设计思想": "贪心算法",
                "适用场景": "构建最优二叉树，用于哈夫曼编码等。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG008",
            "name": "哈夫曼编码",
            "attributes": {
                "难度": "中等",
                "内容": "一种基于哈夫曼树的变长编码方法，属于无前缀编码。将待编码的字符作为叶子结点，字符频率作为权值构造哈夫曼树。约定左分支代表0，右分支代表1（或反之），从根到每个叶子结点的路径构成的01序列即为该叶子结点对应字符的哈夫曼编码。频率高的字符编码短，频率低的编码长。",
                "时间复杂度": "构造树O(n log n)，生成编码O(n)",
                "空间复杂度": "O(n)",
                "设计思想": "贪心、树遍历",
                "适用场景": "数据压缩，减少数据传输或存储的总长度。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "06CON004",
            "name": "无前缀编码",
            "attributes": {
                "难度": "入门",
                "内容": "一种编码方案，其中没有任何一个码字是另一个码字的前缀。这种性质保证了编码序列可以被唯一地、无歧义地解码。哈夫曼编码是无前缀编码的一种。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "06DS005",
            "name": "线索二叉树",
            "attributes": {
                "难度": "中等",
                "内容": "利用二叉链表中的空指针域（原本指向NULL的指针）来存放指向结点在特定遍历次序（如中序）下的前驱和后继结点的指针（称为线索）。为了区分指针域是指向孩子还是线索，结点结构中需要增加两个标志域（ltag, rtag）。",
                "存储开销": "链式存储，每个结点除了数据域和两个指针域外，还需额外存储两个布尔类型的标志域，空间复杂度O(n)。",
                "核心特性": "利用空指针域加速特定遍历（如中序）的前驱和后继查找，便于非递归遍历。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "06CON005",
            "name": "线索",
            "attributes": {
                "难度": "入门",
                "内容": "在线索二叉树中，存放在结点空指针域中的、指向该结点在特定遍历序列中前驱或后继结点的指针。指向前驱的为空左指针域存放，称为左线索或前驱线索；指向后继的为空右指针域存放，称为右线索或后继线索。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG009",
            "name": "线索化",
            "attributes": {
                "难度": "中等",
                "内容": "对普通二叉树按照某种遍历次序（如中序）进行遍历，在遍历过程中修改结点的空指针域，使其指向该结点在此遍历序列中的前驱或后继，并设置相应的线索标志位的过程。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(H)（递归实现）或 O(1)（非递归实现）",
                "设计思想": "树遍历、指针修改",
                "适用场景": "将普通二叉树转换为线索二叉树，以便后续快速查找前驱/后继或进行非递归遍历。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG010",
            "name": "中序线索遍历",
            "attributes": {
                "难度": "中等",
                "内容": "在中序线索二叉树上进行中序遍历的非递归算法。首先找到中序序列的第一个结点（最左下结点），然后重复访问当前结点并利用线索或右子树查找下一个中序后继结点，直到遍历完所有结点。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "利用线索指针进行迭代",
                "适用场景": "高效地（无需栈）对中序线索二叉树进行中序遍历。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "06DS006",
            "name": "平衡二叉树",
            "attributes": {
                "难度": "高级",
                "内容": "又称AVL树，是一种自平衡的二叉搜索树。其任意结点的左、右子树高度差的绝对值不超过1。通过在插入或删除结点后进行旋转操作（LL、RR、LR、RL型调整）来维持平衡，保证查找、插入、删除操作的时间复杂度稳定在O(log n)。",
                "存储开销": "链式存储，每个结点除了数据域和两个指针域外，通常还需要额外存储平衡因子（或子树高度），空间复杂度O(n)。",
                "核心特性": "自平衡，保持二叉搜索树性质，高效的动态操作。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "06CON006",
            "name": "平衡因子",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树中一个结点的左子树高度减去其右子树高度的值。在平衡二叉树（AVL树）中，每个结点的平衡因子只能是-1、0或1。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "06CON007",
            "name": "最小不平衡子树",
            "attributes": {
                "难度": "入门",
                "内容": "在向（或从）平衡二叉树插入（或删除）一个结点后，导致树失衡。从插入（或删除）结点向上回溯，遇到的第一个平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树。平衡调整操作通常针对该子树进行。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG011",
            "name": "LL型调整",
            "attributes": {
                "难度": "中等",
                "内容": "平衡二叉树（AVL树）的一种旋转调整操作。当因在结点A的左孩子B的左子树上插入新结点导致A失衡（平衡因子变为2）时执行。对A进行一次右旋操作：B提升为新的根，A成为B的右孩子，B原来的右子树成为A的左孩子。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "单次右旋转",
                "适用场景": "恢复因在左子树的左子树插入导致的AVL树失衡。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG012",
            "name": "RR型调整",
            "attributes": {
                "难度": "中等",
                "内容": "平衡二叉树（AVL树）的一种旋转调整操作。当因在结点A的右孩子B的右子树上插入新结点导致A失衡（平衡因子变为-2）时执行。对A进行一次左旋操作：B提升为新的根，A成为B的左孩子，B原来的左子树成为A的右孩子。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "单次左旋转",
                "适用场景": "恢复因在右子树的右子树插入导致的AVL树失衡。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG013",
            "name": "LR型调整",
            "attributes": {
                "难度": "中等",
                "内容": "平衡二叉树（AVL树）的一种旋转调整操作。当因在结点A的左孩子B的右子树上插入新结点导致A失衡（平衡因子变为2）时执行。先对A的左孩子B进行一次RR型调整（左旋），然后对A进行一次LL型调整（右旋）。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "先左旋后右旋（双旋转）",
                "适用场景": "恢复因在左子树的右子树插入导致的AVL树失衡。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG014",
            "name": "RL型调整",
            "attributes": {
                "难度": "中等",
                "内容": "平衡二叉树（AVL树）的一种旋转调整操作。当因在结点A的右孩子B的左子树上插入新结点导致A失衡（平衡因子变为-2）时执行。先对A的右孩子B进行一次LL型调整（右旋），然后对A进行一次RR型调整（左旋）。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "先右旋后左旋（双旋转）",
                "适用场景": "恢复因在右子树的左子树插入导致的AVL树失衡。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS001",
            "name": "图",
            "attributes": {
                "难度": "中等",
                "内容": "图(graph)是图型结构的简称，是一种复杂的非线性数据结构，由顶点集V和边集E组成，表示为G=(V,E)。顶点之间可以有任意多个前驱和后继。包含线性表和树。",
                "存储开销": "取决于存储方式，邻接矩阵O(n^2)，邻接表O(n+e)",
                "核心特性": "多对多关系",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "图结构体现了现实世界中广泛存在的网络关系和系统互联，启发学生理解事物普遍联系的观点。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS002",
            "name": "有向图",
            "attributes": {
                "难度": "中等",
                "内容": "边集E(G)中为有向边（序偶）的图。边表示从一个顶点指向另一个顶点的关系。",
                "存储开销": "邻接矩阵O(n^2)，邻接表O(n+e)",
                "核心特性": "边具有方向性",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "有向图模拟了具有方向性的流程或依赖关系，如任务流程、因果关系，有助于培养逻辑思维和系统规划能力。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS003",
            "name": "无向图",
            "attributes": {
                "难度": "中等",
                "内容": "边集E(G)中为无向边（无序对）的图。边表示顶点之间的对称关系。",
                "存储开销": "邻接矩阵O(n^2)，邻接表O(n+2e)",
                "核心特性": "边无方向性，关系对称",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "无向图代表了平等协作或相互连接的关系，如社交网络、交通网络，体现了合作与共享的重要性。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON003",
            "name": "邻接点",
            "attributes": {
                "难度": "入门",
                "内容": "在无向图中，若存在边(vi, vj)，则vi和vj互为邻接点。在有向图中，若存在边<vi, vj>，则vj是vi的出边邻接点，vi是vj的入边邻接点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "邻接关系揭示了节点间的直接联系，是理解网络局部结构和信息传递的基础。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON005",
            "name": "入度",
            "attributes": {
                "难度": "入门",
                "内容": "有向图中顶点v的入边数目，记为ID(v)。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "入度可以衡量一个节点受其他节点影响或指向的程度，例如在依赖关系中表示被依赖的次数。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON006",
            "name": "出度",
            "attributes": {
                "难度": "入门",
                "内容": "有向图中顶点v的出边数目，记为OD(v)。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "出度可以衡量一个节点影响其他节点或指向其他节点的程度，例如在流程图中表示后续步骤的数量。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS004",
            "name": "完全图",
            "attributes": {
                "难度": "入门",
                "内容": "无向图中每两个顶点之间都存在边；有向图中每两个顶点之间都存在方向相反的两条边。n个顶点的无向完全图有n(n-1)/2条边，有向完全图有n(n-1)条边。",
                "存储开销": "邻接矩阵O(n^2)，邻接表O(n+n^2)",
                "核心特性": "顶点间连接最密集",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "完全图代表了理想化的全连接状态，虽然现实中少见，但其概念有助于理解网络连接的上限和极端情况。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON007",
            "name": "稠密图",
            "attributes": {
                "难度": "入门",
                "内容": "边数接近完全图的图，即边数e接近n(n-1)。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "稠密图的概念帮助区分不同连接密度的网络，适用于分析高度互联的系统。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON008",
            "name": "稀疏图",
            "attributes": {
                "难度": "入门",
                "内容": "含有较少边数的图，通常边数e与顶点数n同数量级，即e << n(n-1)。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "稀疏图是现实世界中更常见的网络形态，如社交网络、交通网，其分析和存储优化具有重要实践意义。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON009",
            "name": "子图",
            "attributes": {
                "难度": "入门",
                "内容": "设有两个图G=(V,E)和G'=(V',E')，若V'是V的子集，E'是E的子集，且E'中涉及的顶点均在V'中，则称G'是G的子图。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "子图的概念体现了整体与部分的关系，有助于从局部结构分析复杂系统。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON010",
            "name": "路径",
            "attributes": {
                "难度": "入门",
                "内容": "从顶点v到顶点v'的一个顶点序列v_i1, v_i2, ..., v_im，其中v=v_i1，v'=v_im，且相邻顶点间存在边。路径长度是路径上边的数目。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "路径是探索图中顶点间可达性的基础，模拟了现实世界中的路线、流程或信息传递过程。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON011",
            "name": "回路",
            "attributes": {
                "难度": "入门",
                "内容": "起点和终点相同的路径，也称为环。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "回路代表了系统中的循环或反馈机制，是分析网络稳定性和周期性行为的关键。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON012",
            "name": "简单路径",
            "attributes": {
                "难度": "入门",
                "内容": "路径上所有顶点均不相同的路径。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "简单路径排除了重复访问，常用于最短路径等优化问题，体现了效率和简洁性原则。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON013",
            "name": "简单回路",
            "attributes": {
                "难度": "入门",
                "内容": "除起点和终点相同外，其余顶点均不相同的回路。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "简单回路是构成复杂网络结构的基本单元，在网络分析和环路检测中有重要应用。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON014",
            "name": "连通",
            "attributes": {
                "难度": "入门",
                "内容": "在无向图中，若从顶点vi到顶点vj有路径，则称vi和vj是连通的。在有向图中，若从vi到vj有路径，则称从vi到vj是连通的。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "连通性是衡量网络整体性的重要指标，关系到信息或资源能否在网络中有效流通。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS005",
            "name": "连通图",
            "attributes": {
                "难度": "入门",
                "内容": "无向图中任意两个顶点都连通的图。",
                "存储开销": "取决于存储方式",
                "核心特性": "任意两点可达",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "连通图模型体现了系统的整体性和鲁棒性，即使部分连接中断，仍能保持整体功能。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON015",
            "name": "连通分量",
            "attributes": {
                "难度": "中等",
                "内容": "无向图G的极大连通子图。非连通图有多个连通分量。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "连通分量揭示了非连通网络的内部结构，有助于将复杂问题分解为若干独立子问题处理。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS006",
            "name": "强连通图",
            "attributes": {
                "难度": "中等",
                "内容": "有向图中任意两个顶点vi和vj，从vi到vj和从vj到vi都存在路径。",
                "存储开销": "取决于存储方式",
                "核心特性": "任意两点相互可达",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "强连通图模型强调了网络中任意节点间的双向可达性，常用于分析具有强依赖或循环反馈的系统。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON016",
            "name": "强连通分量",
            "attributes": {
                "难度": "中等",
                "内容": "有向图G的极大强连通子图。非强连通图有多个强连通分量。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "强连通分量是分析有向图结构的关键，有助于识别图中具有紧密双向联系的节点群组。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON017",
            "name": "权",
            "attributes": {
                "难度": "入门",
                "内容": "图中每条边可以标上具有某种含义的数值（通常为非负实数），称为该边的权(weight)。例如表示距离、成本、时间等。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "权的概念为图模型增加了量化维度，使得能够模拟和优化现实世界中带有成本或度量的问题。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS007",
            "name": "带权图",
            "attributes": {
                "难度": "入门",
                "内容": "边上带有权的图，也常称为网(network)。",
                "存储开销": "取决于存储方式，需要在边信息中额外存储权值",
                "核心特性": "边具有量化属性",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "带权图广泛应用于路径优化、资源分配等问题，体现了在约束条件下寻求最优解的工程思想。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS008",
            "name": "邻接矩阵",
            "attributes": {
                "难度": "入门",
                "内容": "表示图形中顶点之间相邻关系的n阶方阵A。A[i,j]=1（或权值）表示顶点i到j有边，否则为0（或无穷大）。无向图的邻接矩阵对称。",
                "存储开销": "O(n^2)",
                "核心特性": "快速判断边是否存在(O(1))，空间占用固定",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "邻接矩阵用规整的二维结构表示复杂的图关系，体现了数学工具在抽象和解决问题中的力量，但需注意空间效率问题。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS009",
            "name": "邻接表",
            "attributes": {
                "难度": "中等",
                "内容": "对图中每个顶点vi建立一个单链表，存储所有以vi为起点的边的信息（邻接点序号、权值等）。用一个数组存储各链表的头指针。",
                "存储开销": "O(n+e)（有向图）或O(n+2e)（无向图）",
                "核心特性": "节省稀疏图空间，方便查找顶点的邻接点",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "邻接表针对稀疏图优化了存储，体现了根据问题特性选择合适数据结构的重要性，培养了具体问题具体分析的思维。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS010",
            "name": "逆邻接表",
            "attributes": {
                "难度": "中等",
                "内容": "对有向图中每个顶点vi建立一个单链表，存储所有以vi为终点的边的信息（入边邻接点序号、权值等）。",
                "存储开销": "O(n+e)",
                "核心特性": "方便查找顶点的入边和入度",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "逆邻接表是对邻接表的补充，解决了特定查询（入边）的效率问题，体现了为满足特定需求而改进数据结构的创新思维。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS011",
            "name": "十字邻接表",
            "attributes": {
                "难度": "高级",
                "内容": "结合邻接表和逆邻接表思想的有向图存储结构。每个边结点包含起点、终点、权值、指向同起点的下一条出边和指向同终点的下一条入边的指针。顶点结点包含第一条入边和第一条出边的指针。",
                "存储开销": "O(n+e)",
                "核心特性": "方便查找顶点的出边、入边、出度和入度",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "十字邻接表通过更复杂的结构整合了多种查询功能，体现了在数据结构设计中权衡复杂性与功能性的思想。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS012",
            "name": "边集数组",
            "attributes": {
                "难度": "入门",
                "内容": "使用一维数组存储图中所有边的信息（起点、终点、权值）。",
                "存储开销": "O(e)",
                "核心特性": "结构简单，适合对边进行遍历处理",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "边集数组以最直接的方式存储边的集合，适用于某些特定算法（如Kruskal），体现了简洁性原则。"
            }
        },
        {
            "type": "算法",
            "ID": "07ALG001",
            "name": "图的遍历",
            "attributes": {
                "难度": "中等",
                "内容": "从图中指定初始点出发，按照一定搜索方法对图中所有可达顶点访问一次且仅访问一次的过程。需要辅助标记数组避免重复访问。",
                "时间复杂度": "取决于具体算法和图的存储结构",
                "空间复杂度": "取决于具体算法和图的存储结构",
                "设计思想": "系统性访问",
                "适用场景": "图的基础操作，许多图算法的基础",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "图的遍历是系统性探索未知网络结构的方法，如同科学研究中的系统调查，强调了全面性和不重复不遗漏的严谨性。"
            }
        },
        {
            "type": "算法",
            "ID": "07ALG002",
            "name": "深度优先搜索",
            "attributes": {
                "难度": "中等",
                "内容": "图遍历算法。从初始点出发，访问该顶点，然后递归地访问其一个未被访问的邻接点，直到该路径走到尽头，再回溯到上一个顶点，访问其其他未被访问的邻接点。",
                "时间复杂度": "邻接矩阵O(n^2)，邻接表O(n+e)",
                "空间复杂度": "O(n)（递归栈或显式栈）",
                "设计思想": "递归、回溯、栈",
                "适用场景": "查找路径、连通性判断、拓扑排序、查找关节点/桥",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "深度优先搜索体现了“一探到底”的探索策略和回溯思想，如同解决问题时深入钻研一个方向，遇到障碍再尝试其他路径，培养了探索精神和解决复杂问题的能力。"
            }
        },
        {
            "type": "算法",
            "ID": "07ALG003",
            "name": "广度优先搜索",
            "attributes": {
                "难度": "中等",
                "内容": "图遍历算法。从初始点出发，访问该顶点，然后访问其所有未被访问的邻接点，再按访问顺序依次访问这些邻接点的未被访问的邻接点，逐层向外扩展。",
                "时间复杂度": "邻接矩阵O(n^2)，邻接表O(n+e)",
                "空间复杂度": "O(n)（队列）",
                "设计思想": "队列、层次扩展",
                "适用场景": "查找最短路径（无权图）、连通性判断、层序遍历",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "广度优先搜索体现了“稳步推进、层层扩展”的策略，如同涟漪扩散，常用于寻找最短路径，培养了系统规划和优化思维。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON001",
            "name": "生成树",
            "attributes": {
                "难度": "入门",
                "内容": "连通图G的一个子图G'，包含G的所有顶点，且边集是G边集的子集，使得G'是连通且无回路的树。生成树包含n个顶点和n-1条边，是原图的极小连通子图。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "生成树体现了在满足基本连通性要求下的最简化结构，启发节约成本、优化资源配置的思维。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON002",
            "name": "最小生成树",
            "attributes": {
                "难度": "中等",
                "内容": "在连通网（带权无向连通图）中，所有生成树里权值总和最小的那棵生成树。用于解决如通信网络建设中总造价最低的问题。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "最小生成树问题是优化思想的典型应用，教育学生在满足要求的前提下追求最优解、最高效费比。"
            }
        },
        {
            "type": "数据结构",
            "ID": "08DS002",
            "name": "深度优先生成树",
            "attributes": {
                "难度": "中等",
                "内容": "通过深度优先搜索（DFS）遍历连通图生成的生成树。",
                "存储开销": "取决于图的存储方式",
                "核心特性": "体现DFS遍历顺序",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "数据结构",
            "ID": "08DS003",
            "name": "广度优先生成树",
            "attributes": {
                "难度": "中等",
                "内容": "通过广度优先搜索（BFS）遍历连通图生成的生成树。",
                "存储开销": "取决于图的存储方式",
                "核心特性": "体现BFS遍历顺序",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "08CON003",
            "name": "连通图",
            "attributes": {
                "难度": "入门",
                "内容": "在无向图中，任意两个顶点之间都存在路径的图。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "08CON004",
            "name": "连通网",
            "attributes": {
                "难度": "入门",
                "内容": "带权的无向连通图，边具有权值（通常为正实数）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "算法",
            "ID": "08ALG001",
            "name": "普里姆算法",
            "attributes": {
                "难度": "中等",
                "内容": "求解最小生成树的贪心算法。从一个顶点开始，逐步将权值最小的连接已选顶点和未选顶点的边加入生成树，直到包含所有顶点。",
                "时间复杂度": "O(n^2) (使用邻接矩阵)",
                "空间复杂度": "O(1) (指额外空间，不计图存储)",
                "设计思想": "贪心",
                "适用场景": "求解稠密图的最小生成树",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了逐步最优累积成全局最优的策略。"
            }
        },
        {
            "type": "算法",
            "ID": "08ALG002",
            "name": "克鲁斯卡尔算法",
            "attributes": {
                "难度": "中等",
                "内容": "求解最小生成树的贪心算法。将所有边按权值排序，依次选择权值最小的边，若该边连接的两个顶点不属于同一连通分量（即不形成回路），则加入生成树，直到包含n-1条边。",
                "时间复杂度": "O(n^2) (按文本描述)",
                "空间复杂度": "O(n^2) (按文本描述，用于存储集合信息)",
                "设计思想": "贪心、并查集思想",
                "适用场景": "求解稀疏图的最小生成树",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "展示了从局部最优选择构建全局最优解的过程，结合了排序和集合操作。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON005",
            "name": "最短路径",
            "attributes": {
                "难度": "中等",
                "内容": "在图中，连接两个顶点之间所有路径中，路径长度（无权图）或带权路径长度（带权图）最小的那条路径。用于解决如交通网络中时间最短或费用最省的问题。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "最短路径问题体现了效率优先的原则，在资源有限的情况下寻找最优解决方案。"
            }
        },
        {
            "type": "算法",
            "ID": "08ALG003",
            "name": "狄克斯特拉算法",
            "attributes": {
                "难度": "中等",
                "内容": "求解单源最短路径问题的贪心算法。维护一个已找到最短路径的顶点集合S，每次从未在S中的顶点里选择距离源点最近的顶点加入S，并更新其他顶点到源点的距离。",
                "时间复杂度": "O(n^2) (使用邻接矩阵)",
                "空间复杂度": "O(n) (用于存储距离和路径信息)",
                "设计思想": "贪心、广度优先思想",
                "适用场景": "求解图中一个顶点到其他所有顶点的最短路径（边权非负）",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了按距离递增的顺序逐步确定最优路径的策略。"
            }
        },
        {
            "type": "算法",
            "ID": "08ALG004",
            "name": "弗洛伊德算法",
            "attributes": {
                "难度": "中等",
                "内容": "求解图中每对顶点之间最短路径的动态规划算法。通过考虑允许经过的中间顶点逐步增加，来更新每对顶点间的最短路径长度。",
                "时间复杂度": "O(n^3)",
                "空间复杂度": "O(n^2) (用于存储距离矩阵)",
                "设计思想": "动态规划",
                "适用场景": "求解图中所有顶点对之间的最短路径，可处理负权边（但不能有负权回路）",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "展示了通过增加中间状态逐步求解复杂问题的动态规划思想。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON006",
            "name": "顶点活动网",
            "attributes": {
                "难度": "中等",
                "内容": "一种有向无环图（DAG），其中顶点表示活动（如工程中的子任务），有向边表示活动之间的先后关系（前驱活动必须完成后继活动才能开始）。简称AOV网。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "AOV网是项目管理和流程规划的有效工具，培养学生理解任务依赖和顺序执行的重要性。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON007",
            "name": "拓扑序列",
            "attributes": {
                "难度": "中等",
                "内容": "对有向无环图（特别是AOV网）的顶点进行线性排序，使得对于图中任意一条有向边<u, v>，顶点u在序列中都出现在顶点v之前。一个图的拓扑序列可能不唯一。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "拓扑序列为具有依赖关系的任务提供了一种可行的执行顺序，体现了逻辑推理和计划安排能力。"
            }
        },
        {
            "type": "算法",
            "ID": "08ALG005",
            "name": "拓扑排序",
            "attributes": {
                "难度": "中等",
                "内容": "生成有向无环图（AOV网）拓扑序列的算法。通常通过重复选择并移除入度为0的顶点，并更新其邻接顶点入度的方式进行。",
                "时间复杂度": "O(n+e)",
                "空间复杂度": "O(n) (存储入度或栈)",
                "设计思想": "基于入度的选择、图遍历",
                "适用场景": "任务调度、依赖分析、检测有向图中的环",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "拓扑排序算法是解决依赖问题的基础，培养学生按逻辑顺序解决问题的能力。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON008",
            "name": "边表示活动的网络",
            "attributes": {
                "难度": "中等",
                "内容": "一种有向带权图，其中边表示活动，边权表示活动持续时间，顶点表示事件（活动的开始或结束）。用于工程计划和进度管理。简称AOE网。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "AOE网是分析工程项目时间安排和关键环节的有力工具，培养学生的时间管理和风险评估意识。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON009",
            "name": "事件",
            "attributes": {
                "难度": "入门",
                "内容": "在AOE网中，表示顶点，代表某些活动的完成和另一些活动的开始的转接点。具有最早发生时间和最迟发生时间属性。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "08CON010",
            "name": "活动",
            "attributes": {
                "难度": "入门",
                "内容": "在AOV网中表示顶点，在AOE网中表示边，代表工程中的一个子任务或需要时间的过程。在AOE网中具有持续时间、最早开始时间和最迟开始时间属性。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "type": "概念",
            "ID": "08CON011",
            "name": "关键路径",
            "attributes": {
                "难度": "高级",
                "内容": "在AOE网中，从源点到汇点的所有路径中，长度（路径上活动持续时间之和）最长的那条（或多条）路径。关键路径上的活动都是关键活动。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "识别关键路径有助于抓住项目管理中的主要矛盾，集中资源确保影响全局进度的活动按时完成，体现了重点论思想。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON012",
            "name": "关键活动",
            "attributes": {
                "难度": "中等",
                "内容": "在AOE网中，最早开始时间等于最迟开始时间的活动（即时间余量为0的活动）。关键活动位于关键路径上，它们的延迟会直接导致整个工程的延期。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "关键活动是项目成功的瓶颈，强调了在复杂系统中识别核心要素的重要性。"
            }
        }
    ],
    "relations": [
        {
            "type": "理论依赖",
            "ID": "01REL001",
            "source": "01DS001",
            "target": "01CON001"
        },
        {
            "type": "理论依赖",
            "ID": "01REL002",
            "source": "01DS001",
            "target": "01CON002"
        },
        {
            "type": "理论依赖",
            "ID": "01REL003",
            "source": "01DS001",
            "target": "01CON008"
        },
        {
            "type": "理论依赖",
            "ID": "01REL004",
            "source": "01DS001",
            "target": "01CON009"
        },
        {
            "type": "理论依赖",
            "ID": "01REL005",
            "source": "01CON003",
            "target": "01CON004"
        },
        {
            "type": "理论依赖",
            "ID": "01REL006",
            "source": "01CON003",
            "target": "01CON005"
        },
        {
            "type": "理论依赖",
            "ID": "01REL007",
            "source": "01CON003",
            "target": "01CON006"
        },
        {
            "type": "理论依赖",
            "ID": "01REL008",
            "source": "01CON005",
            "target": "01CON006"
        },
        {
            "type": "理论依赖",
            "ID": "01REL009",
            "source": "01CON008",
            "target": "01DS002"
        },
        {
            "type": "理论依赖",
            "ID": "01REL010",
            "source": "01CON008",
            "target": "01DS003"
        },
        {
            "type": "理论依赖",
            "ID": "01REL011",
            "source": "01CON008",
            "target": "01DS004"
        },
        {
            "type": "理论依赖",
            "ID": "01REL012",
            "source": "01CON008",
            "target": "01DS005"
        },
        {
            "type": "理论依赖",
            "ID": "01REL013",
            "source": "01CON009",
            "target": "01CON016"
        },
        {
            "type": "理论依赖",
            "ID": "01REL014",
            "source": "01CON009",
            "target": "01CON017"
        },
        {
            "type": "理论依赖",
            "ID": "01REL015",
            "source": "01CON009",
            "target": "01CON018"
        },
        {
            "type": "理论依赖",
            "ID": "01REL016",
            "source": "01CON009",
            "target": "01CON019"
        },
        {
            "type": "理论依赖",
            "ID": "01REL017",
            "source": "01DS001",
            "target": "01CON020"
        },
        {
            "type": "理论依赖",
            "ID": "01REL018",
            "source": "01DS001",
            "target": "01CON021"
        },
        {
            "type": "理论依赖",
            "ID": "01REL019",
            "source": "01DS003",
            "target": "01CON022"
        },
        {
            "type": "理论依赖",
            "ID": "01REL020",
            "source": "01DS003",
            "target": "01CON023"
        },
        {
            "type": "理论依赖",
            "ID": "01REL021",
            "source": "01DS004",
            "target": "01CON022"
        },
        {
            "type": "理论依赖",
            "ID": "01REL022",
            "source": "01DS004",
            "target": "01CON023"
        },
        {
            "type": "理论依赖",
            "ID": "01REL023",
            "source": "01DS005",
            "target": "01CON022"
        },
        {
            "type": "理论依赖",
            "ID": "01REL024",
            "source": "01DS005",
            "target": "01CON023"
        },
        {
            "type": "理论依赖",
            "ID": "01REL027",
            "source": "01CON010",
            "target": "01DS004"
        },
        {
            "type": "理论依赖",
            "ID": "01REL028",
            "source": "01CON010",
            "target": "01DS005"
        },
        {
            "type": "理论依赖",
            "ID": "01REL029",
            "source": "01CON012",
            "target": "01DS001"
        },
        {
            "type": "理论依赖",
            "ID": "01REL030",
            "source": "01CON012",
            "target": "01ALG001"
        },
        {
            "type": "理论依赖",
            "ID": "01REL031",
            "source": "01CON012",
            "target": "01CON011"
        },
        {
            "type": "理论依赖",
            "ID": "01REL032",
            "source": "01CON012",
            "target": "01CON013"
        },
        {
            "type": "理论依赖",
            "ID": "01REL033",
            "source": "01ALG001",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "ID": "01REL034",
            "source": "01ALG001",
            "target": "01CON015"
        },
        {
            "type": "理论依赖",
            "ID": "01REL035",
            "source": "01ALG001",
            "target": "01CON007"
        },
        {
            "type": "理论依赖",
            "ID": "01REL036",
            "source": "01ALG001",
            "target": "01CON024"
        },
        {
            "type": "理论依赖",
            "ID": "01REL037",
            "source": "01ALG002",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "ID": "01REL038",
            "source": "01ALG002",
            "target": "01CON015"
        },
        {
            "type": "理论依赖",
            "ID": "01REL039",
            "source": "01ALG003",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "ID": "01REL040",
            "source": "01ALG003",
            "target": "01CON015"
        },
        {
            "type": "理论依赖",
            "ID": "01REL041",
            "source": "01ALG004",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "ID": "01REL042",
            "source": "01ALG004",
            "target": "01CON015"
        },
        {
            "type": "理论依赖",
            "ID": "01REL043",
            "source": "01ALG005",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "ID": "01REL044",
            "source": "01ALG005",
            "target": "01CON015"
        },
        {
            "type": "继承",
            "ID": "02REL001",
            "source": "02DS005",
            "target": "02DS001"
        },
        {
            "type": "继承",
            "ID": "02REL002",
            "source": "02DS002",
            "target": "02DS001"
        },
        {
            "type": "继承",
            "ID": "02REL003",
            "source": "02DS003",
            "target": "02DS001"
        },
        {
            "type": "变体",
            "ID": "02REL004",
            "source": "02DS004",
            "target": "02DS002"
        },
        {
            "type": "变体",
            "ID": "02REL005",
            "source": "02DS004",
            "target": "02DS003"
        },
        {
            "type": "使用",
            "ID": "02REL006",
            "source": "02DS005",
            "target": "01CON016"
        },
        {
            "type": "使用",
            "ID": "02REL007",
            "source": "02DS002",
            "target": "01CON017"
        },
        {
            "type": "使用",
            "ID": "02REL008",
            "source": "02DS003",
            "target": "01CON017"
        },
        {
            "type": "理论依赖",
            "ID": "02REL009",
            "source": "01CON017",
            "target": "01CON020"
        },
        {
            "type": "理论依赖",
            "ID": "02REL010",
            "source": "01CON020",
            "target": "02CON009"
        },
        {
            "type": "理论依赖",
            "ID": "02REL011",
            "source": "01CON020",
            "target": "02CON010"
        },
        {
            "type": "操作绑定",
            "ID": "02REL012",
            "source": "02ALG001",
            "target": "02DS005"
        },
        {
            "type": "操作绑定",
            "ID": "02REL013",
            "source": "02ALG002",
            "target": "02DS005"
        },
        {
            "type": "操作绑定",
            "ID": "02REL014",
            "source": "02ALG003",
            "target": "02DS005"
        },
        {
            "type": "操作绑定",
            "ID": "02REL015",
            "source": "02ALG004",
            "target": "02DS005"
        },
        {
            "type": "操作绑定",
            "ID": "02REL016",
            "source": "02ALG005",
            "target": "02DS005"
        },
        {
            "type": "操作绑定",
            "ID": "02REL017",
            "source": "02ALG006",
            "target": "02DS005"
        },
        {
            "type": "操作绑定",
            "ID": "02REL018",
            "source": "02ALG007",
            "target": "02DS005"
        },
        {
            "type": "操作绑定",
            "ID": "02REL019",
            "source": "02ALG008",
            "target": "02DS005"
        },
        {
            "type": "操作绑定",
            "ID": "02REL020",
            "source": "02ALG009",
            "target": "02DS005"
        },
        {
            "type": "操作绑定",
            "ID": "02REL021",
            "source": "02ALG010",
            "target": "02DS005"
        },
        {
            "type": "操作绑定",
            "ID": "02REL022",
            "source": "02ALG011",
            "target": "02DS005"
        },
        {
            "type": "操作绑定",
            "ID": "02REL023",
            "source": "02ALG016",
            "target": "02DS002"
        },
        {
            "type": "操作绑定",
            "ID": "02REL024",
            "source": "02ALG017",
            "target": "02DS002"
        },
        {
            "type": "操作绑定",
            "ID": "02REL025",
            "source": "02ALG018",
            "target": "02DS002"
        },
        {
            "type": "操作绑定",
            "ID": "02REL026",
            "source": "02ALG019",
            "target": "02DS002"
        },
        {
            "type": "操作绑定",
            "ID": "02REL027",
            "source": "02ALG020",
            "target": "02DS002"
        },
        {
            "type": "操作绑定",
            "ID": "02REL028",
            "source": "02ALG021",
            "target": "02DS002"
        },
        {
            "type": "操作绑定",
            "ID": "02REL029",
            "source": "02ALG022",
            "target": "02DS002"
        },
        {
            "type": "操作绑定",
            "ID": "02REL030",
            "source": "02ALG023",
            "target": "02DS002"
        },
        {
            "type": "操作绑定",
            "ID": "02REL031",
            "source": "02ALG024",
            "target": "02DS002"
        },
        {
            "type": "操作绑定",
            "ID": "02REL032",
            "source": "02ALG025",
            "target": "02DS002"
        },
        {
            "type": "操作绑定",
            "ID": "02REL033",
            "source": "02ALG026",
            "target": "02DS002"
        },
        {
            "type": "优化",
            "ID": "02REL034",
            "source": "02ALG015",
            "target": "02ALG014"
        },
        {
            "type": "使用",
            "ID": "02REL035",
            "source": "02ALG012",
            "target": "02DS001"
        },
        {
            "type": "使用",
            "ID": "02REL036",
            "source": "02ALG013",
            "target": "02DS001"
        },
        {
            "type": "使用",
            "ID": "02REL037",
            "source": "02ALG014",
            "target": "02DS002"
        },
        {
            "type": "使用",
            "ID": "02REL038",
            "source": "02ALG015",
            "target": "02DS002"
        },
        {
            "type": "理论依赖",
            "ID": "02REL039",
            "source": "02DS001",
            "target": "01CON012"
        },
        {
            "type": "使用",
            "ID": "02REL040",
            "source": "02DS002",
            "target": "02CON005"
        },
        {
            "type": "使用",
            "ID": "02REL041",
            "source": "02DS003",
            "target": "02CON005"
        },
        {
            "type": "使用",
            "ID": "02REL042",
            "source": "02DS002",
            "target": "02CON006"
        },
        {
            "type": "使用",
            "ID": "02REL043",
            "source": "02DS003",
            "target": "02CON006"
        },
        {
            "type": "使用",
            "ID": "02REL044",
            "source": "02DS004",
            "target": "02CON006"
        },
        {
            "type": "理论依赖",
            "ID": "02REL045",
            "source": "01CON016",
            "target": "02CON011"
        },
        {
            "type": "理论依赖",
            "ID": "02REL046",
            "source": "01CON017",
            "target": "02CON012"
        },
        {
            "type": "理论依赖",
            "ID": "02REL047",
            "source": "02ALG002",
            "target": "02CON008"
        },
        {
            "type": "理论依赖",
            "ID": "02REL048",
            "source": "02ALG016",
            "target": "02CON008"
        },
        {
            "type": "理论依赖",
            "ID": "02REL049",
            "source": "02ALG004",
            "target": "02CON008"
        },
        {
            "type": "理论依赖",
            "ID": "02REL050",
            "source": "02ALG018",
            "target": "02CON008"
        },
        {
            "type": "理论依赖",
            "ID": "02REL051",
            "source": "02DS001",
            "target": "02CON008"
        },
        {
            "type": "理论依赖",
            "ID": "02REL052",
            "source": "02ALG012",
            "target": "02CON007"
        },
        {
            "type": "理论依赖",
            "ID": "02REL053",
            "source": "02ALG013",
            "target": "02CON007"
        },
        {
            "type": "理论依赖",
            "ID": "02REL054",
            "source": "02ALG014",
            "target": "02CON007"
        },
        {
            "type": "理论依赖",
            "ID": "02REL055",
            "source": "02ALG015",
            "target": "02CON007"
        },
        {
            "type": "使用",
            "ID": "03REL001",
            "source": "01DS002",
            "target": "01CON016"
        },
        {
            "type": "使用",
            "ID": "03REL002",
            "source": "01DS002",
            "target": "01CON017"
        },
        {
            "type": "理论依赖",
            "ID": "03REL003",
            "source": "03DS004",
            "target": "01CON016"
        },
        {
            "type": "理论依赖",
            "ID": "03REL004",
            "source": "02DS002",
            "target": "01CON017"
        },
        {
            "type": "变体",
            "ID": "03REL005",
            "source": "03DS010",
            "target": "03DS004"
        },
        {
            "type": "使用",
            "ID": "03REL006",
            "source": "01DS002",
            "target": "03DS010"
        },
        {
            "type": "使用",
            "ID": "03REL007",
            "source": "01DS002",
            "target": "02DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL008",
            "source": "03ALG002",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL009",
            "source": "03ALG003",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL010",
            "source": "03ALG004",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL011",
            "source": "03ALG005",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL012",
            "source": "03ALG006",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL013",
            "source": "03ALG007",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL014",
            "source": "03ALG008",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL015",
            "source": "03ALG009",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL016",
            "source": "03ALG010",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL017",
            "source": "03ALG011",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL018",
            "source": "03ALG012",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL019",
            "source": "03ALG013",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL020",
            "source": "03ALG014",
            "target": "01DS002"
        },
        {
            "type": "使用",
            "ID": "03REL021",
            "source": "03ALG007",
            "target": "01ALG002"
        },
        {
            "type": "继承",
            "ID": "03REL022",
            "source": "03DS002",
            "target": "03CON005"
        },
        {
            "type": "使用",
            "ID": "03REL023",
            "source": "03DS002",
            "target": "03DS006"
        },
        {
            "type": "理论依赖",
            "ID": "03REL024",
            "source": "03DS006",
            "target": "03CON006"
        },
        {
            "type": "使用",
            "ID": "03REL025",
            "source": "03DS006",
            "target": "01CON016"
        },
        {
            "type": "使用",
            "ID": "03REL026",
            "source": "03DS006",
            "target": "01CON017"
        },
        {
            "type": "使用",
            "ID": "03REL027",
            "source": "03DS002",
            "target": "03DS007"
        },
        {
            "type": "使用",
            "ID": "03REL028",
            "source": "03DS002",
            "target": "03CON007"
        },
        {
            "type": "操作绑定",
            "ID": "03REL029",
            "source": "03ALG015",
            "target": "03DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL030",
            "source": "03ALG016",
            "target": "03DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL031",
            "source": "03ALG017",
            "target": "03DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL032",
            "source": "03ALG018",
            "target": "03DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL033",
            "source": "03ALG019",
            "target": "03DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL034",
            "source": "03ALG020",
            "target": "03DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL035",
            "source": "03ALG021",
            "target": "03DS002"
        },
        {
            "type": "优化",
            "ID": "03REL036",
            "source": "03ALG017",
            "target": "03ALG016"
        },
        {
            "type": "变体",
            "ID": "03REL037",
            "source": "03DS003",
            "target": "02DS001"
        },
        {
            "type": "使用",
            "ID": "03REL038",
            "source": "03DS003",
            "target": "01CON017"
        },
        {
            "type": "理论依赖",
            "ID": "03REL039",
            "source": "03DS003",
            "target": "01CON024"
        },
        {
            "type": "操作绑定",
            "ID": "03REL040",
            "source": "03ALG022",
            "target": "03DS003"
        },
        {
            "type": "操作绑定",
            "ID": "03REL041",
            "source": "03ALG023",
            "target": "03DS003"
        },
        {
            "type": "操作绑定",
            "ID": "03REL042",
            "source": "03ALG024",
            "target": "03DS003"
        },
        {
            "type": "操作绑定",
            "ID": "03REL043",
            "source": "03ALG025",
            "target": "03DS003"
        },
        {
            "type": "使用",
            "ID": "03REL044",
            "source": "03ALG022",
            "target": "01CON024"
        },
        {
            "type": "使用",
            "ID": "03REL045",
            "source": "03ALG023",
            "target": "01CON024"
        },
        {
            "type": "使用",
            "ID": "03REL046",
            "source": "03ALG024",
            "target": "01CON024"
        },
        {
            "type": "使用",
            "ID": "03REL047",
            "source": "03ALG025",
            "target": "01CON024"
        },
        {
            "type": "理论依赖",
            "ID": "03REL048",
            "source": "01DS002",
            "target": "01CON012"
        },
        {
            "type": "理论依赖",
            "ID": "03REL049",
            "source": "03DS002",
            "target": "01CON012"
        },
        {
            "type": "继承",
            "ID": "04REL001",
            "source": "04DS001",
            "target": "02DS001"
        },
        {
            "type": "理论依赖",
            "ID": "04REL002",
            "source": "04DS001",
            "target": "04CON003"
        },
        {
            "type": "理论依赖",
            "ID": "04REL003",
            "source": "04DS001",
            "target": "04CON001"
        },
        {
            "type": "理论依赖",
            "ID": "04REL004",
            "source": "04DS001",
            "target": "04CON002"
        },
        {
            "type": "操作绑定",
            "ID": "04REL005",
            "source": "04ALG001",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "04REL006",
            "source": "04ALG002",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "04REL007",
            "source": "04ALG003",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "04REL008",
            "source": "04ALG004",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "04REL009",
            "source": "04ALG005",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "04REL010",
            "source": "04ALG006",
            "target": "04DS001"
        },
        {
            "type": "理论依赖",
            "ID": "04REL011",
            "source": "04CON004",
            "target": "04DS001"
        },
        {
            "type": "继承",
            "ID": "04REL012",
            "source": "04DS003",
            "target": "04DS001"
        },
        {
            "type": "理论依赖",
            "ID": "04REL013",
            "source": "04DS003",
            "target": "04CON005"
        },
        {
            "type": "理论依赖",
            "ID": "04REL014",
            "source": "04DS003",
            "target": "04CON006"
        },
        {
            "type": "理论依赖",
            "ID": "04REL015",
            "source": "04DS003",
            "target": "04CON007"
        },
        {
            "type": "继承",
            "ID": "04REL016",
            "source": "04DS004",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "ID": "04REL017",
            "source": "04DS004",
            "target": "02DS002"
        },
        {
            "type": "理论依赖",
            "ID": "04REL018",
            "source": "02DS002",
            "target": "01CON020"
        },
        {
            "type": "理论依赖",
            "ID": "04REL019",
            "source": "04DS004",
            "target": "04CON009"
        },
        {
            "type": "使用",
            "ID": "04REL020",
            "source": "04ALG007",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "ID": "04REL021",
            "source": "04ALG008",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "ID": "04REL022",
            "source": "04ALG009",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "ID": "04REL023",
            "source": "04ALG010",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "ID": "04REL024",
            "source": "04ALG011",
            "target": "04DS001"
        },
        {
            "type": "理论依赖",
            "ID": "04REL025",
            "source": "04ALG011",
            "target": "04CON010"
        },
        {
            "type": "理论依赖",
            "ID": "04REL026",
            "source": "04ALG011",
            "target": "04CON011"
        },
        {
            "type": "理论依赖",
            "ID": "04REL027",
            "source": "04ALG011",
            "target": "04CON012"
        },
        {
            "type": "理论依赖",
            "ID": "04REL028",
            "source": "04CON010",
            "target": "04CON012"
        },
        {
            "type": "使用",
            "ID": "04REL029",
            "source": "01CON024",
            "target": "04DS001"
        },
        {
            "type": "理论依赖",
            "ID": "04REL030",
            "source": "04ALG012",
            "target": "01CON024"
        },
        {
            "type": "理论依赖",
            "ID": "04REL031",
            "source": "04ALG013",
            "target": "01CON024"
        },
        {
            "type": "理论依赖",
            "ID": "04REL032",
            "source": "04ALG014",
            "target": "01CON024"
        },
        {
            "type": "理论依赖",
            "ID": "04REL033",
            "source": "04ALG015",
            "target": "01CON024"
        },
        {
            "type": "理论依赖",
            "ID": "04REL034",
            "source": "04ALG016",
            "target": "01CON024"
        },
        {
            "type": "继承",
            "ID": "04REL035",
            "source": "04DS006",
            "target": "02DS001"
        },
        {
            "type": "理论依赖",
            "ID": "04REL036",
            "source": "04DS006",
            "target": "04CON016"
        },
        {
            "type": "理论依赖",
            "ID": "04REL037",
            "source": "04DS006",
            "target": "04CON014"
        },
        {
            "type": "理论依赖",
            "ID": "04REL038",
            "source": "04DS006",
            "target": "04CON015"
        },
        {
            "type": "操作绑定",
            "ID": "04REL039",
            "source": "04ALG017",
            "target": "04DS006"
        },
        {
            "type": "操作绑定",
            "ID": "04REL040",
            "source": "04ALG018",
            "target": "04DS006"
        },
        {
            "type": "操作绑定",
            "ID": "04REL041",
            "source": "04ALG019",
            "target": "04DS006"
        },
        {
            "type": "操作绑定",
            "ID": "04REL042",
            "source": "04ALG020",
            "target": "04DS006"
        },
        {
            "type": "操作绑定",
            "ID": "04REL043",
            "source": "04ALG021",
            "target": "04DS006"
        },
        {
            "type": "操作绑定",
            "ID": "04REL044",
            "source": "04ALG022",
            "target": "04DS006"
        },
        {
            "type": "理论依赖",
            "ID": "04REL045",
            "source": "04CON017",
            "target": "04DS006"
        },
        {
            "type": "继承",
            "ID": "04REL046",
            "source": "04DS007",
            "target": "04DS006"
        },
        {
            "type": "理论依赖",
            "ID": "04REL047",
            "source": "04DS007",
            "target": "04CON018"
        },
        {
            "type": "理论依赖",
            "ID": "04REL048",
            "source": "04DS007",
            "target": "04CON019"
        },
        {
            "type": "理论依赖",
            "ID": "04REL049",
            "source": "04DS007",
            "target": "04CON020"
        },
        {
            "type": "理论依赖",
            "ID": "04REL050",
            "source": "04DS007",
            "target": "04CON021"
        },
        {
            "type": "理论依赖",
            "ID": "04REL051",
            "source": "04DS007",
            "target": "04CON022"
        },
        {
            "type": "继承",
            "ID": "04REL052",
            "source": "04DS008",
            "target": "04DS006"
        },
        {
            "type": "使用",
            "ID": "04REL053",
            "source": "04DS008",
            "target": "02DS002"
        },
        {
            "type": "理论依赖",
            "ID": "04REL054",
            "source": "04DS008",
            "target": "04CON023"
        },
        {
            "type": "理论依赖",
            "ID": "04REL055",
            "source": "04DS008",
            "target": "04CON024"
        },
        {
            "type": "变体",
            "ID": "04REL056",
            "source": "04DS009",
            "target": "04DS006"
        },
        {
            "type": "使用",
            "ID": "04REL057",
            "source": "04ALG023",
            "target": "04DS006"
        },
        {
            "type": "理论依赖",
            "ID": "05REL001",
            "source": "05DS001",
            "target": "01CON020"
        },
        {
            "type": "理论依赖",
            "ID": "05REL002",
            "source": "05DS001",
            "target": "05CON002"
        },
        {
            "type": "理论依赖",
            "ID": "05REL003",
            "source": "05DS001",
            "target": "05CON003"
        },
        {
            "type": "理论依赖",
            "ID": "05REL004",
            "source": "05DS001",
            "target": "01CON022"
        },
        {
            "type": "理论依赖",
            "ID": "05REL005",
            "source": "05DS001",
            "target": "01CON023"
        },
        {
            "type": "理论依赖",
            "ID": "05REL006",
            "source": "05DS001",
            "target": "05CON006"
        },
        {
            "type": "理论依赖",
            "ID": "05REL007",
            "source": "05DS001",
            "target": "05CON007"
        },
        {
            "type": "理论依赖",
            "ID": "05REL008",
            "source": "05DS001",
            "target": "05CON008"
        },
        {
            "type": "理论依赖",
            "ID": "05REL009",
            "source": "05DS001",
            "target": "05CON009"
        },
        {
            "type": "理论依赖",
            "ID": "05REL010",
            "source": "05DS001",
            "target": "05CON010"
        },
        {
            "type": "理论依赖",
            "ID": "05REL011",
            "source": "05DS001",
            "target": "05CON011"
        },
        {
            "type": "理论依赖",
            "ID": "05REL012",
            "source": "05DS001",
            "target": "05CON012"
        },
        {
            "type": "理论依赖",
            "ID": "05REL013",
            "source": "05DS001",
            "target": "05CON013"
        },
        {
            "type": "理论依赖",
            "ID": "05REL014",
            "source": "05DS001",
            "target": "05CON014"
        },
        {
            "type": "理论依赖",
            "ID": "05REL015",
            "source": "05DS001",
            "target": "05CON015"
        },
        {
            "type": "变体",
            "ID": "05REL016",
            "source": "05DS002",
            "target": "05DS001"
        },
        {
            "type": "变体",
            "ID": "05REL017",
            "source": "05DS003",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "ID": "05REL018",
            "source": "05CON016",
            "target": "05DS001"
        },
        {
            "type": "继承",
            "ID": "05REL019",
            "source": "05DS004",
            "target": "05DS001"
        },
        {
            "type": "继承",
            "ID": "05REL020",
            "source": "05DS005",
            "target": "05DS002"
        },
        {
            "type": "理论依赖",
            "ID": "05REL021",
            "source": "05DS005",
            "target": "01CON020"
        },
        {
            "type": "理论依赖",
            "ID": "05REL022",
            "source": "05DS005",
            "target": "05CON002"
        },
        {
            "type": "理论依赖",
            "ID": "05REL023",
            "source": "05DS005",
            "target": "05CON003"
        },
        {
            "type": "理论依赖",
            "ID": "05REL024",
            "source": "05DS005",
            "target": "05CON006"
        },
        {
            "type": "理论依赖",
            "ID": "05REL025",
            "source": "05DS005",
            "target": "05CON007"
        },
        {
            "type": "理论依赖",
            "ID": "05REL026",
            "source": "05DS005",
            "target": "05CON008"
        },
        {
            "type": "理论依赖",
            "ID": "05REL027",
            "source": "05DS005",
            "target": "05CON009"
        },
        {
            "type": "理论依赖",
            "ID": "05REL028",
            "source": "05DS005",
            "target": "05CON010"
        },
        {
            "type": "理论依赖",
            "ID": "05REL029",
            "source": "05DS005",
            "target": "05CON014"
        },
        {
            "type": "理论依赖",
            "ID": "05REL030",
            "source": "05DS005",
            "target": "05CON015"
        },
        {
            "type": "继承",
            "ID": "05REL031",
            "source": "05DS006",
            "target": "05DS005"
        },
        {
            "type": "继承",
            "ID": "05REL032",
            "source": "05DS007",
            "target": "05DS005"
        },
        {
            "type": "继承",
            "ID": "05REL033",
            "source": "05DS006",
            "target": "05DS007"
        },
        {
            "type": "继承",
            "ID": "05REL034",
            "source": "05DS008",
            "target": "05DS005"
        },
        {
            "type": "继承",
            "ID": "05REL035",
            "source": "05DS007",
            "target": "05DS008"
        },
        {
            "type": "使用",
            "ID": "05REL036",
            "source": "05DS005",
            "target": "01CON016"
        },
        {
            "type": "使用",
            "ID": "05REL037",
            "source": "05DS005",
            "target": "01CON017"
        },
        {
            "type": "使用",
            "ID": "05REL038",
            "source": "05DS009",
            "target": "01CON017"
        },
        {
            "type": "继承",
            "ID": "05REL039",
            "source": "05DS010",
            "target": "05DS009"
        },
        {
            "type": "使用",
            "ID": "05REL040",
            "source": "05DS005",
            "target": "05DS009"
        },
        {
            "type": "操作绑定",
            "ID": "05REL041",
            "source": "05ALG001",
            "target": "05DS005"
        },
        {
            "type": "操作绑定",
            "ID": "05REL042",
            "source": "05ALG002",
            "target": "05DS005"
        },
        {
            "type": "操作绑定",
            "ID": "05REL043",
            "source": "05ALG003",
            "target": "05DS005"
        },
        {
            "type": "操作绑定",
            "ID": "05REL044",
            "source": "05ALG004",
            "target": "05DS005"
        },
        {
            "type": "操作绑定",
            "ID": "05REL045",
            "source": "05ALG005",
            "target": "05DS005"
        },
        {
            "type": "操作绑定",
            "ID": "05REL046",
            "source": "05ALG006",
            "target": "05DS005"
        },
        {
            "type": "操作绑定",
            "ID": "05REL047",
            "source": "05ALG007",
            "target": "05DS005"
        },
        {
            "type": "操作绑定",
            "ID": "05REL048",
            "source": "05ALG008",
            "target": "05DS005"
        },
        {
            "type": "操作绑定",
            "ID": "05REL049",
            "source": "05ALG009",
            "target": "05DS005"
        },
        {
            "type": "操作绑定",
            "ID": "05REL050",
            "source": "05ALG010",
            "target": "05DS005"
        },
        {
            "type": "操作绑定",
            "ID": "05REL051",
            "source": "05ALG011",
            "target": "05DS005"
        },
        {
            "type": "操作绑定",
            "ID": "05REL052",
            "source": "05ALG012",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL053",
            "source": "05ALG013",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL054",
            "source": "05ALG014",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL055",
            "source": "05ALG015",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL056",
            "source": "05ALG004",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL057",
            "source": "05ALG016",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL058",
            "source": "05ALG017",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL059",
            "source": "05ALG018",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL060",
            "source": "05ALG019",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL061",
            "source": "05ALG020",
            "target": "05DS001"
        },
        {
            "type": "使用",
            "ID": "05REL062",
            "source": "05DS001",
            "target": "01CON016"
        },
        {
            "type": "使用",
            "ID": "05REL063",
            "source": "05DS001",
            "target": "01CON017"
        },
        {
            "type": "继承",
            "ID": "05REL064",
            "source": "05DS011",
            "target": "05DS004"
        },
        {
            "type": "操作绑定",
            "ID": "06REL001",
            "source": "06ALG001",
            "target": "06DS001"
        },
        {
            "type": "操作绑定",
            "ID": "06REL002",
            "source": "06ALG002",
            "target": "06DS001"
        },
        {
            "type": "操作绑定",
            "ID": "06REL003",
            "source": "06ALG003",
            "target": "06DS001"
        },
        {
            "type": "操作绑定",
            "ID": "06REL004",
            "source": "06ALG004",
            "target": "06DS001"
        },
        {
            "type": "理论依赖",
            "ID": "06REL005",
            "source": "06DS002",
            "target": "06CON001"
        },
        {
            "type": "操作绑定",
            "ID": "06REL006",
            "source": "06ALG005",
            "target": "06DS002"
        },
        {
            "type": "操作绑定",
            "ID": "06REL007",
            "source": "06ALG006",
            "target": "06DS002"
        },
        {
            "type": "使用",
            "ID": "06REL008",
            "source": "04DS009",
            "target": "06DS002"
        },
        {
            "type": "理论依赖",
            "ID": "06REL009",
            "source": "06DS004",
            "target": "06CON003"
        },
        {
            "type": "理论依赖",
            "ID": "06REL010",
            "source": "06CON003",
            "target": "06CON002"
        },
        {
            "type": "操作绑定",
            "ID": "06REL011",
            "source": "06ALG007",
            "target": "06DS004"
        },
        {
            "type": "使用",
            "ID": "06REL012",
            "source": "06ALG008",
            "target": "06DS004"
        },
        {
            "type": "理论依赖",
            "ID": "06REL013",
            "source": "06ALG008",
            "target": "06CON004"
        },
        {
            "type": "理论依赖",
            "ID": "06REL014",
            "source": "06DS005",
            "target": "06CON005"
        },
        {
            "type": "操作绑定",
            "ID": "06REL015",
            "source": "06ALG009",
            "target": "06DS005"
        },
        {
            "type": "使用",
            "ID": "06REL016",
            "source": "06ALG009",
            "target": "06CON005"
        },
        {
            "type": "操作绑定",
            "ID": "06REL017",
            "source": "06ALG010",
            "target": "06DS005"
        },
        {
            "type": "使用",
            "ID": "06REL018",
            "source": "06ALG010",
            "target": "06CON005"
        },
        {
            "type": "继承",
            "ID": "06REL019",
            "source": "06DS006",
            "target": "06DS001"
        },
        {
            "type": "理论依赖",
            "ID": "06REL020",
            "source": "06DS006",
            "target": "06CON006"
        },
        {
            "type": "操作绑定",
            "ID": "06REL021",
            "source": "06ALG011",
            "target": "06DS006"
        },
        {
            "type": "操作绑定",
            "ID": "06REL022",
            "source": "06ALG012",
            "target": "06DS006"
        },
        {
            "type": "操作绑定",
            "ID": "06REL023",
            "source": "06ALG013",
            "target": "06DS006"
        },
        {
            "type": "操作绑定",
            "ID": "06REL024",
            "source": "06ALG014",
            "target": "06DS006"
        },
        {
            "type": "使用",
            "ID": "06REL025",
            "source": "06ALG011",
            "target": "06CON007"
        },
        {
            "type": "使用",
            "ID": "06REL026",
            "source": "06ALG012",
            "target": "06CON007"
        },
        {
            "type": "使用",
            "ID": "06REL027",
            "source": "06ALG013",
            "target": "06CON007"
        },
        {
            "type": "使用",
            "ID": "06REL028",
            "source": "06ALG014",
            "target": "06CON007"
        },
        {
            "type": "操作绑定",
            "ID": "06REL029",
            "source": "05ALG002",
            "target": "06DS001"
        },
        {
            "type": "理论依赖",
            "ID": "06REL030",
            "source": "06ALG009",
            "target": "05ALG002"
        },
        {
            "type": "继承",
            "ID": "07REL001",
            "source": "07DS002",
            "target": "07DS001"
        },
        {
            "type": "继承",
            "ID": "07REL002",
            "source": "07DS003",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL003",
            "source": "01CON021",
            "target": "01CON020"
        },
        {
            "type": "理论依赖",
            "ID": "07REL004",
            "source": "07CON003",
            "target": "01CON020"
        },
        {
            "type": "理论依赖",
            "ID": "07REL005",
            "source": "07CON003",
            "target": "01CON021"
        },
        {
            "type": "理论依赖",
            "ID": "07REL006",
            "source": "05CON006",
            "target": "01CON020"
        },
        {
            "type": "理论依赖",
            "ID": "07REL007",
            "source": "05CON006",
            "target": "01CON021"
        },
        {
            "type": "理论依赖",
            "ID": "07REL008",
            "source": "07CON005",
            "target": "05CON006"
        },
        {
            "type": "理论依赖",
            "ID": "07REL009",
            "source": "07CON006",
            "target": "05CON006"
        },
        {
            "type": "继承",
            "ID": "07REL010",
            "source": "07DS004",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL011",
            "source": "07CON007",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL012",
            "source": "07CON008",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL013",
            "source": "07CON009",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL014",
            "source": "07CON010",
            "target": "01CON020"
        },
        {
            "type": "理论依赖",
            "ID": "07REL015",
            "source": "07CON010",
            "target": "01CON021"
        },
        {
            "type": "理论依赖",
            "ID": "07REL016",
            "source": "07CON011",
            "target": "07CON010"
        },
        {
            "type": "理论依赖",
            "ID": "07REL017",
            "source": "07CON012",
            "target": "07CON010"
        },
        {
            "type": "理论依赖",
            "ID": "07REL018",
            "source": "07CON013",
            "target": "07CON011"
        },
        {
            "type": "理论依赖",
            "ID": "07REL019",
            "source": "07CON014",
            "target": "07CON010"
        },
        {
            "type": "继承",
            "ID": "07REL020",
            "source": "07DS005",
            "target": "07DS003"
        },
        {
            "type": "理论依赖",
            "ID": "07REL021",
            "source": "07DS005",
            "target": "07CON014"
        },
        {
            "type": "理论依赖",
            "ID": "07REL022",
            "source": "07CON015",
            "target": "07DS005"
        },
        {
            "type": "理论依赖",
            "ID": "07REL023",
            "source": "07CON015",
            "target": "07CON009"
        },
        {
            "type": "继承",
            "ID": "07REL024",
            "source": "07DS006",
            "target": "07DS002"
        },
        {
            "type": "理论依赖",
            "ID": "07REL025",
            "source": "07DS006",
            "target": "07CON014"
        },
        {
            "type": "理论依赖",
            "ID": "07REL026",
            "source": "07CON016",
            "target": "07DS006"
        },
        {
            "type": "理论依赖",
            "ID": "07REL027",
            "source": "07CON016",
            "target": "07CON009"
        },
        {
            "type": "理论依赖",
            "ID": "07REL028",
            "source": "07CON017",
            "target": "01CON021"
        },
        {
            "type": "继承",
            "ID": "07REL029",
            "source": "07DS007",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL030",
            "source": "07DS007",
            "target": "07CON017"
        },
        {
            "type": "理论依赖",
            "ID": "07REL031",
            "source": "07DS008",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL032",
            "source": "07DS009",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL033",
            "source": "07DS010",
            "target": "07DS002"
        },
        {
            "type": "变体",
            "ID": "07REL034",
            "source": "07DS010",
            "target": "07DS009"
        },
        {
            "type": "理论依赖",
            "ID": "07REL035",
            "source": "07DS011",
            "target": "07DS002"
        },
        {
            "type": "变体",
            "ID": "07REL036",
            "source": "07DS011",
            "target": "07DS009"
        },
        {
            "type": "变体",
            "ID": "07REL037",
            "source": "07DS011",
            "target": "07DS010"
        },
        {
            "type": "理论依赖",
            "ID": "07REL038",
            "source": "07DS012",
            "target": "07DS001"
        },
        {
            "type": "操作绑定",
            "ID": "07REL039",
            "source": "07ALG001",
            "target": "07DS001"
        },
        {
            "type": "继承",
            "ID": "07REL040",
            "source": "07ALG002",
            "target": "07ALG001"
        },
        {
            "type": "继承",
            "ID": "07REL041",
            "source": "07ALG003",
            "target": "07ALG001"
        },
        {
            "type": "使用",
            "ID": "07REL042",
            "source": "07ALG003",
            "target": "04DS006"
        },
        {
            "type": "使用",
            "ID": "07REL043",
            "source": "07ALG002",
            "target": "04DS001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL001",
            "source": "08CON001",
            "target": "08CON003"
        },
        {
            "type": "继承",
            "ID": "08REL002",
            "source": "08CON002",
            "target": "08CON001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL003",
            "source": "08CON002",
            "target": "08CON004"
        },
        {
            "type": "继承",
            "ID": "08REL004",
            "source": "08DS002",
            "target": "08CON001"
        },
        {
            "type": "继承",
            "ID": "08REL005",
            "source": "08DS003",
            "target": "08CON001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL006",
            "source": "08CON003",
            "target": "07DS001"
        },
        {
            "type": "继承",
            "ID": "08REL007",
            "source": "08CON004",
            "target": "08CON003"
        },
        {
            "type": "理论依赖",
            "ID": "08REL008",
            "source": "08ALG001",
            "target": "08CON002"
        },
        {
            "type": "使用",
            "ID": "08REL009",
            "source": "08ALG001",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL010",
            "source": "08ALG002",
            "target": "08CON002"
        },
        {
            "type": "使用",
            "ID": "08REL011",
            "source": "08ALG002",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL012",
            "source": "08ALG003",
            "target": "08CON005"
        },
        {
            "type": "使用",
            "ID": "08REL013",
            "source": "08ALG003",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL014",
            "source": "08ALG004",
            "target": "08CON005"
        },
        {
            "type": "使用",
            "ID": "08REL015",
            "source": "08ALG004",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL016",
            "source": "08ALG005",
            "target": "08CON007"
        },
        {
            "type": "理论依赖",
            "ID": "08REL017",
            "source": "08ALG005",
            "target": "08CON006"
        },
        {
            "type": "使用",
            "ID": "08REL018",
            "source": "08ALG005",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL019",
            "source": "08CON007",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL020",
            "source": "08CON011",
            "target": "08CON008"
        },
        {
            "type": "理论依赖",
            "ID": "08REL021",
            "source": "08CON009",
            "target": "08CON008"
        },
        {
            "type": "理论依赖",
            "ID": "08REL022",
            "source": "08CON012",
            "target": "08CON011"
        },
        {
            "type": "理论依赖",
            "ID": "08REL023",
            "source": "08CON011",
            "target": "08CON010"
        },
        {
            "type": "理论依赖",
            "ID": "08REL024",
            "source": "08CON010",
            "target": "08CON006"
        },
        {
            "type": "理论依赖",
            "ID": "08REL025",
            "source": "08CON008",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL026",
            "source": "08CON005",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "ADDREL001",
            "source": "02DS001",
            "target": "01DS003"
        },
        {
            "type": "理论依赖",
            "ID": "ADDREL002",
            "source": "05DS001",
            "target": "01DS004"
        },
        {
            "type": "理论依赖",
            "ID": "ADDREL003",
            "source": "07DS001",
            "target": "01DS005"
        },
        {
            "type": "继承",
            "ID": "ADDREL004",
            "source": "05DS001",
            "target": "07DS001"
        },
        {
            "type": "继承",
            "ID": "ADDREL005",
            "source": "06DS001",
            "target": "05DS005"
        },
        {
            "type": "继承",
            "ID": "ADDREL006",
            "source": "06DS002",
            "target": "05DS005"
        },
        {
            "type": "继承",
            "ID": "ADDREL007",
            "source": "06DS004",
            "target": "05DS005"
        },
        {
            "type": "继承",
            "ID": "ADDREL008",
            "source": "06DS005",
            "target": "05DS005"
        },
        {
            "type": "使用",
            "ID": "ADDREL009",
            "source": "01ALG002",
            "target": "03DS004"
        },
        {
            "type": "使用",
            "ID": "ADDREL010",
            "source": "01ALG003",
            "target": "02DS001"
        },
        {
            "type": "使用",
            "ID": "ADDREL011",
            "source": "08ALG002",
            "target": "01DS002"
        },
        {
            "type": "使用",
            "ID": "ADDREL012",
            "source": "08ALG003",
            "target": "04DS009"
        }
    ]
}
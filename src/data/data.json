{
    "entities": [
        {
            "ID": "01DS001",
            "name": "数据结构",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "指数据以及相互之间的联系。它是根据人们解决实际问题的需要从问题本身所含数据之间的内在联系而抽象出来的逻辑结构。也指数据的逻辑结构和存储结构的总称，专门研究数据如何在计算机系统中表示、存取和处理。",
                "存储开销": "依赖于所选的具体存储结构（顺序、链接、索引、散列等）",
                "核心特性": "定义数据元素间的逻辑关系及操作方式",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON005",
            "name": "关键项",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "能唯一标识一个记录的数据项（或数据项的组合）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON006",
            "name": "关键字",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "关键项中的具体值，用于唯一标识一个记录。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON008",
            "name": "逻辑结构",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素之间的内在联系和组织方式，与计算机存储无关。基本类型包括集合、线性结构、树形结构、图形结构。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01DS002",
            "name": "集合",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "一种逻辑结构，其中数据元素除了同属于一个集合外，没有其他特定关系。",
                "存储开销": "通常使用数组或链表实现，开销依赖于实现方式",
                "核心特性": "元素间无特定顺序或关系",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01DS003",
            "name": "线性结构",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "一种逻辑结构，其中数据元素之间存在一对一的线性关系。除首尾元素外，每个元素有且仅有一个直接前驱和一个直接后继。",
                "存储开销": "顺序存储（数组）或链式存储（链表），开销不同",
                "核心特性": "元素间一对一关系，有序",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01DS004",
            "name": "树形结构",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "一种逻辑结构，其中数据元素之间存在一对多的层次关系。除根结点外，每个元素有且仅有一个直接前驱（父结点），但可以有零个或多个直接后继（子结点）。",
                "存储开销": "通常使用链式存储或数组表示，开销依赖具体实现",
                "核心特性": "元素间一对多关系，层次性",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01DS005",
            "name": "图形结构",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "一种逻辑结构，其中数据元素（顶点）之间存在多对多的关系。任何两个元素之间都可能存在关系。",
                "存储开销": "常用邻接矩阵或邻接表存储，开销与顶点和边数相关",
                "核心特性": "元素间多对多关系，网状",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON009",
            "name": "存储结构",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "数据的逻辑结构在计算机内存中的表示方式，也称物理结构。基本方法有顺序存储、链接存储、索引存储、散列存储。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON010",
            "name": "顺序存储结构",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "将逻辑上相邻的数据元素存储在物理位置也相邻的存储单元中的存储方式。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON011",
            "name": "链接存储结构",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素的存储单元不一定连续，通过指针将逻辑上相邻的元素链接起来的存储方式。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON012",
            "name": "索引存储结构",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在存储元素信息的同时，建立附加的索引表来标识元素的地址的存储方式。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON013",
            "name": "散列存储结构",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "根据元素的关键字直接计算出该元素的存储地址的存储方式，也称哈希存储。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON014",
            "name": "关系",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素之间的联系，在数据结构的二元组表示 B=(K,R) 中，R是数据元素集合K上的二元关系的集合。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON015",
            "name": "直接前驱",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在具有线性关系或层次关系的数据结构中，一个元素的前一个元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON016",
            "name": "直接后继",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在具有线性关系或层次关系的数据结构中，一个元素的后一个元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON017",
            "name": "结点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "数据结构中表示数据元素的图形单元，也称顶点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON018",
            "name": "有向边",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在图形表示中，连接两个结点并带有方向的线段，表示元素间的有序关系（序偶），也称弧。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON019",
            "name": "树根结点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在树形结构中，没有直接前驱（父结点）的唯一结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON020",
            "name": "树叶结点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在树形结构中，没有直接后继（子结点）的结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON021",
            "name": "树枝结点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在树形结构中，除了树根结点和树叶结点之外的结点，也称内部结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON022",
            "name": "非线性结构",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素之间存在一对多或多对多关系的逻辑结构，如树形结构和图形结构。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON024",
            "name": "抽象数据类型",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "由一种数据结构（逻辑结构）和在其上定义的一组操作所组成。强调数据封装和信息隐藏，不关注具体实现。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON026",
            "name": "算法",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "解决特定问题的方法或步骤序列。应具备有穷性、确定性、可行性、输入、输出五个特性。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON027",
            "name": "时间复杂度",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "衡量算法运行时间随问题规模增长而增长的趋势，通常用大O表示法表示其数量级。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON028",
            "name": "空间复杂度",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "衡量算法运行过程中临时占用存储空间大小随问题规模增长而增长的趋势，通常用大O表示法表示。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01ALG002",
            "name": "累加求和",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "遍历数组（或序列），将每个元素的值累加到一个和变量中。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "迭代累加",
                "适用场景": "计算序列元素的总和",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01ALG003",
            "name": "矩阵相加",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "对两个相同维度的矩阵，将对应位置的元素相加，结果存入新的矩阵。",
                "时间复杂度": "O(n^2) (对于n*n矩阵)",
                "空间复杂度": "O(n^2) (若需存储结果矩阵)",
                "设计思想": "遍历对应元素",
                "适用场景": "线性代数中的矩阵加法运算",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01ALG004",
            "name": "简单选择排序",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。",
                "时间复杂度": "O(n^2)",
                "空间复杂度": "O(1)",
                "设计思想": "选择、交换",
                "适用场景": "小规模数据排序",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01CON029",
            "name": "数量级",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "表示函数增长趋势的级别，常用于描述算法复杂度，如 O(1), O(n), O(n^2), O(logn) 等。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01ALG005",
            "name": "顺序查找",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "从数据序列的一端开始，逐个比较元素，直到找到目标元素或遍历完整个序列。",
                "时间复杂度": "O(n) (平均和最坏情况)",
                "空间复杂度": "O(1)",
                "设计思想": "线性遍历、比较",
                "适用场景": "无序或小规模序列的查找",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01DS006",
            "name": "数组",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "数目固定的具有同一类型的数据元素的顺序组合。元素在内存中通常是连续存储的。",
                "存储开销": "O(n)，n为元素个数",
                "核心特性": "连续存储，可通过下标随机访问元素",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01DS007",
            "name": "字符串",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "由零个或多个字符组成的有限序列。通常实现为字符数组，并以特殊结束符（如'\\0'）标记结尾。",
                "存储开销": "O(n)，n为字符个数",
                "核心特性": "字符序列，支持查找、连接、复制等操作",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "01DS009",
            "name": "单链表",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "一种链式存储的线性结构，每个结点包含数据域和指向下一个结点的指针域。",
                "存储开销": "O(n)，n为结点数，包含数据和指针开销",
                "核心特性": "非连续存储，插入删除操作（在已知位置）效率高",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02DS001",
            "name": "线性表",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "具有相同属性的数据元素的一个有限序列。序列中元素个数称为长度，元素之间存在一对一的前驱和后继关系（首元素无前驱，尾元素无后继）。是一种基本的线性结构。",
                "存储开销": "取决于具体实现（顺序或链接）",
                "核心特性": "线性、有序（指逻辑顺序）",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON001",
            "name": "线性结构",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素之间存在一对一线性关系的数据结构。每个元素最多只有一个直接前驱和一个直接后继。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON002",
            "name": "前驱",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在线性结构中，位于一个元素之前的直接相邻元素称为该元素的前驱。首元素没有前驱。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON003",
            "name": "后继",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在线性结构中，位于一个元素之后的直接相邻元素称为该元素的后继。尾元素没有后继。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON004",
            "name": "有序表",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "线性表中存在按值的升序或降序排列的字段（关键字段），则称该线性表为有序表。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON005",
            "name": "无序表",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "线性表中不存在任何按值的升序或降序排列的字段，仅按前后位置有序，则为无序表。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG001",
            "name": "初始化线性表",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空的线性表。对于顺序表，可能涉及分配存储空间并将长度置零；对于链表，通常将头指针置空。",
                "时间复杂度": "O(1) 或 O(MaxSize) (顺序表初始化空间)",
                "空间复杂度": "O(1) 或 O(MaxSize) (顺序表存储)",
                "设计思想": "初始化",
                "适用场景": "创建新的线性表实例",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG002",
            "name": "清空线性表",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "删除线性表中的所有元素，使其变为空表。对于动态分配的存储，需要释放空间。",
                "时间复杂度": "O(1) (顺序表置size=0) 或 O(n) (链表释放结点)",
                "空间复杂度": "O(1)",
                "设计思想": "资源释放",
                "适用场景": "重置线性表状态",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG003",
            "name": "求线性表长度",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "返回线性表中元素的个数。",
                "时间复杂度": "O(1) (顺序表) 或 O(n) (链表，若未存储长度)",
                "空间复杂度": "O(1)",
                "设计思想": "计数/查询",
                "适用场景": "获取线性表大小",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG004",
            "name": "判空线性表",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "判断线性表是否不包含任何元素。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "状态检查",
                "适用场景": "在操作前检查线性表是否为空",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG005",
            "name": "获取元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "根据指定位置（序号）返回线性表中的元素值。",
                "时间复杂度": "O(1) (顺序表) 或 O(n) (链表)",
                "空间复杂度": "O(1)",
                "设计思想": "按位置访问",
                "适用场景": "读取特定位置的数据",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG006",
            "name": "遍历线性表",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "按逻辑顺序访问线性表中的每一个元素。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "顺序访问",
                "适用场景": "处理或显示线性表中所有元素",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG007",
            "name": "查找元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "在线性表中查找第一个值等于给定值的元素。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "顺序搜索",
                "适用场景": "确定元素是否存在或获取其完整信息",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG008",
            "name": "更新元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "在线性表中查找第一个值等于给定值的元素，并用新值更新它。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "查找与修改",
                "适用场景": "修改线性表中特定元素的值",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG009",
            "name": "插入元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "在线性表的指定位置或按特定条件（如保持有序）插入一个新元素。",
                "时间复杂度": "O(n) (顺序表移动元素，链表查找位置)，O(1) (链表指定位置插入)",
                "空间复杂度": "O(1) (可能触发顺序表扩容)",
                "设计思想": "修改结构",
                "适用场景": "向线性表添加数据",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG010",
            "name": "删除元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "从线性表中删除指定位置或第一个满足特定条件的元素。",
                "时间复杂度": "O(n) (顺序表移动元素，链表查找位置)，O(1) (链表指定位置删除)",
                "空间复杂度": "O(1)",
                "设计思想": "修改结构",
                "适用场景": "从线性表移除数据",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG011",
            "name": "排序线性表",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "将线性表中的元素按照特定规则（通常是升序或降序）重新排列。",
                "时间复杂度": "取决于具体排序算法，如插入排序O(n^2)",
                "空间复杂度": "取决于具体排序算法，如插入排序O(1)",
                "设计思想": "排序",
                "适用场景": "使线性表元素有序",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON008",
            "name": "顺序存储",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "将逻辑上相邻的数据元素存储在物理位置也相邻的存储单元中的存储方式。通常借助数组实现。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02DS002",
            "name": "顺序表",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "采用顺序存储结构实现的线性表。元素存储在连续的内存空间中。",
                "存储开销": "O(n)，需要预分配或动态调整连续空间。",
                "核心特性": "随机访问（O(1)时间访问元素），插入删除操作可能需要移动大量元素（O(n)时间）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON010",
            "name": "随机存取",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "访问数据结构中任何元素的时间都是常数，与元素的位置无关。例如数组。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG012",
            "name": "插入排序",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "一种简单的排序算法，通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。",
                "时间复杂度": "O(n^2) (平均/最差)，O(n) (最好)",
                "空间复杂度": "O(1)",
                "设计思想": "增量构建",
                "适用场景": "基本有序或数据量小的序列",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON011",
            "name": "链接存储",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素的存储位置不要求连续，通过指针将逻辑上相邻的元素链接起来的存储方式。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02DS004",
            "name": "链表",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "采用链接存储结构实现的线性表。由一系列结点组成，每个结点包含数据域和指向下一个结点的指针域。",
                "存储开销": "O(n)，每个结点需要额外存储指针。",
                "核心特性": "插入删除操作高效（O(1)时间，若已知位置），访问元素需要顺序遍历（O(n)时间）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON013",
            "name": "数据域",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "链表结点中用于存储数据元素的部分。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON014",
            "name": "指针域",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "链表结点中用于存储下一个（或上一个）结点地址的部分，实现结点间的链接。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON015",
            "name": "顺序存取",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "访问数据结构中特定元素需要从头开始按顺序遍历。例如链表。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02DS006",
            "name": "双链表",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "链表的一种，每个结点有两个指针域，一个指向直接前驱，一个指向直接后继。",
                "存储开销": "O(n)，每个结点两个指针开销。",
                "核心特性": "可以双向遍历，方便查找前驱结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON016",
            "name": "表头结点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "链表中存储第一个数据元素的结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON017",
            "name": "表尾结点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "链表中存储最后一个数据元素的结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON018",
            "name": "表头指针",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "指向链表中第一个结点（通常是表头结点或表头附加结点）的指针。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02CON019",
            "name": "表头附加结点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在链表的表头结点之前额外增加的一个结点，不存储实际数据，目的是简化链表操作（尤其是头部的插入和删除）。也称为头结点或哑结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02DS007",
            "name": "循环链表",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "链表的一种变体，表中最后一个结点的指针域指向头结点（或表头附加结点），形成一个环。",
                "存储开销": "同基本链表（单链或双链）。",
                "核心特性": "从任一结点出发可以遍历整个链表。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02DS008",
            "name": "多项式",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "数学概念，表示为变量的幂的和，每一项包含系数和指数。在数据结构中常使用线性表（顺序或链式）来表示。",
                "存储开销": "取决于表示法，稀疏表示（只存非零项）可节省空间。",
                "核心特性": "系数、指数",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG013",
            "name": "多项式求值（系数数组法）",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "计算给定x值时，用系数数组表示的多项式的值。遍历系数数组，累加每一项的值。",
                "时间复杂度": "O(n)，n为多项式最高次幂+1",
                "空间复杂度": "O(1)",
                "设计思想": "迭代求和",
                "适用场景": "稠密多项式求值",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG014",
            "name": "多项式求值（稀疏表示法）",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "计算给定x值时，用只存储非零项（系数，指数）的线性表表示的多项式的值。遍历列表，累加每一项的值。",
                "时间复杂度": "O(m)，m为非零项个数",
                "空间复杂度": "O(1)",
                "设计思想": "迭代求和",
                "适用场景": "稀疏多项式求值",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG015",
            "name": "多项式相加（调用插入法）",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "将两个用链表表示的多项式相加，生成一个新的表示和的多项式链表。通过比较指数，逐项调用链表插入操作添加到结果链表。",
                "时间复杂度": "O((m+n)^2)，若插入为O(n)",
                "空间复杂度": "O(m+n)",
                "设计思想": "归并思想，利用现有插入操作",
                "适用场景": "教学示例，实现简单但效率较低",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "02ALG016",
            "name": "多项式相加（尾插法）",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "将两个用链表表示的多项式相加，生成一个新的表示和的多项式链表。通过比较指数，直接在结果链表尾部添加新结点。",
                "时间复杂度": "O(m+n)",
                "空间复杂度": "O(m+n)",
                "设计思想": "归并思想，尾插法优化",
                "适用场景": "高效的多项式链表相加实现",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03DS002",
            "name": "集合的顺序存储",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "使用数组存储集合元素的一种实现方式。通常需要额外变量记录当前长度和数组最大容量。插入和删除操作通常作用于逻辑末尾，或通过移动元素来填补空位。",
                "存储开销": "需要连续内存空间，大小固定或动态调整。可能存在空间浪费或需要动态扩容的开销。",
                "核心特性": "基于数组实现，逻辑结构与物理结构可能不一致（删除操作后）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03DS003",
            "name": "集合的链式存储",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "使用链表（通常是单链表）存储集合元素的一种实现方式。每个元素对应一个结点。插入通常在表头进行以简化操作。",
                "存储开销": "结点按需动态分配，存在指针开销。",
                "核心特性": "基于链表实现，动态大小，非连续内存。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03DS004",
            "name": "稀疏矩阵",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "非零元素个数远小于零元素个数的矩阵。通常只存储非零元素及其行号、列号以节省空间。",
                "存储开销": "远小于标准二维数组，具体取决于非零元素数量和存储方式（如三元组表）。",
                "核心特性": "空间高效存储，针对非零元素进行操作。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03DS005",
            "name": "三元组线性表",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "用于表示稀疏矩阵的一种线性数据结构。表中每个元素是一个三元组，包含非零元素的行号、列号和值。通常按行号主序、列号辅序排列。",
                "存储开销": "与非零元素个数成正比，具体取决于其顺序或链式实现。",
                "核心特性": "紧凑存储非零元素信息，逻辑有序（按行列）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03DS006",
            "name": "稀疏矩阵的顺序存储",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "使用数组存储稀疏矩阵对应的三元组线性表。通常还需存储矩阵的行数、列数和非零元总数。",
                "存储开销": "主要是存储三元组的数组开销，与非零元素个数成正比，需要预估最大元素数量。",
                "核心特性": "基于数组实现三元组表，结构相对简单。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03DS007",
            "name": "带行指针向量的链接存储",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "稀疏矩阵的一种链式存储结构。使用一个指针数组（行指针向量），其下标对应行号，每个指针指向该行非零元素（按列号排序）构成的单链表的头结点。",
                "存储开销": "结点动态分配开销加上行指针向量数组的开销。",
                "核心特性": "便于按行处理稀疏矩阵，结点按需分配。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03DS008",
            "name": "十字链表存储",
            "type": "数据结构",
            "attributes": {
                "难度": "高级",
                "内容": "稀疏矩阵的一种链式存储结构。每个非零元素结点包含行、列、值以及指向同行下一个元素和同列下一个元素的指针。同时维护行指针向量和列指针向量。",
                "存储开销": "每个结点需要两个指针域，外加行、列指针向量的开销。",
                "核心特性": "便于按行和按列双向处理稀疏矩阵。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03DS009",
            "name": "广义表",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "线性表的推广，是n(n>=0)个元素（单元素或子表）的有限序列。是一种递归定义的数据结构。",
                "存储开销": "通常采用动态链式存储，开销与结点总数和结构复杂度有关。",
                "核心特性": "递归结构，元素可以是原子或列表，可表示复杂层次关系。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03DS010",
            "name": "广义表的链式存储",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "使用带标志域的结点来存储广义表。结点分为单元素结点（存储值）和子表结点（存储指向子表的指针），通过next指针链接同一层次的元素。",
                "存储开销": "结点按需动态分配，每个结点包含标志域、联合数据域和后继指针域。",
                "核心特性": "能够表示广义表的递归和层次结构，动态存储。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03DS011",
            "name": "矩阵",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "一个m行n列的数表，共包含m*n个数（元素），每个元素由唯一的行号和列号确定位置。",
                "存储开销": "标准实现通常使用二维数组，空间复杂度为O(m*n)。",
                "核心特性": "二维结构，通过行、列索引访问元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG001",
            "name": "集合初始化",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空集合。对于顺序存储，将长度置为0；对于链式存储，将头指针置为NULL。可能涉及初始空间的分配。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "基本初始化",
                "适用场景": "创建新的集合实例时。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG002",
            "name": "清除集合",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "移除集合中的所有元素，使其变为空集。对于动态分配的存储结构（如链式存储或动态数组），需要释放占用的内存空间。",
                "时间复杂度": "顺序存储(仅重置长度) O(1)，链式存储(需遍历释放) O(n)。",
                "空间复杂度": "O(1)",
                "设计思想": "资源回收，重置状态",
                "适用场景": "需要清空集合内容或释放资源时。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG003",
            "name": "求集合长度",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "返回集合中当前元素的数量。",
                "时间复杂度": "顺序存储 O(1)，链式存储 O(n)。",
                "空间复杂度": "O(1)",
                "设计思想": "计数或读取长度属性",
                "适用场景": "查询集合的大小。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG004",
            "name": "判断集合为空",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "检查集合中是否包含任何元素。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "检查长度或头指针",
                "适用场景": "在进行插入、删除等操作前或作为逻辑判断条件。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG005",
            "name": "判断元素是否属于集合",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "检查给定元素是否存在于集合中。通常需要遍历集合进行查找。",
                "时间复杂度": "O(n) (对于无序存储)",
                "空间复杂度": "O(1)",
                "设计思想": "顺序查找",
                "适用场景": "验证元素的成员资格，集合插入操作前的检查。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG006",
            "name": "输出集合元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "遍历集合并按任意顺序（取决于存储）输出所有元素。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "遍历",
                "适用场景": "显示集合内容。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG007",
            "name": "查找集合元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "在集合中查找与给定关键字匹配的元素，若找到则返回该元素的完整信息。",
                "时间复杂度": "O(n) (对于无序存储)",
                "空间复杂度": "O(1)",
                "设计思想": "顺序查找",
                "适用场景": "根据关键字获取集合中元素的详细数据。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG008",
            "name": "修改集合元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "在集合中查找与给定关键字匹配的元素，若找到则用提供的新值更新该元素。",
                "时间复杂度": "O(n) (对于无序存储)",
                "空间复杂度": "O(1)",
                "设计思想": "查找与更新",
                "适用场景": "更新集合中已存在元素的信息。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG009",
            "name": "向集合插入元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "将一个元素添加到集合中。首先检查元素是否已存在，若不存在则添加。顺序存储可能需检查空间并扩容，通常添加到末尾；链式存储通常添加到表头。",
                "时间复杂度": "O(n) (查找开销)",
                "空间复杂度": "O(1) (不计可能的扩容)",
                "设计思想": "查找与添加",
                "适用场景": "向集合增加新元素，保持元素唯一性。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG010",
            "name": "从集合删除元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "在集合中查找给定元素，若找到则将其移除。顺序存储通常用末尾元素填补空位；链式存储需修改前驱结点的指针。可能涉及动态空间的收缩。",
                "时间复杂度": "O(n) (查找开销)",
                "空间复杂度": "O(1)",
                "设计思想": "查找与移除",
                "适用场景": "从集合中移除指定元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG011",
            "name": "求集合并集",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "计算两个集合S1和S2的并集，结果包含所有出现在S1或S2中的元素（唯一）。实现方法：将S1复制到结果集S，然后遍历S2，将S2中不在S中的元素插入S。",
                "时间复杂度": "O(n*m) (基于简单查找和插入)",
                "空间复杂度": "O(n+m) (存储结果集)",
                "设计思想": "集合论运算，遍历与条件插入",
                "适用场景": "合并两个集合的所有不重复元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG012",
            "name": "求集合交集",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "计算两个集合S1和S2的交集，结果包含所有同时出现在S1和S2中的元素。实现方法：遍历S2（或S1），检查每个元素是否存在于S1（或S2）中，若存在则加入结果集。",
                "时间复杂度": "O(n*m) (基于简单查找)",
                "空间复杂度": "O(min(n,m)) (存储结果集)",
                "设计思想": "集合论运算，遍历与查找",
                "适用场景": "找出两个集合共有的元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG013",
            "name": "求集合差集",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "计算两个集合S1和S2的差集 (S1 - S2)，结果包含所有属于S1但不属于S2的元素。实现方法：遍历S1，检查每个元素是否不存在于S2中，若不存在则加入结果集。",
                "时间复杂度": "O(n*m) (基于简单查找)",
                "空间复杂度": "O(n) (存储结果集)",
                "设计思想": "集合论运算，遍历与查找",
                "适用场景": "找出只存在于第一个集合而不存在于第二个集合的元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG015",
            "name": "稀疏矩阵初始化",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空的稀疏矩阵表示。将行数、列数、非零元素个数置为0。对于链式存储，还需初始化指针向量。",
                "时间复杂度": "O(1) 或 O(MaxRows+MaxCols) 取决于存储结构初始化需求。",
                "空间复杂度": "O(1)",
                "设计思想": "基本初始化",
                "适用场景": "创建新的稀疏矩阵实例。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG016",
            "name": "稀疏矩阵转置",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "计算稀疏矩阵的转置矩阵。将原矩阵M的(i, j)处的非零元素放到转置矩阵S的(j, i)处。普通方法逐列扫描原矩阵构建转置矩阵。",
                "时间复杂度": "普通转置O(列数 * 非零元数)",
                "空间复杂度": "O(非零元数) (存储转置结果)",
                "设计思想": "矩阵运算，行列互换",
                "适用场景": "需要获得矩阵转置形式时。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG017",
            "name": "快速转置",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "一种优化的稀疏矩阵转置算法。通过两次扫描三元组表：第一次统计原矩阵每列的非零元个数，计算转置后每行第一个元素在目标数组中的位置；第二次扫描将元素直接放到计算好的位置。",
                "时间复杂度": "O(列数 + 非零元数)",
                "空间复杂度": "O(列数 + 非零元数) (结果存储+辅助数组)",
                "设计思想": "空间换时间，预计算位置",
                "适用场景": "高效计算稀疏矩阵转置，尤其当非零元较多时。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG018",
            "name": "稀疏矩阵加法",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "计算两个维度相同的稀疏矩阵M1和M2的和。按行（或其他顺序）遍历两个矩阵的非零元素，对相同位置的非零元素值相加，只存储和不为零的结果元素。",
                "时间复杂度": "O(t1 + t2) (t1, t2为两个矩阵的非零元数)",
                "空间复杂度": "O(t1 + t2) (最坏情况，结果矩阵存储)",
                "设计思想": "矩阵运算，同步遍历或合并",
                "适用场景": "对稀疏矩阵进行加法运算。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG019",
            "name": "稀疏矩阵乘法",
            "type": "算法",
            "attributes": {
                "难度": "高级",
                "内容": "计算两个稀疏矩阵M1(m*n)和M2(n*p)的乘积M(m*p)。需要高效地找到M1第i行和M2第j列对应的非零元素对并进行乘积累加，计算M的每个非零元素M[i][j]。",
                "时间复杂度": "依赖具体实现和矩阵结构，通常优于稠密矩阵乘法。",
                "空间复杂度": "O(t_result) (结果矩阵存储)",
                "设计思想": "矩阵运算，优化查找和累加",
                "适用场景": "对稀疏矩阵进行乘法运算。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG020",
            "name": "稀疏矩阵输入",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "根据用户输入的行数、列数以及一系列非零元素的三元组（行号、列号、值），构建稀疏矩阵的内部存储结构（如顺序三元组表、十字链表等）。",
                "时间复杂度": "O(t) (t为非零元数，假设输入和单次插入为O(1))",
                "空间复杂度": "O(t) 或 O(MaxTerms) (存储结构)",
                "设计思想": "数据读取与结构构建",
                "适用场景": "从外部源创建稀疏矩阵实例。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG021",
            "name": "稀疏矩阵输出",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "将稀疏矩阵的内部存储表示转换为可读格式（通常是三元组列表）并输出。",
                "时间复杂度": "O(t) (t为非零元数)",
                "空间复杂度": "O(1)",
                "设计思想": "遍历与格式化输出",
                "适用场景": "展示稀疏矩阵的内容。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG022",
            "name": "求广义表长度",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "计算广义表顶层元素的个数。遍历顶层结点的next指针链即可。",
                "时间复杂度": "O(n) (n为顶层元素个数)",
                "空间复杂度": "O(n) (递归实现) 或 O(1) (迭代实现)",
                "设计思想": "遍历顶层链表",
                "适用场景": "获取广义表第一层的元素数量。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG023",
            "name": "求广义表深度",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "计算广义表中括号嵌套的最大层数。递归定义：深度 = 1 + max(所有子表深度)，空表或原子表深度为1。通过递归遍历实现。",
                "时间复杂度": "O(N) (N为广义表中结点总数)",
                "空间复杂度": "O(m) (m为广义表深度，递归栈深度)",
                "设计思想": "递归遍历，深度优先",
                "适用场景": "衡量广义表的嵌套复杂度。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG024",
            "name": "创建广义表",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "根据特定格式的输入字符串（如包含括号、逗号、原子元素）递归地构建广义表的链式存储结构。",
                "时间复杂度": "O(N) (N为输入长度或结点数)",
                "空间复杂度": "O(N) (存储结构和递归栈)",
                "设计思想": "递归下降解析与构建",
                "适用场景": "从文本表示生成内存中的广义表对象。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG025",
            "name": "打印广义表",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "将广义表的链式存储结构递归地转换回其标准的文本表示格式（包含括号、逗号）并输出。",
                "时间复杂度": "O(N) (N为结点总数)",
                "空间复杂度": "O(m) (m为广义表深度，递归栈深度)",
                "设计思想": "递归遍历与格式化输出",
                "适用场景": "以可读形式展示广义表内容。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03ALG026",
            "name": "有序输出集合元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "输出集合中所有元素，并保证输出顺序按元素值的升序排列。通常需要借助辅助空间（如临时数组）和排序算法（如简单选择排序）实现。",
                "时间复杂度": "O(n^2) (若使用简单排序)",
                "空间复杂度": "O(n) (需要临时数组)",
                "设计思想": "复制、排序、输出",
                "适用场景": "需要按特定顺序（如有序）展示集合内容时。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03CON003",
            "name": "三元组",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "由三个相关部分组成的数据单元。在稀疏矩阵上下文中，特指用于表示非零元素的（行号, 列号, 值）组合。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03CON004",
            "name": "单元素",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "广义表中的基本、不可再分的元素，也称为原子。与子表相对。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03CON005",
            "name": "子表",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "广义表中的一个元素，其本身也是一个广义表。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "03CON006",
            "name": "递归",
            "type": "概念",
            "attributes": {
                "难度": "中等",
                "内容": "一种定义或解决问题的方法，其中函数或过程直接或间接调用自身。在数据结构中，指结构（如广义表）的定义包含自身；在算法中，指算法步骤中包含对自身的调用。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04DS001",
            "name": "栈",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "又称堆栈，是一种运算受限的线性表，仅允许在表的一端（栈顶）进行插入（入栈）和删除（出栈）运算。具有后进先出（LIFO）的特性。栈顶是允许操作的一端，另一端为栈底。栈顶元素是栈顶的第一个元素。",
                "存储开销": "顺序存储需要预分配空间（可能浪费或不足），链式存储需要额外指针开销。",
                "核心特性": "后进先出（LIFO）",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04DS002",
            "name": "队列",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "简称队，是一种运算受限的线性表，允许在表的一端（队尾）进行插入（入队），在另一端（队首）进行删除（出队）。具有先进先出（FIFO）的特性。",
                "存储开销": "顺序存储（循环队列）需要预分配空间并可能牺牲一个单元以区分空/满，链式存储需要额外指针开销。",
                "核心特性": "先进先出（FIFO）",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04CON001",
            "name": "栈顶",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "栈允许进行插入和删除操作的一端。栈顶的第一个元素称为栈顶元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04CON002",
            "name": "栈底",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "栈不允许进行插入和删除操作的一端，与栈顶相对。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG001",
            "name": "进栈",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "也称入栈。在栈顶插入一个新元素，使其成为新的栈顶元素。顺序栈实现时需移动栈顶指针并存入元素，链栈实现时需创建新节点并修改头指针。",
                "时间复杂度": "O(1)（顺序栈空间足够或链栈）",
                "空间复杂度": "O(1)",
                "设计思想": "栈的基本操作",
                "适用场景": "向栈中添加数据。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG002",
            "name": "出栈",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "也称退栈。删除栈顶元素，使其下面的相邻元素成为新的栈顶元素。顺序栈实现时移动栈顶指针，链栈实现时修改头指针并释放节点。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "栈的基本操作",
                "适用场景": "从栈中移除并（可选地）获取数据。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04CON003",
            "name": "后进先出",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "Last In First Out (LIFO)。描述栈的操作特性，最后进入栈的元素最先被移出。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG003",
            "name": "读取栈顶元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "查看栈顶元素的值，但不删除它，栈的状态不改变。对应 ADT 中的 Peek 操作。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "栈的访问操作",
                "适用场景": "需要知道栈顶元素但暂时不移除它时。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG004",
            "name": "判断栈空",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "检查栈中是否包含任何元素。对应 ADT 中的 EmptyStack 操作。顺序栈通常检查 top 是否为 -1，链栈检查头指针是否为 NULL。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "栈的状态检查",
                "适用场景": "执行出栈或读取栈顶元素前进行检查，或作为算法终止条件。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG005",
            "name": "清空栈",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "移除栈中所有元素，使其变为空栈。对应 ADT 中的 ClearStack 操作。顺序栈重置 top 指针，链栈需遍历释放所有节点。",
                "时间复杂度": "O(1)（顺序栈），O(n)（链栈）",
                "空间复杂度": "O(1)",
                "设计思想": "栈的重置操作",
                "适用场景": "需要复用栈结构或释放资源时。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG006",
            "name": "初始化栈",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空栈。对应 ADT 中的 InitStack 操作。顺序栈可能分配数组空间并将 top 置为 -1，链栈将头指针置为 NULL。",
                "时间复杂度": "O(1) 或 O(MaxSize)（若涉及分配）",
                "空间复杂度": "O(MaxSize)（顺序栈预分配）或 O(1)（链栈）",
                "设计思想": "栈的创建操作",
                "适用场景": "开始使用栈之前。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04DS004",
            "name": "顺序栈",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "使用数组（顺序存储结构）实现的栈。通过数组下标（栈顶指针 top）来管理栈顶。存在栈满的可能。",
                "存储开销": "固定大小数组，可能空间浪费或不足。需要一个额外的整型变量存储 top。",
                "核心特性": "顺序存储，随机访问（理论上，但栈操作只访问栈顶），可能有容量限制。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04DS005",
            "name": "链栈",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "使用链表（链接存储结构）实现的栈。通常用单链表实现，表头作为栈顶。插入和删除操作在链表头部进行。",
                "存储开销": "每个元素需要额外空间存储指针。动态分配，按需使用空间。",
                "核心特性": "链式存储，动态大小，无栈满问题（理论上受内存限制）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG018",
            "name": "括号配对检查",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "利用栈检查表达式（如 C/C++ 代码）中的括号（圆括号、方括号、大括号）是否正确配对。遇到左括号入栈，遇到右括号检查栈顶是否匹配，匹配则出栈，不匹配则错误。扫描结束时栈应为空。",
                "时间复杂度": "O(n)，n 为表达式长度",
                "空间复杂度": "O(n)，最坏情况所有左括号入栈",
                "设计思想": "利用栈的 LIFO 特性匹配最近的未闭合括号",
                "适用场景": "编译器语法分析、代码编辑器语法高亮/检查。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG019",
            "name": "进制转换",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "将一个十进制整数转换为其他进制（如二至九进制）的表示。利用“除基取余法”，将每次得到的余数入栈，转换完成后依次出栈即可得到正确顺序的转换结果。",
                "时间复杂度": "O(log_r n)，n 为待转换数，r 为目标进制基数",
                "空间复杂度": "O(log_r n)，存储余数",
                "设计思想": "利用栈的 LIFO 特性逆转余数产生的顺序",
                "适用场景": "数值表示转换。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04CON004",
            "name": "中缀表达式",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "运算符位于其操作数之间的算术表达式表示法。如 `a + b`。计算时需要考虑运算符优先级和括号。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04CON005",
            "name": "后缀表达式",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "也称逆波兰式。运算符位于其操作数之后的算术表达式表示法。如 `a b +`。计算时无需考虑优先级和括号，只需从左到右扫描，遇到操作数入栈，遇到运算符则弹出所需操作数计算并将结果入栈。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG007",
            "name": "后缀表达式求值",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "计算后缀表达式的值。使用一个栈存储操作数。从左到右扫描表达式，遇到操作数压入栈，遇到运算符弹出相应数量的操作数进行计算，并将结果压回栈。表达式扫描完毕后，栈中唯一的值即为结果。",
                "时间复杂度": "O(n)，n 为表达式长度",
                "空间复杂度": "O(n)，最坏情况存储所有操作数",
                "设计思想": "利用栈处理运算顺序",
                "适用场景": "计算器、编译器中间代码执行。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG008",
            "name": "中缀转后缀",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "将中缀表达式转换为等价的后缀表达式。使用一个栈存储运算符。扫描中缀表达式，遇到操作数直接输出；遇到运算符，与栈顶运算符比较优先级，若当前运算符优先级低或等于栈顶（且栈顶非左括号），则弹出栈顶运算符输出，重复此过程直到栈顶优先级低或栈空，再将当前运算符入栈；遇到左括号入栈；遇到右括号，弹出栈中运算符直至遇到左括号。",
                "时间复杂度": "O(n)，n 为表达式长度",
                "空间复杂度": "O(n)，最坏情况存储所有运算符",
                "设计思想": "利用栈管理运算符优先级和括号",
                "适用场景": "编译器语法分析、表达式求值预处理。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG009",
            "name": "递归阶乘",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "使用递归方法计算非负整数 n 的阶乘。定义 f(n) = n * f(n-1)，基本情况 f(0) = 1。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(n)（递归栈深度）",
                "设计思想": "递归",
                "适用场景": "教学示例，理解递归概念。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG010",
            "name": "递归迷宫求解",
            "type": "算法",
            "attributes": {
                "难度": "高级",
                "内容": "使用递归（深度优先搜索）寻找迷宫中从入口到出口的路径。从当前位置尝试向四周（如东、南、西、北）未访问过的可通行方格移动，并递归调用自身。若递归调用返回成功，则当前路径有效；若所有方向尝试失败，则回溯。",
                "时间复杂度": "O(m*n)，m, n 为迷宫尺寸（最坏情况访问所有格子）",
                "空间复杂度": "O(m*n)（递归栈深度，最坏情况路径覆盖所有格子）",
                "设计思想": "递归、回溯、深度优先搜索",
                "适用场景": "路径查找问题。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "探索与回溯，体现解决复杂问题的策略性思考。"
            }
        },
        {
            "ID": "04ALG011",
            "name": "递归汉诺塔",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "使用递归解决汉诺塔问题。将 n 个盘子从 A 移动到 C（借助 B）分解为：1. 将 n-1 个盘子从 A 移动到 B（借助 C）；2. 将第 n 个盘子从 A 移动到 C；3. 将 n-1 个盘子从 B 移动到 C（借助 A）。基本情况是 n=1 时直接移动。",
                "时间复杂度": "O(2^n)",
                "空间复杂度": "O(n)（递归栈深度）",
                "设计思想": "递归、分治",
                "适用场景": "教学示例，理解递归和分治思想。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "化繁为简，体现解决复杂问题的分解思想。"
            }
        },
        {
            "ID": "04CON007",
            "name": "队尾",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "队列允许插入元素的一端。新元素入队后成为新的队尾元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04CON008",
            "name": "队首",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "队列允许删除元素的一端。元素出队后，其后继元素成为新的队首元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG012",
            "name": "进队",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "也称入队。在队尾插入一个新元素。循环队列实现时需移动队尾指针（考虑取模），链队实现时需修改尾指针并可能修改头指针（若原队列为空）。",
                "时间复杂度": "O(1)（循环队列空间足够或链队）",
                "空间复杂度": "O(1)",
                "设计思想": "队列的基本操作",
                "适用场景": "向队列中添加数据。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG013",
            "name": "出队",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "也称离队。删除队首元素。循环队列实现时移动队首指针（考虑取模），链队实现时修改头指针并释放节点，可能修改尾指针（若删除后队列为空）。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "队列的基本操作",
                "适用场景": "从队列中移除并（可选地）获取数据。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04CON009",
            "name": "先进先出",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "First In First Out (FIFO)。描述队列的操作特性，最先进入队列的元素最先被移出。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "公平排队原则的体现。"
            }
        },
        {
            "ID": "04ALG014",
            "name": "读取队首元素",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "查看队首元素的值，但不删除它，队列的状态不改变。对应 ADT 中的 PeekQueue 操作。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "队列的访问操作",
                "适用场景": "需要知道下一个将要处理的元素但暂时不处理它时。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG015",
            "name": "判断队空",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "检查队列中是否包含任何元素。对应 ADT 中的 EmptyQueue 操作。循环队列比较 front 和 rear 指针，链队检查头指针是否为 NULL。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "队列的状态检查",
                "适用场景": "执行出队或读取队首元素前进行检查，或作为算法终止条件。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG016",
            "name": "清空队列",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "移除队列中所有元素，使其变为空队。对应 ADT 中的 ClearQueue 操作。循环队列重置 front 和 rear 指针，链队需遍历释放所有节点。",
                "时间复杂度": "O(1)（循环队列），O(n)（链队）",
                "空间复杂度": "O(1)",
                "设计思想": "队列的重置操作",
                "适用场景": "需要复用队列结构或释放资源时。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04ALG017",
            "name": "初始化队列",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空队列。对应 ADT 中的 InitQueue 操作。循环队列可能分配数组空间并将 front 和 rear 置为相同值，链队将头尾指针置为 NULL。",
                "时间复杂度": "O(1) 或 O(MaxSize)（若涉及分配）",
                "空间复杂度": "O(MaxSize)（循环队列预分配）或 O(1)（链队）",
                "设计思想": "队列的创建操作",
                "适用场景": "开始使用队列之前。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04DS006",
            "name": "顺序队列",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "使用数组（顺序存储结构）实现的队列。通常实现为循环队列，利用取模运算处理边界，解决“假溢出”问题。需要队首(front)和队尾(rear)两个指针。",
                "存储开销": "固定大小数组，为区分队空和队满可能牺牲一个存储单元或使用额外计数变量。需要两个整型变量存储 front 和 rear。",
                "核心特性": "顺序存储，循环利用空间，可能有容量限制。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "循环利用资源的思想。"
            }
        },
        {
            "ID": "04DS007",
            "name": "链队",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "使用链表（链接存储结构）实现的队列。需要队首(front)和队尾(rear)两个指针，分别指向链表的头结点和尾结点。入队在链表尾部进行，出队在链表头部进行。",
                "存储开销": "每个元素需要额外空间存储指针。动态分配，按需使用空间。",
                "核心特性": "链式存储，动态大小，无队列满问题（理论上受内存限制）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "04DS008",
            "name": "优先级队列",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "一种特殊的队列，其中每个元素关联一个优先级。出队操作总是移除优先级最高的元素。入队操作可能需要调整结构以维持优先级顺序。常用于调度。",
                "存储开销": "取决于具体实现（如堆）。",
                "核心特性": "按优先级出队，而非 FIFO。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "区分重要性，优先处理关键任务的策略。"
            }
        },
        {
            "ID": "04ALG020",
            "name": "渡口管理模拟",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "模拟轮船渡口车辆管理。使用两个队列分别管理客车和货车，根据特定规则（如客车优先、按比例上船）安排车辆上渡轮。",
                "时间复杂度": "与车辆到达和渡轮调度次数相关",
                "空间复杂度": "O(N)，N 为等待车辆总数",
                "设计思想": "队列应用，模拟",
                "适用场景": "模拟排队系统、资源调度。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "模拟现实场景，体现公平与效率的结合。"
            }
        },
        {
            "ID": "05DS001",
            "name": "树",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "一种重要的非线性数据结构，由n(n>=0)个结点组成。n=0时为空树；n>0时有且仅有一个称为根的结点，其余结点分为m(m>=0)棵互不相交的子树，每棵子树也是一棵树。树的定义是递归的。",
                "存储开销": "依赖具体实现，如顺序存储或链接存储",
                "核心特性": "层次结构, 递归定义",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON001",
            "name": "根",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "非空树中有且仅有的一个没有前驱的结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON002",
            "name": "子树",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "非空树中，根结点以外的结点被分为m(m>=0)棵互不相交的集合，每个集合本身也是一棵树，称为根的子树。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON005",
            "name": "度",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "结点的度是指结点拥有的子树数或后继结点数。树的度是指树中所有结点的度的最大值。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON006",
            "name": "叶子结点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "度等于0的结点，也称终端结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON007",
            "name": "分支结点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "度大于0的结点，也称非终端结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON008",
            "name": "孩子结点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "一个结点的子树的根，或该结点的后继，被称为该结点的孩子（或子女、儿子）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON009",
            "name": "双亲结点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "孩子结点的直接前驱结点，被称为孩子结点的双亲（或父亲、父母）。根结点没有双亲。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON010",
            "name": "兄弟结点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "具有同一双亲的孩子结点互称兄弟。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON011",
            "name": "子孙",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "一个结点的所有子树中的结点被称为该结点的子孙。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON012",
            "name": "祖先",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "从树根结点到达该结点的路径上经过的所有结点被称为该结点的祖先。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON013",
            "name": "层数",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "结点的层数从树根开始定义，根结点为第1层，它的孩子结点为第2层，以此类推。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON014",
            "name": "深度",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "树中所有结点的最大层数，也称高度。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON015",
            "name": "有序树",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "若树中各结点的子树是按照一定的次序从左向右安排的，则称之为有序树。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON016",
            "name": "无序树",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "若树中各结点的子树没有固定的次序，则称之为无序树。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON017",
            "name": "森林",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "m(m>=0)棵互不相交的树的集合。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05DS002",
            "name": "k叉树",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "度为k的树，即每个结点最多有k个孩子。性质包括：结点数等于所有结点的度数加1；第i层至多有k^(i-1)个结点；深度为h的k叉树至多有(k^h-1)/(k-1)个结点；n个结点的k叉树最小深度为ceil(log_k(n(k-1)+1))。",
                "存储开销": "顺序存储适合满k叉树或完全k叉树，链接存储（标准方式、广义标准方式）",
                "核心特性": "度不超过k",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05DS003",
            "name": "二叉树",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "度为2的有序树。递归定义：空树或由一个根结点和两棵互不相交的左、右子树组成，左右子树也是二叉树。性质包括：终端结点数等于双分支结点数加1；第i层至多有2^(i-1)个结点；深度为h的二叉树至多有2^h-1个结点。",
                "存储开销": "顺序存储（适合完全二叉树）、链接存储（二叉链表，可带双亲指针）",
                "核心特性": "度<=2, 有序（区分左右子树）",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON018",
            "name": "左子树",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树根结点的左边的子树。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON019",
            "name": "右子树",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树根结点的右边的子树。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON020",
            "name": "左孩子",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树中一个结点的左子树的根结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON021",
            "name": "右孩子",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树中一个结点的右子树的根结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05DS004",
            "name": "满二叉树",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "深度为h且含有2^h-1个结点的二叉树。树中的每一层都达到最大结点数。",
                "存储开销": "非常适合顺序存储",
                "核心特性": "除叶子结点外，每个结点的度都为2",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05DS005",
            "name": "完全二叉树",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "深度为h，除第h层外，其他各层(1~h-1)的结点数都达到最大个数，第h层的所有结点都连续集中在最左边。性质涉及结点编号与孩子/双亲关系。",
                "存储开销": "非常适合顺序存储",
                "核心特性": "按层序编号连续，结构接近满二叉树",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05CON022",
            "name": "二叉树抽象数据类型",
            "type": "概念",
            "attributes": {
                "难度": "中等",
                "内容": "定义了二叉树的数据集合及其上的操作集合。操作通常包括初始化、创建、判空、遍历（前序、中序、后序、层序）、查找、求深度、打印、清除等。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05DS006",
            "name": "二叉树顺序存储结构",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "使用一维数组按层序编号存储二叉树结点。下标i的结点的左孩子为2i，右孩子为2i+1，双亲为floor(i/2)。适合完全二叉树，对一般二叉树可能浪费大量空间。",
                "存储开销": "O(2^depth)，对非完全二叉树可能很高",
                "核心特性": "随机访问父子结点（通过下标计算），空间效率依赖树形态",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05DS007",
            "name": "二叉树链接存储结构",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "每个结点包含数据域、指向左孩子的指针域和指向右孩子的指针域（二叉链表）。可以增加指向双亲结点的指针域（带双亲指针的二叉链表）。",
                "存储开销": "O(n)，n为结点数",
                "核心特性": "动态存储，空间效率较高，插入删除方便",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG001",
            "name": "前序遍历",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树遍历方法：访问根结点 -> 递归遍历左子树 -> 递归遍历右子树。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 分治",
                "适用场景": "复制树、表达式树求前缀表达式",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG002",
            "name": "中序遍历",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树遍历方法：递归遍历左子树 -> 访问根结点 -> 递归遍历右子树。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 分治",
                "适用场景": "对二叉搜索树得到有序序列",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG003",
            "name": "后序遍历",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树遍历方法：递归遍历左子树 -> 递归遍历右子树 -> 访问根结点。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 分治",
                "适用场景": "计算表达式树的值、释放树结点空间",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG004",
            "name": "按层遍历",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "二叉树遍历方法：从上到下、同一层从左到右访问结点。通常使用队列实现。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(w)",
                "设计思想": "迭代, 队列",
                "适用场景": "求树的宽度、广度优先搜索",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG005",
            "name": "初始化二叉树",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "将二叉树设置为空树，通常是将根指针置为NULL。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "基本操作",
                "适用场景": "创建新二叉树前",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG006",
            "name": "建立二叉树",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "根据特定输入格式（如广义表表示）构建二叉树的链接存储结构。文本描述了使用栈辅助从广义表字符串创建的方法。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "迭代, 栈辅助",
                "适用场景": "从字符串或序列表示构造内存中的二叉树",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG007",
            "name": "判空二叉树",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "判断二叉树是否为空，通常检查根指针是否为NULL。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "基本检查",
                "适用场景": "操作前检查树状态",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG008",
            "name": "求二叉树深度",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "计算二叉树的最大层数。递归定义：空树深度0，非空树深度 = max(左子树深度, 右子树深度) + 1。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 分治",
                "适用场景": "分析树的高度和平衡性",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG009",
            "name": "查找二叉树结点",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "在二叉树中查找具有特定值的结点。通常采用类似前序遍历的递归方式。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 遍历",
                "适用场景": "定位、访问或修改特定结点",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG010",
            "name": "输出二叉树",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "将二叉树以某种可读形式（如广义表）打印出来。文本描述了基于前序遍历思想的广义表输出算法。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 遍历",
                "适用场景": "可视化、调试",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG011",
            "name": "清除二叉树",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "删除二叉树中的所有结点，释放占用的内存空间。通常采用类似后序遍历的递归方式。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 后序遍历",
                "适用场景": "销毁不再使用的二叉树对象",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05DS008",
            "name": "理想平衡二叉树",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "除最后一层外，其余各层都是满的，而最后一层上的结点可以任意分布的二叉树。包含满二叉树和完全二叉树。具有n个结点的理想平衡二叉树深度为ceil(log2(n+1))或floor(log2(n))+1。",
                "存储开销": "O(n)",
                "核心特性": "高度约为log(n)，相对平衡",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05DS009",
            "name": "树的顺序存储结构",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "对k叉树结点按规则编号（根为1，结点i的孩子为k*i-(k-2)到k*i+1），用一维数组存储。结点j的父结点为floor((j-2)/k)+1。适合满k叉树和完全k叉树，否则浪费空间。",
                "存储开销": "依赖树的度和形态，可能很高",
                "核心特性": "通过下标计算父子关系，空间效率依赖树形态",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05DS010",
            "name": "树的链接存储结构",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "常见方式包括：标准方式（每个结点含数据域和k个指向孩子的指针域）、广义标准方式（标准方式基础上增加指向双亲的指针域）、二叉树方式（孩子兄弟表示法）。",
                "存储开销": "标准方式O(n*k)，孩子兄弟表示法O(n)",
                "核心特性": "动态存储，灵活表示树结构",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05DS011",
            "name": "孩子兄弟表示法",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "将任意树转换为二叉树形式存储。每个结点包含数据域、指向第一个孩子的指针（作二叉树的左孩子指针）和指向下一个兄弟的指针（作二叉树的右孩子指针）。",
                "存储开销": "O(n)",
                "核心特性": "用二叉链表存储任意树，空间效率高",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG012",
            "name": "树的先根遍历",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "普通树遍历方法：先访问根结点，然后从左到右依次递归先根遍历每棵子树。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 分治",
                "适用场景": "获取树的某种线性序列",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG013",
            "name": "树的后根遍历",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "普通树遍历方法：从左到右依次递归后根遍历根结点的每棵子树，然后再访问根结点。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 分治",
                "适用场景": "计算依赖子树结果的操作（如计算树的结点数）",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG014",
            "name": "树的按层遍历",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "普通树遍历方法：按层访问，先访问第1层（根），再从左到右访问第2层，依次进行。通常使用队列实现。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(w)",
                "设计思想": "迭代, 队列",
                "适用场景": "广度优先搜索",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG015",
            "name": "建立树",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "根据广义表表示建立k叉树的标准链接存储结构。算法使用两个栈，一个存结点指针，一个存孩子序号。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "迭代, 栈辅助",
                "适用场景": "从字符串表示构造内存中的k叉树",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG016",
            "name": "查找树结点",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "在k叉树中查找具有特定值的结点。采用类似先根遍历的递归方式。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 遍历",
                "适用场景": "定位、访问或修改特定结点",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG017",
            "name": "输出树",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "以广义表形式输出按标准链接方式存储的k叉树。采用类似先根遍历的递归方式。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 遍历",
                "适用场景": "可视化、调试",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG018",
            "name": "求树深度",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "计算k叉树的最大层数。递归定义：空树深度0，非空树深度 = max(所有子树深度) + 1。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 分治",
                "适用场景": "分析树的高度",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "05ALG019",
            "name": "清除树",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "删除k叉树中的所有结点，释放占用的内存空间。采用类似后根遍历的递归方式。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归, 后根遍历",
                "适用场景": "销毁不再使用的k叉树对象",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06DS001",
            "name": "二叉搜索树",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "又称二叉排序树，它或是一棵空树，或者是一棵具有如下特性的非空二叉树：（1）若它的左子树非空，则左子树上所有结点的关键字均小于根结点的关键字。（2）若它的右子树非空，则右子树上所有结点的关键字均大于（或大于等于）根结点的关键字。（3）左、右子树本身又各是一棵二叉搜索树。中序遍历结果为有序序列。适用于需要高效查找、插入、删除的有序数据集。",
                "存储开销": "链式存储O(n)",
                "核心特性": "有序性，左<根<右",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG001",
            "name": "二叉搜索树查找",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "从根结点开始，若查找值等于当前结点值，则成功；若小于，则在左子树中查找；若大于，则在右子树中查找。直到找到或子树为空（失败）。有递归和非递归实现。",
                "时间复杂度": "平均O(logn)，最坏O(n)",
                "空间复杂度": "递归平均O(logn)/最坏O(n)，非递归O(1)",
                "设计思想": "比较、递归/迭代",
                "适用场景": "在二叉搜索树中定位特定关键字的结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG002",
            "name": "二叉搜索树更新",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "算法与查找类似，首先在二叉搜索树中查找目标元素，若查找成功，则用新值更新该结点的值。",
                "时间复杂度": "平均O(logn)，最坏O(n)",
                "空间复杂度": "递归平均O(logn)/最坏O(n)，非递归O(1)",
                "设计思想": "查找与修改",
                "适用场景": "修改二叉搜索树中已存在结点的值。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG003",
            "name": "二叉搜索树插入",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "从根结点开始查找插入位置，若插入值小于当前结点，则向左子树查找；若大于等于，则向右子树查找，直到找到一个空位置插入新结点。有递归和非递归实现。",
                "时间复杂度": "平均O(logn)，最坏O(n)",
                "空间复杂度": "递归平均O(logn)/最坏O(n)，非递归O(1)",
                "设计思想": "比较、递归/迭代",
                "适用场景": "向二叉搜索树中添加新元素并保持其性质。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG004",
            "name": "二叉搜索树删除",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "首先查找要删除的结点。分三种情况处理：(1) 删除叶子结点：直接删除。(2) 删除单支结点：用其子结点替换。(3) 删除双支结点：用其中序前驱（或后继）替换该结点，然后删除中序前驱（或后继）结点。",
                "时间复杂度": "平均O(logn)，最坏O(n)",
                "空间复杂度": "递归平均O(logn)/最坏O(n)，非递归O(1)",
                "设计思想": "分类讨论、递归/迭代、替换",
                "适用场景": "从二叉搜索树中移除元素并保持其性质。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG005",
            "name": "创建二叉搜索树",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "初始化一个空树，然后遍历输入元素（如数组），对每个元素调用二叉搜索树插入算法，将其插入到树中。",
                "时间复杂度": "一般O(nlogn)，最坏O(n^2)",
                "空间复杂度": "O(n)（存储树结点）",
                "设计思想": "迭代调用插入操作",
                "适用场景": "根据一组初始值构建一棵二叉搜索树。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06CON002",
            "name": "中序遍历",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树的一种遍历方式，顺序为：访问左子树 -> 访问根结点 -> 访问右子树。对二叉搜索树进行中序遍历会得到一个按关键字排序的结点序列。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06CON007",
            "name": "中序前驱",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在一个结点的中序遍历序列中，紧邻它之前的那个结点。在二叉搜索树中，是其左子树中关键字最大的结点。用于双支结点的删除操作和线索化。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06DS002",
            "name": "堆",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "一种特殊的完全二叉树，满足堆属性：父结点的关键字总是大于等于（大根堆）或小于等于（小根堆）其子结点的关键字。常用于实现优先级队列和堆排序。",
                "存储开销": "顺序存储O(n)",
                "核心特性": "完全二叉树结构，堆序性（父子关系）",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06DS003",
            "name": "小根堆",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "堆的一种，其中每个父结点的值都小于或等于其子结点的值。因此，堆顶元素（根结点）是整个堆中的最小值。",
                "存储开销": "顺序存储O(n)",
                "核心特性": "父结点 <= 子结点，完全二叉树",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06DS004",
            "name": "大根堆",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "堆的一种，其中每个父结点的值都大于或等于其子结点的值。因此，堆顶元素（根结点）是整个堆中的最大值。",
                "存储开销": "顺序存储O(n)",
                "核心特性": "父结点 >= 子结点，完全二叉树",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06CON008",
            "name": "完全二叉树",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "一棵深度为k，具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为完全二叉树。性质是除了最后一层，其他层都是满的，且最后一层的结点都连续集中在最左边。适合用顺序存储结构表示。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG006",
            "name": "堆初始化",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "为堆分配存储空间（通常是数组），并将堆的当前大小（长度）设置为0，表示一个空堆。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(MaxSize) 或 O(1)（取决于是否包含分配空间）",
                "设计思想": "内存分配与状态设置",
                "适用场景": "在使用堆之前创建和准备堆结构。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG007",
            "name": "堆清除",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "释放堆所占用的存储空间，并将相关状态（如长度、最大容量）重置，使其变回空堆或无效状态。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "内存释放与状态重置",
                "适用场景": "当不再需要堆时，回收其资源。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG008",
            "name": "堆判空",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "检查堆的当前长度是否为0。如果是，则堆为空；否则，堆不为空。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "状态检查",
                "适用场景": "在执行插入、删除等操作前判断堆的状态。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG009",
            "name": "堆插入",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "将新元素添加到堆的末尾（保持完全二叉树结构），然后通过与其父结点比较并交换（向上调整或sift-up），直到满足堆属性或到达根结点。",
                "时间复杂度": "O(logn)",
                "空间复杂度": "O(1)",
                "设计思想": "向上调整（sift-up）",
                "适用场景": "向堆中添加一个新元素并维持堆的性质。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG010",
            "name": "堆删除",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "通常指删除堆顶元素（最大或最小值）。将堆顶元素与堆底元素交换，然后移除堆底元素（缩小堆的大小）。将新的堆顶元素通过与其子结点比较并交换（向下调整或sift-down），直到满足堆属性或到达叶子结点。",
                "时间复杂度": "O(logn)",
                "空间复杂度": "O(1)",
                "设计思想": "向下调整（sift-down）",
                "适用场景": "从堆中获取并移除具有最高（或最低）优先级的元素。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06DS006",
            "name": "哈夫曼树",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "又称最优二叉树，是n个带权叶子结点构成的所有二叉树中带权路径长度（WPL）最小的二叉树。构造算法基于贪心策略。常用于哈夫曼编码。",
                "存储开销": "链式存储O(n)",
                "核心特性": "带权路径长度最小，无度为1的结点",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06CON009",
            "name": "路径",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在树结构中，从一个结点到另一个结点所经过的结点序列。树中任意两个结点之间存在唯一路径。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06CON011",
            "name": "结点的权",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "赋予树中结点的一个数值，通常表示某种度量或重要性，如字符出现的频率。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06CON013",
            "name": "树的带权路径长度",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "树中所有叶子结点的带权路径长度之和，记作WPL (Weighted Path Length)。哈夫曼树旨在最小化WPL。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG011",
            "name": "构造哈夫曼树",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "基于贪心算法：(1) 初始化n棵只有一个带权根结点的树组成的森林。(2) 重复n-1次：选取森林中权值最小的两棵树合并成一棵新树，新树权值为两者之和，并将新树放回森林，移除原来的两棵树。(3) 直到森林只剩一棵树，即为哈夫曼树。",
                "时间复杂度": "O(nlogn)（使用优先队列优化选择最小权值过程）",
                "空间复杂度": "O(n)",
                "设计思想": "贪心",
                "适用场景": "构建最优二叉树，用于数据压缩（哈夫曼编码）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG012",
            "name": "计算带权路径长度",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "递归计算哈夫曼树的WPL。对于叶子结点，返回其权值乘以其深度；对于非叶子结点，返回其左子树WPL与右子树WPL之和。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(H)，H为树高",
                "设计思想": "递归",
                "适用场景": "计算给定哈夫曼树的WPL值。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG013",
            "name": "哈夫曼编码",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "利用已构造的哈夫曼树为字符生成最优前缀编码。从根结点开始，约定向左子树走代表0，向右子树走代表1。从根到每个叶子结点的路径所形成的01序列即为该叶子结点代表字符的哈夫曼编码。",
                "时间复杂度": "O(n)（遍历树生成编码）",
                "空间复杂度": "O(H)，H为树高",
                "设计思想": "树遍历",
                "适用场景": "无损数据压缩，根据字符频率生成高效编码。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06CON016",
            "name": "前缀编码",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "一种编码方案，其中没有任何一个码字是另一个码字的前缀。这保证了编码序列可以被唯一地解码，不会产生歧义。哈夫曼编码是一种最优前缀编码。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06DS007",
            "name": "编码二叉树",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "一种用于表示字符编码方案的二叉树。通常，从根到叶子结点的路径表示一个字符的编码（例如，左分支为0，右分支为1），叶子结点代表被编码的字符。",
                "存储开销": "链式存储O(n)",
                "核心特性": "表示编码与字符的对应关系",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06DS008",
            "name": "线索二叉树",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "利用二叉树中空的左右孩子指针域，存放指向该结点在某种遍历序列（如中序）下的前驱和后继结点的指针（线索）。需要额外的标志位区分指针是孩子还是线索。可以实现高效的非递归遍历和查找前驱/后继。",
                "存储开销": "链式存储O(n)，每个结点增加两个标志位",
                "核心特性": "利用空指针，快速查找前驱/后继",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06CON017",
            "name": "线索",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在线索二叉树中，存储在原本为空的指针域中的、指向结点按某种遍历次序的前驱或后继结点的指针。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06CON021",
            "name": "中序后继",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在一个结点的中序遍历序列中，紧邻它之后的那个结点。在二叉搜索树中，是其右子树中关键字最小的结点。用于线索化和线索遍历。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG014",
            "name": "中序线索化",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "在中序遍历二叉树的过程中，为每个结点的空左指针添加指向其中序前驱的线索，为空右指针添加指向其中序后继的线索，并设置相应的线索标志位。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(H)（递归栈）或 O(1)（非递归）",
                "设计思想": "中序遍历 + 线索链接",
                "适用场景": "将普通二叉树转换为中序线索二叉树。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG015",
            "name": "查找中序后继",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "在中序线索二叉树中查找给定结点的中序后继。若右指针是线索，则直接返回；若右指针是孩子指针，则后继是其右子树中最左下的结点。",
                "时间复杂度": "最坏O(H)，平均O(1)（若大部分为空指针）",
                "空间复杂度": "O(1)",
                "设计思想": "利用线索标志判断路径",
                "适用场景": "在线索二叉树中高效地找到下一个遍历结点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG016",
            "name": "线索中序遍历",
            "type": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "利用中序线索二叉树的线索，实现非递归的中序遍历。首先找到中序序列的第一个结点（最左下结点），然后反复查找当前结点的中序后继并访问，直至遍历完成。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "利用线索指针进行迭代",
                "适用场景": "对线索二叉树进行高效的非递归中序遍历。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG017",
            "name": "带线索标志二叉搜索树插入",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "向带线索标志的二叉搜索树中插入新结点。首先按BST规则找到插入位置，然后插入新结点，并正确设置新结点及其父结点的线索和线索标志。需要区分仅插入结点和插入并链接线索两种情况。",
                "时间复杂度": "平均O(logn)，最坏O(n)",
                "空间复杂度": "O(1)（非递归实现）",
                "设计思想": "BST插入 + 线索维护",
                "适用场景": "构建或动态维护线索二叉搜索树。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG018",
            "name": "创建带线索标志二叉搜索树",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "初始化空树，然后遍历输入元素（如数组），对每个元素调用带线索标志的二叉搜索树插入算法，将元素插入并维护线索结构。",
                "时间复杂度": "一般O(nlogn)，最坏O(n^2)",
                "空间复杂度": "O(n)",
                "设计思想": "迭代调用插入操作（含线索维护）",
                "适用场景": "根据一组初始值构建一棵完整的线索二叉搜索树。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06DS009",
            "name": "平衡二叉树",
            "type": "数据结构",
            "attributes": {
                "难度": "高级",
                "内容": "也称AVL树，是一种自平衡的二叉搜索树。其特性是任何结点的左右两个子树的高度差的绝对值不超过1。通过旋转操作（LL, RR, LR, RL）在插入和删除后维持平衡，保证了操作的时间复杂度为O(logn)。",
                "存储开销": "链式存储O(n)，每个结点增加平衡因子存储",
                "核心特性": "自平衡，左右子树高度差<=1，保持BST性质",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06CON023",
            "name": "平衡因子",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "定义为结点的左子树高度减去右子树高度的值。在平衡二叉树（AVL树）中，每个结点的平衡因子只能是-1, 0, 或 1。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06CON024",
            "name": "最小不平衡子树",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在向AVL树插入或删除结点后，距离插入/删除位置最近的、平衡因子绝对值大于1的结点为根的子树。调整操作通常针对最小不平衡子树进行。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG019",
            "name": "LL型调整",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "当在最小不平衡子树根结点(A)的左孩子(B)的左子树上插入导致不平衡时（A的平衡因子变为2），执行一次右旋转操作。B提升为新的根，A成为B的右孩子，B原来的右子树成为A的左子树。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "右旋转",
                "适用场景": "恢复AVL树因LL型插入导致的不平衡。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG020",
            "name": "RR型调整",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "当在最小不平衡子树根结点(A)的右孩子(B)的右子树上插入导致不平衡时（A的平衡因子变为-2），执行一次左旋转操作。B提升为新的根，A成为B的左孩子，B原来的左子树成为A的右子树。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "左旋转",
                "适用场景": "恢复AVL树因RR型插入导致的不平衡。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG021",
            "name": "LR型调整",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "当在最小不平衡子树根结点(A)的左孩子(B)的右子树(根为C)上插入导致不平衡时（A的平衡因子变为2），执行先左旋转（绕B）再右旋转（绕A）的操作。C提升为新的根，B成为C的左孩子，A成为C的右孩子。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "双旋转（先左后右）",
                "适用场景": "恢复AVL树因LR型插入导致的不平衡。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "06ALG022",
            "name": "RL型调整",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "当在最小不平衡子树根结点(A)的右孩子(B)的左子树(根为C)上插入导致不平衡时（A的平衡因子变为-2），执行先右旋转（绕B）再左旋转（绕A）的操作。C提升为新的根，A成为C的左孩子，B成为C的右孩子。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "双旋转（先右后左）",
                "适用场景": "恢复AVL树因RL型插入导致的不平衡。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "未知"
            }
        },
        {
            "ID": "07DS001",
            "name": "图",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "图(graph)是图型结构的简称，是一种复杂的非线性数据结构，由顶点集V和边集E组成，表示为G=(V,E)。顶点之间的关系是多对多的。",
                "存储开销": "依赖具体存储结构，如邻接矩阵O(n^2)，邻接表O(n+e)",
                "核心特性": "非线性结构，顶点间关系复杂",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "图结构广泛应用于现实世界建模，体现了理论与实践结合的重要性，如交通网络、社交网络等。"
            }
        },
        {
            "ID": "07DS002",
            "name": "有向图",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "边集E(G)中为有向边（序偶）的图。边具有方向性，从起点指向终点。",
                "存储开销": "同图",
                "核心特性": "边有方向",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "有向图能精确表示具有流向或依赖关系的问题，如任务流程、网页链接，培养逻辑思维能力。"
            }
        },
        {
            "ID": "07DS003",
            "name": "无向图",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "边集E(G)中为无向边（无序对）的图。边没有方向性，连接的两个顶点关系是对称的。",
                "存储开销": "同图",
                "核心特性": "边无方向",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "无向图适用于表示对称关系，如朋友关系、物理连接，体现了模型抽象的灵活性。"
            }
        },
        {
            "ID": "07DS004",
            "name": "邻接矩阵",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "使用n阶方阵A表示具有n个顶点的图中顶点之间相邻关系的存储结构。A[i,j]=1(或权值)表示顶点i到j有边，否则为0(或无穷大)。",
                "存储开销": "O(n^2)，n为顶点数",
                "核心特性": "易于判断边是否存在(O(1))，易于计算度(O(n))，空间复杂度高，适合稠密图。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "邻接矩阵直观展示了顶点间的关系，但空间开销大，启示我们在解决问题时要权衡空间与效率。"
            }
        },
        {
            "ID": "07DS005",
            "name": "邻接表",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "对图中每个顶点v建立一个单链表，存储v的所有邻接点（或出边指向的顶点）。所有表头指针存储在一个数组中。",
                "存储开销": "O(n+e)，n为顶点数，e为边数",
                "核心特性": "节省空间，适合稀疏图。查找顶点邻接点方便，但判断边是否存在不如邻接矩阵快。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "邻接表针对稀疏图优化了空间，体现了具体问题具体分析、优化资源使用的思想。"
            }
        },
        {
            "ID": "07DS006",
            "name": "逆邻接表",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "对有向图中每个顶点v建立一个单链表，存储所有指向v的顶点（入边信息）。结构类似邻接表，但存储的是入边信息。",
                "存储开销": "O(n+e)",
                "核心特性": "便于查找顶点的入边和计算入度，是对邻接表的补充。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "逆邻接表的提出是为了解决特定问题（查找入边），启发我们根据需求调整和改进数据结构。"
            }
        },
        {
            "ID": "07DS007",
            "name": "十字邻接表",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "结合邻接表和逆邻接表的思想，用于存储有向图。每个边结点包含起点、终点、权值、指向同起点的下一条出边指针、指向同终点的下一条入边指针。顶点结点包含第一个入边和第一个出边指针。",
                "存储开销": "O(n+e)",
                "核心特性": "方便查找顶点的出边和入边信息。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "十字邻接表整合了多种信息，提高了特定操作的效率，展示了结构设计的集成与优化思想。"
            }
        },
        {
            "ID": "07DS008",
            "name": "边集数组",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "使用一个一维数组存储图中所有边的信息，每个数组元素包含边的起点、终点和权值（若有）。",
                "存储开销": "O(e)，e为边数",
                "核心特性": "结构简单，适合对边进行遍历处理的算法（如Kruskal），不适合基于顶点的操作。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "边集数组关注边的集合，适用于特定算法场景，体现了选择合适数据结构对算法效率的重要性。"
            }
        },
        {
            "ID": "07ALG001",
            "name": "深度优先搜索",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "从初始顶点出发，尽可能深地访问图的分支。访问一个顶点，标记已访问，然后递归访问其未被访问的邻接点，直到当前路径结束，再回溯到上一个顶点，访问其其他未访问的邻接点。",
                "时间复杂度": "邻接矩阵O(n^2)，邻接表O(n+e)",
                "空间复杂度": "O(n)（递归栈或显式栈）",
                "设计思想": "递归、回溯",
                "适用场景": "查找路径、检测环、求解连通分量等。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "深度优先搜索体现了“一往无前”和“回溯反思”的探索策略，在解决复杂问题时，深入探索和适时调整方向同样重要。"
            }
        },
        {
            "ID": "07ALG002",
            "name": "广度优先搜索",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "从初始顶点出发，逐层访问其邻接点。先访问初始点，然后访问其所有未访问的邻接点，再依次访问这些邻接点的未访问邻接点，以此类推。通常需要队列辅助实现。",
                "时间复杂度": "邻接矩阵O(n^2)，邻接表O(n+e)",
                "空间复杂度": "O(n)（队列）",
                "设计思想": "队列、层序遍历",
                "适用场景": "查找最短路径（无权图）、层序遍历等。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "广度优先搜索体现了“稳步推进”、“全面覆盖”的策略，适用于需要按距离或层级处理的问题，培养系统性思维。"
            }
        },
        {
            "ID": "07CON001",
            "name": "顶点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "图的基本组成单元，代表实体或对象。在图中通常用节点表示。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "顶点是构成复杂网络的基础，如同社会中的个体，理解基本单元是掌握整体的关键。"
            }
        },
        {
            "ID": "07CON002",
            "name": "边",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "连接图中两个顶点的线段（无向边）或箭头（有向边），代表顶点之间的关系。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "边代表了事物间的联系，网络的力量在于连接，启示我们关注关系和互动的重要性。"
            }
        },
        {
            "ID": "07CON004",
            "name": "无向边",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "没有方向性的边，用无序对(vi, vj)表示，连接的两个顶点地位平等。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "无向边体现了平等和对称的关系，是许多现实网络模型的基础。"
            }
        },
        {
            "ID": "07CON005",
            "name": "端点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "一条边所连接的两个顶点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "理解基本术语是深入学习的基础。"
            }
        },
        {
            "ID": "07CON006",
            "name": "邻接点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在无向图中，若顶点vi和vj之间有边，则称vi和vj互为邻接点。在有向图中，若存在<vi, vj>，则vj是vi的出边邻接点，vi是vj的入边邻接点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "邻接关系是图结构的核心，理解邻接是理解图遍历等操作的基础。"
            }
        },
        {
            "ID": "07CON007",
            "name": "出边",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在有向图中，以顶点v为起点的边。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "区分出边和入边有助于理解有向图中的信息流和依赖关系。"
            }
        },
        {
            "ID": "07CON008",
            "name": "入边",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在有向图中，以顶点v为终点的边。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "区分出边和入边有助于理解有向图中的信息流和依赖关系。"
            }
        },
        {
            "ID": "07CON010",
            "name": "入度",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "有向图中以顶点v为终点的边的数目（入边的数目），记为ID(v)。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "入度反映了节点受影响或被指向的程度，在社交网络分析等领域有重要应用。"
            }
        },
        {
            "ID": "07CON011",
            "name": "出度",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "有向图中以顶点v为起点的边的数目（出边的数目），记为OD(v)。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "出度反映了节点发出信息或影响其他节点的程度。"
            }
        },
        {
            "ID": "07CON012",
            "name": "完全图",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "无向图中任意两个顶点之间都存在边；有向图中任意两个顶点之间都存在方向相反的两条边。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "完全图是一种理想化的连接状态，有助于理解网络连接的上限和密度概念。"
            }
        },
        {
            "ID": "07CON013",
            "name": "稠密图",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "边数接近完全图边数的图，即边数e接近n(n-1)/2（无向）或n(n-1)（有向）。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "稠密和稀疏是相对概念，指导我们根据图的特性选择合适的存储结构和算法。"
            }
        },
        {
            "ID": "07CON014",
            "name": "稀疏图",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "边数远小于完全图边数的图，通常边数e与顶点数n同数量级。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "现实世界中的许多大型网络（如社交网络、互联网）都是稀疏图，针对稀疏图的优化非常重要。"
            }
        },
        {
            "ID": "07CON015",
            "name": "子图",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "设G=(V,E)和G'=(V',E')，若V'是V的子集，E'是E的子集，且E'中的边所关联的顶点均在V'中，则称G'是G的子图。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "子图概念有助于分析复杂网络的局部结构和特性。"
            }
        },
        {
            "ID": "07CON017",
            "name": "回路",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "起点和终点相同的路径，也称为环。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "回路（环）检测是图算法中的一个重要问题，在任务调度、死锁检测等方面有应用。"
            }
        },
        {
            "ID": "07CON018",
            "name": "简单路径",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "路径序列中顶点不重复出现的路径。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "简单路径排除了回路，是许多路径算法的基本研究对象。"
            }
        },
        {
            "ID": "07CON019",
            "name": "简单回路",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "除了起点和终点相同外，其余顶点不重复出现的回路。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "简单回路是构成图结构的基本环状单元。"
            }
        },
        {
            "ID": "07CON020",
            "name": "连通",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在无向图中，若从顶点vi到vj有路径，则称vi和vj是连通的。在有向图中，若从vi到vj有路径，称vi到vj是连通的。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "连通性是衡量网络整体性的重要指标。"
            }
        },
        {
            "ID": "07CON021",
            "name": "连通图",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在无向图中，如果任意两个顶点之间都是连通的，则称该图为连通图。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "连通图保证了网络中任何节点都可以到达其他节点，是许多网络应用的基础。"
            }
        },
        {
            "ID": "07CON022",
            "name": "连通分量",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "无向图的极大连通子图。非连通图由多个连通分量组成。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "连通分量将非连通图分解为独立的子网络，便于分析和处理。"
            }
        },
        {
            "ID": "07CON023",
            "name": "强连通图",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在有向图中，如果对于任意两个顶点vi和vj，都存在从vi到vj的路径和从vj到vi的路径，则称该图为强连通图。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "强连通性是比普通连通性更强的要求，表示网络中任意节点间可以相互到达。"
            }
        },
        {
            "ID": "07CON024",
            "name": "强连通分量",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "有向图的极大强连通子图。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "强连通分量识别有向图中的紧密联系的节点群组，在网络分析中有重要意义。"
            }
        },
        {
            "ID": "07CON025",
            "name": "权",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "图中赋予边的数值，可以表示距离、成本、容量等含义。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "权值使图模型能表示更丰富的现实信息，体现了数学建模的灵活性和实用性。"
            }
        },
        {
            "ID": "07CON026",
            "name": "带权图",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "边上带有权值的图。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "带权图广泛应用于优化问题，如最短路径、最小生成树等，培养解决实际问题的能力。"
            }
        },
        {
            "ID": "07CON027",
            "name": "网",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "带权图的常用称呼。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "同“带权图”。"
            }
        },
        {
            "ID": "07CON028",
            "name": "图的遍历",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "从图中某个顶点出发，按照某种搜索方法访问图中所有顶点一次且仅一次的过程。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "图的遍历是图算法的基础，如同系统地认识一个网络，是后续分析和操作的前提。"
            }
        },
        {
            "ID": "07CON029",
            "name": "图的抽象数据类型",
            "type": "概念",
            "attributes": {
                "难度": "中等",
                "内容": "定义了图的数据集合（顶点和边）以及可施加的操作（如初始化、创建、遍历、查找、求最小生成树、最短路径等）的数学模型。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "抽象数据类型（ADT）是软件工程中的重要思想，将数据表示和实现细节分离，关注逻辑功能，培养抽象思维和模块化设计能力。"
            }
        },
        {
            "ID": "08DS002",
            "name": "生成树",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "连通图的一个子图，包含原图的所有顶点，且边的数量足以连接所有顶点而没有形成回路。包含n个顶点的生成树恰好有n-1条边。",
                "存储开销": "通常使用边集表示，O(n)",
                "核心特性": "连通性、无环性、极小连通子图",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "用最少的资源连接所有节点，体现了效率和优化的思想。"
            }
        },
        {
            "ID": "08DS003",
            "name": "最小生成树",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "对于带权连通图，所有生成树中边权值总和最小的那棵生成树。用于解决网络建设中成本最低的问题。",
                "存储开销": "通常使用边集表示，O(n)",
                "核心特性": "权值和最小、连通性、无环性",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "在满足基本要求的前提下追求成本最小化，体现了经济效益和优化决策。"
            }
        },
        {
            "ID": "08DS004",
            "name": "连通图",
            "type": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "无向图中任意两个顶点之间都存在路径的图。",
                "存储开销": "同图的存储开销",
                "核心特性": "所有顶点可达",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "强调了整体性和系统内各部分的联系。"
            }
        },
        {
            "ID": "08DS008",
            "name": "AOV网",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "顶点活动网（Activity On Vertex network），用顶点表示活动，有向边表示活动间的优先（先后）关系的有向无环图。",
                "存储开销": "通常使用邻接表，O(n+e)",
                "核心特性": "表示活动间的依赖关系，无环",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "模拟工程项目流程，强调了计划、顺序和依赖关系的重要性。"
            }
        },
        {
            "ID": "08DS009",
            "name": "AOE网",
            "type": "数据结构",
            "attributes": {
                "难度": "中等",
                "内容": "边活动网（Activity On Edge network），用有向边表示活动，边权表示活动持续时间，顶点表示事件（活动的开始或结束）的有向无环图。",
                "存储开销": "通常使用邻接表，O(n+e)",
                "核心特性": "表示工程进度、活动持续时间、事件依赖",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "用于工程管理和优化，体现了时间规划和资源调度的重要性。"
            }
        },
        {
            "ID": "08ALG001",
            "name": "普里姆算法",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "从一个顶点开始，逐步扩展生成树，每次选择连接已选顶点集和未选顶点集的最短边，直到包含所有顶点。用于求最小生成树。",
                "时间复杂度": "O(n^2)（使用邻接矩阵）或O(elogn)（使用优先队列和邻接表）",
                "空间复杂度": "O(1)（不计图存储）或O(n)（使用辅助数组）",
                "设计思想": "贪心",
                "适用场景": "稠密图",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "从局部最优（选择当前最短边）出发，最终达到全局最优（最小生成树），体现了贪心策略的应用。"
            }
        },
        {
            "ID": "08ALG002",
            "name": "克鲁斯卡尔算法",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "按边权从小到大依次考察所有边，如果一条边连接的两个顶点不在同一个连通分量中，则加入该边，直到加入n-1条边。用于求最小生成树。",
                "时间复杂度": "O(elog e) 或 O(elogn)（主要取决于排序和并查集操作）",
                "空间复杂度": "O(n+e)（需要存储边和并查集）",
                "设计思想": "贪心",
                "适用场景": "稀疏图",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "从全局角度按权值选择边，通过避免回路来构建最优结构，体现了不同的贪心视角。"
            }
        },
        {
            "ID": "08ALG003",
            "name": "狄克斯特拉算法",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "计算带权有向图中单源最短路径的算法。按路径长度递增的顺序，依次确定源点到各顶点的最短路径。",
                "时间复杂度": "O(n^2)（使用邻接矩阵）或O(elogn)（使用优先队列和邻接表）",
                "空间复杂度": "O(n)（需要辅助数组存储距离和路径信息）",
                "设计思想": "贪心",
                "适用场景": "没有负权边的单源最短路径问题",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "逐步确定最短路径，每一步都基于已确定的最优解，体现了动态规划和贪心思想的结合。"
            }
        },
        {
            "ID": "08ALG004",
            "name": "弗洛伊德算法",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "计算带权有向图中所有顶点对之间的最短路径的算法。通过动态规划思想，逐步考虑中间顶点来更新路径长度。",
                "时间复杂度": "O(n^3)",
                "空间复杂度": "O(n^2)（需要邻接矩阵存储路径长度）",
                "设计思想": "动态规划",
                "适用场景": "所有顶点对之间的最短路径问题，可以处理负权边（但不能处理负权回路）",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "通过迭代优化所有点对的路径，体现了动态规划中状态转移和最优子结构的思想。"
            }
        },
        {
            "ID": "08ALG005",
            "name": "拓扑排序",
            "type": "算法",
            "attributes": {
                "难度": "中等",
                "内容": "对有向无环图（AOV网）的顶点进行线性排序，使得对于图中任意一条有向边<u, v>，顶点u在序列中都出现在顶点v之前。用于检测图中是否存在回路以及确定活动执行顺序。",
                "时间复杂度": "O(n+e)",
                "空间复杂度": "O(n)（需要存储入度和栈/队列）",
                "设计思想": "基于入度的迭代删除",
                "适用场景": "任务调度、依赖关系分析",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "合理安排任务顺序，确保前置条件满足，体现了计划性和流程管理。"
            }
        },
        {
            "ID": "08ALG006",
            "name": "关键路径算法",
            "type": "算法",
            "attributes": {
                "难度": "高级",
                "内容": "在AOE网中找出从源点到汇点的最长路径（关键路径），这条路径上的活动（关键活动）决定了整个工程的最短完成时间。",
                "时间复杂度": "O(n+e)",
                "空间复杂度": "O(n)（需要存储事件时间和拓扑序列）",
                "设计思想": "基于拓扑排序计算事件最早/最晚发生时间",
                "适用场景": "项目管理、工期估算、进度优化",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "识别影响全局进度的关键环节，集中资源优化，体现了抓住主要矛盾的管理思想。"
            }
        },
        {
            "ID": "08CON002",
            "name": "最短路径",
            "type": "概念",
            "attributes": {
                "难度": "中等",
                "内容": "在图中，连接两个顶点并且路径长度（无权图的边数或带权图的权值之和）最小的路径。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "优化路径选择，体现了效率和最优化的追求。"
            }
        },
        {
            "ID": "08CON003",
            "name": "拓扑序列",
            "type": "概念",
            "attributes": {
                "难度": "中等",
                "内容": "有向无环图（AOV网）的所有顶点的一种线性排序，该排序满足图中任意一条有向边<u, v>，顶点u在序列中都出现在顶点v之前。一个图的拓扑序列可能不唯一。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "体现了任务或事件的合理执行顺序。"
            }
        },
        {
            "ID": "08CON004",
            "name": "关键路径",
            "type": "概念",
            "attributes": {
                "难度": "高级",
                "内容": "在AOE网中，从源点到汇点的所有路径中，长度（路径上活动持续时间之和）最长的一条或多条路径。关键路径的长度决定了整个工程的最短完成时间。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "识别制约项目整体进度的核心环节。"
            }
        },
        {
            "ID": "08CON011",
            "name": "活动",
            "type": "概念",
            "attributes": {
                "难度": "中等",
                "内容": "在AOV网中由顶点表示，或在AOE网中由边表示的子工程或任务。具有先后关系或持续时间。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "工程或项目中的基本执行单元。"
            }
        },
        {
            "ID": "08CON012",
            "name": "事件",
            "type": "概念",
            "attributes": {
                "难度": "中等",
                "内容": "在AOE网中由顶点表示，标志着某些活动的完成和另一些活动的开始的瞬间点。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "工程或项目中的里程碑或状态转换点。"
            }
        },
        {
            "ID": "08CON013",
            "name": "源点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在有向图中，特别是AOE网中，没有入边的顶点，表示整个工程或过程的开始。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "事物的起点、初始状态。"
            }
        },
        {
            "ID": "08CON014",
            "name": "汇点",
            "type": "概念",
            "attributes": {
                "难度": "入门",
                "内容": "在有向图中，特别是AOE网中，没有出边的顶点，表示整个工程或过程的结束。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "事物的终点、目标状态。"
            }
        },
        {
            "ID": "08CON015",
            "name": "最早发生时间",
            "type": "概念",
            "attributes": {
                "难度": "中等",
                "内容": "在AOE网中，一个事件能够发生的最早时刻，等于从源点到该事件顶点的最长路径长度。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "最优情况下的时间点，计划的下限。"
            }
        },
        {
            "ID": "08CON016",
            "name": "最迟发生时间",
            "type": "概念",
            "attributes": {
                "难度": "中等",
                "内容": "在AOE网中，一个事件在不推迟整个工程完成时间的前提下，必须发生的最晚时刻。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "允许的最晚时间点，计划的上限。"
            }
        },
        {
            "ID": "08CON017",
            "name": "最早开始时间",
            "type": "概念",
            "attributes": {
                "难度": "中等",
                "内容": "在AOE网中，一个活动能够开始的最早时刻，等于该活动起点事件的最早发生时间。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "活动启动的最优时间点。"
            }
        },
        {
            "ID": "08CON018",
            "name": "最迟开始时间",
            "type": "概念",
            "attributes": {
                "难度": "中等",
                "内容": "在AOE网中，一个活动在不推迟整个工程完成时间的前提下，必须开始的最晚时刻，等于其终点事件的最迟发生时间减去活动持续时间。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "活动启动的最后期限。"
            }
        },
        {
            "ID": "08CON019",
            "name": "关键活动",
            "type": "概念",
            "attributes": {
                "难度": "高级",
                "内容": "在AOE网中，最早开始时间和最迟开始时间相等的活动，即开始时间余量为0的活动。这些活动位于关键路径上。",
                "教学视频": "未知",
                "教学材料": "未知",
                "思政点": "决定项目工期的核心任务，需要重点关注。"
            }
        }
    ],
    "relations": [
        {
            "type": "理论依赖",
            "ID": "01REL001",
            "source": "01DS001",
            "target": "01CON008"
        },
        {
            "type": "理论依赖",
            "ID": "01REL002",
            "source": "01DS001",
            "target": "01CON009"
        },
        {
            "type": "理论依赖",
            "ID": "01REL006",
            "source": "01CON006",
            "target": "01CON005"
        },
        {
            "type": "理论依赖",
            "ID": "01REL007",
            "source": "01DS002",
            "target": "01CON008"
        },
        {
            "type": "理论依赖",
            "ID": "01REL008",
            "source": "01DS003",
            "target": "01CON008"
        },
        {
            "type": "理论依赖",
            "ID": "01REL009",
            "source": "01DS004",
            "target": "01CON008"
        },
        {
            "type": "理论依赖",
            "ID": "01REL010",
            "source": "01DS005",
            "target": "01CON008"
        },
        {
            "type": "理论依赖",
            "ID": "01REL011",
            "source": "01CON010",
            "target": "01CON009"
        },
        {
            "type": "理论依赖",
            "ID": "01REL012",
            "source": "01CON011",
            "target": "01CON009"
        },
        {
            "type": "理论依赖",
            "ID": "01REL013",
            "source": "01CON012",
            "target": "01CON009"
        },
        {
            "type": "理论依赖",
            "ID": "01REL014",
            "source": "01CON013",
            "target": "01CON009"
        },
        {
            "type": "理论依赖",
            "ID": "01REL015",
            "source": "01DS001",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "ID": "01REL016",
            "source": "01DS003",
            "target": "01CON015"
        },
        {
            "type": "理论依赖",
            "ID": "01REL017",
            "source": "01DS003",
            "target": "01CON016"
        },
        {
            "type": "继承",
            "ID": "01REL018",
            "source": "01DS004",
            "target": "01DS005"
        },
        {
            "type": "继承",
            "ID": "01REL019",
            "source": "01DS003",
            "target": "01DS004"
        },
        {
            "type": "理论依赖",
            "ID": "01REL020",
            "source": "01DS004",
            "target": "01CON017"
        },
        {
            "type": "理论依赖",
            "ID": "01REL021",
            "source": "01DS005",
            "target": "01CON017"
        },
        {
            "type": "理论依赖",
            "ID": "01REL022",
            "source": "01DS005",
            "target": "01CON018"
        },
        {
            "type": "理论依赖",
            "ID": "01REL023",
            "source": "01DS004",
            "target": "01CON019"
        },
        {
            "type": "理论依赖",
            "ID": "01REL024",
            "source": "01DS004",
            "target": "01CON020"
        },
        {
            "type": "理论依赖",
            "ID": "01REL025",
            "source": "01DS004",
            "target": "01CON021"
        },
        {
            "type": "理论依赖",
            "ID": "01REL026",
            "source": "01CON019",
            "target": "01CON017"
        },
        {
            "type": "理论依赖",
            "ID": "01REL027",
            "source": "01CON020",
            "target": "01CON017"
        },
        {
            "type": "理论依赖",
            "ID": "01REL028",
            "source": "01CON021",
            "target": "01CON017"
        },
        {
            "type": "理论依赖",
            "ID": "01REL029",
            "source": "01DS004",
            "target": "01CON022"
        },
        {
            "type": "理论依赖",
            "ID": "01REL030",
            "source": "01DS005",
            "target": "01CON022"
        },
        {
            "type": "理论依赖",
            "ID": "01REL031",
            "source": "01CON024",
            "target": "01DS001"
        },
        {
            "type": "理论依赖",
            "ID": "01REL032",
            "source": "01CON024",
            "target": "01CON026"
        },
        {
            "type": "理论依赖",
            "ID": "01REL034",
            "source": "01CON027",
            "target": "01CON026"
        },
        {
            "type": "理论依赖",
            "ID": "01REL035",
            "source": "01CON028",
            "target": "01CON026"
        },
        {
            "type": "理论依赖",
            "ID": "01REL036",
            "source": "01CON027",
            "target": "01CON029"
        },
        {
            "type": "理论依赖",
            "ID": "01REL037",
            "source": "01CON028",
            "target": "01CON029"
        },
        {
            "type": "使用",
            "ID": "01REL038",
            "source": "01ALG002",
            "target": "01DS006"
        },
        {
            "type": "使用",
            "ID": "01REL039",
            "source": "01ALG003",
            "target": "01DS006"
        },
        {
            "type": "使用",
            "ID": "01REL040",
            "source": "01ALG004",
            "target": "01DS006"
        },
        {
            "type": "使用",
            "ID": "01REL041",
            "source": "01ALG005",
            "target": "01DS006"
        },
        {
            "type": "理论依赖",
            "ID": "01REL042",
            "source": "01DS006",
            "target": "01CON010"
        },
        {
            "type": "理论依赖",
            "ID": "01REL043",
            "source": "01DS009",
            "target": "01CON011"
        },
        {
            "type": "继承",
            "ID": "01REL044",
            "source": "01DS009",
            "target": "01DS003"
        },
        {
            "type": "使用",
            "ID": "01REL045",
            "source": "01DS007",
            "target": "01DS006"
        },
        {
            "type": "理论依赖",
            "ID": "02REL001",
            "source": "02DS001",
            "target": "02CON001"
        },
        {
            "type": "理论依赖",
            "ID": "02REL002",
            "source": "02DS001",
            "target": "02CON002"
        },
        {
            "type": "理论依赖",
            "ID": "02REL003",
            "source": "02DS001",
            "target": "02CON003"
        },
        {
            "type": "理论依赖",
            "ID": "02REL004",
            "source": "02DS001",
            "target": "01CON024"
        },
        {
            "type": "操作绑定",
            "ID": "02REL005",
            "source": "02ALG001",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "ID": "02REL006",
            "source": "02ALG002",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "ID": "02REL007",
            "source": "02ALG003",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "ID": "02REL008",
            "source": "02ALG004",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "ID": "02REL009",
            "source": "02ALG005",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "ID": "02REL010",
            "source": "02ALG006",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "ID": "02REL011",
            "source": "02ALG007",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "ID": "02REL012",
            "source": "02ALG008",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "ID": "02REL013",
            "source": "02ALG009",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "ID": "02REL014",
            "source": "02ALG010",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "ID": "02REL015",
            "source": "02ALG011",
            "target": "02DS001"
        },
        {
            "type": "继承",
            "ID": "02REL016",
            "source": "02DS002",
            "target": "02DS001"
        },
        {
            "type": "理论依赖",
            "ID": "02REL017",
            "source": "02DS002",
            "target": "02CON008"
        },
        {
            "type": "使用",
            "ID": "02REL018",
            "source": "02DS002",
            "target": "01DS006"
        },
        {
            "type": "理论依赖",
            "ID": "02REL019",
            "source": "02DS002",
            "target": "02CON010"
        },
        {
            "type": "理论依赖",
            "ID": "02REL020",
            "source": "02ALG007",
            "target": "01CON027"
        },
        {
            "type": "理论依赖",
            "ID": "02REL021",
            "source": "02ALG008",
            "target": "01CON027"
        },
        {
            "type": "理论依赖",
            "ID": "02REL022",
            "source": "02ALG009",
            "target": "01CON027"
        },
        {
            "type": "理论依赖",
            "ID": "02REL023",
            "source": "02ALG010",
            "target": "01CON027"
        },
        {
            "type": "操作绑定",
            "ID": "02REL024",
            "source": "02ALG012",
            "target": "02DS002"
        },
        {
            "type": "理论依赖",
            "ID": "02REL025",
            "source": "02ALG012",
            "target": "01CON027"
        },
        {
            "type": "继承",
            "ID": "02REL026",
            "source": "02DS004",
            "target": "02DS001"
        },
        {
            "type": "理论依赖",
            "ID": "02REL027",
            "source": "02DS004",
            "target": "02CON011"
        },
        {
            "type": "理论依赖",
            "ID": "02REL028",
            "source": "02DS004",
            "target": "01CON017"
        },
        {
            "type": "理论依赖",
            "ID": "02REL029",
            "source": "02DS004",
            "target": "02CON015"
        },
        {
            "type": "理论依赖",
            "ID": "02REL030",
            "source": "01CON017",
            "target": "02CON013"
        },
        {
            "type": "理论依赖",
            "ID": "02REL031",
            "source": "01CON017",
            "target": "02CON014"
        },
        {
            "type": "继承",
            "ID": "02REL032",
            "source": "01DS009",
            "target": "02DS004"
        },
        {
            "type": "继承",
            "ID": "02REL033",
            "source": "02DS006",
            "target": "02DS004"
        },
        {
            "type": "理论依赖",
            "ID": "02REL034",
            "source": "02DS004",
            "target": "02CON016"
        },
        {
            "type": "理论依赖",
            "ID": "02REL035",
            "source": "02DS004",
            "target": "02CON017"
        },
        {
            "type": "理论依赖",
            "ID": "02REL036",
            "source": "02DS004",
            "target": "02CON018"
        },
        {
            "type": "理论依赖",
            "ID": "02REL037",
            "source": "02DS004",
            "target": "02CON019"
        },
        {
            "type": "变体",
            "ID": "02REL038",
            "source": "02DS007",
            "target": "02DS004"
        },
        {
            "type": "理论依赖",
            "ID": "02REL039",
            "source": "02ALG003",
            "target": "01CON027"
        },
        {
            "type": "理论依赖",
            "ID": "02REL040",
            "source": "02ALG005",
            "target": "01CON027"
        },
        {
            "type": "理论依赖",
            "ID": "02REL041",
            "source": "02ALG011",
            "target": "01CON027"
        },
        {
            "type": "使用",
            "ID": "02REL042",
            "source": "02DS008",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "ID": "02REL043",
            "source": "02ALG013",
            "target": "02DS008"
        },
        {
            "type": "操作绑定",
            "ID": "02REL044",
            "source": "02ALG014",
            "target": "02DS008"
        },
        {
            "type": "操作绑定",
            "ID": "02REL045",
            "source": "02ALG015",
            "target": "02DS008"
        },
        {
            "type": "操作绑定",
            "ID": "02REL046",
            "source": "02ALG016",
            "target": "02DS008"
        },
        {
            "type": "优化",
            "ID": "02REL047",
            "source": "02ALG016",
            "target": "02ALG015"
        },
        {
            "type": "理论依赖",
            "ID": "02REL048",
            "source": "02ALG015",
            "target": "01CON027"
        },
        {
            "type": "理论依赖",
            "ID": "02REL049",
            "source": "02ALG016",
            "target": "01CON027"
        },
        {
            "type": "理论依赖",
            "ID": "02REL050",
            "source": "02DS001",
            "target": "02CON004"
        },
        {
            "type": "理论依赖",
            "ID": "02REL051",
            "source": "02DS001",
            "target": "02CON005"
        },
        {
            "type": "操作绑定",
            "ID": "03REL001",
            "source": "03ALG001",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL002",
            "source": "03ALG002",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL003",
            "source": "03ALG003",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL004",
            "source": "03ALG004",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL005",
            "source": "03ALG005",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL006",
            "source": "03ALG006",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL007",
            "source": "03ALG007",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL008",
            "source": "03ALG008",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL009",
            "source": "03ALG009",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL010",
            "source": "03ALG010",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL011",
            "source": "03ALG011",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL012",
            "source": "03ALG012",
            "target": "01DS002"
        },
        {
            "type": "操作绑定",
            "ID": "03REL013",
            "source": "03ALG013",
            "target": "01DS002"
        },
        {
            "type": "变体",
            "ID": "03REL014",
            "source": "03DS002",
            "target": "01DS002"
        },
        {
            "type": "变体",
            "ID": "03REL015",
            "source": "03DS003",
            "target": "01DS002"
        },
        {
            "type": "继承",
            "ID": "03REL016",
            "source": "03DS004",
            "target": "03DS011"
        },
        {
            "type": "理论依赖",
            "ID": "03REL017",
            "source": "03DS005",
            "target": "03CON003"
        },
        {
            "type": "使用",
            "ID": "03REL018",
            "source": "03DS004",
            "target": "03DS005"
        },
        {
            "type": "使用",
            "ID": "03REL019",
            "source": "03DS006",
            "target": "03DS005"
        },
        {
            "type": "变体",
            "ID": "03REL020",
            "source": "03DS006",
            "target": "03DS004"
        },
        {
            "type": "变体",
            "ID": "03REL021",
            "source": "03DS007",
            "target": "03DS004"
        },
        {
            "type": "变体",
            "ID": "03REL022",
            "source": "03DS008",
            "target": "03DS004"
        },
        {
            "type": "操作绑定",
            "ID": "03REL023",
            "source": "03ALG015",
            "target": "03DS004"
        },
        {
            "type": "操作绑定",
            "ID": "03REL024",
            "source": "03ALG016",
            "target": "03DS004"
        },
        {
            "type": "优化",
            "ID": "03REL025",
            "source": "03ALG017",
            "target": "03ALG016"
        },
        {
            "type": "操作绑定",
            "ID": "03REL026",
            "source": "03ALG018",
            "target": "03DS004"
        },
        {
            "type": "操作绑定",
            "ID": "03REL027",
            "source": "03ALG019",
            "target": "03DS004"
        },
        {
            "type": "操作绑定",
            "ID": "03REL028",
            "source": "03ALG020",
            "target": "03DS004"
        },
        {
            "type": "操作绑定",
            "ID": "03REL029",
            "source": "03ALG021",
            "target": "03DS004"
        },
        {
            "type": "理论依赖",
            "ID": "03REL030",
            "source": "03DS009",
            "target": "03CON006"
        },
        {
            "type": "使用",
            "ID": "03REL031",
            "source": "03DS009",
            "target": "03CON004"
        },
        {
            "type": "使用",
            "ID": "03REL032",
            "source": "03DS009",
            "target": "03CON005"
        },
        {
            "type": "变体",
            "ID": "03REL034",
            "source": "03DS010",
            "target": "03DS009"
        },
        {
            "type": "操作绑定",
            "ID": "03REL035",
            "source": "03ALG022",
            "target": "03DS009"
        },
        {
            "type": "操作绑定",
            "ID": "03REL036",
            "source": "03ALG023",
            "target": "03DS009"
        },
        {
            "type": "操作绑定",
            "ID": "03REL037",
            "source": "03ALG024",
            "target": "03DS009"
        },
        {
            "type": "操作绑定",
            "ID": "03REL038",
            "source": "03ALG025",
            "target": "03DS009"
        },
        {
            "type": "理论依赖",
            "ID": "03REL039",
            "source": "03ALG022",
            "target": "03CON006"
        },
        {
            "type": "理论依赖",
            "ID": "03REL040",
            "source": "03ALG023",
            "target": "03CON006"
        },
        {
            "type": "理论依赖",
            "ID": "03REL041",
            "source": "03ALG024",
            "target": "03CON006"
        },
        {
            "type": "理论依赖",
            "ID": "03REL042",
            "source": "03ALG025",
            "target": "03CON006"
        },
        {
            "type": "使用",
            "ID": "03REL043",
            "source": "03ALG026",
            "target": "01ALG004"
        },
        {
            "type": "操作绑定",
            "ID": "03REL044",
            "source": "03ALG026",
            "target": "01DS002"
        },
        {
            "type": "理论依赖",
            "ID": "03REL045",
            "source": "01DS002",
            "target": "01CON024"
        },
        {
            "type": "理论依赖",
            "ID": "03REL046",
            "source": "03DS004",
            "target": "01CON024"
        },
        {
            "type": "继承",
            "ID": "04REL001",
            "source": "04DS001",
            "target": "02DS001"
        },
        {
            "type": "继承",
            "ID": "04REL002",
            "source": "04DS002",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "ID": "04REL003",
            "source": "04ALG001",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "04REL004",
            "source": "04ALG002",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "04REL005",
            "source": "04ALG003",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "04REL006",
            "source": "04ALG004",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "04REL007",
            "source": "04ALG005",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "04REL008",
            "source": "04ALG006",
            "target": "04DS001"
        },
        {
            "type": "理论依赖",
            "ID": "04REL009",
            "source": "04DS001",
            "target": "04CON001"
        },
        {
            "type": "理论依赖",
            "ID": "04REL010",
            "source": "04DS001",
            "target": "04CON002"
        },
        {
            "type": "理论依赖",
            "ID": "04REL011",
            "source": "04DS001",
            "target": "04CON003"
        },
        {
            "type": "变体",
            "ID": "04REL012",
            "source": "04DS004",
            "target": "04DS001"
        },
        {
            "type": "变体",
            "ID": "04REL013",
            "source": "04DS005",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "ID": "04REL014",
            "source": "04ALG018",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "ID": "04REL015",
            "source": "04ALG019",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "ID": "04REL016",
            "source": "04ALG007",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "ID": "04REL017",
            "source": "04ALG008",
            "target": "04DS001"
        },
        {
            "type": "理论依赖",
            "ID": "04REL018",
            "source": "04ALG007",
            "target": "04CON005"
        },
        {
            "type": "理论依赖",
            "ID": "04REL019",
            "source": "04ALG008",
            "target": "04CON004"
        },
        {
            "type": "理论依赖",
            "ID": "04REL020",
            "source": "04ALG008",
            "target": "04CON005"
        },
        {
            "type": "理论依赖",
            "ID": "04REL021",
            "source": "04ALG009",
            "target": "03CON006"
        },
        {
            "type": "理论依赖",
            "ID": "04REL022",
            "source": "04ALG010",
            "target": "03CON006"
        },
        {
            "type": "理论依赖",
            "ID": "04REL023",
            "source": "04ALG011",
            "target": "03CON006"
        },
        {
            "type": "理论依赖",
            "ID": "04REL024",
            "source": "03CON006",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "04REL025",
            "source": "04ALG012",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "ID": "04REL026",
            "source": "04ALG013",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "ID": "04REL027",
            "source": "04ALG014",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "ID": "04REL028",
            "source": "04ALG015",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "ID": "04REL029",
            "source": "04ALG016",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "ID": "04REL030",
            "source": "04ALG017",
            "target": "04DS002"
        },
        {
            "type": "理论依赖",
            "ID": "04REL031",
            "source": "04DS002",
            "target": "04CON007"
        },
        {
            "type": "理论依赖",
            "ID": "04REL032",
            "source": "04DS002",
            "target": "04CON008"
        },
        {
            "type": "理论依赖",
            "ID": "04REL033",
            "source": "04DS002",
            "target": "04CON009"
        },
        {
            "type": "变体",
            "ID": "04REL034",
            "source": "04DS006",
            "target": "04DS002"
        },
        {
            "type": "变体",
            "ID": "04REL035",
            "source": "04DS007",
            "target": "04DS002"
        },
        {
            "type": "变体",
            "ID": "04REL036",
            "source": "04DS008",
            "target": "04DS002"
        },
        {
            "type": "使用",
            "ID": "04REL037",
            "source": "04ALG020",
            "target": "04DS002"
        },
        {
            "type": "继承",
            "ID": "05REL001",
            "source": "05DS003",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "ID": "05REL002",
            "source": "05DS003",
            "target": "05CON015"
        },
        {
            "type": "继承",
            "ID": "05REL003",
            "source": "05DS004",
            "target": "05DS003"
        },
        {
            "type": "继承",
            "ID": "05REL004",
            "source": "05DS005",
            "target": "05DS003"
        },
        {
            "type": "继承",
            "ID": "05REL005",
            "source": "05DS004",
            "target": "05DS005"
        },
        {
            "type": "继承",
            "ID": "05REL006",
            "source": "05DS004",
            "target": "05DS008"
        },
        {
            "type": "继承",
            "ID": "05REL007",
            "source": "05DS005",
            "target": "05DS008"
        },
        {
            "type": "操作绑定",
            "ID": "05REL008",
            "source": "05ALG001",
            "target": "05DS003"
        },
        {
            "type": "操作绑定",
            "ID": "05REL009",
            "source": "05ALG002",
            "target": "05DS003"
        },
        {
            "type": "操作绑定",
            "ID": "05REL010",
            "source": "05ALG003",
            "target": "05DS003"
        },
        {
            "type": "操作绑定",
            "ID": "05REL011",
            "source": "05ALG004",
            "target": "05DS003"
        },
        {
            "type": "使用",
            "ID": "05REL012",
            "source": "05ALG004",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "ID": "05REL013",
            "source": "05ALG005",
            "target": "05DS003"
        },
        {
            "type": "操作绑定",
            "ID": "05REL014",
            "source": "05ALG006",
            "target": "05DS003"
        },
        {
            "type": "使用",
            "ID": "05REL015",
            "source": "05ALG006",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL016",
            "source": "05ALG007",
            "target": "05DS003"
        },
        {
            "type": "操作绑定",
            "ID": "05REL017",
            "source": "05ALG008",
            "target": "05DS003"
        },
        {
            "type": "操作绑定",
            "ID": "05REL018",
            "source": "05ALG009",
            "target": "05DS003"
        },
        {
            "type": "操作绑定",
            "ID": "05REL019",
            "source": "05ALG010",
            "target": "05DS003"
        },
        {
            "type": "操作绑定",
            "ID": "05REL020",
            "source": "05ALG011",
            "target": "05DS003"
        },
        {
            "type": "理论依赖",
            "ID": "05REL021",
            "source": "05DS006",
            "target": "05DS005"
        },
        {
            "type": "理论依赖",
            "ID": "05REL022",
            "source": "05DS007",
            "target": "05DS003"
        },
        {
            "type": "继承",
            "ID": "05REL023",
            "source": "05DS002",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL024",
            "source": "05ALG012",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL025",
            "source": "05ALG013",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL026",
            "source": "05ALG014",
            "target": "05DS001"
        },
        {
            "type": "使用",
            "ID": "05REL027",
            "source": "05ALG014",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "ID": "05REL028",
            "source": "05ALG015",
            "target": "05DS001"
        },
        {
            "type": "使用",
            "ID": "05REL029",
            "source": "05ALG015",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL030",
            "source": "05ALG016",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL031",
            "source": "05ALG017",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL032",
            "source": "05ALG018",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "ID": "05REL033",
            "source": "05ALG019",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "ID": "05REL034",
            "source": "05DS011",
            "target": "05DS001"
        },
        {
            "type": "使用",
            "ID": "05REL035",
            "source": "05DS011",
            "target": "05DS003"
        },
        {
            "type": "理论依赖",
            "ID": "05REL036",
            "source": "05DS009",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "ID": "05REL037",
            "source": "05DS010",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "ID": "05REL038",
            "source": "05DS001",
            "target": "05CON001"
        },
        {
            "type": "理论依赖",
            "ID": "05REL039",
            "source": "05DS001",
            "target": "05CON002"
        },
        {
            "type": "理论依赖",
            "ID": "05REL040",
            "source": "05DS001",
            "target": "05CON005"
        },
        {
            "type": "理论依赖",
            "ID": "05REL041",
            "source": "05DS001",
            "target": "05CON006"
        },
        {
            "type": "理论依赖",
            "ID": "05REL042",
            "source": "05DS001",
            "target": "05CON007"
        },
        {
            "type": "理论依赖",
            "ID": "05REL043",
            "source": "05DS001",
            "target": "05CON008"
        },
        {
            "type": "理论依赖",
            "ID": "05REL044",
            "source": "05DS001",
            "target": "05CON009"
        },
        {
            "type": "理论依赖",
            "ID": "05REL045",
            "source": "05DS001",
            "target": "05CON010"
        },
        {
            "type": "理论依赖",
            "ID": "05REL046",
            "source": "05DS001",
            "target": "05CON013"
        },
        {
            "type": "理论依赖",
            "ID": "05REL047",
            "source": "05DS001",
            "target": "05CON014"
        },
        {
            "type": "理论依赖",
            "ID": "05REL048",
            "source": "05CON015",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "ID": "05REL049",
            "source": "05CON016",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "ID": "05REL050",
            "source": "05CON017",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "ID": "05REL051",
            "source": "05DS003",
            "target": "05CON018"
        },
        {
            "type": "理论依赖",
            "ID": "05REL052",
            "source": "05DS003",
            "target": "05CON019"
        },
        {
            "type": "理论依赖",
            "ID": "05REL053",
            "source": "05DS003",
            "target": "05CON020"
        },
        {
            "type": "理论依赖",
            "ID": "05REL054",
            "source": "05DS003",
            "target": "05CON021"
        },
        {
            "type": "理论依赖",
            "ID": "05REL055",
            "source": "05ALG001",
            "target": "05CON022"
        },
        {
            "type": "理论依赖",
            "ID": "05REL056",
            "source": "05ALG002",
            "target": "05CON022"
        },
        {
            "type": "理论依赖",
            "ID": "05REL057",
            "source": "05ALG003",
            "target": "05CON022"
        },
        {
            "type": "理论依赖",
            "ID": "05REL058",
            "source": "05ALG004",
            "target": "05CON022"
        },
        {
            "type": "理论依赖",
            "ID": "05REL059",
            "source": "05ALG005",
            "target": "05CON022"
        },
        {
            "type": "理论依赖",
            "ID": "05REL060",
            "source": "05ALG006",
            "target": "05CON022"
        },
        {
            "type": "理论依赖",
            "ID": "05REL061",
            "source": "05ALG007",
            "target": "05CON022"
        },
        {
            "type": "理论依赖",
            "ID": "05REL062",
            "source": "05ALG008",
            "target": "05CON022"
        },
        {
            "type": "理论依赖",
            "ID": "05REL063",
            "source": "05ALG009",
            "target": "05CON022"
        },
        {
            "type": "理论依赖",
            "ID": "05REL064",
            "source": "05ALG010",
            "target": "05CON022"
        },
        {
            "type": "理论依赖",
            "ID": "05REL065",
            "source": "05ALG011",
            "target": "05CON022"
        },
        {
            "type": "理论依赖",
            "ID": "05REL066",
            "source": "05DS001",
            "target": "02CON002"
        },
        {
            "type": "理论依赖",
            "ID": "05REL067",
            "source": "05DS001",
            "target": "02CON003"
        },
        {
            "type": "理论依赖",
            "ID": "05REL068",
            "source": "05DS001",
            "target": "05CON011"
        },
        {
            "type": "理论依赖",
            "ID": "05REL069",
            "source": "05DS001",
            "target": "05CON012"
        },
        {
            "type": "继承",
            "ID": "06REL001",
            "source": "06DS001",
            "target": "05DS003"
        },
        {
            "type": "继承",
            "ID": "06REL002",
            "source": "06DS002",
            "target": "05DS003"
        },
        {
            "type": "继承",
            "ID": "06REL003",
            "source": "06DS006",
            "target": "05DS003"
        },
        {
            "type": "继承",
            "ID": "06REL004",
            "source": "06DS008",
            "target": "05DS003"
        },
        {
            "type": "继承",
            "ID": "06REL005",
            "source": "06DS009",
            "target": "06DS001"
        },
        {
            "type": "继承",
            "ID": "06REL006",
            "source": "06DS003",
            "target": "06DS002"
        },
        {
            "type": "继承",
            "ID": "06REL007",
            "source": "06DS004",
            "target": "06DS002"
        },
        {
            "type": "继承",
            "ID": "06REL008",
            "source": "06DS007",
            "target": "05DS003"
        },
        {
            "type": "操作绑定",
            "ID": "06REL009",
            "source": "06ALG001",
            "target": "06DS001"
        },
        {
            "type": "操作绑定",
            "ID": "06REL010",
            "source": "06ALG002",
            "target": "06DS001"
        },
        {
            "type": "操作绑定",
            "ID": "06REL011",
            "source": "06ALG003",
            "target": "06DS001"
        },
        {
            "type": "操作绑定",
            "ID": "06REL012",
            "source": "06ALG004",
            "target": "06DS001"
        },
        {
            "type": "操作绑定",
            "ID": "06REL013",
            "source": "06ALG005",
            "target": "06DS001"
        },
        {
            "type": "操作绑定",
            "ID": "06REL014",
            "source": "06ALG006",
            "target": "06DS002"
        },
        {
            "type": "操作绑定",
            "ID": "06REL015",
            "source": "06ALG007",
            "target": "06DS002"
        },
        {
            "type": "操作绑定",
            "ID": "06REL016",
            "source": "06ALG008",
            "target": "06DS002"
        },
        {
            "type": "操作绑定",
            "ID": "06REL017",
            "source": "06ALG009",
            "target": "06DS002"
        },
        {
            "type": "操作绑定",
            "ID": "06REL018",
            "source": "06ALG010",
            "target": "06DS002"
        },
        {
            "type": "使用",
            "ID": "06REL019",
            "source": "04DS008",
            "target": "06DS002"
        },
        {
            "type": "操作绑定",
            "ID": "06REL020",
            "source": "06ALG011",
            "target": "06DS006"
        },
        {
            "type": "操作绑定",
            "ID": "06REL021",
            "source": "06ALG012",
            "target": "06DS006"
        },
        {
            "type": "使用",
            "ID": "06REL022",
            "source": "06ALG013",
            "target": "06DS006"
        },
        {
            "type": "理论依赖",
            "ID": "06REL023",
            "source": "06ALG013",
            "target": "06CON016"
        },
        {
            "type": "理论依赖",
            "ID": "06REL024",
            "source": "06ALG013",
            "target": "06CON013"
        },
        {
            "type": "理论依赖",
            "ID": "06REL025",
            "source": "06DS006",
            "target": "06CON013"
        },
        {
            "type": "理论依赖",
            "ID": "06REL026",
            "source": "06DS006",
            "target": "06CON011"
        },
        {
            "type": "使用",
            "ID": "06REL027",
            "source": "06ALG013",
            "target": "06DS007"
        },
        {
            "type": "操作绑定",
            "ID": "06REL028",
            "source": "06ALG014",
            "target": "06DS008"
        },
        {
            "type": "操作绑定",
            "ID": "06REL029",
            "source": "06ALG015",
            "target": "06DS008"
        },
        {
            "type": "操作绑定",
            "ID": "06REL030",
            "source": "06ALG016",
            "target": "06DS008"
        },
        {
            "type": "操作绑定",
            "ID": "06REL031",
            "source": "06ALG017",
            "target": "06DS008"
        },
        {
            "type": "操作绑定",
            "ID": "06REL032",
            "source": "06ALG018",
            "target": "06DS008"
        },
        {
            "type": "理论依赖",
            "ID": "06REL033",
            "source": "06DS008",
            "target": "06CON017"
        },
        {
            "type": "理论依赖",
            "ID": "06REL034",
            "source": "06DS008",
            "target": "06CON007"
        },
        {
            "type": "理论依赖",
            "ID": "06REL035",
            "source": "06DS008",
            "target": "06CON021"
        },
        {
            "type": "理论依赖",
            "ID": "06REL036",
            "source": "06DS009",
            "target": "06CON023"
        },
        {
            "type": "操作绑定",
            "ID": "06REL037",
            "source": "06ALG019",
            "target": "06DS009"
        },
        {
            "type": "操作绑定",
            "ID": "06REL038",
            "source": "06ALG020",
            "target": "06DS009"
        },
        {
            "type": "操作绑定",
            "ID": "06REL039",
            "source": "06ALG021",
            "target": "06DS009"
        },
        {
            "type": "操作绑定",
            "ID": "06REL040",
            "source": "06ALG022",
            "target": "06DS009"
        },
        {
            "type": "理论依赖",
            "ID": "06REL041",
            "source": "06ALG019",
            "target": "06CON024"
        },
        {
            "type": "理论依赖",
            "ID": "06REL042",
            "source": "06ALG020",
            "target": "06CON024"
        },
        {
            "type": "理论依赖",
            "ID": "06REL043",
            "source": "06ALG021",
            "target": "06CON024"
        },
        {
            "type": "理论依赖",
            "ID": "06REL044",
            "source": "06ALG022",
            "target": "06CON024"
        },
        {
            "type": "理论依赖",
            "ID": "06REL045",
            "source": "06DS001",
            "target": "01CON006"
        },
        {
            "type": "理论依赖",
            "ID": "06REL046",
            "source": "06DS001",
            "target": "06CON002"
        },
        {
            "type": "理论依赖",
            "ID": "06REL047",
            "source": "06ALG004",
            "target": "06CON007"
        },
        {
            "type": "理论依赖",
            "ID": "06REL048",
            "source": "06DS002",
            "target": "06CON008"
        },
        {
            "type": "继承",
            "ID": "07REL001",
            "source": "07DS002",
            "target": "07DS001"
        },
        {
            "type": "继承",
            "ID": "07REL002",
            "source": "07DS003",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL003",
            "source": "07DS001",
            "target": "07CON001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL004",
            "source": "07DS001",
            "target": "07CON002"
        },
        {
            "type": "理论依赖",
            "ID": "07REL005",
            "source": "07DS002",
            "target": "01CON018"
        },
        {
            "type": "理论依赖",
            "ID": "07REL006",
            "source": "07DS003",
            "target": "07CON004"
        },
        {
            "type": "理论依赖",
            "ID": "07REL007",
            "source": "07CON002",
            "target": "07CON005"
        },
        {
            "type": "理论依赖",
            "ID": "07REL008",
            "source": "07CON006",
            "target": "07CON001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL009",
            "source": "07CON006",
            "target": "07CON002"
        },
        {
            "type": "理论依赖",
            "ID": "07REL010",
            "source": "07CON007",
            "target": "01CON018"
        },
        {
            "type": "理论依赖",
            "ID": "07REL011",
            "source": "07CON008",
            "target": "01CON018"
        },
        {
            "type": "理论依赖",
            "ID": "07REL012",
            "source": "05CON005",
            "target": "07CON001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL013",
            "source": "05CON005",
            "target": "07CON002"
        },
        {
            "type": "理论依赖",
            "ID": "07REL014",
            "source": "07CON010",
            "target": "05CON005"
        },
        {
            "type": "理论依赖",
            "ID": "07REL015",
            "source": "07CON011",
            "target": "05CON005"
        },
        {
            "type": "理论依赖",
            "ID": "07REL016",
            "source": "07CON010",
            "target": "07CON008"
        },
        {
            "type": "理论依赖",
            "ID": "07REL017",
            "source": "07CON011",
            "target": "07CON007"
        },
        {
            "type": "理论依赖",
            "ID": "07REL018",
            "source": "07CON012",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL019",
            "source": "07CON013",
            "target": "07CON012"
        },
        {
            "type": "理论依赖",
            "ID": "07REL020",
            "source": "07CON014",
            "target": "07CON012"
        },
        {
            "type": "理论依赖",
            "ID": "07REL021",
            "source": "07CON015",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL022",
            "source": "06CON009",
            "target": "07CON001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL023",
            "source": "06CON009",
            "target": "07CON002"
        },
        {
            "type": "理论依赖",
            "ID": "07REL024",
            "source": "07CON017",
            "target": "06CON009"
        },
        {
            "type": "理论依赖",
            "ID": "07REL025",
            "source": "07CON018",
            "target": "06CON009"
        },
        {
            "type": "理论依赖",
            "ID": "07REL026",
            "source": "07CON019",
            "target": "07CON017"
        },
        {
            "type": "理论依赖",
            "ID": "07REL027",
            "source": "07CON020",
            "target": "06CON009"
        },
        {
            "type": "理论依赖",
            "ID": "07REL028",
            "source": "07CON021",
            "target": "07CON020"
        },
        {
            "type": "理论依赖",
            "ID": "07REL029",
            "source": "07CON021",
            "target": "07DS003"
        },
        {
            "type": "理论依赖",
            "ID": "07REL030",
            "source": "07CON022",
            "target": "07CON021"
        },
        {
            "type": "理论依赖",
            "ID": "07REL031",
            "source": "07CON022",
            "target": "07CON015"
        },
        {
            "type": "理论依赖",
            "ID": "07REL032",
            "source": "07CON023",
            "target": "07CON020"
        },
        {
            "type": "理论依赖",
            "ID": "07REL033",
            "source": "07CON023",
            "target": "07DS002"
        },
        {
            "type": "理论依赖",
            "ID": "07REL034",
            "source": "07CON024",
            "target": "07CON023"
        },
        {
            "type": "理论依赖",
            "ID": "07REL035",
            "source": "07CON024",
            "target": "07CON015"
        },
        {
            "type": "理论依赖",
            "ID": "07REL036",
            "source": "07CON026",
            "target": "07CON025"
        },
        {
            "type": "理论依赖",
            "ID": "07REL037",
            "source": "07CON027",
            "target": "07CON026"
        },
        {
            "type": "理论依赖",
            "ID": "07REL038",
            "source": "07CON028",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL039",
            "source": "07ALG001",
            "target": "07CON028"
        },
        {
            "type": "理论依赖",
            "ID": "07REL040",
            "source": "07ALG002",
            "target": "07CON028"
        },
        {
            "type": "使用",
            "ID": "07REL041",
            "source": "07ALG001",
            "target": "07DS001"
        },
        {
            "type": "使用",
            "ID": "07REL042",
            "source": "07ALG002",
            "target": "07DS001"
        },
        {
            "type": "变体",
            "ID": "07REL043",
            "source": "07DS006",
            "target": "07DS005"
        },
        {
            "type": "变体",
            "ID": "07REL044",
            "source": "07DS007",
            "target": "07DS005"
        },
        {
            "type": "变体",
            "ID": "07REL045",
            "source": "07DS007",
            "target": "07DS006"
        },
        {
            "type": "理论依赖",
            "ID": "07REL046",
            "source": "07CON029",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "07REL047",
            "source": "07CON029",
            "target": "07CON028"
        },
        {
            "type": "使用",
            "ID": "07REL048",
            "source": "07DS004",
            "target": "07CON001"
        },
        {
            "type": "使用",
            "ID": "07REL049",
            "source": "07DS004",
            "target": "07CON002"
        },
        {
            "type": "使用",
            "ID": "07REL050",
            "source": "07DS005",
            "target": "07CON001"
        },
        {
            "type": "使用",
            "ID": "07REL051",
            "source": "07DS005",
            "target": "07CON002"
        },
        {
            "type": "使用",
            "ID": "07REL052",
            "source": "07DS008",
            "target": "07CON001"
        },
        {
            "type": "使用",
            "ID": "07REL053",
            "source": "07DS008",
            "target": "07CON002"
        },
        {
            "type": "继承",
            "ID": "08REL001",
            "source": "08DS003",
            "target": "08DS002"
        },
        {
            "type": "继承",
            "ID": "08REL002",
            "source": "08DS008",
            "target": "07DS001"
        },
        {
            "type": "继承",
            "ID": "08REL003",
            "source": "08DS009",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL004",
            "source": "08DS002",
            "target": "08DS004"
        },
        {
            "type": "理论依赖",
            "ID": "08REL005",
            "source": "08DS002",
            "target": "07CON001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL006",
            "source": "08DS002",
            "target": "07CON002"
        },
        {
            "type": "理论依赖",
            "ID": "08REL007",
            "source": "08DS002",
            "target": "07CON017"
        },
        {
            "type": "理论依赖",
            "ID": "08REL008",
            "source": "08DS003",
            "target": "07CON025"
        },
        {
            "type": "使用",
            "ID": "08REL009",
            "source": "08ALG001",
            "target": "07DS001"
        },
        {
            "type": "使用",
            "ID": "08REL010",
            "source": "08ALG001",
            "target": "07DS004"
        },
        {
            "type": "理论依赖",
            "ID": "08REL011",
            "source": "08ALG001",
            "target": "08DS003"
        },
        {
            "type": "使用",
            "ID": "08REL012",
            "source": "08ALG002",
            "target": "07DS001"
        },
        {
            "type": "使用",
            "ID": "08REL013",
            "source": "08ALG002",
            "target": "07DS008"
        },
        {
            "type": "理论依赖",
            "ID": "08REL014",
            "source": "08ALG002",
            "target": "08DS003"
        },
        {
            "type": "使用",
            "ID": "08REL015",
            "source": "08ALG003",
            "target": "07DS001"
        },
        {
            "type": "使用",
            "ID": "08REL016",
            "source": "08ALG003",
            "target": "07DS004"
        },
        {
            "type": "理论依赖",
            "ID": "08REL017",
            "source": "08ALG003",
            "target": "08CON002"
        },
        {
            "type": "使用",
            "ID": "08REL018",
            "source": "08ALG004",
            "target": "07DS001"
        },
        {
            "type": "使用",
            "ID": "08REL019",
            "source": "08ALG004",
            "target": "07DS004"
        },
        {
            "type": "理论依赖",
            "ID": "08REL020",
            "source": "08ALG004",
            "target": "08CON002"
        },
        {
            "type": "使用",
            "ID": "08REL021",
            "source": "08ALG005",
            "target": "08DS008"
        },
        {
            "type": "使用",
            "ID": "08REL022",
            "source": "08ALG005",
            "target": "07DS005"
        },
        {
            "type": "使用",
            "ID": "08REL023",
            "source": "08ALG005",
            "target": "04DS001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL024",
            "source": "08ALG005",
            "target": "08CON003"
        },
        {
            "type": "理论依赖",
            "ID": "08REL025",
            "source": "08ALG005",
            "target": "07CON010"
        },
        {
            "type": "使用",
            "ID": "08REL026",
            "source": "08ALG006",
            "target": "08DS009"
        },
        {
            "type": "使用",
            "ID": "08REL027",
            "source": "08ALG006",
            "target": "07DS005"
        },
        {
            "type": "理论依赖",
            "ID": "08REL028",
            "source": "08ALG006",
            "target": "08CON004"
        },
        {
            "type": "理论依赖",
            "ID": "08REL029",
            "source": "08ALG006",
            "target": "08CON019"
        },
        {
            "type": "理论依赖",
            "ID": "08REL030",
            "source": "08ALG006",
            "target": "08CON015"
        },
        {
            "type": "理论依赖",
            "ID": "08REL031",
            "source": "08ALG006",
            "target": "08CON016"
        },
        {
            "type": "理论依赖",
            "ID": "08REL032",
            "source": "08ALG006",
            "target": "08CON017"
        },
        {
            "type": "理论依赖",
            "ID": "08REL033",
            "source": "08ALG006",
            "target": "08CON018"
        },
        {
            "type": "理论依赖",
            "ID": "08REL034",
            "source": "08DS008",
            "target": "08CON011"
        },
        {
            "type": "理论依赖",
            "ID": "08REL035",
            "source": "08DS008",
            "target": "07CON001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL036",
            "source": "08DS008",
            "target": "07CON002"
        },
        {
            "type": "理论依赖",
            "ID": "08REL037",
            "source": "08DS008",
            "target": "07CON017"
        },
        {
            "type": "理论依赖",
            "ID": "08REL038",
            "source": "08DS008",
            "target": "07CON010"
        },
        {
            "type": "理论依赖",
            "ID": "08REL039",
            "source": "08DS008",
            "target": "07CON011"
        },
        {
            "type": "理论依赖",
            "ID": "08REL040",
            "source": "08DS009",
            "target": "08CON011"
        },
        {
            "type": "理论依赖",
            "ID": "08REL041",
            "source": "08DS009",
            "target": "08CON012"
        },
        {
            "type": "理论依赖",
            "ID": "08REL042",
            "source": "08DS009",
            "target": "08CON013"
        },
        {
            "type": "理论依赖",
            "ID": "08REL043",
            "source": "08DS009",
            "target": "08CON014"
        },
        {
            "type": "理论依赖",
            "ID": "08REL044",
            "source": "08DS009",
            "target": "07CON001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL045",
            "source": "08DS009",
            "target": "07CON002"
        },
        {
            "type": "理论依赖",
            "ID": "08REL046",
            "source": "08DS009",
            "target": "07CON025"
        },
        {
            "type": "理论依赖",
            "ID": "08REL047",
            "source": "07DS001",
            "target": "07CON001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL048",
            "source": "07DS001",
            "target": "07CON002"
        },
        {
            "type": "理论依赖",
            "ID": "08REL049",
            "source": "08CON002",
            "target": "07CON025"
        },
        {
            "type": "理论依赖",
            "ID": "08REL050",
            "source": "08CON002",
            "target": "07CON002"
        },
        {
            "type": "理论依赖",
            "ID": "08REL051",
            "source": "08CON002",
            "target": "07CON001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL052",
            "source": "08DS002",
            "target": "07CON015"
        },
        {
            "type": "理论依赖",
            "ID": "08REL053",
            "source": "08CON004",
            "target": "08CON019"
        },
        {
            "type": "理论依赖",
            "ID": "08REL054",
            "source": "08CON004",
            "target": "08CON013"
        },
        {
            "type": "理论依赖",
            "ID": "08REL055",
            "source": "08CON004",
            "target": "08CON014"
        },
        {
            "type": "理论依赖",
            "ID": "08REL056",
            "source": "08DS004",
            "target": "07CON001"
        },
        {
            "type": "理论依赖",
            "ID": "08REL057",
            "source": "08DS004",
            "target": "07CON002"
        }
    ]
}
{
    "entities": [
        {
            "type": "概念",
            "ID": "01CON001",
            "name": "数据",
            "attributes": {
                "难度": "入门",
                "内容": "对现实世界事物及其活动的符号记录，需要编码为二进制形式以便计算机处理。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON002",
            "name": "数据元素",
            "attributes": {
                "难度": "入门",
                "内容": "数据的基本单位，一个数据整体中相对独立的单位。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON007",
            "name": "数据处理",
            "attributes": {
                "难度": "入门",
                "内容": "利用计算机对数据进行存储、检索、插入、删除、合并、拆分、排序、统计、计算、转换、输入、输出等的过程。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON008",
            "name": "数据结构",
            "attributes": {
                "难度": "入门",
                "内容": "指数据以及数据元素之间的相互联系（关系），通常指逻辑结构。由数据元素的集合K和K上关系的集合R组成。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON009",
            "name": "逻辑结构",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素之间的内在联系，与计算机存储和处理无关。基本结构包括集合、线、树、图等。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON010",
            "name": "存储结构",
            "attributes": {
                "难度": "入门",
                "内容": "数据的逻辑结构在计算机存储器中的表现形式，也称物理结构。基本方法有顺序、链接、索引、散列等。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON011",
            "name": "关系",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素之间的二元联系，通常表示为序偶的集合。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON012",
            "name": "直接前驱",
            "attributes": {
                "难度": "入门",
                "内容": "在关系序偶<x,y>中，x是y的直接前驱。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON013",
            "name": "直接后继",
            "attributes": {
                "难度": "入门",
                "内容": "在关系序偶<x,y>中，y是x的直接后继。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON014",
            "name": "结点",
            "attributes": {
                "难度": "入门",
                "内容": "数据结构图形表示中对应数据元素的单元，也叫顶点。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON015",
            "name": "有向边",
            "attributes": {
                "难度": "入门",
                "内容": "数据结构图形表示中带箭头的连线，对应关系中的序偶，也称弧。"
            }
        },
        {
            "type": "数据结构",
            "ID": "01DS001",
            "name": "集合结构",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素之间除了“同属一个集合”外，没有其他关系的数据结构。",
                "存储开销": "取决于存储方式",
                "核心特性": "无序性（逻辑上）"
            }
        },
        {
            "type": "数据结构",
            "ID": "01DS002",
            "name": "线性结构",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素之间存在一对一的线性关系的数据结构。除首尾元素外，每个元素有且仅有一个直接前驱和一个直接后继。",
                "存储开销": "取决于存储方式（顺序或链式）",
                "核心特性": "有序性（逻辑上），1:1关系"
            }
        },
        {
            "type": "数据结构",
            "ID": "01DS003",
            "name": "树形结构",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素之间存在一对多的层次关系的数据结构。除根结点外，每个结点有且仅有一个直接前驱，可以有任意多个直接后继。",
                "存储开销": "取决于存储方式",
                "核心特性": "层次性，1:N关系"
            }
        },
        {
            "type": "概念",
            "ID": "01CON016",
            "name": "树根结点",
            "attributes": {
                "难度": "入门",
                "内容": "树形结构中没有前驱只有后继的结点。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON017",
            "name": "树叶结点",
            "attributes": {
                "难度": "入门",
                "内容": "树形结构中只有前驱没有后继的结点。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON018",
            "name": "树枝结点",
            "attributes": {
                "难度": "入门",
                "内容": "树形结构中除树根和树叶之外的结点。"
            }
        },
        {
            "type": "数据结构",
            "ID": "01DS004",
            "name": "图形结构",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素之间存在多对多的关系的数据结构。每个结点可以有任意多个前驱和后继。",
                "存储开销": "取决于存储方式（邻接矩阵或邻接表）",
                "核心特性": "网状性，M:N关系"
            }
        },
        {
            "type": "概念",
            "ID": "01CON019",
            "name": "非线性结构",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素之间存在非一对一关系的结构统称，主要包括树形结构和图形结构。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON020",
            "name": "数据类型",
            "attributes": {
                "难度": "入门",
                "内容": "对数据的取值范围、数据元素之间的结构以及允许施加操作的一种总体描述。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON021",
            "name": "简单类型",
            "attributes": {
                "难度": "入门",
                "内容": "数据无法再分割的整体的数据类型，如整数、字符等。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON022",
            "name": "结构类型",
            "attributes": {
                "难度": "入门",
                "内容": "由简单类型或其他结构类型数据按一定规则构造而成的数据类型，如数组、记录等。"
            }
        },
        {
            "type": "数据结构",
            "ID": "01DS005",
            "name": "数组",
            "attributes": {
                "难度": "入门",
                "内容": "数目固定的具有同一类型的数据元素的顺序组合，具有线性结构特点，可通过下标访问。",
                "存储开销": "连续存储空间，大小固定",
                "核心特性": "可索引性，定长"
            }
        },
        {
            "type": "数据结构",
            "ID": "01DS006",
            "name": "记录",
            "attributes": {
                "难度": "入门",
                "内容": "多个不同（或相同）类型的数组据线性结构排列而成，可通过成员运算符访问域。",
                "存储开销": "连续存储空间，大小固定，等于各域之和",
                "核心特性": "组合性，异构性"
            }
        },
        {
            "type": "概念",
            "ID": "01CON023",
            "name": "抽象数据类型",
            "attributes": {
                "难度": "入门",
                "内容": "由一种数据结构和在其上的所有操作所组成，强调逻辑结构和操作说明，隐藏实现细节。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON024",
            "name": "数据对象",
            "attributes": {
                "难度": "入门",
                "内容": "属于一种数据类型中的特定实例或值。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON025",
            "name": "算法",
            "attributes": {
                "难度": "入门",
                "内容": "解决特定问题或执行特定计算而设计的一系列明确、有限的步骤。具有有穷性、确定性、可行性、输入、输出五个特性。"
            }
        },
        {
            "type": "算法",
            "ID": "01ALG001",
            "name": "累加求和",
            "attributes": {
                "难度": "入门",
                "内容": "计算一组数（如数组元素）的总和。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "迭代",
                "适用场景": "求和计算"
            }
        },
        {
            "type": "算法",
            "ID": "01ALG002",
            "name": "矩阵相加",
            "attributes": {
                "难度": "入门",
                "内容": "将两个相同维度的矩阵对应位置的元素相加。",
                "时间复杂度": "O(n^2)",
                "空间复杂度": "O(1)",
                "设计思想": "迭代",
                "适用场景": "矩阵运算"
            }
        },
        {
            "type": "算法",
            "ID": "01ALG003",
            "name": "简单选择排序",
            "attributes": {
                "难度": "入门",
                "内容": "每次从未排序部分选取最小（或最大）元素放到已排序部分的末尾。",
                "时间复杂度": "O(n^2)",
                "空间复杂度": "O(1)",
                "设计思想": "选择",
                "适用场景": "小规模数据排序"
            }
        },
        {
            "type": "算法",
            "ID": "01ALG004",
            "name": "顺序查找",
            "attributes": {
                "难度": "入门",
                "内容": "按顺序逐个比较元素，直到找到目标元素或遍历完所有元素。",
                "时间复杂度": "O(n) (平均/最差), O(1) (最好)",
                "空间复杂度": "O(1)",
                "设计思想": "线性扫描",
                "适用场景": "无序或小规模数据查找"
            }
        },
        {
            "type": "概念",
            "ID": "01CON026",
            "name": "时间复杂度",
            "attributes": {
                "难度": "入门",
                "内容": "算法运行时间的相对度量，通常表示为问题规模n的函数，常用大O表示法（数量级）。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON027",
            "name": "空间复杂度",
            "attributes": {
                "难度": "入门",
                "内容": "算法在运行过程中临时占用存储空间大小的量度，衡量算法对内存资源的需求。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON028",
            "name": "正确性",
            "attributes": {
                "难度": "入门",
                "内容": "算法在合理输入下能在有限时间内得出正确结果的特性。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON029",
            "name": "稳健性",
            "attributes": {
                "难度": "入门",
                "内容": "算法对不合理数据输入的反应和处理能力。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON030",
            "name": "可读性",
            "attributes": {
                "难度": "入门",
                "内容": "算法供人阅读和理解的容易程度。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON031",
            "name": "数量级",
            "attributes": {
                "难度": "入门",
                "内容": "时间复杂度或空间复杂度的一种简化表示，关注函数随规模增长的主要趋势，如O(n), O(n^2)。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON032",
            "name": "递归",
            "attributes": {
                "难度": "中等",
                "内容": "一个函数直接或间接调用自身的过程或结构。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON033",
            "name": "非递归",
            "attributes": {
                "难度": "入门",
                "内容": "不使用递归调用实现的算法，通常使用循环等结构。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON034",
            "name": "顺序存储",
            "attributes": {
                "难度": "入门",
                "内容": "把逻辑上相邻的数据元素存储在物理位置也相邻的存储单元中的方法。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON035",
            "name": "链式存储",
            "attributes": {
                "难度": "入门",
                "内容": "数据元素的存储单元不一定连续，通过指针域将元素链接起来的存储方法。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON036",
            "name": "索引存储",
            "attributes": {
                "难度": "中等",
                "内容": "在存储数据信息的同时，还建立附加的索引表来标识结点的地址的存储方法。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON037",
            "name": "散列存储",
            "attributes": {
                "难度": "中等",
                "内容": "根据结点的关键字直接计算出该结点的存储地址的存储方法，也称哈希存储。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON038",
            "name": "有穷性",
            "attributes": {
                "难度": "入门",
                "内容": "算法必须在执行有穷步之后结束。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON039",
            "name": "确定性",
            "attributes": {
                "难度": "入门",
                "内容": "算法中的每一步都必须具有确切的含义，无二义性。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON040",
            "name": "可行性",
            "attributes": {
                "难度": "入门",
                "内容": "算法中的每一步都必须是可行的，能够通过有限次操作在有限时间内实现。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON041",
            "name": "输入",
            "attributes": {
                "难度": "入门",
                "内容": "算法可以有零个或多个输入量。"
            }
        },
        {
            "type": "概念",
            "ID": "01CON042",
            "name": "输出",
            "attributes": {
                "难度": "入门",
                "内容": "算法执行结束后至少要有一个输出量。"
            }
        },
        {
            "type": "数据结构",
            "ID": "02DS001",
            "name": "线性表",
            "attributes": {
                "难度": "入门",
                "内容": "具有相同属性的数据元素的一个有限序列。元素之间存在一对一的线性关系，有表头元素和表尾元素，除表头外每个元素有唯一前驱，除表尾外每个元素有唯一后继。是包括顺序表、链表等具体数据结构的一种抽象数据类型（ADT）。",
                "存储开销": "取决于具体实现（顺序或链式）",
                "核心特性": "序列性、有限性、元素类型相同"
            }
        },
        {
            "type": "数据结构",
            "ID": "02DS002",
            "name": "顺序表",
            "attributes": {
                "难度": "入门",
                "内容": "线性表的一种实现方式，指用一组地址连续的存储单元依次存储线性表的数据元素。通常使用数组实现。",
                "存储开销": "存储密度高，需要预先分配连续空间，可能存在空间浪费或不足。",
                "核心特性": "支持随机访问（O(1)时间复杂度访问元素），插入和删除操作平均需要移动大量元素（O(n)时间复杂度）。"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG001",
            "name": "初始化列表",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空的线性表。对于顺序表，通常是分配存储空间并将长度设为0；对于链表，通常是将头指针设为空或指向头结点。",
                "时间复杂度": "O(1)（链表）或 O(1)/O(MaxSize)（顺序表，取决于是否需要初始化空间）",
                "空间复杂度": "O(1) 或 O(MaxSize)（取决于实现）",
                "设计思想": "初始化",
                "适用场景": "使用线性表前"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG002",
            "name": "清除列表",
            "attributes": {
                "难度": "入门",
                "内容": "删除线性表中的所有元素，使其成为空表。对于顺序表，通常是将长度设为0；对于链表，需要遍历并释放所有结点。",
                "时间复杂度": "O(1)（顺序表）或 O(n)（链表）",
                "空间复杂度": "O(1)",
                "设计思想": "资源释放/重置",
                "适用场景": "重用列表结构或释放内存"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG003",
            "name": "获取列表长度",
            "attributes": {
                "难度": "入门",
                "内容": "返回线性表中元素的个数。",
                "时间复杂度": "O(1)（顺序表，若长度字段已维护）或 O(n)（链表，若无长度字段）",
                "空间复杂度": "O(1)",
                "设计思想": "计数/查询",
                "适用场景": "获取列表大小信息"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG004",
            "name": "判空列表",
            "attributes": {
                "难度": "入门",
                "内容": "判断线性表是否包含元素。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "状态检查",
                "适用场景": "在操作前检查列表状态"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG005",
            "name": "获取元素",
            "attributes": {
                "难度": "入门",
                "内容": "返回线性表中指定位置（序号）的元素值。",
                "时间复杂度": "O(1)（顺序表）或 O(n)（链表）",
                "空间复杂度": "O(1)",
                "设计思想": "按位置访问",
                "适用场景": "读取特定位置的数据"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG006",
            "name": "遍历列表",
            "attributes": {
                "难度": "入门",
                "内容": "按逻辑顺序访问线性表中的每一个元素。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "顺序访问",
                "适用场景": "处理或显示所有元素"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG007",
            "name": "查找元素",
            "attributes": {
                "难度": "入门",
                "内容": "在线性表中查找第一个值等于给定值的元素。",
                "时间复杂度": "O(n)（顺序查找）",
                "空间复杂度": "O(1)",
                "设计思想": "搜索",
                "适用场景": "定位特定元素"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG008",
            "name": "更新元素",
            "attributes": {
                "难度": "入门",
                "内容": "修改线性表中第一个值等于给定值的元素。",
                "时间复杂度": "O(n)（顺序查找定位）",
                "空间复杂度": "O(1)",
                "设计思想": "搜索与修改",
                "适用场景": "修改特定元素的值"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG009",
            "name": "插入元素",
            "attributes": {
                "难度": "入门",
                "内容": "在线性表的指定位置插入一个新的元素。顺序表需要移动后续元素，链表需要修改指针。",
                "时间复杂度": "O(n)（顺序表平均情况，链表查找位置）",
                "空间复杂度": "O(1)（通常）或 O(n)（顺序表扩容时）",
                "设计思想": "修改结构",
                "适用场景": "向列表中添加数据"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG010",
            "name": "删除元素",
            "attributes": {
                "难度": "入门",
                "内容": "从线性表中删除指定位置或指定值的元素。顺序表需要移动后续元素，链表需要修改指针。",
                "时间复杂度": "O(n)（顺序表平均情况，链表查找位置）",
                "空间复杂度": "O(1)",
                "设计思想": "修改结构",
                "适用场景": "从列表中移除数据"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG011",
            "name": "排序列表",
            "attributes": {
                "难度": "中等",
                "内容": "将线性表中的元素按照某种规则（如升序或降序）重新排列。",
                "时间复杂度": "取决于具体排序算法，如插入排序为 O(n^2)",
                "空间复杂度": "取决于具体排序算法，如插入排序为 O(1)",
                "设计思想": "排序",
                "适用场景": "需要有序数据时"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG012",
            "name": "插入排序",
            "attributes": {
                "难度": "入门",
                "内容": "一种简单的排序算法，通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。分为直接插入排序、折半插入排序、希尔排序等。",
                "时间复杂度": "O(n^2)（平均和最坏），O(n)（最好）",
                "空间复杂度": "O(1)",
                "设计思想": "增量构建",
                "适用场景": "基本有序或小规模数据"
            }
        },
        {
            "type": "数据结构",
            "ID": "02DS004",
            "name": "链表",
            "attributes": {
                "难度": "入门",
                "内容": "线性表的一种实现方式，通过一组任意的存储单元（可以不连续）来存储线性表的数据元素。每个存储单元称为结点，除了存储数据外，还存储指向下一个（或上一个）结点的指针。",
                "存储开销": "每个元素需要额外的指针空间。",
                "核心特性": "插入和删除操作通常只需修改指针（O(1)时间复杂度，若位置已知），访问元素需要顺序遍历（O(n)时间复杂度）。"
            }
        },
        {
            "type": "概念",
            "ID": "02CON005",
            "name": "指针",
            "attributes": {
                "难度": "入门",
                "内容": "一个变量，其值为另一个变量的地址，即内存位置的直接地址。在链表中用于链接结点。"
            }
        },
        {
            "type": "数据结构",
            "ID": "02DS005",
            "name": "单链表",
            "attributes": {
                "难度": "入门",
                "内容": "链表的一种，每个结点只包含一个指向其直接后继结点的指针域。",
                "存储开销": "每个结点一个指针域。",
                "核心特性": "只能单向遍历。"
            }
        },
        {
            "type": "数据结构",
            "ID": "02DS006",
            "name": "双向链表",
            "attributes": {
                "难度": "中等",
                "内容": "链表的一种，每个结点包含两个指针域，一个指向直接前驱结点，一个指向直接后继结点。",
                "存储开销": "每个结点两个指针域。",
                "核心特性": "可以双向遍历，方便查找前驱结点。"
            }
        },
        {
            "type": "数据结构",
            "ID": "02DS007",
            "name": "循环链表",
            "attributes": {
                "难度": "中等",
                "内容": "链表的一种变体，表中最后一个结点的指针域指向头结点（或第一个元素结点），形成一个环。可以是循环单链表或循环双向链表。",
                "存储开销": "与单链表或双向链表相同。",
                "核心特性": "从任一结点出发可遍历整个链表。"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG013",
            "name": "多项式求值",
            "attributes": {
                "难度": "入门",
                "内容": "计算给定x值时一个多项式P(x)的值。可以使用线性表（顺序表或链表）表示多项式系数或非零项（系数+指数）来进行计算。",
                "时间复杂度": "O(n)（若使用秦九韶算法）或更高（取决于幂运算实现和多项式表示）",
                "空间复杂度": "O(1)（若不考虑存储多项式的空间）",
                "设计思想": "数值计算、累加",
                "适用场景": "数学计算"
            }
        },
        {
            "type": "算法",
            "ID": "02ALG014",
            "name": "多项式加法",
            "attributes": {
                "难度": "中等",
                "内容": "计算两个多项式 P1(x) 和 P2(x) 的和 P3(x)。通常使用链表表示非零项，通过合并两个有序链表（按指数排序）来实现。",
                "时间复杂度": "O(m+n)，其中m和n分别为两个多项式的项数。",
                "空间复杂度": "O(m+n)（用于存储结果多项式）",
                "设计思想": "合并、归并",
                "适用场景": "符号计算、代数运算"
            }
        },
        {
            "type": "数据结构",
            "ID": "03DS002",
            "name": "稀疏矩阵",
            "attributes": {
                "难度": "中等",
                "内容": "非零元素的个数远远小于零元素的个数的矩阵。通常使用三元组线性表来存储非零元素以节省空间。",
                "存储开销": "主要取决于非零元素的个数，远小于使用二维数组存储整个矩阵的开销。",
                "核心特性": "稀疏性"
            }
        },
        {
            "type": "数据结构",
            "ID": "03DS003",
            "name": "广义表",
            "attributes": {
                "难度": "中等",
                "内容": "线性表的推广，是n(n≥0)个元素的一个有限序列，其元素可以是单元素或子表。是一种递归的数据结构。",
                "存储开销": "通常采用动态链接结构，开销取决于元素和子表的总数及嵌套深度。",
                "核心特性": "递归结构、元素可以是原子或子表"
            }
        },
        {
            "type": "概念",
            "ID": "03CON001",
            "name": "空集",
            "attributes": {
                "难度": "入门",
                "内容": "不包含任何元素的集合，其长度为0。"
            }
        },
        {
            "type": "概念",
            "ID": "03CON002",
            "name": "集合的抽象数据类型",
            "attributes": {
                "难度": "入门",
                "内容": "定义了集合的数据（一个集合S）和操作（如初始化、清空、求长度、判空、判断元素归属、插入、删除、并、交、差等）。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG001",
            "name": "初始化集合",
            "attributes": {
                "难度": "入门",
                "内容": "将集合设置为空集。对于动态顺序存储，分配初始空间并将长度置0；对于链式存储，将头指针置NULL。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)（不计结构本身空间）",
                "设计思想": "初始化",
                "适用场景": "创建新的集合对象时。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG002",
            "name": "清除集合",
            "attributes": {
                "难度": "入门",
                "内容": "移除集合中的所有元素。对于动态存储，需要释放分配的空间。",
                "时间复杂度": "O(1)（顺序动态数组释放）或 O(n)（链表逐个释放）",
                "空间复杂度": "O(1)",
                "设计思想": "资源释放",
                "适用场景": "销毁集合对象或重用前清空。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG003",
            "name": "求集合长度",
            "attributes": {
                "难度": "入门",
                "内容": "返回集合中元素的个数。",
                "时间复杂度": "O(1)（顺序存储）或 O(n)（链式存储）",
                "空间复杂度": "O(1)",
                "设计思想": "计数",
                "适用场景": "获取集合大小。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG004",
            "name": "判断集合是否为空",
            "attributes": {
                "难度": "入门",
                "内容": "检查集合长度是否为0。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "状态检查",
                "适用场景": "在进行某些操作（如删除）前检查集合状态。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG005",
            "name": "判断元素是否属于集合",
            "attributes": {
                "难度": "入门",
                "内容": "在集合中查找是否存在指定元素。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "顺序查找",
                "适用场景": "检查元素成员资格。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG006",
            "name": "输出集合元素",
            "attributes": {
                "难度": "入门",
                "内容": "遍历并打印集合中的所有元素。可以实现无序输出或有序输出（需额外排序）。",
                "时间复杂度": "O(n)（无序）或 O(n^2)（若使用简单选择排序等进行有序输出）",
                "空间复杂度": "O(1)（无序）或 O(n)（有序输出临时数组）",
                "设计思想": "遍历",
                "适用场景": "展示集合内容。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG007",
            "name": "查找集合元素",
            "attributes": {
                "难度": "入门",
                "内容": "在集合中查找指定元素，若找到则返回该元素的完整信息。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "顺序查找",
                "适用场景": "获取集合中特定元素的数据。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG008",
            "name": "修改集合元素",
            "attributes": {
                "难度": "入门",
                "内容": "在集合中查找指定元素（通常通过关键字），若找到则用新值更新该元素。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "查找与更新",
                "适用场景": "更新集合中已存在的元素信息。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG009",
            "name": "向集合插入元素",
            "attributes": {
                "难度": "入门",
                "内容": "首先检查元素是否已存在，若不存在则添加到集合中。对于顺序存储，可能需要检查空间并进行扩容。",
                "时间复杂度": "平均O(n)（查找）+ 可能的O(n)（扩容）或 O(1)（链表头插）",
                "空间复杂度": "O(1)（均摊）",
                "设计思想": "查找与添加",
                "适用场景": "向集合中增加新元素。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG010",
            "name": "从集合删除元素",
            "attributes": {
                "难度": "入门",
                "内容": "在集合中查找指定元素，若找到则移除。对于顺序存储，通常用末尾元素填补空位；对于链式存储，修改指针。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "查找与移除",
                "适用场景": "从集合中移除元素。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG011",
            "name": "求集合并集",
            "attributes": {
                "难度": "入门",
                "内容": "计算两个集合S1和S2的并集，结果存入新集合S。将S1复制到S，然后将S2中不在S中的元素插入S。",
                "时间复杂度": "O(n*m)（基本实现）",
                "空间复杂度": "O(n+m)（结果集）",
                "设计思想": "合并与去重",
                "适用场景": "计算两个集合的所有元素的组合。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG012",
            "name": "求集合交集",
            "attributes": {
                "难度": "入门",
                "内容": "计算两个集合S1和S2的交集，结果存入新集合S。遍历S2，检查每个元素是否在S1中，若在则插入S。",
                "时间复杂度": "O(n*m)",
                "空间复杂度": "O(min(n, m))（结果集）",
                "设计思想": "查找共同元素",
                "适用场景": "找出两个集合共有的元素。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG013",
            "name": "求集合差集",
            "attributes": {
                "难度": "入门",
                "内容": "计算两个集合S1和S2的差集 (S1-S2)，结果存入新集合S。遍历S1，检查每个元素是否在S2中，若不在则插入S。",
                "时间复杂度": "O(n*m)",
                "空间复杂度": "O(n)（结果集）",
                "设计思想": "排除共同元素",
                "适用场景": "找出只存在于第一个集合而不存在于第二个集合的元素。"
            }
        },
        {
            "type": "概念",
            "ID": "03CON005",
            "name": "三元组",
            "attributes": {
                "难度": "入门",
                "内容": "由三个数据项组成的有序对，在稀疏矩阵中通常指 (行号, 列号, 元素值)。"
            }
        },
        {
            "type": "数据结构",
            "ID": "03DS005",
            "name": "三元组线性表",
            "attributes": {
                "难度": "入门",
                "内容": "用一个线性表（顺序或链式）存储稀疏矩阵的非零元素的三元组 (行号, 列号, 值)，通常按行号主序、列号辅序排列。",
                "存储开销": "存储非零元素的个数 * 3 + 存储矩阵维度信息。",
                "核心特性": "紧凑存储稀疏矩阵非零元"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG014",
            "name": "稀疏矩阵转置",
            "attributes": {
                "难度": "中等",
                "内容": "计算稀疏矩阵的转置矩阵，即将原矩阵的(i, j)处的元素放到新矩阵的(j, i)处。有普通转置和快速转置等方法。",
                "时间复杂度": "依赖具体实现（如O(n*t)或O(n+t))",
                "空间复杂度": "O(t)（存储转置结果）",
                "设计思想": "行列互换",
                "适用场景": "需要对稀疏矩阵进行转置操作时。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG015",
            "name": "普通转置",
            "attributes": {
                "难度": "中等",
                "内容": "一种稀疏矩阵转置算法，按列扫描原三元组表，将对应列的元素转换后写入新的三元组表。",
                "时间复杂度": "O(列数 * 非零元素数)",
                "空间复杂度": "O(非零元素数)",
                "设计思想": "按列扫描转换",
                "适用场景": "实现稀疏矩阵转置的基础方法。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG016",
            "name": "快速转置",
            "attributes": {
                "难度": "中等",
                "内容": "一种优化的稀疏矩阵转置算法，通过两次扫描三元组表完成。第一次统计每列非零元个数确定在新表中的起始位置，第二次直接放置元素。",
                "时间复杂度": "O(列数 + 非零元素数)",
                "空间复杂度": "O(列数 + 非零元素数)",
                "设计思想": "空间换时间、预计算位置",
                "适用场景": "高效进行稀疏矩阵转置。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG017",
            "name": "稀疏矩阵加法",
            "attributes": {
                "难度": "中等",
                "内容": "计算两个相同维度的稀疏矩阵的和。通常需要遍历两个矩阵的三元组表（或链表），合并对应位置的元素。",
                "时间复杂度": "O(M1.t + M2.t)（对于链接存储）",
                "空间复杂度": "O(M1.t + M2.t)（最坏情况）",
                "设计思想": "按行（或整体）合并",
                "适用场景": "计算两个稀疏矩阵的和。"
            }
        },
        {
            "type": "概念",
            "ID": "03CON006",
            "name": "行指针向量",
            "attributes": {
                "难度": "中等",
                "内容": "在稀疏矩阵的带行指针向量的链接存储中，用于存储每一行对应单链表的头指针的一维数组。"
            }
        },
        {
            "type": "概念",
            "ID": "03CON007",
            "name": "十字链接存储",
            "attributes": {
                "难度": "中等",
                "内容": "稀疏矩阵的一种链式存储结构，每个非零元素结点同时属于所在行的链表和所在列的链表，需要行、列两个指针向量。"
            }
        },
        {
            "type": "概念",
            "ID": "03CON008",
            "name": "单元素",
            "attributes": {
                "难度": "入门",
                "内容": "在广义表中，指非列表类型的基本数据元素，也称原子。"
            }
        },
        {
            "type": "概念",
            "ID": "03CON009",
            "name": "子表",
            "attributes": {
                "难度": "入门",
                "内容": "在广义表中，指作为另一个广义表元素的表。"
            }
        },
        {
            "type": "概念",
            "ID": "03CON010",
            "name": "深度",
            "attributes": {
                "难度": "入门",
                "内容": "广义表中括号嵌套的最大层数。空表或仅含单元素的表深度为1。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG018",
            "name": "求广义表长度",
            "attributes": {
                "难度": "入门",
                "内容": "计算广义表顶层元素的个数。可通过遍历顶层链表实现，递归或非递归均可。",
                "时间复杂度": "O(n)（n为顶层元素个数）",
                "空间复杂度": "O(1)（非递归）或 O(n)（递归）",
                "设计思想": "遍历计数",
                "适用场景": "获取广义表顶层的元素数量。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG019",
            "name": "求广义表深度",
            "attributes": {
                "难度": "中等",
                "内容": "计算广义表中括号嵌套的最大层数。通常使用递归实现，深度等于所有子表深度的最大值加1。",
                "时间复杂度": "O(N)（N为表中结点总数）",
                "空间复杂度": "O(m)（m为广义表深度，递归栈开销）",
                "设计思想": "递归遍历",
                "适用场景": "分析广义表的嵌套层级。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG020",
            "name": "建立广义表",
            "attributes": {
                "难度": "中等",
                "内容": "根据给定的字符串表示（如'(a,(b,c))'）构建广义表的链接存储结构。通常使用递归实现。",
                "时间复杂度": "O(N)（N为输入字符串长度或结点数）",
                "空间复杂度": "O(N)（递归栈开销）",
                "设计思想": "递归构建",
                "适用场景": "从外部表示创建广义表内存结构。"
            }
        },
        {
            "type": "算法",
            "ID": "03ALG021",
            "name": "打印广义表",
            "attributes": {
                "难度": "中等",
                "内容": "将广义表的链接存储结构转换回其字符串表示形式并输出。通常使用递归实现。",
                "时间复杂度": "O(N)（N为表中结点总数）",
                "空间复杂度": "O(m)（m为广义表深度，递归栈开销）",
                "设计思想": "递归遍历与格式化输出",
                "适用场景": "展示广义表内容。"
            }
        },
        {
            "type": "数据结构",
            "ID": "04DS001",
            "name": "栈",
            "attributes": {
                "难度": "入门",
                "内容": "一种运算受限的线性表，仅允许在表的一端（栈顶）进行插入（入栈）和删除（出栈）运算。具有后进先出（LIFO）的特性。也称堆栈。",
                "存储开销": "顺序存储需要预分配空间或动态扩展，链式存储需要额外指针开销。",
                "核心特性": "后进先出 (LIFO)"
            }
        },
        {
            "type": "数据结构",
            "ID": "04DS002",
            "name": "队列",
            "attributes": {
                "难度": "入门",
                "内容": "一种运算受限的线性表，允许在表的一端（队尾）进行插入（入队），在另一端（队首）进行删除（出队）。具有先进先出（FIFO）的特性。",
                "存储开销": "顺序存储（循环队列）需要预分配空间或动态扩展，链式存储需要额外指针开销。",
                "核心特性": "先进先出 (FIFO)"
            }
        },
        {
            "type": "数据结构",
            "ID": "04DS004",
            "name": "循环队列",
            "attributes": {
                "难度": "入门",
                "内容": "利用取模运算将顺序存储的队列空间视为一个环状空间，以解决顺序队列的“假溢出”问题。",
                "存储开销": "固定大小数组，可能牺牲一个存储单元以区分队空和队满，或使用计数器。",
                "核心特性": "先进先出 (FIFO)、空间循环利用"
            }
        },
        {
            "type": "数据结构",
            "ID": "04DS005",
            "name": "优先级队列",
            "attributes": {
                "难度": "中等",
                "内容": "一种特殊的队列，其中的元素带有优先级。出队时，优先级最高的元素最先出队。通常使用堆实现。",
                "存储开销": "通常基于堆实现，存储开销类似堆。",
                "核心特性": "按优先级出队"
            }
        },
        {
            "type": "概念",
            "ID": "04CON001",
            "name": "栈顶",
            "attributes": {
                "难度": "入门",
                "内容": "栈允许进行插入和删除操作的一端。栈顶元素是最后插入且最先被删除的元素。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON002",
            "name": "栈底",
            "attributes": {
                "难度": "入门",
                "内容": "栈不允许进行插入和删除操作的一端，与栈顶相对。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON003",
            "name": "队首",
            "attributes": {
                "难度": "入门",
                "内容": "队列允许进行删除操作的一端。队首元素是最先进入队列且最先被删除的元素。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON004",
            "name": "队尾",
            "attributes": {
                "难度": "入门",
                "内容": "队列允许进行插入操作的一端。新元素总是插入到队尾。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON005",
            "name": "后进先出",
            "attributes": {
                "难度": "入门",
                "内容": "Last-In, First-Out (LIFO)。描述了栈的操作特性，即最后进入栈的元素最先离开栈。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON006",
            "name": "先进先出",
            "attributes": {
                "难度": "入门",
                "内容": "First-In, First-Out (FIFO)。描述了队列的操作特性，即最先进入队列的元素最先离开队列。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON008",
            "name": "中缀表示",
            "attributes": {
                "难度": "入门",
                "内容": "一种常见的算术表达式表示法，其中运算符位于其操作数之间。计算时需要考虑运算符优先级和括号。"
            }
        },
        {
            "type": "概念",
            "ID": "04CON009",
            "name": "后缀表示",
            "attributes": {
                "难度": "入门",
                "内容": "也称为逆波兰表示法（Reverse Polish Notation, RPN）。一种算术表达式表示法，其中运算符位于其操作数之后。计算时无需考虑优先级和括号，通常使用栈进行求值。"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG001",
            "name": "入栈",
            "attributes": {
                "难度": "入门",
                "内容": "将元素添加到栈顶的操作。顺序栈中top指针加1并赋值，链栈中创建新节点并修改头指针。",
                "时间复杂度": "O(1)（顺序栈不考虑扩容）",
                "空间复杂度": "O(1)",
                "设计思想": "栈的基本操作",
                "适用场景": "向栈中添加元素"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG002",
            "name": "出栈",
            "attributes": {
                "难度": "入门",
                "内容": "删除并（可选地）返回栈顶元素的操作。顺序栈中取值并top指针减1，链栈中取值、修改头指针并释放原头结点。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "栈的基本操作",
                "适用场景": "从栈中移除并获取元素"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG003",
            "name": "读取栈顶元素",
            "attributes": {
                "难度": "入门",
                "内容": "返回栈顶元素的值，但不删除它。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "栈的基本操作",
                "适用场景": "查看栈顶元素而不修改栈"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG004",
            "name": "判断栈空",
            "attributes": {
                "难度": "入门",
                "内容": "检查栈中是否包含元素。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "栈的基本操作",
                "适用场景": "执行出栈或读取栈顶前的检查"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG005",
            "name": "初始化栈",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空栈。顺序栈中设置top为-1或0（取决于实现），链栈中设置头指针为NULL。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)（不计存储空间本身）",
                "设计思想": "栈的构造",
                "适用场景": "使用栈之前"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG006",
            "name": "清空栈",
            "attributes": {
                "难度": "入门",
                "内容": "移除栈中所有元素，使其变为空栈，并可能释放相关资源。",
                "时间复杂度": "O(1)（顺序栈），O(n)（链栈，需遍历释放节点）",
                "空间复杂度": "O(1)",
                "设计思想": "栈的重置或销毁",
                "适用场景": "重用栈或释放内存"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG007",
            "name": "入队",
            "attributes": {
                "难度": "入门",
                "内容": "将元素添加到队尾的操作。",
                "时间复杂度": "O(1)（循环队列不考虑扩容，链队需要维护尾指针）",
                "空间复杂度": "O(1)",
                "设计思想": "队列的基本操作",
                "适用场景": "向队列中添加元素"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG008",
            "name": "出队",
            "attributes": {
                "难度": "入门",
                "内容": "删除并（可选地）返回队首元素的操作。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "队列的基本操作",
                "适用场景": "从队列中移除并获取元素"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG009",
            "name": "读取队首元素",
            "attributes": {
                "难度": "入门",
                "内容": "返回队首元素的值，但不删除它。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "队列的基本操作",
                "适用场景": "查看队首元素而不修改队列"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG010",
            "name": "判断队列空",
            "attributes": {
                "难度": "入门",
                "内容": "检查队列中是否包含元素。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "队列的基本操作",
                "适用场景": "执行出队或读取队首前的检查"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG011",
            "name": "初始化队列",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空队列。循环队列中设置front=rear=0，链队中设置front=rear=NULL。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)（不计存储空间本身）",
                "设计思想": "队列的构造",
                "适用场景": "使用队列之前"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG012",
            "name": "清空队列",
            "attributes": {
                "难度": "入门",
                "内容": "移除队列中所有元素，使其变为空队列，并可能释放相关资源。",
                "时间复杂度": "O(1)（循环队列），O(n)（链队，需遍历释放节点）",
                "空间复杂度": "O(1)",
                "设计思想": "队列的重置或销毁",
                "适用场景": "重用队列或释放内存"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG013",
            "name": "后缀表达式求值",
            "attributes": {
                "难度": "中等",
                "内容": "使用栈计算后缀表示（逆波兰表示）的算术表达式的值。遇到操作数则入栈，遇到运算符则弹出所需操作数进行计算，结果再入栈。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(n)（栈空间）",
                "设计思想": "栈应用",
                "适用场景": "计算无需括号和优先级的表达式"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG014",
            "name": "中缀转后缀",
            "attributes": {
                "难度": "中等",
                "内容": "将中缀表示的算术表达式转换为等价的后缀表示。使用栈来暂存运算符，根据运算符优先级和括号规则进行转换。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(n)（栈空间）",
                "设计思想": "栈应用",
                "适用场景": "表达式求值预处理"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG015",
            "name": "括号配对检查",
            "attributes": {
                "难度": "入门",
                "内容": "检查一个包含括号（如(), [], {}）的字符串中的括号是否正确配对。使用栈，遇到左括号入栈，遇到右括号检查栈顶是否匹配，若匹配则出栈，否则错误。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(n)（栈空间）",
                "设计思想": "栈应用",
                "适用场景": "语法检查、代码编辑"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG016",
            "name": "进制转换",
            "attributes": {
                "难度": "入门",
                "内容": "将一个十进制数转换为其他进制（如二进制、八进制、十六进制）的表示。通常使用除基取余法，将余数依次入栈，最后依次出栈得到结果。",
                "时间复杂度": "O(log_r N)，r为目标基数，N为数值",
                "空间复杂度": "O(log_r N)（栈空间）",
                "设计思想": "栈应用",
                "适用场景": "数值表示转换"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG017",
            "name": "递归阶乘",
            "attributes": {
                "难度": "入门",
                "内容": "使用递归方法计算非负整数n的阶乘 (n!)。递归关系为 f(n) = n * f(n-1)，基本情况为 f(0) = 1。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(n)（递归栈深度）",
                "设计思想": "递归",
                "适用场景": "教学示例、简单递归问题"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG018",
            "name": "布尔量组合输出",
            "attributes": {
                "难度": "中等",
                "内容": "输出n个布尔变量所有可能的2^n种取值组合。通常使用递归实现，每次递归决定一位是0还是1。",
                "时间复杂度": "O(n * 2^n)（包含输出时间）",
                "空间复杂度": "O(n)（递归栈深度）",
                "设计思想": "递归、回溯",
                "适用场景": "组合生成、状态枚举"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG019",
            "name": "全排列",
            "attributes": {
                "难度": "中等",
                "内容": "生成n个不同元素的所有n!种排列顺序。通常使用递归和交换策略实现。",
                "时间复杂度": "O(n * n!)（包含输出时间）",
                "空间复杂度": "O(n)（递归栈深度）",
                "设计思想": "递归、回溯",
                "适用场景": "排列生成、组合优化问题探索"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG020",
            "name": "迷宫求解",
            "attributes": {
                "难度": "中等",
                "内容": "寻找从迷宫入口到出口的一条路径。可以使用递归（深度优先搜索）或队列（广度优先搜索）实现。递归方法中系统隐式使用栈，非递归DFS显式使用栈。",
                "时间复杂度": "O(m*n)（m, n为迷宫维度）",
                "空间复杂度": "O(m*n)（递归栈深度或辅助空间）",
                "设计思想": "递归、回溯、深度优先搜索、栈应用",
                "适用场景": "路径查找、图搜索"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG021",
            "name": "汉诺塔",
            "attributes": {
                "难度": "中等",
                "内容": "解决经典的汉诺塔问题，将n个盘子从源柱借助辅助柱移动到目标柱。标准的解决方案是递归的。",
                "时间复杂度": "O(2^n)",
                "空间复杂度": "O(n)（递归栈深度）",
                "设计思想": "递归、分治",
                "适用场景": "教学示例、递归思维训练"
            }
        },
        {
            "type": "算法",
            "ID": "04ALG022",
            "name": "渡口管理模拟",
            "attributes": {
                "难度": "中等",
                "内容": "模拟轮船渡口的车辆管理，根据特定规则（车辆类型、到达顺序、装载限制）安排车辆上船。通常使用队列来管理等待的车辆。",
                "时间复杂度": "取决于模拟的复杂度和事件数量",
                "空间复杂度": "O(N)（N为等待车辆数，队列空间）",
                "设计思想": "队列应用、模拟",
                "适用场景": "事件驱动模拟、资源调度"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS001",
            "name": "树",
            "attributes": {
                "难度": "入门",
                "内容": "重要的非线性数据结构，由n(n>=0)个有限结点组成一个具有层次关系的集合。递归定义：空树或由一个根结点及m(m>=0)棵互不相交的子树构成。",
                "存储开销": "依赖于具体存储方式（顺序、链式）",
                "核心特性": "层次结构、递归定义、非线性"
            }
        },
        {
            "type": "概念",
            "ID": "05CON002",
            "name": "子树",
            "attributes": {
                "难度": "入门",
                "内容": "非空树中除根结点外，其余结点按关系划分成的m(m>=0)棵互不相交的树，每棵子树本身也是一棵树。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON004",
            "name": "度",
            "attributes": {
                "难度": "入门",
                "内容": "结点的度指结点拥有的子树（或后继结点）的个数。树的度指树中所有结点度的最大值。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON007",
            "name": "孩子结点",
            "attributes": {
                "难度": "入门",
                "内容": "一个结点的子树的根结点，也称为该结点的子女或后继。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON008",
            "name": "双亲结点",
            "attributes": {
                "难度": "入门",
                "内容": "孩子结点的前驱结点，也称为父结点。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON009",
            "name": "兄弟结点",
            "attributes": {
                "难度": "入门",
                "内容": "具有相同双亲结点的孩子结点。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON012",
            "name": "有序树",
            "attributes": {
                "难度": "入门",
                "内容": "树中任意结点的各子树是按一定次序从左到右排列的，不能互换次序。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON013",
            "name": "无序树",
            "attributes": {
                "难度": "入门",
                "内容": "树中任意结点的各子树之间没有次序关系，可以任意交换位置。"
            }
        },
        {
            "type": "概念",
            "ID": "05CON014",
            "name": "森林",
            "attributes": {
                "难度": "入门",
                "内容": "m(m>=0)棵互不相交的树的集合。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS002",
            "name": "二叉树",
            "attributes": {
                "难度": "入门",
                "内容": "度不超过2的有序树。递归定义：空树或由一个根结点和两棵互不相交的左、右子树组成，左右子树也都是二叉树。",
                "存储开销": "依赖顺序或链式存储",
                "核心特性": "有序性、度最多为2、左右子树不能任意互换"
            }
        },
        {
            "type": "概念",
            "ID": "05CON015",
            "name": "k叉树",
            "attributes": {
                "难度": "中等",
                "内容": "树的度为k的树，即每个结点的度最多为k。"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS003",
            "name": "满二叉树",
            "attributes": {
                "难度": "中等",
                "内容": "深度为h且具有2^h-1个结点的二叉树。除叶子结点外，每个结点的度都为2。",
                "存储开销": "若用顺序存储则无空间浪费",
                "核心特性": "结构规整、每层结点数满"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS004",
            "name": "完全二叉树",
            "attributes": {
                "难度": "中等",
                "内容": "深度为h，具有n个结点的二叉树，其结点编号与深度为h的满二叉树中编号1到n的结点一一对应。特性是除最后一层外，其余各层均是满的，且最后一层的结点都连续集中在最左边。",
                "存储开销": "适合顺序存储，空间利用率高",
                "核心特性": "结点编号与数组下标有对应关系、堆的基础结构"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS005",
            "name": "理想平衡二叉树",
            "attributes": {
                "难度": "中等",
                "内容": "除最后一层外，其余各层都是满的二叉树，最后一层结点可以任意分布。包含满二叉树和完全二叉树。",
                "存储开销": "依赖具体实现",
                "核心特性": "层数尽可能少，深度接近log2(n)"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS006",
            "name": "二叉树顺序存储",
            "attributes": {
                "难度": "入门",
                "内容": "使用一维数组存储二叉树结点，通常按层序遍历的顺序将结点存入数组，空结点用特定值表示。通过下标计算父子关系。",
                "存储开销": "对于完全二叉树空间效率高，对于一般二叉树（尤其单支树）可能浪费大量空间。",
                "核心特性": "利用数组下标隐式表示结点关系、适合完全二叉树"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS007",
            "name": "二叉链表",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树的链式存储结构，每个结点包含数据域、指向左孩子的指针域和指向右孩子的指针域。",
                "存储开销": "每个结点需要额外存储两个指针的空间",
                "核心特性": "灵活表示任意形态二叉树、插入删除操作相对方便"
            }
        },
        {
            "type": "概念",
            "ID": "05CON016",
            "name": "树根指针",
            "attributes": {
                "难度": "入门",
                "内容": "在树的链式存储结构中，指向树的根结点的指针。"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG001",
            "name": "二叉树遍历",
            "attributes": {
                "难度": "入门",
                "内容": "按照特定规则访问二叉树中的所有结点，且每个结点仅被访问一次。常见的有前序、中序、后序、层序遍历。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h) 或 O(w)",
                "设计思想": "递归或迭代（使用栈或队列）",
                "适用场景": "访问、处理、查找、复制、销毁树中所有结点"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG002",
            "name": "前序遍历",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树遍历的一种方式：先访问根结点，然后前序遍历左子树，再前序遍历右子树 (DLR)。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h) (递归栈)",
                "设计思想": "递归",
                "适用场景": "构建表达式树的前缀表示、树的复制"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG003",
            "name": "中序遍历",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树遍历的一种方式：先中序遍历左子树，然后访问根结点，再中序遍历右子树 (LDR)。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h) (递归栈)",
                "设计思想": "递归",
                "适用场景": "对二叉搜索树进行排序输出"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG004",
            "name": "后序遍历",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树遍历的一种方式：先后序遍历左子树，再后序遍历右子树，最后访问根结点 (LRD)。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h) (递归栈)",
                "设计思想": "递归",
                "适用场景": "计算表达式树的值、释放树结点空间"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG005",
            "name": "层序遍历",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树遍历的一种方式：从上到下、从左到右逐层访问结点。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(w) (w为树的最大宽度，使用队列)",
                "设计思想": "迭代 (使用队列)",
                "适用场景": "求树的宽度、图的广度优先搜索"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG006",
            "name": "初始化二叉树",
            "attributes": {
                "难度": "入门",
                "内容": "创建一个空的二叉树，通常是将根指针置为NULL。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "赋值",
                "适用场景": "开始构建新树之前"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG007",
            "name": "建立二叉树",
            "attributes": {
                "难度": "中等",
                "内容": "根据给定的输入序列（如广义表、前序+中序序列等）构造二叉树的内存表示（通常是二叉链表）。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h) (递归或栈)",
                "设计思想": "递归或迭代（栈辅助）",
                "适用场景": "从外部数据源恢复或构建二叉树结构"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG008",
            "name": "判空二叉树",
            "attributes": {
                "难度": "入门",
                "内容": "检查二叉树是否为空树。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "判断根指针是否为NULL",
                "适用场景": "在对树进行操作前进行检查"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG009",
            "name": "求二叉树深度",
            "attributes": {
                "难度": "入门",
                "内容": "计算二叉树的最大层数。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h) (递归栈)",
                "设计思想": "递归（深度 = max(左子树深度, 右子树深度) + 1）",
                "适用场景": "分析树的平衡性、评估算法空间复杂度"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG010",
            "name": "查找二叉树结点",
            "attributes": {
                "难度": "入门",
                "内容": "在二叉树中搜索具有特定值的结点。",
                "时间复杂度": "O(n) (最坏情况，对于非搜索树)",
                "空间复杂度": "O(h) (递归栈)",
                "设计思想": "递归遍历（类似前序）",
                "适用场景": "定位树中特定数据"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG011",
            "name": "输出二叉树",
            "attributes": {
                "难度": "入门",
                "内容": "将二叉树的结构以某种人类可读的格式（如广义表）打印出来。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h) (递归栈)",
                "设计思想": "递归遍历（类似前序）",
                "适用场景": "调试、可视化树结构"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG012",
            "name": "清除二叉树",
            "attributes": {
                "难度": "入门",
                "内容": "释放二叉树中所有结点占用的内存空间，使树变为空树。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h) (递归栈)",
                "设计思想": "递归（类似后序遍历）",
                "适用场景": "程序结束前或不再需要树时回收资源"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS010",
            "name": "树的顺序存储",
            "attributes": {
                "难度": "中等",
                "内容": "使用一维数组存储k叉树结点，结点按特定规则编号，通过下标计算父子关系。适合满k叉树或完全k叉树。",
                "存储开销": "对于非满/完全树空间浪费严重",
                "核心特性": "通过下标计算关系，结构固定"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS011",
            "name": "树的标准链接存储",
            "attributes": {
                "难度": "中等",
                "内容": "树的链式存储方式，每个结点包含数据域和k个指针域，分别指向k个孩子结点（k为树的度）。",
                "存储开销": "指针开销大，尤其当k大且结点度不一时存储密度低。",
                "核心特性": "直接表示父子关系，结构灵活"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS012",
            "name": "树的广义标准链接存储",
            "attributes": {
                "难度": "中等",
                "内容": "在标准链接存储的基础上，为每个结点增加一个指向其双亲结点的指针域。",
                "存储开销": "比标准方式需要更多指针空间",
                "核心特性": "方便查找孩子和双亲结点"
            }
        },
        {
            "type": "数据结构",
            "ID": "05DS013",
            "name": "树的二叉树表示法",
            "attributes": {
                "难度": "中等",
                "内容": "也称孩子兄弟表示法。将任意树转换为二叉树进行存储。结点的左指针指向其第一个孩子，右指针指向其下一个兄弟。",
                "存储开销": "与二叉链表相同",
                "核心特性": "将多叉树问题转化为二叉树问题处理，存储结构统一"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG013",
            "name": "树遍历",
            "attributes": {
                "难度": "入门",
                "内容": "按照特定规则访问树中的所有结点，且每个结点仅被访问一次。常见有先根、后根、层序遍历。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h) 或 O(w)",
                "设计思想": "递归或迭代",
                "适用场景": "访问、处理树中所有结点"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG014",
            "name": "先根遍历",
            "attributes": {
                "难度": "入门",
                "内容": "树遍历的一种方式：先访问根结点，然后从左到右依次先根遍历根的各棵子树。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归",
                "适用场景": "树的结构性操作"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG015",
            "name": "后根遍历",
            "attributes": {
                "难度": "入门",
                "内容": "树遍历的一种方式：先从左到右依次后根遍历根的各棵子树，最后访问根结点。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归",
                "适用场景": "计算依赖子树结果的操作、销毁树"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG016",
            "name": "树的层序遍历",
            "attributes": {
                "难度": "入门",
                "内容": "树遍历的一种方式：按照从上到下、同一层从左到右的次序访问结点。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(w)",
                "设计思想": "迭代（使用队列）",
                "适用场景": "广度优先搜索相关问题"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG017",
            "name": "建立树",
            "attributes": {
                "难度": "中等",
                "内容": "根据给定的输入序列（如广义表）构造树的内存表示（如k叉链表）。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "迭代（栈辅助）",
                "适用场景": "从外部数据源构建树结构"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG018",
            "name": "查找树结点",
            "attributes": {
                "难度": "入门",
                "内容": "在（普通）树中搜索具有特定值的结点。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归（类似先根遍历）",
                "适用场景": "定位树中特定数据"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG019",
            "name": "输出树",
            "attributes": {
                "难度": "入门",
                "内容": "将（普通）树的结构以某种人类可读的格式（如广义表）打印出来。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归（类似先根遍历）",
                "适用场景": "调试、可视化树结构"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG020",
            "name": "求树深度",
            "attributes": {
                "难度": "入门",
                "内容": "计算（普通）树的最大层数。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归",
                "适用场景": "分析树的高度相关特性"
            }
        },
        {
            "type": "算法",
            "ID": "05ALG021",
            "name": "清除树",
            "attributes": {
                "难度": "入门",
                "内容": "释放（普通）树中所有结点占用的内存空间，使树变为空树。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(h)",
                "设计思想": "递归（类似后根遍历）",
                "适用场景": "回收树占用的资源"
            }
        },
        {
            "type": "数据结构",
            "ID": "06DS001",
            "name": "二叉搜索树",
            "attributes": {
                "难度": "中等",
                "内容": "又称二叉排序树，它或是一棵空树，或者是一棵具有如下特性的非空二叉树：(1) 若它的左子树非空，则左子树上所有结点的关键字均小于根结点的关键字；(2) 若它的右子树非空，则右子树上所有结点的关键字均大于（或大于等于）根结点的关键字；(3) 左、右子树本身又各是一棵二叉搜索树。中序遍历结果为有序序列。适用于需要高效查找、插入、删除有序数据的场景。",
                "存储开销": "通常采用链式存储，空间复杂度与节点数成正比 O(n)。",
                "核心特性": "有序性（中序遍历）、可查找性"
            }
        },
        {
            "type": "数据结构",
            "ID": "06DS002",
            "name": "堆",
            "attributes": {
                "难度": "中等",
                "内容": "一种特殊的完全二叉树。分为小根堆（父节点值小于等于子节点值）和大根堆（父节点值大于等于子节点值）。堆顶元素分别是最小值或最大值。常用于实现优先队列。",
                "存储开销": "通常采用顺序存储（数组），空间效率高 O(n)。",
                "核心特性": "堆序性（父子节点关系）、完全二叉树结构"
            }
        },
        {
            "type": "数据结构",
            "ID": "06DS003",
            "name": "哈夫曼树",
            "attributes": {
                "难度": "中等",
                "内容": "又称最优二叉树，指n个带权叶子结点构成的所有二叉树中，带权路径长度（WPL）最小的二叉树。构造算法基于贪心策略，权值越大的叶子离根越近。常用于哈夫曼编码。",
                "存储开销": "通常采用链式存储，空间复杂度与节点数（叶子+内部）成正比 O(n)。",
                "核心特性": "最优性（WPL最小）、带权特性"
            }
        },
        {
            "type": "数据结构",
            "ID": "06DS004",
            "name": "线索二叉树",
            "attributes": {
                "难度": "中等",
                "内容": "利用二叉链表中的空指针域（线索）指向结点在某种遍历次序下的前驱或后继的二叉树。增加了ltag和rtag标志位。目的是为了快速查找前驱/后继，实现非递归遍历。",
                "存储开销": "链式存储，每个节点增加两个标志位，空间复杂度略高于普通二叉链表 O(n)。",
                "核心特性": "线索化、便于查找前驱/后继"
            }
        },
        {
            "type": "数据结构",
            "ID": "06DS005",
            "name": "平衡二叉树",
            "attributes": {
                "难度": "高级",
                "内容": "又称AVL树，是一种自平衡的二叉搜索树。其任何节点的左、右子树高度差的绝对值不超过1（平衡因子为-1, 0, 1）。通过旋转操作（LL, RR, LR, RL）在插入/删除后维持平衡，保证操作的时间复杂度。",
                "存储开销": "链式存储，每个节点需要额外存储平衡因子，空间复杂度 O(n)。",
                "核心特性": "平衡性、自调整性"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG001",
            "name": "二叉搜索树查找",
            "attributes": {
                "难度": "中等",
                "内容": "根据二叉搜索树的性质，比较目标值与当前节点值，决定向左子树或右子树递归查找。有递归和非递归实现。",
                "时间复杂度": "平均O(log n)，最坏O(n)",
                "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
                "设计思想": "分治",
                "适用场景": "在二叉搜索树中定位特定值的节点。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG002",
            "name": "二叉搜索树更新",
            "attributes": {
                "难度": "中等",
                "内容": "首先执行查找操作定位到目标节点，若找到则修改节点的值。实现与查找类似。",
                "时间复杂度": "平均O(log n)，最坏O(n)",
                "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
                "设计思想": "查找与修改",
                "适用场景": "修改二叉搜索树中已存在节点的值。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG003",
            "name": "二叉搜索树插入",
            "attributes": {
                "难度": "中等",
                "内容": "查找合适的插入位置（一个空链接），然后创建新节点并链接。保持二叉搜索树性质。有递归和非递归实现。",
                "时间复杂度": "平均O(log n)，最坏O(n)",
                "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
                "设计思想": "查找与链接",
                "适用场景": "向二叉搜索树添加新节点，同时保持其有序性。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG004",
            "name": "二叉搜索树删除",
            "attributes": {
                "难度": "中等",
                "内容": "查找待删除节点，分情况处理：叶子节点、单分支节点、双分支节点（通常用中序前驱或后继替换）。需要维护二叉搜索树性质。",
                "时间复杂度": "平均O(log n)，最坏O(n)",
                "空间复杂度": "递归：平均O(log n)，最坏O(n)；非递归：O(1)",
                "设计思想": "查找与替换/链接调整",
                "适用场景": "从二叉搜索树移除节点，同时保持其有序性。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG005",
            "name": "堆插入",
            "attributes": {
                "难度": "中等",
                "内容": "将新元素添加到堆的末尾（数组末尾），然后通过比较和交换操作（上滤/sift-up），将其调整到合适位置以维持堆性质。",
                "时间复杂度": "O(log n)",
                "空间复杂度": "O(1)",
                "设计思想": "上滤调整",
                "适用场景": "向堆中添加元素并保持堆序性。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG006",
            "name": "堆删除",
            "attributes": {
                "难度": "中等",
                "内容": "通常指删除堆顶元素（最大或最小值）。将堆尾元素移到堆顶，然后通过比较和交换操作（下滤/sift-down），将其调整到合适位置以恢复堆性质。",
                "时间复杂度": "O(log n)",
                "空间复杂度": "O(1)",
                "设计思想": "下滤调整",
                "适用场景": "获取并移除堆中的最值元素，同时保持堆序性。"
            }
        },
        {
            "type": "概念",
            "ID": "06CON002",
            "name": "路径",
            "attributes": {
                "难度": "入门",
                "内容": "在一棵树中，从一个结点到另一个结点所经过的结点序列。树中任意两点间的路径是唯一的。"
            }
        },
        {
            "type": "概念",
            "ID": "06CON003",
            "name": "路径长度",
            "attributes": {
                "难度": "入门",
                "内容": "一条路径上所经过的分支（边）的数量。"
            }
        },
        {
            "type": "概念",
            "ID": "06CON004",
            "name": "结点的权",
            "attributes": {
                "难度": "入门",
                "内容": "赋予树中结点的一个具有某种意义的数值。"
            }
        },
        {
            "type": "概念",
            "ID": "06CON005",
            "name": "带权路径长度",
            "attributes": {
                "难度": "入门",
                "内容": "从树根结点到某一结点之间的路径长度与该结点上权的乘积。"
            }
        },
        {
            "type": "概念",
            "ID": "06CON006",
            "name": "树的带权路径长度",
            "attributes": {
                "难度": "入门",
                "内容": "树中所有叶子结点的带权路径长度之和，记为WPL。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG007",
            "name": "构造哈夫曼树",
            "attributes": {
                "难度": "中等",
                "内容": "基于贪心策略的算法：(1) 初始化n棵单节点树；(2) 重复n-1次：选取权值最小的两棵树合并为一棵新树，新树权值为两者之和；(3) 直到只剩一棵树。通常规定左子树权值小于等于右子树权值。",
                "时间复杂度": "O(n log n)（使用优先队列优化选择最小权值）",
                "空间复杂度": "O(n)",
                "设计思想": "贪心",
                "适用场景": "构建最优二叉树，用于哈夫曼编码等。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG008",
            "name": "哈夫曼编码",
            "attributes": {
                "难度": "中等",
                "内容": "利用哈夫曼树为字符生成变长、无前缀的二进制编码。从根节点出发，向左分支记为0，向右分支记为1，到达叶子节点的路径即为该叶子对应字符的编码。出现频率高的字符编码短。",
                "时间复杂度": "取决于哈夫曼树的构建和遍历",
                "空间复杂度": "取决于存储编码和树的结构",
                "设计思想": "贪心、树遍历",
                "适用场景": "数据压缩，减少传输或存储的数据量。"
            }
        },
        {
            "type": "概念",
            "ID": "06CON007",
            "name": "线索",
            "attributes": {
                "难度": "入门",
                "内容": "在线索二叉树中，利用结点的空指针域存放的指向该结点在某种遍历次序下的前驱或后继结点的指针。分为左线索（前驱）和右线索（后继）。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG009",
            "name": "二叉树线索化",
            "attributes": {
                "难度": "中等",
                "内容": "对二叉树进行某种遍历（如中序），在遍历过程中修改结点的空指针域，使其指向前驱或后继结点，并设置线索标志位。例如中序线索化，在访问节点时处理其左线索（指向前驱）和前驱节点的右线索（指向当前节点）。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)（若递归则为O(h)，h为树高）",
                "设计思想": "树遍历、指针修改",
                "适用场景": "为二叉树添加线索，以便进行非递归、快速的前驱/后继查找和遍历。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG010",
            "name": "中序线索二叉树遍历",
            "attributes": {
                "难度": "中等",
                "内容": "利用线索进行非递归的中序遍历。首先找到中序序列的第一个节点（最左下节点），然后反复查找当前节点的后继节点（通过右线索或右子树的最左下节点）并访问，直至遍历完成。",
                "时间复杂度": "O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "指针跟踪、利用线索",
                "适用场景": "高效地、非递归地按中序访问线索二叉树的所有节点。"
            }
        },
        {
            "type": "概念",
            "ID": "06CON008",
            "name": "平衡因子",
            "attributes": {
                "难度": "入门",
                "内容": "二叉树中某个结点的左子树高度减去右子树高度的值。在平衡二叉树（AVL树）中，平衡因子只能是-1、0或1。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG011",
            "name": "LL型调整",
            "attributes": {
                "难度": "高级",
                "内容": "平衡二叉树的一种旋转操作。当在根结点A的左孩子B的左子树上插入导致A失衡（平衡因子变为2）时进行。将B提升为新的根，A成为B的右孩子，B原来的右子树成为A的左子树。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "旋转操作",
                "适用场景": "恢复平衡二叉树因LL型插入导致的失衡。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG012",
            "name": "RR型调整",
            "attributes": {
                "难度": "高级",
                "内容": "平衡二叉树的一种旋转操作。当在根结点A的右孩子B的右子树上插入导致A失衡（平衡因子变为-2）时进行。将B提升为新的根，A成为B的左孩子，B原来的左子树成为A的右子树。与LL型对称。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "旋转操作",
                "适用场景": "恢复平衡二叉树因RR型插入导致的失衡。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG013",
            "name": "LR型调整",
            "attributes": {
                "难度": "高级",
                "内容": "平衡二叉树的一种双旋转操作。当在根结点A的左孩子B的右子树（根为C）上插入导致A失衡（平衡因子变为2）时进行。先对B进行RR旋转，再对A进行LL旋转。最终C成为新的根。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "双旋转操作",
                "适用场景": "恢复平衡二叉树因LR型插入导致的失衡。"
            }
        },
        {
            "type": "算法",
            "ID": "06ALG014",
            "name": "RL型调整",
            "attributes": {
                "难度": "高级",
                "内容": "平衡二叉树的一种双旋转操作。当在根结点A的右孩子B的左子树（根为C）上插入导致A失衡（平衡因子变为-2）时进行。先对B进行LL旋转，再对A进行RR旋转。最终C成为新的根。与LR型对称。",
                "时间复杂度": "O(1)",
                "空间复杂度": "O(1)",
                "设计思想": "双旋转操作",
                "适用场景": "恢复平衡二叉树因RL型插入导致的失衡。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS001",
            "name": "图",
            "attributes": {
                "难度": "中等",
                "内容": "一种复杂的非线性数据结构，由顶点集(V)和边集(E)组成。V是顶点集合，E是V上顶点对（无序或有序）的集合，表示顶点之间的关系。",
                "存储开销": "依赖于存储结构，如邻接矩阵为O(n^2)，邻接表为O(n+e)",
                "核心特性": "非线性结构，顶点间关系复杂（多对多）"
            }
        },
        {
            "type": "概念",
            "ID": "07CON002",
            "name": "边",
            "attributes": {
                "难度": "入门",
                "内容": "连接图中两个顶点的线，表示顶点之间的关系。可以是无向边或有向边。用E表示边集合。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON004",
            "name": "无向边",
            "attributes": {
                "难度": "入门",
                "内容": "没有方向性的边，连接两个顶点，关系是双向的。在无向图中表示为无序对 (vi, vj)。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS002",
            "name": "有向图",
            "attributes": {
                "难度": "中等",
                "内容": "边集E(G)中均为有向边的图。",
                "存储开销": "依赖于存储结构，如邻接矩阵为O(n^2)，邻接表为O(n+e)",
                "核心特性": "边具有方向性"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS003",
            "name": "无向图",
            "attributes": {
                "难度": "中等",
                "内容": "边集E(G)中均为无向边的图。",
                "存储开销": "依赖于存储结构，如邻接矩阵为O(n^2)，邻接表为O(n+2e)",
                "核心特性": "边没有方向性"
            }
        },
        {
            "type": "概念",
            "ID": "07CON005",
            "name": "邻接点",
            "attributes": {
                "难度": "入门",
                "内容": "在无向图中，若存在边(vi, vj)，则vi和vj互为邻接点。在有向图中，若存在边<vi, vj>，则称vj是vi的出边邻接点，vi是vj的入边邻接点。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON006",
            "name": "出边",
            "attributes": {
                "难度": "入门",
                "内容": "在有向图中，从顶点vi出发的有向边<vi, vj>称为vi的一条出边。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON007",
            "name": "入边",
            "attributes": {
                "难度": "入门",
                "内容": "在有向图中，指向顶点vj的有向边<vi, vj>称为vj的一条入边。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON009",
            "name": "入度",
            "attributes": {
                "难度": "入门",
                "内容": "有向图中顶点v的入度是该顶点的入边的数目，记为ID(v)。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON010",
            "name": "出度",
            "attributes": {
                "难度": "入门",
                "内容": "有向图中顶点v的出度是该顶点的出边的数目，记为OD(v)。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON011",
            "name": "完全图",
            "attributes": {
                "难度": "入门",
                "内容": "无向图中每对顶点之间都存在边，或有向图中每对顶点之间都存在方向相反的两条边。n个顶点的无向完全图有n(n-1)/2条边，有向完全图有n(n-1)条边。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON012",
            "name": "稠密图",
            "attributes": {
                "难度": "入门",
                "内容": "边数接近完全图的图，即边数e接近n(n-1)数量级。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON013",
            "name": "稀疏图",
            "attributes": {
                "难度": "入门",
                "内容": "边数远少于完全图的图，通常边数e与顶点数n同数量级（e << n(n-1)）。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON014",
            "name": "子图",
            "attributes": {
                "难度": "入门",
                "内容": "设有两个图G=(V,E)和G'=(V',E')，若V'是V的子集，E'是E的子集，并且E'中所涉及到的顶点全部包含在V'中，则称G'是G的子图。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON016",
            "name": "回路",
            "attributes": {
                "难度": "入门",
                "内容": "起点和终点相同的路径，也称为环。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON017",
            "name": "简单路径",
            "attributes": {
                "难度": "入门",
                "内容": "路径序列中顶点不重复出现的路径。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON018",
            "name": "简单回路",
            "attributes": {
                "难度": "入门",
                "内容": "除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，也称为简单环。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON019",
            "name": "连通",
            "attributes": {
                "难度": "入门",
                "内容": "在无向图中，若从顶点vi到顶点vj有路径存在，则称vi和vj是连通的。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON020",
            "name": "连通图",
            "attributes": {
                "难度": "入门",
                "内容": "在无向图中，如果任意两个顶点之间都存在路径，则称此无向图为连通图。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON021",
            "name": "非连通图",
            "attributes": {
                "难度": "入门",
                "内容": "存在顶点之间不连通的无向图。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON022",
            "name": "连通分量",
            "attributes": {
                "难度": "中等",
                "内容": "无向图G的极大连通子图称为G的连通分量。连通图只有一个连通分量，非连通图有多个连通分量。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON023",
            "name": "强连通图",
            "attributes": {
                "难度": "中等",
                "内容": "在有向图中，如果对于任意两个顶点vi和vj，都存在从vi到vj和从vj到vi的路径，则称此有向图为强连通图。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON024",
            "name": "强连通分量",
            "attributes": {
                "难度": "中等",
                "内容": "有向图G的极大强连通子图称为G的强连通分量。"
            }
        },
        {
            "type": "概念",
            "ID": "07CON025",
            "name": "权",
            "attributes": {
                "难度": "入门",
                "内容": "图中每条边可以标上的具有某种含义的数值，通常为非负实数，称为该边的权(weight)。"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS004",
            "name": "带权图",
            "attributes": {
                "难度": "中等",
                "内容": "边上带有权的图，也常称做网(network)。",
                "存储开销": "同图，但边信息需额外存储权值",
                "核心特性": "边具有权重信息"
            }
        },
        {
            "type": "算法",
            "ID": "07ALG001",
            "name": "初始化图",
            "attributes": {
                "难度": "入门",
                "内容": "初始化图的存储空间，例如将邻接矩阵置零或无穷大，或将邻接表头指针置空。",
                "时间复杂度": "O(n^2)或O(n)",
                "空间复杂度": "O(1)",
                "设计思想": "初始化",
                "适用场景": "创建图之前准备存储结构"
            }
        },
        {
            "type": "算法",
            "ID": "07ALG002",
            "name": "创建图",
            "attributes": {
                "难度": "入门",
                "内容": "根据输入的顶点和边集信息，构建图的具体存储表示（如邻接矩阵、邻接表）。",
                "时间复杂度": "取决于输入方式和存储结构，通常与边数e相关",
                "空间复杂度": "O(1)（操作本身）",
                "设计思想": "构建",
                "适用场景": "从数据源生成图的内存表示"
            }
        },
        {
            "type": "算法",
            "ID": "07ALG003",
            "name": "遍历图",
            "attributes": {
                "难度": "中等",
                "内容": "按照特定规则（如深度优先或广度优先）访问图中所有可达顶点一次且仅一次。",
                "时间复杂度": "O(n+e) (邻接表) / O(n^2) (邻接矩阵)",
                "空间复杂度": "O(n) (辅助空间)",
                "设计思想": "搜索",
                "适用场景": "系统性地访问图的每个部分，是许多图算法的基础"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS005",
            "name": "邻接矩阵",
            "attributes": {
                "难度": "入门",
                "内容": "使用n阶方阵存储n个顶点之间的邻接关系。A[i][j]的值表示顶点vi到vj是否存在边（或边的权值）。",
                "存储开销": "O(n^2)",
                "核心特性": "判断边存在O(1)，求顶点度/邻接点O(n)，适合稠密图"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS006",
            "name": "邻接表",
            "attributes": {
                "难度": "入门",
                "内容": "为图中每个顶点维护一个单链表，存储所有与该顶点邻接的边（或顶点）。使用数组存储每个链表的头指针。",
                "存储开销": "O(n+e)",
                "核心特性": "节省空间（稀疏图），查找顶点所有邻接点高效，不方便查找入边（对有向图）"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS007",
            "name": "边集数组",
            "attributes": {
                "难度": "入门",
                "内容": "使用一个数组存储图中所有的边，每个数组元素包含一条边的起点、终点和权值（可选）。",
                "存储开销": "O(e)",
                "核心特性": "直观表示边，适合需要直接操作边的算法（如Kruskal），查找特定边或顶点邻接点效率低O(e)"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS008",
            "name": "逆邻接表",
            "attributes": {
                "难度": "中等",
                "内容": "邻接表的变体，用于有向图。每个顶点的链表存储所有指向该顶点的入边信息（即存储入边邻接点）。",
                "存储开销": "O(n+e)",
                "核心特性": "方便查找顶点的入边和计算入度"
            }
        },
        {
            "type": "数据结构",
            "ID": "07DS009",
            "name": "十字邻接表",
            "attributes": {
                "难度": "中等",
                "内容": "用于有向图的存储结构。每个顶点和每条边都有结点。边结点包含起点、终点、权值以及指向同起点下一条出边和同终点下一条入边的指针。",
                "存储开销": "O(n+e)",
                "核心特性": "同时方便查找顶点的出边和入边信息，以及计算出度和入度"
            }
        },
        {
            "type": "算法",
            "ID": "07ALG004",
            "name": "深度优先搜索",
            "attributes": {
                "难度": "中等",
                "内容": "图遍历算法。从起始顶点出发，沿一条路径尽可能深地访问，直到末端再回溯，访问其他分支。通常使用递归或栈实现。",
                "时间复杂度": "O(n+e) (邻接表) / O(n^2) (邻接矩阵)",
                "空间复杂度": "O(n) (递归栈或辅助栈)",
                "设计思想": "递归/回溯/栈",
                "适用场景": "查找路径、检测环、拓扑排序、连通性判断"
            }
        },
        {
            "type": "算法",
            "ID": "07ALG005",
            "name": "广度优先搜索",
            "attributes": {
                "难度": "中等",
                "内容": "图遍历算法。从起始顶点出发，逐层访问其邻接点。首先访问距离起点为1的所有顶点，然后是距离为2的，以此类推。通常使用队列实现。",
                "时间复杂度": "O(n+e) (邻接表) / O(n^2) (邻接矩阵)",
                "空间复杂度": "O(n) (队列)",
                "设计思想": "队列/层次遍历",
                "适用场景": "查找无权图最短路径、连通性判断"
            }
        },
        {
            "type": "数据结构",
            "ID": "08DS001",
            "name": "生成树",
            "attributes": {
                "难度": "中等",
                "内容": "连通图G的一个子图G'，包含G的所有顶点，且边集是G的边集的子集，使得G'是连通的且无回路。具有n个顶点的生成树恰好有n-1条边，是极小连通子图。",
                "存储开销": "O(V) （边列表）",
                "核心特性": "连通性、无回路、包含所有顶点"
            }
        },
        {
            "type": "数据结构",
            "ID": "08DS002",
            "name": "深度优先生成树",
            "attributes": {
                "难度": "中等",
                "内容": "通过深度优先搜索遍历连通图生成的生成树。",
                "存储开销": "O(V)",
                "核心特性": "反映DFS遍历顺序"
            }
        },
        {
            "type": "数据结构",
            "ID": "08DS003",
            "name": "广度优先生成树",
            "attributes": {
                "难度": "中等",
                "内容": "通过广度优先搜索遍历连通图生成的生成树。",
                "存储开销": "O(V)",
                "核心特性": "反映BFS遍历顺序，通常较矮"
            }
        },
        {
            "type": "概念",
            "ID": "08CON004",
            "name": "极小连通子图",
            "attributes": {
                "难度": "入门",
                "内容": "连通图的包含所有顶点的连通子图，其边数最少。生成树是极小连通子图。"
            }
        },
        {
            "type": "数据结构",
            "ID": "08DS004",
            "name": "连通网",
            "attributes": {
                "难度": "入门",
                "内容": "带权的连通图，即边上具有权值的连通图。最小生成树是针对连通网定义的。",
                "存储开销": "O(V^2)（邻接矩阵）或 O(V+E)（邻接表）",
                "核心特性": "连通性、带权边"
            }
        },
        {
            "type": "数据结构",
            "ID": "08DS005",
            "name": "最小生成树",
            "attributes": {
                "难度": "中等",
                "内容": "在连通网中，连接所有顶点且权值总和最小的生成树。用于解决网络建设成本最低等问题。",
                "存储开销": "O(V) （边列表）",
                "核心特性": "连通性、无回路、权值和最小"
            }
        },
        {
            "type": "算法",
            "ID": "08ALG003",
            "name": "普里姆算法",
            "attributes": {
                "难度": "中等",
                "内容": "求解最小生成树的贪心算法。从一个顶点开始，逐步扩展生成树，每次选择连接已选顶点集和未选顶点集之间权值最小的边。",
                "时间复杂度": "O(n^2)（邻接矩阵实现）",
                "空间复杂度": "O(n)（辅助数组）",
                "设计思想": "贪心算法",
                "适用场景": "求解稠密图的最小生成树"
            }
        },
        {
            "type": "算法",
            "ID": "08ALG004",
            "name": "克鲁斯卡尔算法",
            "attributes": {
                "难度": "中等",
                "内容": "求解最小生成树的贪心算法。将所有边按权值排序，依次选择权值最小的边，若该边连接的两个顶点不在同一连通分量（即不形成回路），则加入生成树。",
                "时间复杂度": "O(E log E) 或 O(E log V)（主要取决于排序和并查集操作），文中提及 O(n^2)",
                "空间复杂度": "O(E) 或 O(V)（取决于边存储和并查集实现），文中提及 O(n^2)",
                "设计思想": "贪心算法、并查集",
                "适用场景": "求解稀疏图的最小生成树"
            }
        },
        {
            "type": "概念",
            "ID": "08CON009",
            "name": "最短路径",
            "attributes": {
                "难度": "入门",
                "内容": "图中两个顶点之间路径长度最短的路径。对于带权图，指带权路径长度最小的路径。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON010",
            "name": "最短距离",
            "attributes": {
                "难度": "入门",
                "内容": "图中两个顶点之间最短路径的路径长度（或带权路径长度）。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON012",
            "name": "源点",
            "attributes": {
                "难度": "入门",
                "内容": "在路径问题或网络流问题中定义的起始顶点。如单源最短路径的起点，AOE网的工程起点。"
            }
        },
        {
            "type": "算法",
            "ID": "08ALG005",
            "name": "狄克斯特拉算法",
            "attributes": {
                "难度": "中等",
                "内容": "求解带权图中单源最短路径的贪心算法。按路径长度递增的顺序，依次确定源点到各顶点的最短路径。不能处理负权边。",
                "时间复杂度": "O(n^2)（邻接矩阵实现）",
                "空间复杂度": "O(n)（辅助数组）",
                "设计思想": "贪心算法、广度优先思想的扩展",
                "适用场景": "求解无负权边的单源最短路径问题"
            }
        },
        {
            "type": "算法",
            "ID": "08ALG006",
            "name": "弗洛伊德算法",
            "attributes": {
                "难度": "中等",
                "内容": "求解图中每对顶点之间最短路径的动态规划算法。通过考虑中间顶点，逐步更新任意两点间的最短距离。可以处理负权边（但不能处理负权回路）。",
                "时间复杂度": "O(n^3)",
                "空间复杂度": "O(n^2)（距离矩阵）",
                "设计思想": "动态规划",
                "适用场景": "求解所有顶点对之间的最短路径，允许负权边（无负权回路）"
            }
        },
        {
            "type": "概念",
            "ID": "08CON014",
            "name": "活动",
            "attributes": {
                "难度": "入门",
                "内容": "表示工程中的一个子工程或任务。在AOV网中用顶点表示，在AOE网中用边表示。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON015",
            "name": "前驱活动",
            "attributes": {
                "难度": "入门",
                "内容": "在工程计划中，必须在某个活动开始之前完成的活动。"
            }
        },
        {
            "type": "数据结构",
            "ID": "08DS010",
            "name": "顶点活动网",
            "attributes": {
                "难度": "中等",
                "内容": "用顶点表示活动，用有向边表示活动之间的先后（前驱）关系的图。用于表示工程活动依赖关系，必须是无环图。",
                "存储开销": "O(V+E)（邻接表）",
                "核心特性": "顶点表示活动、边表示优先关系、有向无环"
            }
        },
        {
            "type": "概念",
            "ID": "08CON016",
            "name": "后续活动",
            "attributes": {
                "难度": "入门",
                "内容": "在工程计划中，必须在某个活动完成之后才能开始的活动。"
            }
        },
        {
            "type": "数据结构",
            "ID": "08DS011",
            "name": "有向无环图",
            "attributes": {
                "难度": "入门",
                "内容": "不包含有向回路的有向图。AOV网和AOE网通常是DAG。",
                "存储开销": "O(V^2)（邻接矩阵）或 O(V+E)（邻接表）",
                "核心特性": "有向性、无回路"
            }
        },
        {
            "type": "概念",
            "ID": "08CON017",
            "name": "死锁",
            "attributes": {
                "难度": "入门",
                "内容": "在AOV网中，由于存在回路（循环依赖）导致所有相关活动都无法开始的状态。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON018",
            "name": "拓扑序列",
            "attributes": {
                "难度": "入门",
                "内容": "有向无环图（AOV网）中所有顶点的一个线性排序，使得对于图中任意一条有向边(u, v)，u在该序列中都出现在v之前。拓扑序列可能不唯一。"
            }
        },
        {
            "type": "算法",
            "ID": "08ALG007",
            "name": "拓扑排序",
            "attributes": {
                "难度": "中等",
                "内容": "生成有向无环图（AOV网）的拓扑序列的过程。常用方法是重复选择并输出入度为0的顶点，然后删除该顶点及其出边。",
                "时间复杂度": "O(n+e)（邻接表实现）",
                "空间复杂度": "O(n)（入度数组和栈/队列）",
                "设计思想": "基于入度的迭代移除、基于DFS",
                "适用场景": "任务调度、依赖解析、判断图是否有环"
            }
        },
        {
            "type": "数据结构",
            "ID": "08DS014",
            "name": "边活动网",
            "attributes": {
                "难度": "中等",
                "内容": "用带权有向边表示活动及其持续时间，用顶点表示事件（活动的开始或结束）的网络图。用于工程计划和关键路径分析。",
                "存储开销": "O(V+E)（邻接表）",
                "核心特性": "边表示活动、顶点表示事件、带权、有向无环"
            }
        },
        {
            "type": "概念",
            "ID": "08CON021",
            "name": "事件",
            "attributes": {
                "难度": "入门",
                "内容": "在AOE网中，表示某些活动完成和另一些活动开始的转接点，通常用顶点表示。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON022",
            "name": "持续时间",
            "attributes": {
                "难度": "入门",
                "内容": "在AOE网中，表示完成一个活动所需的时间，通常作为边的权值。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON025",
            "name": "最早发生时间",
            "attributes": {
                "难度": "中等",
                "内容": "在AOE网中，一个事件（顶点）可能发生的最早时间点。等于从源点到该事件顶点的最长路径长度。用ve表示。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON027",
            "name": "最长路径",
            "attributes": {
                "难度": "中等",
                "内容": "在带权图中，两个顶点之间带权路径长度最大的路径。在AOE网中用于计算事件最早发生时间。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON028",
            "name": "拓扑有序",
            "attributes": {
                "难度": "入门",
                "内容": "按照拓扑序列的顺序。计算AOE网事件最早发生时间需要按拓扑有序进行。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON029",
            "name": "最迟发生时间",
            "attributes": {
                "难度": "中等",
                "内容": "在AOE网中，一个事件（顶点）在不延误整个工程完成的前提下，必须发生的最晚时间点。用vl表示。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON031",
            "name": "逆拓扑有序",
            "attributes": {
                "难度": "入门",
                "内容": "按照拓扑序列的逆序。计算AOE网事件最迟发生时间需要按逆拓扑有序进行。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON032",
            "name": "开始时间余量",
            "attributes": {
                "难度": "中等",
                "内容": "在AOE网中，活动的最迟开始时间与最早开始时间之差（l[i] - e[i]）。表示该活动可以推迟开始而不影响总工期的时间。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON033",
            "name": "关键活动",
            "attributes": {
                "难度": "中等",
                "内容": "在AOE网中，开始时间余量为0的活动。这些活动是影响工程总工期的关键环节。"
            }
        },
        {
            "type": "概念",
            "ID": "08CON034",
            "name": "关键路径",
            "attributes": {
                "难度": "中等",
                "内容": "在AOE网中，从源点到汇点的、完全由关键活动组成的路径。关键路径的长度等于整个工程的最短完成时间。"
            }
        },
        {
            "type": "算法",
            "ID": "08ALG008",
            "name": "关键路径算法",
            "attributes": {
                "难度": "中等",
                "内容": "计算AOE网中关键路径的过程。包括计算所有事件的最早和最迟发生时间，进而计算活动的开始时间余量，找出关键活动和关键路径。",
                "时间复杂度": "O(n+e)",
                "空间复杂度": "O(n) 或 O(n+e)",
                "设计思想": "拓扑排序、动态规划思想",
                "适用场景": "工程项目管理、进度优化"
            }
        }
    ],
    "relations": [
        {
            "type": "理论依赖",
            "source": "01CON008",
            "target": "01CON001"
        },
        {
            "type": "理论依赖",
            "source": "01CON008",
            "target": "01CON002"
        },
        {
            "type": "理论依赖",
            "source": "01CON008",
            "target": "01CON011"
        },
        {
            "type": "理论依赖",
            "source": "01CON008",
            "target": "01CON009"
        },
        {
            "type": "理论依赖",
            "source": "01CON008",
            "target": "01CON010"
        },
        {
            "type": "理论依赖",
            "source": "01CON002",
            "target": "01CON001"
        },
        {
            "type": "理论依赖",
            "source": "01CON009",
            "target": "01DS001"
        },
        {
            "type": "理论依赖",
            "source": "01CON009",
            "target": "01DS002"
        },
        {
            "type": "理论依赖",
            "source": "01CON009",
            "target": "01DS003"
        },
        {
            "type": "理论依赖",
            "source": "01CON009",
            "target": "01DS004"
        },
        {
            "type": "理论依赖",
            "source": "01CON010",
            "target": "01CON034"
        },
        {
            "type": "理论依赖",
            "source": "01CON010",
            "target": "01CON035"
        },
        {
            "type": "理论依赖",
            "source": "01CON010",
            "target": "01CON036"
        },
        {
            "type": "理论依赖",
            "source": "01CON010",
            "target": "01CON037"
        },
        {
            "type": "理论依赖",
            "source": "01CON011",
            "target": "01CON012"
        },
        {
            "type": "理论依赖",
            "source": "01CON011",
            "target": "01CON013"
        },
        {
            "type": "理论依赖",
            "source": "01DS001",
            "target": "01CON009"
        },
        {
            "type": "理论依赖",
            "source": "01DS002",
            "target": "01CON009"
        },
        {
            "type": "理论依赖",
            "source": "01DS002",
            "target": "01CON012"
        },
        {
            "type": "理论依赖",
            "source": "01DS002",
            "target": "01CON013"
        },
        {
            "type": "理论依赖",
            "source": "01DS003",
            "target": "01CON009"
        },
        {
            "type": "理论依赖",
            "source": "01DS003",
            "target": "01CON019"
        },
        {
            "type": "理论依赖",
            "source": "01DS003",
            "target": "01CON012"
        },
        {
            "type": "理论依赖",
            "source": "01DS003",
            "target": "01CON013"
        },
        {
            "type": "理论依赖",
            "source": "01DS003",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "source": "01DS003",
            "target": "01CON016"
        },
        {
            "type": "理论依赖",
            "source": "01DS003",
            "target": "01CON017"
        },
        {
            "type": "理论依赖",
            "source": "01DS003",
            "target": "01CON018"
        },
        {
            "type": "理论依赖",
            "source": "01DS004",
            "target": "01CON009"
        },
        {
            "type": "理论依赖",
            "source": "01DS004",
            "target": "01CON019"
        },
        {
            "type": "理论依赖",
            "source": "01DS004",
            "target": "01CON012"
        },
        {
            "type": "理论依赖",
            "source": "01DS004",
            "target": "01CON013"
        },
        {
            "type": "理论依赖",
            "source": "01DS004",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "source": "01DS004",
            "target": "01CON015"
        },
        {
            "type": "继承",
            "source": "01DS003",
            "target": "01DS004"
        },
        {
            "type": "继承",
            "source": "01DS002",
            "target": "01DS003"
        },
        {
            "type": "理论依赖",
            "source": "01CON020",
            "target": "01CON021"
        },
        {
            "type": "理论依赖",
            "source": "01CON020",
            "target": "01CON022"
        },
        {
            "type": "理论依赖",
            "source": "01CON022",
            "target": "01DS005"
        },
        {
            "type": "理论依赖",
            "source": "01CON022",
            "target": "01DS006"
        },
        {
            "type": "理论依赖",
            "source": "01CON023",
            "target": "01CON008"
        },
        {
            "type": "理论依赖",
            "source": "01CON023",
            "target": "01CON020"
        },
        {
            "type": "理论依赖",
            "source": "01CON024",
            "target": "01CON020"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON007"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON038"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON039"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON040"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON041"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON042"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON026"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON027"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON028"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON029"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON030"
        },
        {
            "type": "理论依赖",
            "source": "01ALG001",
            "target": "01CON025"
        },
        {
            "type": "使用",
            "source": "01ALG001",
            "target": "01DS005"
        },
        {
            "type": "理论依赖",
            "source": "01ALG002",
            "target": "01CON025"
        },
        {
            "type": "使用",
            "source": "01ALG002",
            "target": "01DS005"
        },
        {
            "type": "理论依赖",
            "source": "01ALG003",
            "target": "01CON025"
        },
        {
            "type": "使用",
            "source": "01ALG003",
            "target": "01DS005"
        },
        {
            "type": "理论依赖",
            "source": "01ALG004",
            "target": "01CON025"
        },
        {
            "type": "使用",
            "source": "01ALG004",
            "target": "01DS005"
        },
        {
            "type": "理论依赖",
            "source": "01CON026",
            "target": "01CON031"
        },
        {
            "type": "理论依赖",
            "source": "01CON027",
            "target": "01CON031"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON032"
        },
        {
            "type": "理论依赖",
            "source": "01CON025",
            "target": "01CON033"
        },
        {
            "type": "理论依赖",
            "source": "02DS001",
            "target": "01CON023"
        },
        {
            "type": "理论依赖",
            "source": "02DS001",
            "target": "01CON008"
        },
        {
            "type": "继承",
            "source": "02DS002",
            "target": "02DS001"
        },
        {
            "type": "使用",
            "source": "02DS002",
            "target": "01DS005"
        },
        {
            "type": "继承",
            "source": "02DS004",
            "target": "02DS001"
        },
        {
            "type": "使用",
            "source": "02DS004",
            "target": "01CON014"
        },
        {
            "type": "使用",
            "source": "02DS004",
            "target": "02CON005"
        },
        {
            "type": "继承",
            "source": "02DS005",
            "target": "02DS004"
        },
        {
            "type": "继承",
            "source": "02DS006",
            "target": "02DS004"
        },
        {
            "type": "继承",
            "source": "02DS007",
            "target": "02DS005"
        },
        {
            "type": "继承",
            "source": "02DS007",
            "target": "02DS004"
        },
        {
            "type": "操作绑定",
            "source": "02ALG001",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "source": "02ALG002",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "source": "02ALG003",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "source": "02ALG004",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "source": "02ALG005",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "source": "02ALG006",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "source": "02ALG007",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "source": "02ALG008",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "source": "02ALG009",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "source": "02ALG010",
            "target": "02DS001"
        },
        {
            "type": "操作绑定",
            "source": "02ALG011",
            "target": "02DS001"
        },
        {
            "type": "使用",
            "source": "02ALG007",
            "target": "01ALG004"
        },
        {
            "type": "使用",
            "source": "02ALG008",
            "target": "01ALG004"
        },
        {
            "type": "使用",
            "source": "02ALG011",
            "target": "02ALG012"
        },
        {
            "type": "理论依赖",
            "source": "02ALG012",
            "target": "01CON026"
        },
        {
            "type": "理论依赖",
            "source": "02ALG012",
            "target": "01CON027"
        },
        {
            "type": "理论依赖",
            "source": "02ALG012",
            "target": "01CON025"
        },
        {
            "type": "使用",
            "source": "02ALG013",
            "target": "02DS001"
        },
        {
            "type": "使用",
            "source": "02ALG014",
            "target": "02DS001"
        },
        {
            "type": "使用",
            "source": "02ALG014",
            "target": "02DS005"
        },
        {
            "type": "理论依赖",
            "source": "01ALG004",
            "target": "01CON026"
        },
        {
            "type": "操作绑定",
            "source": "03ALG001",
            "target": "01DS001"
        },
        {
            "type": "操作绑定",
            "source": "03ALG002",
            "target": "01DS001"
        },
        {
            "type": "操作绑定",
            "source": "03ALG003",
            "target": "01DS001"
        },
        {
            "type": "操作绑定",
            "source": "03ALG004",
            "target": "01DS001"
        },
        {
            "type": "操作绑定",
            "source": "03ALG005",
            "target": "01DS001"
        },
        {
            "type": "操作绑定",
            "source": "03ALG006",
            "target": "01DS001"
        },
        {
            "type": "操作绑定",
            "source": "03ALG007",
            "target": "01DS001"
        },
        {
            "type": "操作绑定",
            "source": "03ALG008",
            "target": "01DS001"
        },
        {
            "type": "操作绑定",
            "source": "03ALG009",
            "target": "01DS001"
        },
        {
            "type": "操作绑定",
            "source": "03ALG010",
            "target": "01DS001"
        },
        {
            "type": "操作绑定",
            "source": "03ALG011",
            "target": "01DS001"
        },
        {
            "type": "操作绑定",
            "source": "03ALG012",
            "target": "01DS001"
        },
        {
            "type": "操作绑定",
            "source": "03ALG013",
            "target": "01DS001"
        },
        {
            "type": "理论依赖",
            "source": "01DS001",
            "target": "03CON001"
        },
        {
            "type": "理论依赖",
            "source": "01DS001",
            "target": "03CON002"
        },
        {
            "type": "使用",
            "source": "01DS001",
            "target": "01CON034"
        },
        {
            "type": "使用",
            "source": "01DS001",
            "target": "01CON035"
        },
        {
            "type": "使用",
            "source": "01DS001",
            "target": "02DS005"
        },
        {
            "type": "使用",
            "source": "03DS002",
            "target": "03DS005"
        },
        {
            "type": "理论依赖",
            "source": "03DS005",
            "target": "03CON005"
        },
        {
            "type": "使用",
            "source": "03DS005",
            "target": "01CON034"
        },
        {
            "type": "使用",
            "source": "03DS005",
            "target": "01CON035"
        },
        {
            "type": "操作绑定",
            "source": "03ALG014",
            "target": "03DS002"
        },
        {
            "type": "变体",
            "source": "03ALG015",
            "target": "03ALG014"
        },
        {
            "type": "变体",
            "source": "03ALG016",
            "target": "03ALG014"
        },
        {
            "type": "优化",
            "source": "03ALG016",
            "target": "03ALG015"
        },
        {
            "type": "操作绑定",
            "source": "03ALG017",
            "target": "03DS002"
        },
        {
            "type": "使用",
            "source": "03DS002",
            "target": "03CON006"
        },
        {
            "type": "使用",
            "source": "03DS002",
            "target": "03CON007"
        },
        {
            "type": "使用",
            "source": "03DS002",
            "target": "02DS005"
        },
        {
            "type": "理论依赖",
            "source": "03DS003",
            "target": "03CON008"
        },
        {
            "type": "理论依赖",
            "source": "03DS003",
            "target": "03CON009"
        },
        {
            "type": "理论依赖",
            "source": "03DS003",
            "target": "03CON010"
        },
        {
            "type": "操作绑定",
            "source": "03ALG018",
            "target": "03DS003"
        },
        {
            "type": "操作绑定",
            "source": "03ALG019",
            "target": "03DS003"
        },
        {
            "type": "操作绑定",
            "source": "03ALG020",
            "target": "03DS003"
        },
        {
            "type": "操作绑定",
            "source": "03ALG021",
            "target": "03DS003"
        },
        {
            "type": "使用",
            "source": "03DS003",
            "target": "01CON035"
        },
        {
            "type": "使用",
            "source": "03DS003",
            "target": "02DS005"
        },
        {
            "type": "继承",
            "source": "04DS001",
            "target": "02DS001"
        },
        {
            "type": "继承",
            "source": "04DS002",
            "target": "02DS001"
        },
        {
            "type": "变体",
            "source": "04DS004",
            "target": "04DS002"
        },
        {
            "type": "变体",
            "source": "04DS005",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "source": "04ALG001",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "source": "04ALG002",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "source": "04ALG003",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "source": "04ALG004",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "source": "04ALG005",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "source": "04ALG006",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "source": "04ALG007",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "source": "04ALG008",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "source": "04ALG009",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "source": "04ALG010",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "source": "04ALG011",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "source": "04ALG012",
            "target": "04DS002"
        },
        {
            "type": "理论依赖",
            "source": "04DS001",
            "target": "04CON001"
        },
        {
            "type": "理论依赖",
            "source": "04DS001",
            "target": "04CON002"
        },
        {
            "type": "理论依赖",
            "source": "04DS001",
            "target": "04CON005"
        },
        {
            "type": "理论依赖",
            "source": "04DS002",
            "target": "04CON003"
        },
        {
            "type": "理论依赖",
            "source": "04DS002",
            "target": "04CON004"
        },
        {
            "type": "理论依赖",
            "source": "04DS002",
            "target": "04CON006"
        },
        {
            "type": "使用",
            "source": "04ALG013",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "source": "04ALG014",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "source": "04ALG015",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "source": "04ALG016",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "source": "04ALG020",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "source": "04ALG022",
            "target": "04DS002"
        },
        {
            "type": "理论依赖",
            "source": "04ALG017",
            "target": "01CON032"
        },
        {
            "type": "理论依赖",
            "source": "04ALG018",
            "target": "01CON032"
        },
        {
            "type": "理论依赖",
            "source": "04ALG019",
            "target": "01CON032"
        },
        {
            "type": "理论依赖",
            "source": "04ALG020",
            "target": "01CON032"
        },
        {
            "type": "理论依赖",
            "source": "04ALG021",
            "target": "01CON032"
        },
        {
            "type": "理论依赖",
            "source": "04ALG013",
            "target": "04CON009"
        },
        {
            "type": "理论依赖",
            "source": "04ALG014",
            "target": "04CON008"
        },
        {
            "type": "理论依赖",
            "source": "04ALG014",
            "target": "04CON009"
        },
        {
            "type": "使用",
            "source": "04DS001",
            "target": "01CON034"
        },
        {
            "type": "使用",
            "source": "04DS001",
            "target": "01CON035"
        },
        {
            "type": "使用",
            "source": "04DS002",
            "target": "01CON034"
        },
        {
            "type": "使用",
            "source": "04DS002",
            "target": "01CON035"
        },
        {
            "type": "使用",
            "source": "04DS004",
            "target": "01CON034"
        },
        {
            "type": "理论依赖",
            "source": "05DS001",
            "target": "01CON016"
        },
        {
            "type": "理论依赖",
            "source": "05DS001",
            "target": "05CON002"
        },
        {
            "type": "理论依赖",
            "source": "05DS001",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "source": "01CON014",
            "target": "05CON004"
        },
        {
            "type": "理论依赖",
            "source": "05DS001",
            "target": "05CON004"
        },
        {
            "type": "理论依赖",
            "source": "01CON017",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "source": "01CON017",
            "target": "05CON004"
        },
        {
            "type": "理论依赖",
            "source": "01CON018",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "source": "01CON018",
            "target": "05CON004"
        },
        {
            "type": "理论依赖",
            "source": "05CON007",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "source": "05CON008",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "source": "05CON007",
            "target": "05CON008"
        },
        {
            "type": "理论依赖",
            "source": "05CON009",
            "target": "05CON007"
        },
        {
            "type": "理论依赖",
            "source": "05CON009",
            "target": "05CON008"
        },
        {
            "type": "理论依赖",
            "source": "01CON014",
            "target": "03CON010"
        },
        {
            "type": "理论依赖",
            "source": "05DS001",
            "target": "03CON010"
        },
        {
            "type": "理论依赖",
            "source": "03CON010",
            "target": "03CON010"
        },
        {
            "type": "理论依赖",
            "source": "05CON012",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "source": "05CON013",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "source": "05CON014",
            "target": "05DS001"
        },
        {
            "type": "继承",
            "source": "05DS002",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "source": "05DS002",
            "target": "05CON012"
        },
        {
            "type": "理论依赖",
            "source": "05CON015",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "source": "05CON015",
            "target": "05CON004"
        },
        {
            "type": "继承",
            "source": "05DS003",
            "target": "05DS002"
        },
        {
            "type": "继承",
            "source": "05DS004",
            "target": "05DS002"
        },
        {
            "type": "继承",
            "source": "05DS003",
            "target": "05DS004"
        },
        {
            "type": "继承",
            "source": "05DS005",
            "target": "05DS002"
        },
        {
            "type": "继承",
            "source": "05DS004",
            "target": "05DS005"
        },
        {
            "type": "使用",
            "source": "05DS006",
            "target": "05DS002"
        },
        {
            "type": "使用",
            "source": "05DS006",
            "target": "05DS004"
        },
        {
            "type": "使用",
            "source": "05DS007",
            "target": "05DS002"
        },
        {
            "type": "理论依赖",
            "source": "05DS007",
            "target": "05CON016"
        },
        {
            "type": "操作绑定",
            "source": "05ALG001",
            "target": "05DS002"
        },
        {
            "type": "继承",
            "source": "05ALG002",
            "target": "05ALG001"
        },
        {
            "type": "使用",
            "source": "05ALG002",
            "target": "04DS001"
        },
        {
            "type": "继承",
            "source": "05ALG003",
            "target": "05ALG001"
        },
        {
            "type": "使用",
            "source": "05ALG003",
            "target": "04DS001"
        },
        {
            "type": "继承",
            "source": "05ALG004",
            "target": "05ALG001"
        },
        {
            "type": "使用",
            "source": "05ALG004",
            "target": "04DS001"
        },
        {
            "type": "继承",
            "source": "05ALG005",
            "target": "05ALG001"
        },
        {
            "type": "使用",
            "source": "05ALG005",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "source": "05ALG006",
            "target": "05DS002"
        },
        {
            "type": "操作绑定",
            "source": "05ALG007",
            "target": "05DS002"
        },
        {
            "type": "使用",
            "source": "05ALG007",
            "target": "05DS007"
        },
        {
            "type": "使用",
            "source": "05ALG007",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "source": "05ALG008",
            "target": "05DS002"
        },
        {
            "type": "操作绑定",
            "source": "05ALG009",
            "target": "05DS002"
        },
        {
            "type": "理论依赖",
            "source": "05ALG009",
            "target": "03CON010"
        },
        {
            "type": "操作绑定",
            "source": "05ALG010",
            "target": "05DS002"
        },
        {
            "type": "操作绑定",
            "source": "05ALG011",
            "target": "05DS002"
        },
        {
            "type": "操作绑定",
            "source": "05ALG012",
            "target": "05DS002"
        },
        {
            "type": "使用",
            "source": "05ALG012",
            "target": "05ALG004"
        },
        {
            "type": "使用",
            "source": "05DS010",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "source": "05DS010",
            "target": "05CON015"
        },
        {
            "type": "使用",
            "source": "05DS011",
            "target": "05DS001"
        },
        {
            "type": "变体",
            "source": "05DS012",
            "target": "05DS011"
        },
        {
            "type": "使用",
            "source": "05DS013",
            "target": "05DS001"
        },
        {
            "type": "使用",
            "source": "05DS013",
            "target": "05DS007"
        },
        {
            "type": "理论依赖",
            "source": "05DS013",
            "target": "05CON009"
        },
        {
            "type": "操作绑定",
            "source": "05ALG013",
            "target": "05DS001"
        },
        {
            "type": "继承",
            "source": "05ALG014",
            "target": "05ALG013"
        },
        {
            "type": "继承",
            "source": "05ALG015",
            "target": "05ALG013"
        },
        {
            "type": "继承",
            "source": "05ALG016",
            "target": "05ALG013"
        },
        {
            "type": "使用",
            "source": "05ALG016",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "source": "05ALG017",
            "target": "05DS001"
        },
        {
            "type": "使用",
            "source": "05ALG017",
            "target": "05DS011"
        },
        {
            "type": "使用",
            "source": "05ALG017",
            "target": "04DS001"
        },
        {
            "type": "操作绑定",
            "source": "05ALG018",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "source": "05ALG019",
            "target": "05DS001"
        },
        {
            "type": "操作绑定",
            "source": "05ALG020",
            "target": "05DS001"
        },
        {
            "type": "理论依赖",
            "source": "05ALG020",
            "target": "03CON010"
        },
        {
            "type": "操作绑定",
            "source": "05ALG021",
            "target": "05DS001"
        },
        {
            "type": "使用",
            "source": "05ALG021",
            "target": "05ALG015"
        },
        {
            "type": "继承",
            "source": "06DS001",
            "target": "05DS002"
        },
        {
            "type": "继承",
            "source": "06DS003",
            "target": "05DS002"
        },
        {
            "type": "继承",
            "source": "06DS004",
            "target": "05DS002"
        },
        {
            "type": "继承",
            "source": "06DS005",
            "target": "06DS001"
        },
        {
            "type": "使用",
            "source": "06DS002",
            "target": "05DS004"
        },
        {
            "type": "继承",
            "source": "05DS004",
            "target": "05DS002"
        },
        {
            "type": "操作绑定",
            "source": "06ALG001",
            "target": "06DS001"
        },
        {
            "type": "操作绑定",
            "source": "06ALG002",
            "target": "06DS001"
        },
        {
            "type": "操作绑定",
            "source": "06ALG003",
            "target": "06DS001"
        },
        {
            "type": "操作绑定",
            "source": "06ALG004",
            "target": "06DS001"
        },
        {
            "type": "操作绑定",
            "source": "06ALG005",
            "target": "06DS002"
        },
        {
            "type": "操作绑定",
            "source": "06ALG006",
            "target": "06DS002"
        },
        {
            "type": "理论依赖",
            "source": "06ALG007",
            "target": "06CON006"
        },
        {
            "type": "使用",
            "source": "06ALG007",
            "target": "06DS003"
        },
        {
            "type": "使用",
            "source": "06ALG008",
            "target": "06DS003"
        },
        {
            "type": "理论依赖",
            "source": "06DS004",
            "target": "06CON007"
        },
        {
            "type": "操作绑定",
            "source": "06ALG009",
            "target": "06DS004"
        },
        {
            "type": "操作绑定",
            "source": "06ALG010",
            "target": "06DS004"
        },
        {
            "type": "理论依赖",
            "source": "06DS005",
            "target": "06CON008"
        },
        {
            "type": "操作绑定",
            "source": "06ALG011",
            "target": "06DS005"
        },
        {
            "type": "操作绑定",
            "source": "06ALG012",
            "target": "06DS005"
        },
        {
            "type": "操作绑定",
            "source": "06ALG013",
            "target": "06DS005"
        },
        {
            "type": "操作绑定",
            "source": "06ALG014",
            "target": "06DS005"
        },
        {
            "type": "理论依赖",
            "source": "06CON003",
            "target": "06CON002"
        },
        {
            "type": "理论依赖",
            "source": "06CON005",
            "target": "06CON003"
        },
        {
            "type": "理论依赖",
            "source": "06CON005",
            "target": "06CON004"
        },
        {
            "type": "理论依赖",
            "source": "06CON006",
            "target": "06CON005"
        },
        {
            "type": "理论依赖",
            "source": "06DS003",
            "target": "06CON006"
        },
        {
            "type": "理论依赖",
            "source": "07DS001",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "source": "07DS001",
            "target": "07CON002"
        },
        {
            "type": "继承",
            "source": "01CON015",
            "target": "07CON002"
        },
        {
            "type": "继承",
            "source": "07CON004",
            "target": "07CON002"
        },
        {
            "type": "继承",
            "source": "07DS002",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "source": "07DS002",
            "target": "01CON015"
        },
        {
            "type": "继承",
            "source": "07DS003",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "source": "07DS003",
            "target": "07CON004"
        },
        {
            "type": "理论依赖",
            "source": "07CON005",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "source": "07CON005",
            "target": "07CON002"
        },
        {
            "type": "理论依赖",
            "source": "07CON006",
            "target": "01CON015"
        },
        {
            "type": "理论依赖",
            "source": "07CON007",
            "target": "01CON015"
        },
        {
            "type": "理论依赖",
            "source": "05CON004",
            "target": "01CON014"
        },
        {
            "type": "理论依赖",
            "source": "05CON004",
            "target": "07CON002"
        },
        {
            "type": "理论依赖",
            "source": "07CON009",
            "target": "05CON004"
        },
        {
            "type": "理论依赖",
            "source": "07CON009",
            "target": "07CON007"
        },
        {
            "type": "理论依赖",
            "source": "07CON010",
            "target": "05CON004"
        },
        {
            "type": "理论依赖",
            "source": "07CON010",
            "target": "07CON006"
        },
        {
            "type": "理论依赖",
            "source": "07CON011",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "source": "07CON012",
            "target": "07CON011"
        },
        {
            "type": "理论依赖",
            "source": "07CON013",
            "target": "07CON011"
        },
        {
            "type": "理论依赖",
            "source": "07CON014",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "source": "06CON002",
            "target": "07DS001"
        },
        {
            "type": "继承",
            "source": "07CON016",
            "target": "06CON002"
        },
        {
            "type": "继承",
            "source": "07CON017",
            "target": "06CON002"
        },
        {
            "type": "继承",
            "source": "07CON018",
            "target": "07CON016"
        },
        {
            "type": "继承",
            "source": "07CON018",
            "target": "07CON017"
        },
        {
            "type": "理论依赖",
            "source": "07CON019",
            "target": "06CON002"
        },
        {
            "type": "理论依赖",
            "source": "07CON019",
            "target": "07DS003"
        },
        {
            "type": "理论依赖",
            "source": "07CON020",
            "target": "07CON019"
        },
        {
            "type": "理论依赖",
            "source": "07CON021",
            "target": "07CON019"
        },
        {
            "type": "理论依赖",
            "source": "07CON022",
            "target": "07CON020"
        },
        {
            "type": "理论依赖",
            "source": "07CON022",
            "target": "07CON014"
        },
        {
            "type": "理论依赖",
            "source": "07CON023",
            "target": "06CON002"
        },
        {
            "type": "理论依赖",
            "source": "07CON023",
            "target": "07DS002"
        },
        {
            "type": "理论依赖",
            "source": "07CON024",
            "target": "07CON023"
        },
        {
            "type": "理论依赖",
            "source": "07CON024",
            "target": "07CON014"
        },
        {
            "type": "理论依赖",
            "source": "07CON025",
            "target": "07CON002"
        },
        {
            "type": "继承",
            "source": "07DS004",
            "target": "07DS001"
        },
        {
            "type": "理论依赖",
            "source": "07DS004",
            "target": "07CON025"
        },
        {
            "type": "操作绑定",
            "source": "07ALG001",
            "target": "07DS001"
        },
        {
            "type": "操作绑定",
            "source": "07ALG002",
            "target": "07DS001"
        },
        {
            "type": "操作绑定",
            "source": "07ALG003",
            "target": "07DS001"
        },
        {
            "type": "使用",
            "source": "07DS001",
            "target": "07DS005"
        },
        {
            "type": "理论依赖",
            "source": "07DS005",
            "target": "07CON012"
        },
        {
            "type": "使用",
            "source": "07DS001",
            "target": "07DS006"
        },
        {
            "type": "理论依赖",
            "source": "07DS006",
            "target": "07CON013"
        },
        {
            "type": "使用",
            "source": "07DS001",
            "target": "07DS007"
        },
        {
            "type": "理论依赖",
            "source": "07DS007",
            "target": "07CON013"
        },
        {
            "type": "变体",
            "source": "07DS008",
            "target": "07DS006"
        },
        {
            "type": "使用",
            "source": "07DS002",
            "target": "07DS008"
        },
        {
            "type": "变体",
            "source": "07DS009",
            "target": "07DS006"
        },
        {
            "type": "变体",
            "source": "07DS009",
            "target": "07DS008"
        },
        {
            "type": "使用",
            "source": "07DS002",
            "target": "07DS009"
        },
        {
            "type": "继承",
            "source": "07ALG004",
            "target": "07ALG003"
        },
        {
            "type": "继承",
            "source": "07ALG005",
            "target": "07ALG003"
        },
        {
            "type": "继承",
            "source": "08DS002",
            "target": "08DS001"
        },
        {
            "type": "继承",
            "source": "08DS003",
            "target": "08DS001"
        },
        {
            "type": "继承",
            "source": "08DS005",
            "target": "08DS001"
        },
        {
            "type": "操作绑定",
            "source": "07ALG004",
            "target": "07DS002"
        },
        {
            "type": "操作绑定",
            "source": "07ALG005",
            "target": "07DS002"
        },
        {
            "type": "使用",
            "source": "07ALG004",
            "target": "04DS001"
        },
        {
            "type": "使用",
            "source": "07ALG005",
            "target": "04DS002"
        },
        {
            "type": "操作绑定",
            "source": "08ALG003",
            "target": "08DS005"
        },
        {
            "type": "操作绑定",
            "source": "08ALG004",
            "target": "08DS005"
        },
        {
            "type": "使用",
            "source": "08ALG003",
            "target": "07DS005"
        },
        {
            "type": "使用",
            "source": "08ALG004",
            "target": "07DS007"
        },
        {
            "type": "理论依赖",
            "source": "08ALG004",
            "target": "07CON022"
        },
        {
            "type": "理论依赖",
            "source": "08DS001",
            "target": "07CON020"
        },
        {
            "type": "理论依赖",
            "source": "08DS001",
            "target": "07CON016"
        },
        {
            "type": "理论依赖",
            "source": "08DS001",
            "target": "07CON014"
        },
        {
            "type": "理论依赖",
            "source": "08DS001",
            "target": "08CON004"
        },
        {
            "type": "继承",
            "source": "08DS005",
            "target": "08DS004"
        },
        {
            "type": "理论依赖",
            "source": "08DS005",
            "target": "07CON025"
        },
        {
            "type": "理论依赖",
            "source": "08ALG005",
            "target": "08CON009"
        },
        {
            "type": "使用",
            "source": "08ALG005",
            "target": "07DS005"
        },
        {
            "type": "理论依赖",
            "source": "08ALG005",
            "target": "08CON012"
        },
        {
            "type": "理论依赖",
            "source": "08ALG006",
            "target": "08CON009"
        },
        {
            "type": "使用",
            "source": "08ALG006",
            "target": "07DS005"
        },
        {
            "type": "操作绑定",
            "source": "08ALG007",
            "target": "08DS011"
        },
        {
            "type": "使用",
            "source": "08ALG007",
            "target": "07DS006"
        },
        {
            "type": "使用",
            "source": "08ALG007",
            "target": "04DS001"
        },
        {
            "type": "理论依赖",
            "source": "08ALG007",
            "target": "07CON009"
        },
        {
            "type": "理论依赖",
            "source": "08ALG007",
            "target": "08CON018"
        },
        {
            "type": "继承",
            "source": "08DS010",
            "target": "08DS011"
        },
        {
            "type": "理论依赖",
            "source": "08DS010",
            "target": "08CON014"
        },
        {
            "type": "理论依赖",
            "source": "08DS010",
            "target": "08CON015"
        },
        {
            "type": "理论依赖",
            "source": "08CON017",
            "target": "07CON016"
        },
        {
            "type": "继承",
            "source": "08DS014",
            "target": "08DS011"
        },
        {
            "type": "理论依赖",
            "source": "08DS014",
            "target": "08CON014"
        },
        {
            "type": "理论依赖",
            "source": "08DS014",
            "target": "08CON021"
        },
        {
            "type": "理论依赖",
            "source": "08DS014",
            "target": "07CON025"
        },
        {
            "type": "理论依赖",
            "source": "08DS014",
            "target": "08CON022"
        },
        {
            "type": "操作绑定",
            "source": "08ALG008",
            "target": "08DS014"
        },
        {
            "type": "理论依赖",
            "source": "08ALG008",
            "target": "08CON034"
        },
        {
            "type": "使用",
            "source": "08ALG008",
            "target": "08ALG007"
        },
        {
            "type": "理论依赖",
            "source": "08ALG008",
            "target": "08CON025"
        },
        {
            "type": "理论依赖",
            "source": "08ALG008",
            "target": "08CON029"
        },
        {
            "type": "理论依赖",
            "source": "08ALG008",
            "target": "08CON032"
        },
        {
            "type": "理论依赖",
            "source": "08CON034",
            "target": "08CON033"
        },
        {
            "type": "理论依赖",
            "source": "08CON033",
            "target": "08CON032"
        },
        {
            "type": "理论依赖",
            "source": "08CON025",
            "target": "08CON027"
        },
        {
            "type": "理论依赖",
            "source": "08CON025",
            "target": "08CON028"
        },
        {
            "type": "理论依赖",
            "source": "08CON029",
            "target": "08CON031"
        },
        {
            "type": "继承",
            "source": "08DS004",
            "target": "07DS004"
        },
        {
            "type": "理论依赖",
            "source": "08DS004",
            "target": "07CON020"
        },
        {
            "type": "理论依赖",
            "source": "08CON009",
            "target": "06CON002"
        },
        {
            "type": "理论依赖",
            "source": "08CON009",
            "target": "06CON003"
        },
        {
            "type": "理论依赖",
            "source": "08CON010",
            "target": "08CON009"
        },
        {
            "type": "理论依赖",
            "source": "01DS001",
            "target": "01CON008"
        },
        {
            "type": "理论依赖",
            "source": "01DS002",
            "target": "01CON008"
        },
        {
            "type": "理论依赖",
            "source": "01DS003",
            "target": "01CON008"
        },
        {
            "type": "理论依赖",
            "source": "01DS004",
            "target": "01CON008"
        },
        {
            "type": "继承",
            "source": "02DS001",
            "target": "01DS002"
        },
        {
            "type": "继承",
            "source": "05DS001",
            "target": "01DS003"
        },
        {
            "type": "继承",
            "source": "07DS001",
            "target": "01DS004"
        },
        {
            "type": "继承",
            "source": "08DS001",
            "target": "05DS001"
        },
        {
            "type": "继承",
            "source": "08DS011",
            "target": "07DS002"
        },
        {
            "type": "使用",
            "source": "04DS005",
            "target": "06DS002"
        },
        {
            "type": "理论依赖",
            "source": "01DS005",
            "target": "01CON034"
        },
        {
            "type": "理论依赖",
            "source": "02DS004",
            "target": "01CON035"
        },
        {
            "type": "理论依赖",
            "source": "08CON016",
            "target": "08CON014"
        }
    ]
}
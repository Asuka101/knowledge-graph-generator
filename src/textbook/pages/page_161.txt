(3)$20 \times 0y0 + 0 \times 010x0 - 0/$(4)$250 \times 0 + 0a0a0b0 + 0 \times 0b0 + 0 \times$从以上实例可以看出, 转换前后每个数据元素的前后次序没有改变, 改变的只是表达式中每个运算符的位置和次序。

\section*{4.5 .2 后缀表达式求值的算法}

后缀表达式的求值比较简单, 扫描一遍即可完成。它需要使用一个栈, 假定用 S 表示,其元素类型应为操作数的类型, 假定为浮点型 double, 用此栈存储后缀表达式中的操作数、计算过程中的中间结果以及最后结果。一个后缀算术表达式以一个字符串的方式提供, 后缀表达式求值算法的基本思路是: 把包含后缀算术表达式的一个字符串由一个字符指针参数所指明, 每次从该字符串中读入一个字符, 若它是空格则不做任何处理, 若它是运算符, 则表明它的两个操作数已经在栈 S 中, 其中栈顶元素为运算符的后一个操作数, 栈顶元素的前一个元素为运算符的前一个操作数, 把它们弹出后进行相应运算并保存到一个变量 (假定为 x) 中, 否则, 扫描到的字符必为数字或小数点, 应把从此开始的浮点数字符串转换为一个浮点数并存入 x 中, 然后把计算或转换得到的浮点数 (即 x 的值) 压入到栈 S 中。依次向下扫描每一个字符并进行上述处理, 直到遇到字符串结束符 (即 ASCII 为 0 的空字符) 为止, 表明后缀表达式计算完毕, 最终结果保存在栈中, 并且栈中仅存这一个值, 把它弹出返回即可。具体算法描述如下。

double Compute(char* str) //计算由 str 所指字符串的后缀表达式的值

{
//用 S 栈存储操作数和中间计算结果, 元素类型为 double
Stack S;
//初始化栈 s
InitStack(S);
//定义 x,y 用于保存浮点数, 定义 i 用于扫描后缀表达式
double x,y;
int i=0;
//扫描后缀表达式中的每个字符, 并进行相应处理
while(str[i]) {
if(str[i]==' ') //扫描到空格字符不做任何处理
{i++; continue;}
switch(str[i]) {
case '+':
x=Pop(S)+Pop(S); //做栈顶两个元素的加法, 和赋给 x
i++; break;
case '-':
x=Pop(S)-x; //做栈顶两个元素的减法, 差赋给 x
x=Pop(S)-x; //弹出减数
i++; break;
case '*': //做栈顶两个元素的乘法, 积赋给 x

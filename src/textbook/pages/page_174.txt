数和列数, 亦即出口点的坐标, maze 和 mark 分别为具有$[m+2][n+2]$大小的全局整型数组, 分别用来保存迷宫数据和访问标记, move 为具有$[4][2]$大小的全局整型数组, 用来保存向每个方向前进的位移量。

bool SeekPath(int x,int y)
    //从迷宫中坐标点$(x,y)$的位置寻找通向终点$(m,n)$的路径,若找到则
    //返回 true,否则返回 false,$(x,y)$的初始值通常为$(1,1)${
    //i 作为循环变量,代表从当前位置移到下一个位置的方向
    int i;
    //g 和 h 用作为下一个位置的行坐标和列坐标
    int g,h;
    //到达终点返回 true 结束递归
    if ($(x==m)\&\&(y==n)$) return true;
    //依次按每个方向寻找通向终点的路径,$i=0,1,2,3$分别为东,南,西,北方向
    for(i=0;$i<4$; i++)
    {
        //求出下一个位置的行坐标和列坐标$g=x+\operatorname{move}[i][0]$;$h=y+\operatorname{move}[i][1]$;
        //若下一位罝可通行同时没有被访问过,则从该位置起寻找
        if ($(maze[g][h]==0)\&\&(mark[g][h]==0)$)
        {
            //置 mark 数组中对应位置为 1 ,表明已访问过
            mark[g][h]=1;
            //当条件成立 (即返回 true)时,表明从$(g,h)$到终点存在
            //通路,应输出该位置坐标,同时返回 true 结束递归,
            //否则进入下一轮循环,向下一个方向试探
            if (SeekPath(g,h)) {
                cout<<("("<g<", "<h<")", ");
                return true;
            }
        }
    }
    //从当前位置$(x,y)$没有通向终点的路径,应返回 false
    return false;
}

当用户调用这个递归算法时, 系统将自动建立含有值参 x 和 y 域, 局部变量 i、g 和 h 域以及返回地址 r 域的一个栈, 每次递归调用时都自动进行进栈操作, 每次算法执行结束 (包括执行到 return 语句或算法最后的花括号) 后都自动进行出栈操作。若算法执行时的 maze 数组, 如图 4-7 (b) 所示, 第 0 次递归调用时的返回地址用 r1 表示, 算法中仅有一处递归调用, 其返回地址用 r2 表示, 则从第 0 次递归调用到第 3 次递归调用前系统栈的变化状态, 如图 4-8 所示。对于系统栈的以后变化, 读者可继续分析。

1. 已知奇偶转换排序方法如下所述: 第 1 趟对所有偶数$i$，将 a[i] 和 a[i+1] 进行比较，第 2 趟对所有偶数$i$，将 a[i] 和 a[i+1] 进行比较，每次比较时若 a[i]>a[i+1]，则将两者交换，重复以上过程，直到整个数组有序。

    (1) 试问：排序结束的条件是什么？

    (2) 编写一个实现上述排序过程的算法，函数原型如下。

    void oeSort(int a[], int n);

2. 一个集合中的元素为正整数或负整数，设计一个算法，将正整数和负整数分开，使集合的前部为负整数，后部为正整数，不要求对它们排序，但要求尽量减少交换次数。函数原型如下。

    void Separate(int s[], int n);

3. 编写一个对整型数组 A[n] 中的 A[0]~A[n-1] 元素进行选择排序的算法，要求首先从待排序区间中选择出一个最小值并同第 1 个元素交换，再从待排序区间中选择出一个最大值并同最后一个元素交换，反复进行直到待排序区间中元素的个数不超过 1 为止。算法原型如下。

    void SelectSort1(int A[], int n);

4. 按照下面函数声明编写在直接插入排序中使用二分查找方法查找出插入位置的排序算法。

    void InsertSort1(ElemType A[], int n);

5. 按照下面叙述编写一个快速排序算法。

    对于快速排序的方法和算法，各种教材的说法可能有差别，但基本思想是相同的。有一种说法是: 在对当前区间 A[s]~A[r] 进行一次划分时，用$i$和$j$分别暂存区间开始和结束位置，用$x$暂存基准元素 A[s] 的值，首先让$j$从后向前取值，若碰到小于$x$的元素 A[j]，同时$j$大于$i$，则把 A[j] 的值赋给 A[i] 位置（此时该位置已空闲），接着让$i$从前向后取值，若碰到大于$x$的元素 A[i]，同时$i$小于$j$，则把 A[i] 的值赋给 A[j] 位置（此时该位置已空闲）；以此循环进行，直到$i$等于$j$为止，此时的$i$或$j$的位置就是基准元素$x$的最终位置（此时该位置已空闲），把$x$的值赋给 A[i] 后就完成了一次划分，得到左区间为 A[s]~A[i-1]，右区间为 A[i+1]~A[r]。按照这种比较和交换元素的方法写出相应的算法。

6. 编写出对数组 A 中$n$个元素进行快速排序的非递归算法。

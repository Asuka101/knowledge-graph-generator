```c
if (BT->data == x) { /*树根结点的值等于x则由x带回结点值并返回真*/
    x = BT->data; return true;
}
else {
    /*向左子树查找若成功则继续返回真*/
    if (FindBTree(BT->left, x)) return true;
    /*向右子树查找若成功则继续返回真*/
    if (FindBTree(BT->right, x)) return true;
    /*左、右子树查找均失败则返回假*/
    return false;
}

6. 输出二叉树

输出二叉树就是根据二叉树的链接存储结构以某种树的表示形式打印出来，通常采用广义表的形式打印。用广义表表示一棵二叉树的规则是：根结点被放在由左、右子树组成的表的前面，而表是用一对圆括号括起来的。对于图5-13所示的二叉树，其对应的广义表表示为：$A(B(C,D),E(F(G)))$因此，用广义表的形式输出一棵二叉树时，应首先输出根结点，然后再依次输出它的左子树和右子树，不过在输出左子树之前要打印出左括号，在输出右子树之后要打印出右括号；另外，依次输出的左、右子树要至少有一个不为空，若均为空就没有输出的必要了。

由以上分析可知，输出二叉树的算法可在前序遍历算法的基础上作适当修改后得到，具体给出如下。

void PrintBTree(BTreeNode* BT)
{
    //输出二叉树的广义表表示
    if (BT != NULL) {
        cout << '<' << BT->data; //输出根结点的值
        if (BT->left != NULL || BT->right != NULL) {
            cout << '('; //输出左括号
            PrintBTree(BT->left); //输出左子树
            if (BT->right != NULL)
                cout << ','; //若右子树不为空则首先输出逗号分隔符
            PrintBTree(BT->right); //输出右子树
            cout << ')'; //输出右括号
        }
    }
}

7. 清除二叉树，使之变为一棵空树

要清除一棵二叉树必须先清除左子树，再清除右子树，最后删除（即回收）根结点并
```

一个算法的时间复杂度还可以具体分为最好、最差（又称最坏）和平均3种情况讨论。下面结合从一维数组 a[n]中顺序查找其值等于给定值 item 的元素的算法进行说明。

int SequenceSearch(int a[], int n, int item)
    //若查找成功则返回元素的下标，否则返回-1
{
    for(int i=0; i<n; i++)
        if(a[i]==key) return i;
    return -1;
}

此算法的时间复杂度主要取决于 for 循环体被反复执行的次数。最好情况是第 1 个元素 a[0]的值就等于 item，此时只需要进行元素的一次比较就查找成功，相应的时间复杂度为$O(1)$；最差情况是最后一个元素 a[n-1]的值等于 item，此时需要进行同全部 n 个元素的比较才能查找成功，相应的时间复杂度为$O(n)$；平均情况是：每一个元素都有相同的概率$\left(\text{即均为} \frac{1}{n}\right)$等于给定值 item，则查找成功需要同元素进行比较的平均次数为$\frac{1}{n} \sum_{i=1}^{n} i = \frac{1}{2}(n+1)$，相应的时间复杂度为$O(n)$，它同最坏情况具有相同的数量级，因为它们之间的比较次数只在系数项和常数项上有差别，而在 n 的指数上没有差别。

当在数组 a 上顺序比较 n 个全部元素后仍找不到等于给定值 item 的元素，则表明查找失败，这种情况所对应的时间复杂度也为$O(n)$。

在一个算法中，最好情况的时间复杂度最容易求出，但它通常没有多大的实际意义，因为数据一般都是随意分布的，出现最好情况分布的概率极小；最差情况的时间复杂度也容易求出，它比最好情况有实际意义，通过它可以估计到算法运行时所需要的相对最长时间，并且能够使用户知道如何设法改变数据的排列次序，尽量避免或减少最差情况的发生；平均情况下的时间复杂度的计算要困难一些，因为它往往需要概率统计等方面的数学知识，有时还需要经过严格的理论推导才能求出，但平均情况的时间复杂度最有实际意义，它确切地反映了运行一个算法的平均快慢程度，通常就用它来表示一个算法的时间复杂度。对于大多数算法来说，平均和最差这两种情况下的时间复杂度的数量级形式往往是相同的，它们主要是差别在最高次幂的系数上。另外有一些算法，其最好、最差和平均情况下的时间复杂度或相应的数量级都是相同的，如对于介绍过的算法 1-1、算法 1-2 和算法 1-3 就是如此。

5. 空间复杂度

空间复杂度(space complexity)或称空间复杂性是对一个算法在运行过程中临时占用存储空间大小的量度，它也是衡量算法有效性的一个指标。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间、算法的输入/输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间等 3 个方面。

算法的输入/输出数据所占用的存储空间是由要解决的问题所决定的，是通过参数表由

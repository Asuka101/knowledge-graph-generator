对于由数组元素结点构成的单链表, 其下标为 0 的元素结点的指针域保存元素单链表的表头指针, 所以该结点成为元素单链表的附加表头结点, 而元素单链表的最后一个结点的指针域为 0 表示空指针, 它正好是表头附加结点的下标, 由此构成带表头附加结点的循环单链表。空闲表的最后一个结点的指针域被置为整数 0 表示空指针, 若被置为整数 1 则可构成带表头附加结点的循环空闲表。

对于独立分配存储空间的结点, 通常由指针所指向, 若使用的指针为 p, 则*p 就表示该结点, p->data 和 p->next 就分别表示该结点的数值域和指针域。对于数组中的元素结点, 它是由数组名和下标值标识的, 假定数组名为 a, 下标值为 k, 则 a[k] 就表示该结点, a[k].data 和 a[k].next 就分别表示该结点的数值域和指针域, 元素单链表的表头指针为 a[0].next, 空闲单链表的表头指针为 a[1].next。了解独立结点和元素结点在访问上的差别后, 学会在独立结点所构成的单链表上进行各种运算的算法, 也就不难写出对元素单链表进行各种运算的算法。

\section*{2.5 线性表操作在单链表上的实现}

每个单链表都有一个表头指针, 用 HL 表示, 由表头指针可以访问到单链表中的任何结点, 所以要对单链表进行操作, 必须给出表头指针。假定以 HL 为表头指针的单链表是由 LNode 类型的动态结点所组成, 并且不带有表头附加结点, 下面给出对线性表抽象数据类型中列举的每一操作在单链表上的具体实现, 即 C++语言算法描述。

\section*{1. 初始化单链表}

void InitList (LNode* &HL)

{
    HL=NULL;                          //置单链表为空
}

\section*{2. 删除单链表中的所有结点, 使之成为一个空表}

删除单链表中的所有结点, 需要遍历单链表, 通过 delete 操作释放被访问的每一个结点所占的存储空间, 然后把表头指针置为空。

void ClearList(LNode*& HL)
{
    LNode *cp;                        //将用 cp(current pointer) 指向待处理结点
    LNode *np;                        //将用 np(next pointer) 指向 cp 的后继结点
    cp=HL;                            //表头指针赋给 cp
    while(cp!=NULL) {
        np=cp->next;                  //保存下一个结点的地址
        delete cp;                    //删除当前结点, 即被处理的结点
        cp=np;                        //使下一个结点成为当前结点
    }
    HL=NULL;                          //置单链表为空
}

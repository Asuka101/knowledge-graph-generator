complexity), 它是算法有效性的量度之一, 量度有效性的另一个指标是空间复杂度。时间复杂度是一个算法运行时间的相对度量。一个算法的运行时间是指在计算机上从开始到结束运行所花费的时间长短, 它大致等于计算机执行一种简单操作 (如赋值、比较、计算、转向、返回、输入和输出等) 所需的时间与算法中进行简单操作次数的乘积。因为执行一种简单操作所需的时间随机器而异, 它是由机器本身硬件环境决定的, 与算法无关, 所以只讨论影响运行时间的另一个因素——算法中进行简单操作次数的多少。

不管一个算法是简单还是复杂, 最终都是被编译后分解成简单操作再通过 CPU 来具体执行的。因此, 每个算法都对应着一定的简单操作的次数。显然, 在一个算法中, 进行简单操作的次数越少, 其运行时间也就相对的越短; 次数越多, 其运行时间也就相对的越长。所以, 通常把算法中包含简单操作次数的多少叫做该算法的时间复杂度, 用它来衡量一个算法的运行时间性能(或称计算性能)。

若解决一个问题的规模为$n$, 即所处理的数据中包含有$n$个元素, 则算法的时间复杂度通常是$n$的一个函数, 假定记为$f(n)$。下面通过例子来分析算法的时间复杂度。

【算法 1-1】累加求和。

int Sum(int b[], int n)

{

int i, s=0;

for(i=0;i<n;i++)

s+=b[i];

return s;

}

计算机执行这个算法时, 函数体中第 1 条定义并赋初值语句和第 3 条返回语句都各执行一次简单操作, 第 2 条 for 循环语句所包含的简单操作的次数可进行如下分解计算。

i=0; //1次

mark1: if(i>=n) goto mark2; //n+1次

s+=b[i]; //n次

i++; //n次

goto mark1; //n次

mark2: return s;

把第 2 条语句分解后的每一条简单语句的执行次数加起来, 就得到了它包含的简单操作的次数, 即为$4n+2$。因此, 算法 1-1 的时间复杂度为:$f(n)=4n+4$【算法 1-2】矩阵相加。

void MatrixAdd(int a[MS][MS], int b[MS][MS], int c[MS][MS], int n)

//实现矩阵 a[n,n] 和 b[n,n] 的加法, 其和存入 c[n,n] 中

//MS 为大于等于 n 的常量

{

int i,j;

for(i=0;i<n;i++)

for(j=0;j<n;j++)

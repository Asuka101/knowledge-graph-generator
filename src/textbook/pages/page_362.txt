10.2.1 直接插入排序

直接插入排序 (straight insertion sorting) 是一种简单的排序方法，在第 2 章已经做了详细讨论，这里不再赘述，下面只给出相应的 C++语言算法描述。

void InsertSort(ElemType A[], int n)
{
    //对数组A中的n个元素进行直接插入排序
    ElemType x;
    int i,j;
    for(i=1; i<n; i++) {
        x=A[i];                          //i表示插入次数,共进行n-1次插入
        for(j=i-1; j>=0;j--)             //暂存待插入有序表中的元素A[i]的值
            if(x.stn<A[j].stn) A[j+1]=A[j]; //进行顺序比较和移动
            else break;                  //查询到j+1位置时离开j循环
        A[j+1]=x;                        //把原A[i]的值插入到下标为j+1的位置
    }
}

若在程序中定义有如下对小于运算符重载的函数，则上述算法中所使用的条件 x.stn<$<$A[j].stn 应修改为$x<A[j]$。另外，若排序码 stn 域不是简单类型，而是字符指针（即字符串）类型，则重载函数中的返回表达式应改为 strcmp(x1.stn,x2.stn)$<0$。

bool operator<(ElemType& x1, ElemType& x2)
{
    return x1.stn<x2.stn;
}

直接插入排序的时间复杂度为$O(n^2)$。

在直接插入排序中，若采用二分查找而不是顺序查找待插入元素的插入位置，则可减少记录的最大和平均比较的总次数，使排序速度有所提高，但提高不会太大，因为移动记录的总次数不受改变，其时间复杂度仍为$O(n^2)$。

由上面对直接插入排序的时间复杂度的分析可知，当待排序记录为正序或接近正序时，所用的比较和移动次数较少，当待排序记录为逆序或接近逆序时，所用的比较和移动次数较多，所以直接插入排序更适合于原始数据基本有序（即正序）的情况。

在直接插入排序中，只使用一个临时工作单元 x，暂存待插入的元素，所以其空间复杂度为$O(1)$。另外，直接插入排序算法是稳定的，因为具有同一排序码的后一元素必然插在具有同一排序码的前一元素的后面，即相对次序保持不变。但若采用二分查找插入位置时，则算法的排序结果就是不稳定的。

最后还需要指出，直接插入排序的方法不仅适用于顺序表（即数组），而且适用于单链表，不过在单链表上进行直接插入排序时，不是移动记录的位置，而是修改相应的指针。

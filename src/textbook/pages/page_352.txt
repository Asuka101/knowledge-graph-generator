MT->ptr[0]=p; MT->ptr[1]=ap;
p->parent=ap->parent=MT;
return true;

}$/求出新的索引项(K,num,ap)在双亲结点的插入位置$p=p->parent;
i=1;
while(K>p->key[i]) i++;

}

\section*{9.5 .4 B_树删除}

在 B_树上删除一个关键字$K$也和在二叉搜索树上类似，都首先经过一个从树根结点到待删除关键字所在结点的查找过程，然后再分情况进行删除。若被删除的关键字在叶子结点中则直接从该叶子结点中删除之，若被删除的关键字在非叶子结点中，则首先要将被删除的关键字同它的中序前驱关键字（即它的左边指针所指子树的最右下叶子结点中的最大关键字）或中序后继关键字（即它的右边指针所指子树的最左下叶子结点中的最小关键字）进行对调（当然要连同对应记录的存储位置一起对调），然后再从对应的叶子结点中删除之。例如，若从图 9-7 (h) 中删除关键字 46 时，首先要将它与中序前驱关键字 38 或中序后继关键字 50 对调，然后再从对调后的叶子结点中删除关键字 46。从 B_树上一个叶子结点中删除一个关键字后，使得该结点的关键字个数$n$减 1，此时应分以下 3 种情况进行处理。

(1) 若删除后该结点的关键字个数$n \geqslant \lceil m / 2\rceil - 1$，则删除完成。如从图 9-7 (a) 中删除关键字 18 或 32 时就属于这种情况。

(2) 若删除后该结点的关键字个数$n < \lceil m / 2\rceil - 1$，而它的左兄弟（或右兄弟）结点中的关键字个数$n \geqslant \lceil m / 2\rceil - 1$，则首先将双亲结点中的指向该结点指针的左边（或右边）一个关键字下移至该结点中，接着将它的左兄弟（或右兄弟）结点中的最大关键字（或最小关键字）上移至它们的双亲结点中刚空出的位置上，然后再将左兄弟（或右兄弟）结点中的$P_n$指针（或$P_0$指针）赋给该结点的$P_0$指针域（或$P_n$指针域）。

如从图 9-7 (a) 中删除关键字 58 后，需首先把 46 下移至被删除关键字 58 的结点中，接着把它的左兄弟结点中的最大关键字 32 上移至原 46 的位置上，然后把左兄弟结点中的原$P_2$指针（即为空）赋给被删除关键字 58 结点的$P_0$指针域，得到的 B_树如图 9-8 (a) 所示。再如从图 9-7 (d) 中删除关键字 32 后，需首先把双亲结点中的 46 下移至该结点中，接着把右兄弟结点中的最小关键字 58 上移至双亲结点中刚空出的位置上，然后把右兄弟结点中的原$P_0$指针（即为空）赋给被删除关键字 32 结点的$P_1$指针域，删除结果如图 9-8 (b) 所示。

(3) 若删除后该结点的关键字个数$n < \lceil m / 2\rceil - 1$，同时它的左兄弟和右兄弟（若有的话）结点中的关键字个数均等于$\lceil m / 2\rceil - 1$。在这种情况下，就无法从它的左、右兄弟中通过双亲结点调到关键字以弥补自己的不足，此时就必须进行结点的“合并”，即将该结点中

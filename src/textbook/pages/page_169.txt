(a) 计算$f(4)$值
(b) 计算$f(3)$值
(c) 计算$f(2)$值
(d) 计算$f(1)$值
(e) 计算$f(0)$值

(f) 返回$f(0)$值 1
(g) 返回$f(1)$值 1
(h) 返回$f(2)$值 2
(i) 返回$f(3)$值 6
(j) 返回$f(4)$值 24

图 4-6 进行$f(4)$调用的系统栈的变化状态

间复杂度为$O(1)$, 执行整个算法求出$n!$的值需要进行$n+1$次调用, 所以其时间复杂度也为$O(n)$。由于采用循环算法求解$n!$的问题, 其空间复杂度为$O(1)$, 时间复杂度为$O(n)$, 并且省去进出栈的繁琐操作, 显然比采用递归算法更为有效。求$n$阶乘采用递归算法, 是为了详细说明系统对递归算法的处理过程, 以便能够理解更复杂的递归算法。

【例 4-5】编写一个算法输出$n$个布尔量的所有可能的组合。

分析: 每个布尔量取真和假两种值, 分别对应为数值 1 和 0。根据题意, 当$n$为 1 时有两种输出 0 和 1, 当$n$为 2 时有 4 种组合输出, 依次为 00、01、10 和 11, 当$n$为 3 时有 8 种组合输出, 依此为 000、001、010、011、100、101、110 和 111。总之, 对于$n$个布尔量所有可能的组合数为$2^n$种, 每一种为$n$位, 即$n$个布尔量的值。$n$个布尔量的$2^n$种所有不同的输出可以看成$2 \times 2^{n-1}$种输出, 其中$2^{n-1}$种输出是$n-1$个布尔量的全部输出, 每种输出包含有$n-1$个布尔量的值。$n$个布尔量的每一种输出是在$n-1$个布尔量的每种输出的前面加上假 (即 0) 或加上真 (即 1) 而分别得到的结果, 合起来正好是$2 \times 2^{n-1} = 2^n$种输出。由此可以看出它是一个递归的过程。

设$n$个布尔量用一个布尔型数组$b[n]$来表示, 要得到$b[0] \sim b[n-1]$这$n$个布尔量的每一种可能的组合, 则要首先在$b[0]$被置 0 的情况下得到$b[1] \sim b[n-1]$这$n-1$个布尔量的每一种可能的组合, 然后在$b[0]$被置 1 的情况下得到$b[1] \sim b[n-1]$这$n-1$个布尔量的每一种可能的组合; 同理, 要得到$b[1] \sim b[n-1]$这$n-1$个布尔量的每一种可能的组合, 则要首先在$b[1]$被置 0 的情况下得到$b[2] \sim b[n-1]$这$n-2$个布尔量的每一种可能的组合, 然后在$b[1]$被置 1 的情况下得到$b[2] \sim b[n-1]$这$n-2$个布尔量的每一种可能的组合; 以此类推, 直到最后一个布尔量$b[n-1]$被置 0 后输出整个数组和被置 1 后输出整个数组为止。

下面递归算法是对$b[k] \sim b[n-1]$之间的$n-k$个布尔量输出所有可能的组合, 初始调用该算法时$k$值为 0。

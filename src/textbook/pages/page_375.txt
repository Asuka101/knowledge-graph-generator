void TwoMerge(ElemType A[], ElemType R[], int s, int m, int t)
{
    //把A数组中两个相邻的有序表A[s]~A[m]和A[m+1]~A[t]
    //归并为R数组中对应位置上的一个有序表R[s]~R[t]
    int i,j,k;
    i=s; j=m+1; k=s;  //分别给指示每个有序表元素位置的指针赋初值
    //两个有序表中同时存在未归并元素时的处理过程
    while(i<=m && j<=t)
        if(A[i].stn<=A[j].stn) {
            R[k]=A[i]; i++; k++;
        }
        else {
            R[k]=A[j]; j++; k++;
        }
    //对第一个有序表中存在的未归并元素进行处理
    while(i<=m) {
        R[k]=A[i]; i++; k++;
    }
    //对第二个有序表中存在的未归并元素进行处理
    while(j<=t) {
        R[k]=A[j]; j++; k++;
    }
}

归并排序（merge sorting）就是利用归并操作把一个无序表排列成一个有序表的过程。
若利用二路归并操作则称为二路归并排序。二路归并排序的过程是：首先把待排序区间
(即无序表)中的每一个元素都看作一个有序表，则$n$个元素构成$n$个有序表，接着两两归
并，即第1个表同第2个表归并，第3个表同第4个表归并……若最后只剩下一个表，则
直接进入下一趟归并，这样就得到了$\lceil n/2 \rceil$个长度为2（最后一个表的长度可能小于2）的
有序表，称此为一趟归并；然后再两有序表归并，得到$\lceil n/2 \rceil /2$个长度为4（最后一个表
的长度可能小于4）的有序表；如此进行下去，直到归并第$\lceil \log_2 n \rceil$趟后得到一个长度为$n$的有序表为止。

例如，有10个元素的排序码为：
\[
(45, 53, 18, 36, 72, 30, 48, 93, 15, 36)
\]
则进行二路归并排序的过程，如图10-9所示。

(0)[45] [53] [18] [36] [72] [30] [48] [93] [15] [36]
(1)[45 53] [18 36] [30 72] [48 93] [15 36]
(2)[18 36 45 53] [30 48 72 93] [15 36]
(3)[18 30 36 45 48 53 72 93] [15 36]
(4)[15 18 30 36 36 45 48 53 72 93]

图10-9 二路归并排序的过程示例

要给出二路归并的排序算法，首先要给出一趟归并排序的算法。设数组A[n]中每个有

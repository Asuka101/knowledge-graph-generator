第7章图
7.1图的概念
7.1.1图的定义
图(graph)是图型结构的简称，是一种复杂的非线性数据结构。图在各个领域都有着广泛的应用。图的二元组定义为：G=(V,E)。其中V是顶点集合，V=v_i|0leqileqn-1,ngeq0,v_iintextVertexType，textVertexType为顶点值的类型，同以前使用的textElemType一样可以代表任何类型，n为顶点数，当n=0时则V为空集；E是V上二元关系的集合，通常讨论仅含一个二元关系的情况，且直接用E表示这个关系。这样，E就是V上顶点的序偶或无序对（每个无序对(x,y)是两个对称序偶langlex,yrangle和langley,xrangle的简写形式）的集合。对于V上的每个顶点，在E中都允许有任意多个前驱和任意多个后继，即对每个顶点的前驱和后继个数均不加限制。
回顾一下线性表和树的二元组定义，都是在其二元关系上规定了某种限制，线性表的限制是只允许每个结点有一个前驱和一个后继；树的限制是只允许每个结点有一个前驱。因此，图比线性表和树更具有广泛性，它包含线性表和树在内，线性表和树可看作图的简单情况。
对于一个图G，若E是序偶的集合，则每个序偶对应图形中的一条有向边，若E是无序对的集合，则每个无序对对应图形中的一条无向边，所以可把E看作为边的集合。这样图的二元组定义可叙述为：图由顶点集（vertexset）和边集（edgeset）所组成。针对图G，顶点集和边集可分别记为V(G)和E(G)。若顶点集为空，则边集必然为空；若顶点集非空，则边集可空可不空。当边集为空时，图G中的顶点均为孤立顶点。
对于一个图G，若边集E(G)中为有向边，则称此图为有向图（directedgraph）；若边集E(G)中为无向边，则称此图为无向图（undirectedgraph）。如图7-1所示，G1和G2分别为一个无向图和有向图，G1中每个顶点里的数字为该顶点的序号（序号从0开始），顶点的值没有在图形中给出，G2中每个顶点里的字母为该顶点的值或关键字，顶点外面的数字为该顶点的序号。在一般的图型结构讨论中，只关心顶点的序号而不关心顶点的值，所有顶点的值通常被另外保存在一个数组或文件中，待需要时取用。G1和G2对应的顶点集和边集分别如下所示，这里假定用每个顶点的序号i代替顶点v_i的值。
V(G1)=0,1,2,3,4,5,E(G1)=(0,1),(0,2),(0,3),(0,4),(1,4),(2,4),(2,5),(3,5),(4,5)V(G2)=0,1,2,3,4E(G2)=<0,1>,<0,2>,<1,2>,<1,4>,<2,1>,<2,3>,<4,3>若用G2顶点的值表示其顶点集和边集，则如下所示。V(G2)=textA,B,C,D,EE(G2)=<textA,B>,<textA,C>,<textB,C>,<textB,E>,<textC,B>,<textC,D>,<textE,D>在日常生活中，图的应用到处可见，如各种交通图、线路图、结构图和流程图等。
subsection7.1.2图的基本术语
section1.端点和邻接点
在一个无向图中，若存在一条边(v_i,v_j)，则称v_i、v_j为此边的两个端点，并称它们互为邻接点(adjacent)，即v_i是v_j的一个邻接点，v_j也是v_i的一个邻接点。在图7-1(a)中，以顶点v_0为端点的4条边是(0,1)、(0,2)、(0,3)和(0,4)，v_0的4个邻接点分别为v_1、v_2、v_3和v_4；以顶点v_3为端点的两条边是(3,0)和(3,5)，v_3的两个邻接点分别为v_0和v_5。
在一个有向图中，若存在一条边<v_i,v_j>，则称此边是顶点v_i的一条出边（outedge）。顶点v_j的一条入边（inedge）；称v_i为此边的起始点，简称起点或始点，v_j为此边的终止端点，简称终点；称v_i和v_j互为邻接点，并称v_j是v_i的出边邻接点，v_i是v_j的入边邻接点。在图7-1(b)中，顶点C有两条出边<textC,B>和<textC,D>，两条入边<textA,C>和<textB,C>，顶点C的两个出边邻接点为B和D，两个入边邻接点为A和B。
section2.顶点的度
无向图中顶点v的度（degree）为以该顶点为一个端点的边的数目，简单地说，就是该顶点的边的数目，记为D(v)。在图G1中v_0顶点的度为4，v_1顶点的度为2。有向图中顶点v的度有入度和出度之分，入度（indegree）是该顶点的入边的数目，记为textID(v)；出度（outdegree）是该顶点的出边的数目，记为textOD(v)；顶点v的度等于它的入度和出度之和，即D(v)=textID(v)+textOD(v)。在图G2中顶点A的入度为0，出度为2，度为2；顶点C的入度为2，出度为2，度为4。
若一个图中有n个顶点和e条边，则该图所有顶点的度数之和同边数e满足下面关系：e=frac12sum_i=0^n-1D(v_i)因为每条边各为两个端点增加度数1，合起来为图中添加度数2，所以全部顶点的度数之和为所有边数的2倍，或者说，边数为全部顶点的度数之和的一半。
3.完全图、稠密图、稀疏图
若无向图中的每两个顶点之间都存在着一条边，有向图中的每两个顶点之间都存在着方向相反的两条边，则称此图为完全图。显然，若完全图是无向的，则图中包含有frac12n(n-1)条边，它等于从n个元素中每次取出2个元素的所有组合数；若完全图是有向的，则图中包含有n(n-1)条边，即每个顶点到其余n-1个顶点之间都有一条出边。当一个图接近完全图时，则称它为稠密图，相反，当一个图含有较少的边数（即e<<n(n-1)，双小于号表示远远小于，此边数通常与顶点数n同数量级）时，则称它为稀疏图。如图7-2所示，G3就是一个含有5个顶点的无向完全图，G4就是一个含有6个顶点的稀疏图。
(a)G3
(b)G4
图7-2完全图和稀疏图
4.子图
设有两个图G=(V,E)和G'=(V',E')，若V'是V的子集，即V'subseteqV，且E'是E的子集，即E'subseteqE，并且E'中所涉及到的顶点全部包含在V'中，则称G'是G的子图。例如，由G3中的全部顶点和同一v_0相连的所有边可构成G3的一个子图，由G3中的顶点v_0、v_1、v_2和它们之间的所有边可构成G3的另一个子图。
5.路径和回路
在一个图G中，从顶点v到顶点v'的一条路径(path)是一个顶点序列v_i1,v_i2,cdots,v_im，其中v=v_i1，v'=v_im，若此图是无向图，则(v_j-1,v_j)inE(G)，(2leqjleqm)；若此图是有向图，则<v_j-1,v_j>inE(G)，(2leqjleqm)。从顶点v到顶点v'的路径长度是指该路径上经过的边的数目。若在一条路径上的所有顶点均不同，则称为简单路径。若一条路径上的前后两端点相同，则称为回路或环(cycle)，若回路中除前后两端点相同外，基余顶点均不同则称为简
单回路或简单环。在图G4中,从顶点c到顶点d的一条简单路径为c、e、a、b、d,其路径长度为4;路径a、b、e、a为一条简单回路,其路径长度为3;路径a、b、e、f、b不是一条简单路径,因为存在着从顶点b到b的一条回路。
6.连通和连通分量
在无向图G中,若从顶点v_i到顶点v_j有路径,则称v_i和v_j是连通的。若图G中任意两个顶点都连通,则称G为连通图,否则若存在顶点之间不连通的情况则称为非连通图。无向图G的极大连通子图称为G的连通分量。显然,任何连通图都可以通过一个连通分量把所有顶点连通起来,而非连通图有多个连通分量。例如,上面给出的图G1和图G3都是连通图。下面图7-3(a)所示为一个非连通图,它包含有3个连通分量,如图7-3(b)、图7-3(c)、图7-3(d)所示。
(a)无向图
(b)第一个连通分量
(c)第二个连通分量
(d)第三个连通分量
图7-3非连通图和连通分量
7.强连通图和强连通分量
在有向图G中,从顶点v_i到顶点v_j有路径,则称从v_i到v_j是连通的。若图G中的任意两个顶点v_i和v_j都连通,即从v_i到v_j和从v_j到v_i都存在路径,则称G是强连通图。有向图G的极大强连通子图称为G的强连通分量。显然,强连通图可以通过一个强连通分量把所有顶点连通起来,非强连通图有多个强连通分量。如图7-4(a)所示有3个强连通分量,如图7-4(b)、图7-4(c)、图7-4(d)所示。
(a)有向量
(b)第一个强连通分量
(c)第二个强连通分量
(d)第三个强连通分量
图7-4有向图和强连通分量
8.权和网
在一个图中,每条边可以标上具有某种含义的数值,通常为非负实数,此数值称为该边的权(weight)。例如,对于一个反映城市交通线路的图,边上的权可表示该条线路的长度或等级;对于一个反映电子线路的图,边上的权可表示两端点间的电阻、电流或电压;对于一个反映零件装配的图,边上的权可表示一个端点零件需要装配另一个端点零件的数量。
量；对于一个反映工程进度的图，边上的权可表示从前一子工程到后一子工程所需要的天数。边上带有权的图称作带权图，也常称做网(network)。如图7-5所示的G5和G6就分别是一个无向带权图和有向带权图。
(a)G5
(b)G6
图7-5无向带权图和有向带权图
对于带权图，若用图的顶点集和边集表示，则边集中每条边的后面应附加该边上的权值。图G5和G6的边集分别为：E(G5)=(0,1)5,(0,2)7,(1,2)12,(1,3)3,(1,4)8,(2,3)6,(2,4)20,(3,4)15E(G6)=<0,1>2,<0,2>3,<0,3>8,<1,3>12,<2,0>6,<2,3>6,<2,4>1,<3,4>4subsection7.1.3图的抽象数据类型
图的抽象数据类型的数部分为一个图G，它可以采用顺序、链接等任一种存储结构，存储类型用GraphType标识符表示，操作部分包括初始化图、建立图、遍历图、查找图、输出图、清除图等常用运算，以及求图的最小生成树、最短路径、拓扑排序、关键路径等特定运算。图的抽象数据类型的具体定义如下。
DATGRAPHis
Data:
一个图G，存储类型用标识符GraphType表示
Operations
voidInitGraph(GraphType&G);//初始化图的存储空间
voidCreateGraph(GraphType&G,charE,intn);//根据图的边集E建立图的存储结构
voidTraverseGraph(GraphType&G,inti,intn);//按照一定次序从顶点i开始遍历图
boolFindGraph(GraphType&G,VertexType&item,intn);//从图中查找给定值顶点
voidPrintGraph(GraphType&G,intn);//按照图的一种表示方法输出一个图
voidClearGraph(GraphType&GT);//清除图中动态分配的存储空间
voidMinSpanGraph(GraphType&G,intn);//求图中的最小生成树
voidMinPathGraph(GraphType&G,intn);//求图中顶点之间的最短路径
voidTopolGraph(GraphType&G,intn);//求有向图中顶点之间的拓扑序列
voidKeyPathGraph(GraphType&G,intn);//求有向带权图中的关键路径
endGeneralTree
本章将结合图的存储结构和遍历讨论图的常用运算的算法，对于图的特定运算的方法和算法，将留到第8章专门讨论。
section7.2图的存储结构
图的存储结构又称图的存储表示或图的表示。图有多种表示方法，这里介绍比较常用的邻接矩阵、邻接表和边集数组3种。
subsection7.2.1邻接矩阵
邻接矩阵（adjacencymatrix）是表示图形中顶点之间相邻关系的矩阵。设G=(V,E)是具有n个顶点的图，顶点序号依次为0,1,2,cdots,n-1，则G的邻接矩阵是具有如下定义的n阶方阵。A[i,j]=begincases1&text对于无向图，(v_i,v_j)text或(v_j,v_i)inE(G);1&text对于有向图，langlev_i,v_jrangleinE(G)0&E(G)text中不存在v_isimv_jtext的边endcases对于图7-1中的G_1和G_2，它们的邻接矩阵分别为如A_1和A_2所示。由A_1可以看出，无向图的邻接矩阵是按主对角线为轴对称的。A_1=beginbmatrix0&1&1&1&1&01&0&0&0&1&01&0&0&0&1&01&0&0&0&0&11&1&1&0&0&10&0&1&1&1&0endbmatrix,A_2=beginbmatrix0&1&1&0&00&0&1&0&10&1&0&1&00&0&0&0&00&0&0&1&0endbmatrix若图G是一个带权图，则用邻接矩阵表示也很方便，只要把1换为相应边上的权值，把非对角线上的0换为某一个很大的特定实数，表示这个边不存在，这个特定实数通常用infty或MaxValue表示，它要大于图G中所有边上的权值之和。
例如，对于图7-5中的带权图G_5和G_6，它们的邻接矩阵分别用A_3和A_4所示。A_1=beginbmatrix0&5&7&infty&infty5&0&12&3&8infty&12&0&6&20infty&3&6&0&15infty&8&20&15&0endbmatrix,A_2=beginbmatrix0&2&3&8&inftyinfty&0&infty&12&infty6&infty&0&6&1infty&infty&infty&0&4infty&infty&infty&infty&0endbmatrix
采用邻接矩阵表示图，便于查找图中任一条边或边上的权。如要查找边(i,j)或<i,j>,则只要查找邻接矩阵中第i行第j列的元素A[i,j]是否为一个有效值（即非零值和非MaxValue值）。若该元素为一个有效值，则表明此边存在，否则此边不存在。邻接矩阵中的元素可以随机存取，所以查找一条边的时间复杂度为O(1)。这种存储表示也便于查找图中任一点的度，对于无向图，顶点v_i的度就是对应第i行或第i列上有效元素的个数；对于有向图，顶点v_i的出度就是对应第i行上有效元素的个数，顶点v_i的入度就是对应第i列上有效元素的个数。由于求任一点的度需访问对应一行或一列中的所有元素，所以其时间复杂度为O(n)，n表示图中的顶点数，即邻接矩阵的阶数。从图的邻接矩阵中查任一项点的一个邻接点或所有邻接点同样也很方便。如查找v_i的一个邻接点（对于无向图）或出边邻接点（对于有向图），则只要在第i行上查找出一个有效元素，以该元素所在的列号j为序号的顶点v_j就是所求的一个邻接点或出边邻接点。一般算法要求是依次查找出一个顶点v_i的所有邻接点（对于有向图则为出边邻接点或入边邻接点），此时需访问对应第i行或第i列上的所有元素，所以其时间复杂度为O(n)。
图的邻接矩阵的存储需要占用ntimesn个整数存储位置（因顶点的序号为整数），所以其空间复杂度为O(n^2)。这种存储结构用于表示稠密图能够充分利用存储空间，但若用于表示稀疏图，则将使邻接矩阵变为稀疏矩阵，从而造成存储空间的很大浪费。
图的邻接矩阵表示，只是使用一个二维数组存储顶点之间相邻的关系，为了存储图中n个顶点元素的信息，通常还需要使用一个一维数组，用数组中下标为i的元素存储顶点v_i的信息。这两种数组的类型可定义如下。
constintMaxVertexNum=图的最大顶点数，它要大于等于具体图的顶点数n;
constintMaxEdgeNum=图的最大边数，它要大于等于具体图的边数e;
typedefintWeightType;//定义边的权值类型
constWeightTypeMaxValue=特定权值，它要大于图中所有有效权值之和;
typedefVertexTypevexlist[MaxVertexNum];//定义vexlist为存储顶点信息的数组类型
typedefintadjmatrix[MaxVertexNum][MaxVertexNum];
//定义adjmatrix为存储邻接矩阵的数组类型
图的顶点信息利用vexlist类型的一维数组存储后，能够根据顶点序号直接访问到相应元素，图中顶点之间的邻接关系利用邻接矩阵存储后，也能够根据任一条边的两个端点直接访问到相应元素，所以，可把它们看作是图的一种顺序存储。
section1.图的邻接矩阵存储的初始化算法
voidInitMatrix(adjmatrixGA,intk)//假定k等于0为无权图，k不等于0为有权图
inti,j;
for(i=0;i<MaxVertexNum;i++)
for(j=0;j<MaxVertexNum;j++)
if(i==j)GA[i][j]=0;
elseif(k)GA[i][j]=MaxValue;
elseGA[i][j]=0;
2.根据一个图的边集生成图的邻接矩阵的算法
voidCreateMatrix(adjmatrixGA,intn,chars,intk1,intk2)
//k1为0则为无向图否则为有向图，k2为0则为无权图否则为有权图
//s字符串用来保存一个图的边集，n为图的顶点数
istringstreamsin(s);//定义sin为字符串输入流，与s边集对应
charc1,c2,c3;//用来保存从输入流中读入的字符
inti,j;//用i,j保存一条边的起点和终点序号
WeightTypew;//用w保存一条边的权值
sin>>c1;//从sin输入流中读入第1个字符'('
if(k1==0&&k2==0)//建立无向无权图
do
sin>>c1>>i>>c2>>j>>c3;//依次读入一条边的5个数据
GA[i][j]=GA[j][i]=1;//置相应的对称元素为1
sin>>c1;//读入逗号或右花括号
if(c1==')')break;//边集处理完毕，退出循环
while(1);
elseif(k1==0&&k2!=0)//建立无向有权图
do
sin>>c1>>i>>c2>>j>>c3>>w;
GA[i][j]=GA[j][i]=w;//置相应的对称元素为w
sin>>c1;
if(c1==')')break;
while(1);
elseif(k1!=0&&k2==0)//建立有向无权图
do
sin>>c1>>i>>c2>>j>>c3;
GA[i][j]=1;//置相应的元素为1
sin>>c1;
if(c1==')')break;
while(1);
elseif(k1!=0&&k2!=0)//建立有向有权图
do
sin>>c1>>i>>c2>>j>>c3>>w;
GA[i][j]=w;//置相应的元素为w
sin>>c1;
if(c1==')')break;
while(1);
在算法中的每条sin语句之后可增加一条语句或函数调用检查i和j是否在0simn-1范围内，若不在则退出运行。
3.根据图的邻接矩阵输出图的二元组表示（顶点集和边集）的算法
voidPrintMatrix(adjmatrixGA,intn,intk1,intk2)
```cpp
//输出用邻接矩阵表示一个图的顶点集和边集
inti,j;
cout<<"V=";//输出顶点集开始
for(i=0;i<n-1;i++)cout<<i<<',';
cout<<n-1<<''<<endl;//输出顶点集结束
cout<<"E=";//输出边集开始
if(k2==0)
//对无权图的处理情况
for(i=0;i<n;i++)
for(j=0;j<n;j++)
if(GA[i][j]==1)
if(k1==0)
//对无向无权图的处理
if(i<j)cout<<'('<<i<<','<<j<<')'<<',';
else
//对有向无权图的处理
cout<<'<'<<i<<','<<j<<'>'<<',';
else
//对有权图的处理情况
for(i=0;i<n;i++)
for(j=0;j<n;j++)
if(GA[i][j]!=0&&GA[i][j]!=MaxValue)
if(k1==0)
//对无向有权图的处理
if(i<j)cout<<'('<<i<<','<<j<<')'<<GA[i][j]<<',';
else
//对有向有权图的处理
cout<<'<'<<i<<','<<j<<'>'<<GA[i][j]<<',';
cout<<''<<endl;//注意:边集的最后一条边的后面多出一个逗号
在上面的各算法中，邻接矩阵参数GA为值参，由于它是指针参数，只占用4个字节的存储空间，与调用它的实参指向同一个二维数组，共同访问该实参数组中的相应元素。所以，对于指针值参，也同样具有一般引用参数的作用。
section7.2.2邻接表
邻接表(adjacencylist)是对图中的每个顶点建立一个邻接关系的单链表，并把它们的表头指针用一维向量（数组）存储的一种图的表示方法。为顶点v_i建立的邻接关系的单链表称作v_i邻接表。v_i邻接表中的每个结点用来存储以该顶点为端点或起点的一条边的信息，因而被称为边结点。v_i邻接表中的结点数，对于无向图来说，等于v_i的度数、邻接点数或出度数；对于有向图来说，等于v_i的出边数、出边邻接点数或出度数。边结点的类型通常被定义为3个域：一是邻接点域(adjvex)，用以存储顶点v_i的一个邻接顶点v_j的序号j；二是权域(weight)，用以存储边(v_i,v_j)或<v_i,v_j>上的权；三是链域(next)，用以链接v_i邻接表中的下一个结点。在这3个域中，邻接点域和链域是必不可少的，权域可根据情况取舍，
```
若表示的是无权图，则可省去此域。对于每个顶点v_i的邻接表，需要设置一个表头指针，若图G中有n个顶点，则就有n个表头指针。为了便于随机访问任一顶点的邻接表，需要把这n个表头指针用一个一维数组（数组）存储起来，其中第i个分量存储v_i邻接表的表头指针。这样，图G就可以由这个表头向量来表示和存取。
图7-1中的G1和图7-5中的G6对应的邻接表如图7-6所示。
(a)G1所示的邻接表
(b)G6所示的邻接表
图7-6G1和G6的邻接表
图的邻接表不是唯一的，因为在每个顶点的邻接表中，各边结点的链接次序可以任意安排，其具体链接次序与边的输入次序和生成算法有关。
建立图的邻接表中边结点的类型定义和表头向量的类型定义如下。
structedgenode
intadjvex;//邻接点域
WeightTypeweight;//权值域，对无权图可省去
edgenodenext;//指向下—个边结点的链域
;
typedefedgenodeadjlist[MaxVertexNum];//定义adjlist为存储n个表头指针的
//数组类型
1.初始化一个图邻接表的算法
voidInitAdjoin(adjlistGL)
for(inti=0;i<MaxVertexNum;i++)GL[i]=NULL;
2.根据一个图的边集生成其邻接表的算法
voidCreateAdjoin(adjlistGL,intn,chars,intk1,intk2)
//k1为0则为无向图；否则为有向图，k2为0则为无权图；否则为有权图
istringstreamsin(s);
charc1,c2,c3;
inti,j;
WeightTypew;
edgenodep;
sin>>c1;
if(k2==0)
do
//从输入流中读入一条边
sin>>c1>>i>>c2>>j>>c3;
p=newedgenode;
p->adjvex=j;p->weight=1;//假定无权图的每条边的权为1
p->next=GL[i];
GL[i]=p;
//对于无向图,还需向序号为j的单链表的表头插入一个边结点
if(k1==0)
p=newedgenode;
p->adjvex=i;p->weight=1;
p->next=GL[j];
GL[j]=p;
while(c1==',');
else
do
//从输入流中读入一条边
sin>>c1>>i>>c2>>j>>c3>>w;
p=newedgenode;
p->adjvex=j;p->weight=w;
p->next=GL[i];
GL[i]=p;
//对于无向图,还需向序号为j的单链表的表头插入一个边结点
if(k1==0)
p=newedgenode;
p->adjvex=i;p->weight=w;
p->next=GL[j];
GL[j]=p;
while(c1==',');
3.把邻接表表示的图用顶点集和边集的形式输出的算法
voidPrintAdjJoin(adjlistGL,intn,intk1,intk2)
//输出用邻接表表示一个图的顶点集和边集
inti,j;
edgenodep;
cout<<"V=";
for(i=0;i<n-1;i++)cout<<i<<',';
cout<<n-1<<''<<endl;
cout<<"E=";
for(i=0;i<n;i++)
if(k2==0)
p=GL[i];
while(p)
j=p->adjvex;
if(k1==0)
//对无向无权图的处理情况
if(i<j)cout<<'('<<i<<','<<j<<')'<<',';
//使用条件i<j，是为了避免输出重复边
else
//对有向无权图的处理
cout<<'<'<<i<<','<<j<<'>'<<',';
p=p->next;
else
//对有权图的处理情况
p=GL[i];
while(p)
j=p->adjvex;
if(k1==0)if(i<j)
//对无向有权图的处理
cout<<'('<<i<<','<<j<<')'<<p->weight<<',';
else
//对有向有权图的处理
cout<<'<'<<i<<','<<j<<'>'<<p->weight<<',';
p=p->next;
cout<<''<<endl;
//注意：边集的最后一条边的后面多出一个逗号
在图的邻接表中查找一个顶点的边（出边）或邻接点（出边邻接点），只要首先从表头向量中取出对应的表头指针，然后从表头指针出发进行查找即可。由于每个顶点单链表的平均长度为e/n（对于有向图）或2e/n（对于无向图），所以此查找运算的时间复杂度为O(e/n)。但从有向图的邻接表中查找一个顶点的入边或入边邻接点，那就不方便了，它需要扫描所有顶点邻接表中的边结点，因此其时间复杂度为O(n+e)。对于那些需要经常查找
顶点入边或入边邻接点的运算,可以为此专门建立一个逆邻接表(ContraryAdjacencyList),该表中每个顶点的单链表不是存储该顶点的所有出边的信息,而是存储所有入边的信息,邻接域存储的是入边邻接点的序号。如图7-5所示是为图7-5中的G_6建立的逆邻接表,从此表中很容易求出每个顶点的入边、入边上的权、入边邻接点和入度。
![0]->[26∧]
1->[02∧]
2->[03∧]
3->[08-]->[112-]->[26∧]
4->[21-]->[34∧]
图7-7G6的逆邻接表
在有向图的邻接表中,求顶点的出边信息较方便,在逆邻接表中,则求顶点的入边信息较方便,若把它们合起来构成一个十字邻接表(orthogonaladjacencylist),则求顶点的出边信息和入边信息都将很方便。如图7-8所示是为图7-5中的G_6建立的十字邻接表。
![0]->[012∧]->[023∧]->[038∧]
1->[1312∧]
2->[206∧]->[236∧]->[241∧]
3->[344∧]
4->[]
图7-8G6的十字邻接表
在十字邻接表中,每个边结点对应图中的一条有向边,它包含5个域:边的起点域、终点域、边上的权域、入边链域和出边链域。其中,入边链域用于指向同一个顶点的下一条入边结点,通过它把入边链接起来;出边链域用于指向同一个顶点的下一条出边结点,通过它把出边链接起来。表头向量中的每个分量包括两个域:入边表的表头指针域和出边表的表头指针域。
在图的邻接表、逆邻接表或十字邻接表示中,表头向量需要占用n个或2n个指针存储空间,所有边结点需要占用2e(对于无向图)或e(对于有向图)个边结点空间,所以其空间复杂度为O(n+e)。这种存储结构用于表示稀疏图比较节省存储空间,因为只需要很少的边结点,若用于表示稠密图,则将占用较多的存储空间,同时也将增加在每个顶点邻接表中查找结点的时间。
图的邻接表表示和图的邻接矩阵表示,虽然方法不同,但也存在着对应的关系。邻接
表中每个顶点v_i的单链表对应邻接矩阵中的第i行，整个邻接表可看做是邻接矩阵的带行指针向量的链接存储；整个逆邻接表可看成邻接矩阵的带列指针向量的链接存储；整个十字邻接表可看成邻接矩阵的十字链接存储。对于稀疏矩阵，若采用链接存储是比较节省存储空间的，所以稀疏图的邻接表示比邻接矩阵表示要节省存储空间。
section7.2.3边集数组
边集数组(edgesetarray)是利用一维数组存储图中所有边的一种图的表示方法。该数组中所含元素的个数要大于等于图中边的条数，每个元素用来存储一条边的起点、终点（对于无向图，可选定边的任一端点为起点或终点）和权（若有的话），各边在数组中的次序可任意安排，也可根据具体要求而定。边集数组只是存储图中所有边的信息，若需要存储顶点信息，同样需要一个具有n个元素的一维数组。图7-1中的G2和图7-5中的G5所对应的边集数组如图7-9所示。
(a)G2的边集数组
(b)G5的边集数组
图7-9G2和G5的边集数组
section1.边集数组中的元素类型和边集数组类型定义
structedge
intfromvex;//边的起点域
intendvex;//边的终点域
WeightTypeweight;//边的权值域,对于无权图可省去此域
;
typedefedgeedgeset[MaxEdgeNum];//定义edgeset为边集数组类型
section2.初始化图的边集数组的算法
voidInitArray(edgesetGE)
for(inti=0;i<MaxEdgeNum;i++)
GE[i].fromvex=GE[i].endvex=-1;
GE[i].weight=MaxValue;
section3.根据图的边集生成图的边集数组的算法
voidCreateArray(edgesetGE,intn,chars,intk)
//k为0则无权图否则为有权图
```cpp
istringstreamsin(s);
charc1,c2,c3;
inti,j,c=0;
WeightTypew;
sin>>c1;
if(k==0)//建立无权图
do
//从输入流中读入一条边
sin>>c1>>i>>c2>>j>>c3;
//置边集数组中下标为c的元素值
GE[c].fromvex=i;
GE[c].endvex=j;
GE[c].weight=1;//假定无权图的每条边的权为1
c++;
//读入逗号或右花括号
sin>>c1;
while(c1==',');
else//建立有权图
do
//从输入流中读入一条边
sin>>c1>>i>>c2>>j>>c3>>w;
//置边集数组中下标为c的元素值
GE[c].fromvex=i;
GE[c].endvex=j;
GE[c].weight=w;
c++;
//读入逗号或右花括号
sin>>c1;
while(c1==',');
4.根据图的边集数组表示输出图的二元组表示的算法
voidPrintArray(edgesetGE,intn,intk1,intk2)
//输出用边集数组表示一个图的顶点集和边集
inti;
cout<<"V=";
for(i=0;i<n-1;i++)cout<<i<<",";
cout<<n-1<<""<<endl;
cout<<"E=";
i=-1;
while(GE[++i].fromvex!=-1)//访问边集数组中的每条边
if(k2==0)
if(k1==0)//对无向无权图的处理
```
```cpp
cout<<'('<<GE[i].fromvex<<','<<GE[i].endvex<<')'<<',';
else
//对有向无权图的处理
cout<<'<''<GE[i].fromvex<<','<<GE[i].endvex<<'>'<<',';
else
if(x1==0)//对无向有权图的处理
cout<<'('<<GE[i].fromvex<<','<<GE[i].endvex;
cout<<')'<<GE[i].weight<<',';
else
//对有向有权图的处理
cout<<'<''<GE[i].fromvex<<','<<GE[i].endvex;
cout<<'>'<<GE[i].weight<<',';
cout<<')'<<endl;//注意:边集的最后一条边的后面多出一个逗号
若一个图中有e条边，在边集数组中查找一条边或一个顶点的度都需要扫描整个数组，所以其时间复杂度为O(e)。边集数组适合那些对边依次进行处理的运算，不适合对顶点的运算和对任一条边的运算。边集数组表示的空间复杂度为O(e)。从空间复杂度上讲，边集数组也适合表示稀疏图。
图的邻接矩阵、邻接表和边集数组表示各有利弊，具体应用时，要根据图的稠密和稀疏程度以及算法的要求进行选择。
section7.3图的遍历
图的遍历就是从指定的某个顶点（称此为初始点）出发，按照一定的搜索方法对图中的所有顶点都做一次访问的过程。图的遍历比树的遍历要复杂，因为从树根到达树中的每个结点只有一条路径，而从图的初始点到达图中的每个顶点可能存在着多条路径。当顺着图中的一条路径访问过某一个顶点后，可能还会顺着另一条路径回到该顶点。为了避免重复访问图中的同一个顶点，必须记住每个顶点是否被访问过，为此可设置一个辅助数组visited[n]，它的每个元素的初值均为逻辑值假，即常量0，表明未被访问过，一旦访问了顶点v_i，就把对应元素visited[i]置为逻辑值真，即常量1，表明v_i已被访问过。
根据搜索方法的不同，图的遍历有两种：深度优先搜索遍历和广度优先搜索遍历。
subsection7.3.1深度优先搜索遍历
深度优先搜索（depth-firstsearch）遍历类似于对树的先根遍历，它是一个递归过程，可叙述为：首先访问一个顶点v_i（一开始为初始点），并将其标记为已访问过，然后从v_i的任一个未被访问过的邻接点（有向图的入边邻接点除外，下同）出发进行深度优先搜索
```
遍历,当v_1的所有邻接点均被访问过时,则退回到上一个顶点v_k,从v_k的另一个未被访问过的邻接点出发进行深度优先搜索遍历,直到退回到初始点并且没有未被访问过的邻接点为止。
结合如图7-10所示的无向图G7分析以v_0作为初始点的深度优先搜索遍历的过程。
(1)访问顶点v_0,并将visited[0]置为真,表明v_0已被访问过,接着从v_0的一个未被访问过的邻接点v_1(v_0的3个邻接点v_1,v_2和v_3都未被访问过,先访问v_1)出发进行深度优先搜索遍历。
(2)访问顶点v_1,并将visited[1]置为真,表明v_1已被访问过,接着从v_1的一个未被访问过的邻接点v_4(v_1的4个邻接点中只有v_0被访问过,其余3个邻接点v_4,v_5,v_6均未被访问过,先访问v_4)出发进行深度优先搜索遍历。
(3)访问顶点v_4,并将visited[4]置为真,表明v_4已被访问过,接着从v_4的一个未被访问过的邻接点v_5(v_4的两个邻接点为v_1和v_5,v_1被访问过,只剩v_5一个未被访问)出发进行深度优先搜索遍历。
(4)访问顶点v_5,并将visited[5]置为真,表明v_5已被访问过,接着因v_5的两个邻接点v_1和v_4都已被访问过,所以退回到上一个顶点v_4,又因v_4的两个邻接点v_1和v_5都已被访问过,所以再退回到上一个顶点v_1,v_1的4个邻接点中有3个已被访问过,此时只能从未被访问过的邻接点v_6出发进行深度优先搜索遍历。
(5)访问顶点v_6,并将visited[6]置为真,表明v_6已被访问过,接着从v_6的一个未被访问过的邻接点v_2(只此一个)出发进行深度优先搜索遍历。
(6)访问顶点v_2,并将visited[2]置为真,表明v_2已被访问过,接着因v_2的所有邻接点(即v_0和v_6)都被访问过,所以退回到上一个顶点v_6,同理,由v_6退回到v_1,再从v_1的一个未被访问过的邻接点v_3(只此一个)出发进行深度优先搜索遍历。
(7)访问顶点v_3,并将visited[3]置为真,表明v_3已被访问过,接着因v_3的所有邻接点(它仅有一个邻接点v_0)都被访问过,所以退回到上一个顶点v_0,又因v_0的所有邻接点都已被访问过,所以再退回,实际上就结束了对G7的深度优先搜索遍历的过程,返回到调用此算法的函数中去。
从对无向图G7进行深度优先搜索遍历的过程分析可知,从初始点v_0出发,访问G7中各顶点的次序为:v_0,v_1,v_4,v_5,v_6,v_2,v_3。
图的深度优先搜索遍历的过程是递归的,visited[n]为保存顶点访问标记的逻辑型数组,每个元素的初值均为假。下面分别以邻接矩阵和邻接表作为图的存储结构,给出相应的深度优先搜索遍历的算法描述。
voiddfsMatrix(adjmatrixGA,inti,intn,boolvisited)
//从初始点v_i出发深度优先搜索由邻接矩阵GA表示的图
cout<<i<<'';
//假设访问顶点v_i以输出该顶点的序号代之
visited[i]=true;
//标记v_i已被访问过
for(intj=0;j<n;j++)
//依次搜索v_i的每个邻接点
if(GA[i][j]!=0&&GA[i][j]!=MaxValue&&!visited[j])
```cpp
//若从初始点v_i的一个有效邻接点v_j未被访问过，则从v_j出发进行递归调用
dfsMatrix(GA,j,n,visited);
voiddfsAdjion(adjlistGL,inti,intn,boolvisited)
cout<<i<<'';//假设访问顶点v_i以输出该顶点的序号代之
visited[i]=true;//标记v_i已被访问过
edgenodep=GL[i];//取v_i邻接表的表头指针
while(p!=NULL)//依次搜索v_i的每个邻接点
intj=p->adjvex;//j为v_i的一个邻接点序号
if(!visited[j])//若v_j未被访问过，则从v_j出发进行递归调用
dfsAdjion(GL,j,n,visited);
p=p->next;//使p指向v_i单链表的下一个边结点
图7-10中的G7所对应的邻接矩阵和邻接表如图7-11所示，请结合图分析以上的两个算法，判断从顶点v_1出发得到的深度优先搜索遍历的顶点序列是否分别为以下序列。
序列1：1,0,2,6,3,4,5序列2：1,6,2,0,3,5,4(a)邻接矩阵
(b)邻接表
图7-11G7所对应的邻接矩阵和邻接表
当图中每个顶点的序号确定后，图的邻接矩阵表示是唯一的，所以从某一项点出发进行深度优先搜索遍历时访问各顶点的次序也是唯一的。但图的邻接表表示不是唯一的，它与边的输入次序和链接次序有关，所以对于同一个图的不同邻接表，从某一项点出发进行深度优先搜索遍历时访问各顶点的次序也可能不同。另外，对于同一个邻接矩阵或邻接表，如果指定的出发点不同，则将得到不同的遍历序列。
从以上两个算法可以看出，对邻接矩阵表示的图进行深度优先搜索遍历时，需要扫描邻接矩阵中的每一个元素，所以其时间复杂度为O(n^2)；对邻接表表示的图进行深度优先搜
```
索遍历时,需要扫描邻接表中的每个边结点,所以其时间复杂度为O(e);两者的空间复杂度均为O(n)。
section7.3.2广度优先搜索遍历
广度优先搜索(breadth-firstsearch)遍历类似于对树的按层遍历,其过程为:首先访问初始点v_0,并将其标记为已访问过,接着访问v_0的所有未被访问过的邻接点,其访问次序可以任意,假定依次为v_i1,v_i2,cdots,v_in,并均标记为已访问过,然后再按照v_i1,v_i2,cdots,v_in的次序,访问每一个顶点的所有未被访问过的邻接点（次序任意）,并均标记为已访问过,以此类推,直到图中所有和初始点v_0有路径相通的顶点都被访问过为止。
结合如图7-12所示的有向图G8分析从v_0出发进行广度优先搜索遍历的过程。
(1)访问初始点v_0,并将其标记为已访问过。
(2)访问v_0的所有未被访问过的邻接点v_1和v_2,并将它们标记为已访问过。
(3)访问顶点v_1的所有未被访问过的邻接点v_3、v_4和v_5,并将它们标记为已访问过。
(4)访问顶点v_2的所有未被访问过的邻接点v_6（它的两个邻接点中的一个顶点v_5已被访问过），并将其标记为已访问过。
(5)访问顶点v_3的所有未被访问过的邻接点v_7（只此一个邻接点且没有被访问），并将其标记为已访问过。
(6)访问顶点v_4的所有未被访问过的邻接点，因v_4的邻接点v_7（只此一个）已被访问过，所以此次不访问任何顶点。
(7)访问顶点v_5的所有未被访问过的邻接点v_8,并将其标记为已访问过。
(8)访问顶点v_6的所有未被访问过的邻接点，因v_6的仅一个邻接点v_8已被访问过，所以此次不访问任何顶点。
(9)依次访问v_7和v_8的所有未被访问的邻接点，因它们均没有邻接点，所以整个遍历过程到此结束。
从以上对有向图G8进行广度优先搜索遍历的过程分析可知，从初始点v_0出发，得到的访问各顶点的次序为：v_0,v_1,v_2,v_3,v_4,v_5,v_6,v_7,v_8。
在广度优先搜索遍历中，先被访问的顶点，其邻接点亦先被访问，所以在算法的实现中需要使用一个队列，用来依次记住被访问过的顶点。算法开始时，将初始点v_0访问后插入队列中，以后每次从队列中删除一个元素，就依次访问它的每一个未被访问过的邻接点，并令其进队，这样，当队列为空时，表明所有与初始点有路径相通的顶点都已访问完毕，算法到此结束。下面分别以邻接矩阵和邻接表作为图的存储结构给出相应的广度优先搜索遍历的算法，在算法中使用的队列可以采用第4章已经给出的顺序或链接队列类型，也可以直接定义队列和进行运算操作。
n
[图片]
voidbfsMatrix(adjmatrixGA,inti,intn,boolvisited)
//从初始点v_i出发广度优先搜索由邻接矩阵GA表示的图
constintMaxSize=30;//定义队列的最大长度
intq[MaxSize]=0;//定义一个队列q，其元素类型应为整型
intfront=0,rear=0;//定义队首和队尾指针
cout<<i<<'';
visited[i]=true;//标记初始点v_i已访问过
q[++rear]=i;//将已访问过的初始点序号i入队
while(front!=rear)
front=(front+1)%MaxSize;
intk=q[front];//删除队首元素，第1次执行时k的值为ifor(intj=0;j<n;j++)//依次搜索v_k的每一个可能的邻接点
if(GA[k][j]!=0&&GA[k][j]!=MaxValue&&!visited[j])
cout<<j<<'';//访问一个未被访问过的邻接点v_jvisited[j]=true;//标记v_j已访问过
rear=(rear+1)%MaxSize;
q[rear]=j;//顶点序号j入队
voidbfsAdjoin(adjlistGL,inti,intn,boolvisited)
//从初始点v_i出发广度优先搜索由邻接表GL表示的图
constintMaxSize=30;//给出顺序队列的最大长度
intq[MaxSize]=0;//定义一个队列q，其元素类型应为整型
intfront=0,rear=0;//定义队首和队尾指针
cout<<i<<'';
visited[i]=true;//标记初始点v_i已访问过
q[++rear]=i;//将已访问过的初始点序号i入队
while(front!=rear)
front=(front+1)%MaxSize;
intk=q[front];//删除队首元素，第1次执行时k的值为iedgenodep=GL[k];//取v_k邻接表的表头指针
while(p!=NULL)
intj=p->adjvex;//依次搜索v_k的每一个邻接点
if(!visited[j])//若v_j没有被访问过则进行处理
cout<<j<<'';
visited[j]=true;
rear=(rear+1)%MaxSize;
q[rear]=j;//顶点序号j入队
p=p->next;//使p指向v_k邻接表的下一个边结点
结合图7-11(a)和图7-11(b)分析上面的两个算法，判断从顶点v_1出发得到的广度优先搜索遍历的顶点序列是否分别为以下序列。
序列1:1,0,4,5,6,2,3序列2:1,6,5,4,0,2,3与图的深度优先搜索遍历一样，对于图的广度优先搜索遍历，若采用邻接矩阵表示，其时间复杂度为O(n^2)；若采用邻接表表示，其时间复杂度为O(e)。两者的空间复杂度均为O(n)。
由图的某个顶点出发进行广度优先搜索遍历时，访问各顶点的次序，对于邻接矩阵来说是唯一的，对于邻接表来说，可能因邻接表的不同而不同，这一点也与图的深度优先搜索遍历时的情形一样。
section7.3.3非连通图的遍历
在图的深度优先搜索遍历算法和图的广度优先搜索遍历算法中，对于无向图来说，若无向图是连通图，则能够访问到图中的所有顶点；若无向图是非连通图，则只能访问到初始点所在连通分量中的所有顶点，其他连通分量中的顶点是不可能访问到的。为此需要从其他每个连通分量中选定初始点，分别进行搜索遍历，才能够访问到图中的所有顶点。对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能够访问到所有顶点。为此需要从未被访问的顶点中再选一些顶点作为初始点，进行搜索遍历，直到图中的所有顶点都被访问过为止。
为了能够访问到任何图中的所有顶点，要以图中未被访问到的每一个顶点作为初始点，去调用上面的任何一个算法。在某个函数中执行下面的for语句：
for(inti=0;i<n;i++)
if(!visited[i])
dfsMatrix(GA,i,n,visited);//也可以调用其他遍历算法
若一个无向图是连通的，或从一个有向图的顶点v_0到其余每个顶点都是有路径的，则此循环语句只执行一次调用（即dfsMatrix（GA,0,n,visited）调用）就结束遍历过程，否则要执行多次调用才能结束遍历过程。对无向图来说，每次调用将遍历一个连通分量，有多少次调用过程，就说明该图有多少个连通分量。
采用图的邻接矩阵进行图的遍历运算的程序举例如下。
include<iostream.h>
include<stdlib.h>
include<strstrea.h>//使用字符串流所需的系统头文件
typedefintVertexType;//定义顶点值的类型
typedefintWeightType;//定义边上权值的类型
constintMaxVertexNum=10;//定义图的最多顶点数
constWeightTypeMaxValue=1000;//定义无边上的特定权值
typedefVertexTypevexlist[MaxVertexNum];
//定义vexlist为存储顶点信息的数组类型
typedefintadjmatrix[MaxVertexNum][MaxVertexNum];
//定义adjmatrix为存储邻接矩阵的数组类型
include"采用邻接矩阵存储的图的常用运算.cpp"
voidmain()
inti,n,k1,k2;
cout<<"输入待处理图的顶点数:";
cin>>n;
cout<<"输入图的有无向和有无权选择(0为无,非0为有):";
cin>>k1>>k2;
boolvisited=newbool[n];//定义并动态分配标志数组
adjmatrixga;
InitMatrix(ga,k2);
cout<<"输入图的边集:";
chara=newchar[100];
cin>>a;//输入一个图的边集
CreateMatrix(ga,n,a,k1,k2);
cout<<"按图的邻接矩阵得到的深度优先遍历序列:"<<endl;
for(i=0;i<n;i++)visited[i]=false;
dfsMatrix(ga,0,n,visited);
cout<<endl;
cout<<"按图的邻接矩阵得到的广度优先遍历序列:"<<endl;
for(i=0;i<n;i++)visited[i]=false;
bfsMatrix(ga,0,n,visited);
cout<<endl;
PrintMatrix(ga,n,k1,k2);
该程序的一次运行结果如下:
输入待处理图的顶点数:7
输入图的有无向和有无权选择(0为无,非0为有):00
输入图的边集:(0,1),(0,2),(0,3),(1,4),(1,5),(1,6),(2,6),(4,5)
按图的邻接矩阵得到的深度优先遍历序列:
0145623
按图的邻接矩阵得到的广度优先遍历序列:
0123456
V=0,1,2,3,4,5,6
E=(0,1),(0,2),(0,3),(1,4),(1,5),(1,6),(2,6),(4,5),
习题7
【习题7-1】运算题。
1.如图7-13（a）和图7-13（b）所示，求：
(1)每一个图的二元组表示。
(2)图7-13（a）中每个顶点的度，以及每个顶点的所有邻接点和所有边。
(3)图7-13（b）中每个顶点的入度、出度和度，以及每个顶点的所有入边的出边。
(4)图7-13（a）中从v_0到v_4的所有简单路径及相应带权路径长度。
(5)图7-13（b）中从v_0到v_4的所有简单路径及相应带权路径长度。
(a)无向图
(b)有向图
图7-13运算题图1
2.根据图7-13（a）和图7-13（b），画出：
(1)每个图的邻接矩阵。
(2)每个图的邻接表。
(3)图7-13（b）的逆邻接表和十字邻接表。
(4)每个图的边集数组。
3.如图7-14所示，按下列条件分别写出从顶点v_0出发按深度优先搜索遍历得到的顶点序列和按广度优先搜索遍历得到的顶点序列。
(1)假定它们均采用邻接矩阵表示。
(2)假定它们均采用邻接表表示，并且每个顶点邻接表中的结点都是按顶点序号从大到小的次序链接的。
(a)无向图
(b)有向图
图7-14运算题图2
4.已知一个图的二元组表示如下：
V=0,1,2,3,4,5,6,7,8E=(0,3),(0,4),(1,2),(1,4),(2,4),(2,5),(3,6),(3,7),(4,7),(5,8),(6,7),(7,8)（1）画出对应的图形。
（2）假定从顶点0出发，给出邻接矩阵表示的图的深度优先和广度优先搜索遍历的顶点序列。
（3）假定从顶点0出发，给出邻接表表示的图的深度优先和广度优先搜索遍历的顶点序列，假定每个顶点邻接表中的结点都是按顶点序号从大到小的次序链接的。
【习题7-2】算法设计题。
1.根据邻接矩阵GA所表示的图，求序号为numb的顶点的度数。
2.根据无向图的邻接表GL求序号为numb的顶点的度数。
3.求出一个用邻接矩阵GA表示的图中所有顶点的最大出度值。
4.对用邻接矩阵表示的图的深度优先搜索算法做适当的修改，输出依次访问顶点所经过的各条边的算法。
5.若图采用邻接矩阵表示，编写进行深度优先遍历的非递归算法。
6.对用邻接表示的图的广度优先搜索算法做修改，使算法中使用的队列是在第4章已经定义过的顺序队列。
7.根据图的邻接矩阵得到图的邻接表。
8.根据图的邻接矩阵得到图的边集数组。
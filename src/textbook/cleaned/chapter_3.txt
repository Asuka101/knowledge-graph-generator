第3章集合、稀疏矩阵和广义表
section3.1集合的定义和抽象数据类型
subsection3.1.1集合定义
集合(set)又称集合结构，由具有相同属性的数据元素组合而成，数据之间没有任何前驱和后继关系。集合中数据元素的个数称为集合的长度，假定用n表示，ngeqslant0。当n=0时则为空集。若集合为空，则表示为，若非空则表示为：lefta_1,a_2,cdots,a_i,a_i+1,cdots,a_nright其中每个元素的下标为对该元素的编号，它是为了区别而任意标注的，不代表任何次序。因为集合中的元素可以按任何次序排列，假定按元素前后位置编号的次序排列，那么a_1就是集合中第1个元素，a_2就是第2个元素，a_i就是第i个元素，a_n就是第n个（最后一个）元素。
像线性表一样，集合的长度是变化的，当向它插入一个元素后其长度就增加1，当从中删除一个元素后其长度就减少1。
集合中的元素类型可以为任何一种类型，用标识符ElemType表示。若实际的元素类型为某一具体类型，如整型，则可以通过typedef语句指定为ElemType类型。
subsection3.1.2集合的抽象数据类型
集合的抽象数据类型同样包括数据和操作两个部分。数据部分为一个集合，假定用标识符S表示。操作部分包括对集合进行的各种常用运算，如初始化集合为空、清除集合中的所有元素、求集合中元素个数、判断集合是否为空、判断一个元素是否属于集合、输出集合中所有元素、从集合中查找一个元素、从集合删除一个元素、向集合插入一个元素、修改集合中的一个指定元素、求两个集合的并集、求两个集合的交集、求两个集合的差集等。
集合的抽象数据类型定义如下。
ADTSETis
Data:
一个集合S，假定用标识符SetT表示抽象存储类型
Operation:
voidInitSet(SetT&S);//初始化集合为空
voidClearSet(SetT&S);//清除集合中的所有元素
intLengthSet(SetT&S);//求出集合的长度
boolEmptySet(SetT&S);//判断集合是否为空
boolInSet(SetT&S,ElemTypeitem);//判断一个元素是否属于集合
voidOutputSet(SetT&S);//输出集合中所有元素
boolFindSet(SetT&S,ElemType&item);//从集合中查找一个元素
boolModifySet(SetT&S,constElemType&item);//修改集合元素
boolInsertSet(SetT&S,ElemTypeitem);//向集合插入一个元素
boolDeleteSet(SetT&S,ElemType&item);//从集合删除一个元素
voidUnionSet(SetT&S1,SetT&S2,SetT&S);//求两个集合的并集
voidInterseSet(SetT&S1,SetT&S2,SetT&S);//求两个集合的交集
voidDifferenceSet(SetT&S1,SetT&S2,SetT&S);//求两个集合的差集
endSET
在以上列出的各种运算操作中，第1、2、8~13种运算需要改变集合S的状态，所以S必须为引用参数，而其他运算中的S参数和11~13种运算中的S1和S2参数，由于不需要改变它们，所以可采用常量引用，即在参数前加上const保留字。
section3.2集合的顺序存储结构和操作实现
集合的顺序存储就是定义一个数组类型的对象来存储集合元素，同时要定义一个整数变量来存储当前集合长度和定义一个整型常量或变量来存储数组类型的长度。这3个对象的定义假定如下。
constintMaxSize=20;//定义存储集合元素的数组的长度
ElemTypeset[MaxSize];//定义存储集合所有元素的数组
intlen;//定义集合当前长度变量，取值在0~MaxSize之间
集合中的元素可以按任何次序存入到set数组中，不妨按照元素在集合中的位置次序相应保存到对应元素中，即第1个元素保存到下标为0的元素set[0]中，第2个元素保存到下标为1的元素set[1]中，以此类推。因为集合中的元素与次序无关，所以新添的元素则直接加到后面，删除一个元素后则把最后一个元素调到这个空出的位置上，使得插入和删除不需要移动任何元素，从而节省运算时间。
为了集合操作方便，可以把set数组和len变量封装在一个结构类型中，结构类型名用Set表示，具体定义如下。
structSet
ElemTypeset[MaxSize];
intlen;
;
若对存储集合的数组空间采用动态分配，并且其数组长度能够随之改变，则可以定义出如下的Set类型。
structSet
ElemTypeset;//set指向动态分配的数组空间
intlen;//存集合当前长度
intMaxSize;//存set数组长度，亦即所能存储集合的最大长度
;
定义一个集合对象之后，在初始化时要使该对象中的set指针指向由newElemType[MaxSize]或(ElemType)malloc(sizeof(Elemtype)MaxSize))分配的动态数组空间，同时使len的值为0，表示为空集。
集合的顺序存储结构如图3-1所示。
下标012cdotsn-1n+1rightarrowMaxSize-1
set|a_1|a_2|a_3|cdots|a_n|||||
|---|---|---|---|---|---|---|---|---|---|
|||||||||||
图3-1集合的顺序存储结构示意图
下面以set为集合的顺序存储类型，给出每个集合运算的算法。
1.初始化集合并置为空
初始化集合时，让set指向动态数组空间，用于保存集合元素，数组空间的初始大小可以任意设定，假定为10，以后可以在插入元素的过程中根据需要增加。
voidInitSet(Set&S)
//初始定义数组长度为10,以后可增减
S.MaxSize=10;
//动态存储空间分配
S.set=newElemType[10];
if(!S.set)
cout<<“动态可分配的存储空间用完,退出运行!”<<endl;
exit(1);
//置集合长度为0,即为空集合
S.len=0;
2.清除集合中的所有元素
在Set集合类型的对象中，由于集合数组空间是动态分配的，所以清除集合就是释放所拥有的动态存储空间。
voidClearSet(Set&S)
if(S.set!=NULL)
delete[]S.set;
S.set=NULL;
S.MaxSize=0;
S.len=0;
3.求出集合的长度,即所含元素的个数
此算法返回集合S中的len域的值。
intLenthSet(Set&S)
returnS.len;
4.判断集合是否为空
此算法很简单,若集合长度为0则返回真表示空,否则返回假表示非空。
boolEmptySet(Set&S)
returnS.len==0;
5.判断一个元素是否属于集合
此算法就是一个顺序查找元素的过程。若找到表明该元素属于这个集合，则返回真;否则不属于这个集合，则返回假。
boolInSet(Set&S,ElemTypeitem)
for(inti=0;i<S.len;i++)
if(S.set[i]==item)returntrue;
returnfalse;
6.输出集合中所有元素
此算法使用一个for循环，依次输出S集合中set域数组中保存的每个元素的值。
voidOutputSet(Set&S)
for(inti=0;i<S.len;i++)
cout<<S.set[i]<<'';
cout<<endl;
若要求输出的所有集合元素是按值的升序排列的，并且原有集合S的状态保持不变。
这时首先把集合S中set数组内容复制到一个临时数组中，然后对这个临时数组进行排序，
并按下标位置依次输出各元素值。对数组进行排序有多种不同方法，最简单的方法是简单插入排序和简单选择排序。
设数组a中含有n个元素，简单选择排序的方法是：需要依次进行n-1次循环，每次把a中n个元素看为一个有序表和一个无序表，第1次有序表为空，无序表含有全部n个元素，从无序表中顺序查找出一个最小值，把它与此表中第一个元素a[0]交换其值，经此次后a[0]成为最小值元素；接着进行第二次循环处理时，有序表中有一个元素a[0]，无序表中有n-1个元素a[1]~a[n-1]，第2次从当前无序表中查找一个最小值元素，把它与此表中第1个元素a[1]交换其值，经此次后a[1]成为此表的最小值元素，当然它小于等于a[0]；然后进入第3次循环处理时，有序表中有两个元素a[0]~a[1]，无序表中有n-2个元素a[2]~a[n-1]，以此类推，进行n-1次循环处理时，有序表中已有n-2个元素a[0]~a[n-3]，无序表中只有两个元素a[n-2]~a[n-1]，从这两个元素中查找到最小值并交换到a[n-2]位置后，整个数组中的元素就按值的升序排列好了。此排序方法与简单插入排序方法具有相同的时间复杂度，即为O(n^2)。
采用简单选择排序方法进行有序输出集合元素的算法如下。
voidOutputSet1(Set&S)
inti,j,k;
ElemTypea=newElemType[S.len];//定义临时数组a
for(i=0;i<S.len;i++)
a[i]=S.set[i];//把集合元素赋给数组a
for(i=0;i<S.len-1;i++)
k=i;//k暂存本次最小值元素的下标
for(j=i+1;j<S.len;j++)
if(a[j]<a[k])k=j;//顺序查找找出本次最小值元素a[k]
ElemTypex=a[i];a[i]=a[k];a[k]=x;//a[k]同a[i]交换其值
cout<<a[i]<<'';
cout<<endl;
delete[]a;
7.从集合中查找一个元素
此算法首先从集合中顺序查找值等于待查值item的元素，若存在则把该元素值赋给item引用参数带回，并返回真表示查找成功；若不存在，则返回假表示查找失败。
通常传递给item的待查值是一个元素的关键字，不是完整的记录。如对于学生记录，待查值是学号，对于产品记录，待查值是产品号。若查询到对应值的元素，则需要把该元素的完整值赋给item带回，以便使用。如可以通过item得到某个学生的成绩，某个产品的价格等。
boolFindSet(Set&S,ElemType&item)//从集合中查找一个元素
for(inti=0;i<S.len;i++)
if(S.set[i]==item)break;
if(i<S.len)
item=S.set[i];nreturntrue;nnelsereturnfalse;nnn8.修改集合中的一个指定元素nn此算法与查找算法类似,需要首先在集合中顺序查找待修改的元素,即关键字等于item关键字的元素,若找到相应元素则用item的完整值修改这个元素,使它具有item的值,并返回真;若未找到则无法修改,返回假表示修改失败。nnboolModifySet(Set&S,constElemType&item)nnfor(inti=0;i<S.len;i++)nif(S.set[i]==item)break;nif(i<S.len)nS.set[i]=item;nreturntrue;nnelsereturnfalse;nnn9.向集合插入一个元素nn此算法包含如下5个步骤。n(1)顺序查找集合中是否存在值为待插值item的元素,若存在则不能插入,返回假,因为集合中不允许存在重复的元素。n(2)检查集合空间是否用完,若是则动态重分配,增加存储空间。n(3)把item值插入到表尾(即最后一个集合元素的后面空位置)上。n(4)集合长度增1。n(5)返回真表示插入成功。n对应的算法描述如下。nnboolInsertSet(Set&S,ElemTypeitem)//向集合插入一个元素nninti;nfor(i=0;i<S.len;i++)//元素已存在,返回假表示不用插入nif(S.set[i]==item)returnfalse;nif(S.len==S.MaxSize)//若集合存储空间用完,则重新分配较大空间nintk=sizeof(ElemType);//计算每个元素存储空间的长度nS.set=(ElemType)realloc(S.set,2S.MaxSizek);n//集合动态存储空间扩展为原来的2倍,原内容不变nif(S.set==NULL)ncout<<"动态可分配的存储空间用完,退出运行!"<<endl;nexit(1);n
S.MaxSize=2S.MaxSize;//把集合空间大小修改为新的长度
S.set[S.len]=item;//在末尾插入新元素
S.len++;//集合长度增1
returntrue;//返回真表示插入成功
10.从集合删除一个元素
此算法首先从集合中顺序查找值等于待删值item的元素,若存在该元素,则由item带回并删除它,把空出的位置用最后一个元素填补,接着若集合数组空间空余过多可释放一半,然后使集合长度减1,返回真表示删除成功。若集合中不存在,则无法删除,返回假表示删除失败。
boolDeleteSet(Set&S,ElemType&item)//从集合删除一个元素
inti;
for(i=0;i<S.len;i++)
if(S.set[i]==item)break;
if(i<S.len)
//删除set[i]元素
item=S.set[i];//由item带回被删元素的完整值
S.set[i]=S.set[S.len-1];//用最后一个元素填补
S.len--;//集合长度减1
if((float(S.len)/S.MaxSize<0.4&&S.MaxSize>10))
//若集合存储空间空余太多,则进行适当削减,若不削减可省此步
intk=sizeof(ElemType);
S.set=(ElemType)realloc(S.set,S.MaxSizek/2);
S.MaxSize=S.MaxSize/2;//把集合空间大小修改为新的长度
returntrue;//删除成功返回真
elsereturnfalse;//删除失败返回假
集合的插入和删除元素均需要一个查找过程,所以其算法的时间复杂度均为O(n),n表示集合长度。
11.求两个集合的并集
该算法是求两个集合S1和S2的并集,并将结果存入S引用参数所表示的集合中带回。首先把S1集合复制到S集合中,然后把S2中的每个元素依次插入到集合S中,当然重复的元素不应该被插入,最后在S中就得到了S1和S2的并集,也就是在S所对应的实际参数集合中得到并集。
把S1集合复制到S集合中,可以通过遍历S1集合中的每个元素,并调用插入算法把
它插入到S集合来实现,这样其时间复杂度为O(n^2),其中n表示集合S1的长度。因为每插入一个元素都要比较S集合中的当前所有元素后,才能插入到表尾。每插入一个元素的时间复杂度为O(n),所以插入n个元素的时间复杂度为O(n^2)。在下面算法中,S1复制到S采用元素直接赋值的方法,其时间复杂度仅为O(n)。
在Set集合类型的对象中,存在着动态分配的存储空间,所以不能简单地采用赋值语句进行直接赋值式的复制,若这样的话,不同对象的set指针将指向同一个动态存储空间,即不同的对象共同占用该空间,这是系统所不允许的。道理很简单,正常释放一个对象中set所指向的动态存储空间后,共同使用该空间的其他对象中由set所指向的动态存储空间也被非法的释放而无法访问。因此,对于含有动态存储空间的对象,在复制时必须使之具有不同的动态存储空间,并且必须把被复制对象中动态存储空间所保存的内容复制到复制对象的动态存储空间中。
下面算法共包含4步,其中前3步完成把S1复制到S的任务,第4步通过把S2中的每个元素插入到S集合中,完成两集合的并运算。设S1和S2集合的长度分别为n和m,则此算法的时间复杂度主要由第4步求出,为O(ntimesm)。
voidUnionSet(Set&S1,Set&S2,Set&S)
inti;
if(S.MaxSize<S1.MaxSize)//为了把S1复制到S,重分配S动态数组
delete[]S.set;
S.set=newElemType[S1.MaxSize];
S.MaxSize=S1.MaxSize;
for(i=0;i<S1.len;i++)//S1集合中的全部元素依次复制到S中
S.set[i]=S1.set[i];
S.len=S1.len;//置集合S的长度为S1的长度
for(i=0;i<S2.len;i++)//向集合S依次插入集合S2中的每个元素
InsertSet(S,S2.set[i]);
12.求两个集合的交集
此算法首先把存放结果的集合S变为一个空集,然后依次从S2集合中取出每一个元素,利用它去查找S1集合,看是否存在,若存在则把它写入交集S中,这样写入S中的元素既属于S1又属于S2。在此算法中,从S1中查找一个元素的时间复杂度为O(n),所以整个算法的时间复杂度为O(ntimesm)。
voidInterseSet(Set&S1,Set&S2,Set&S)
inti;
ElemTypex;
S.len=0;//置集合S为一个空集
for(i=0;i<S2.len;i++)//用S2中的每个元素去查找S1集合
x=S2.set[i];
if(FindSet(S1,x))
S.set[S.len]=x;S.len++;//把x插入S集合末尾
if(S.len==S.MaxSize)
intk=sizeof(ElemType);
S.set=(ElemType)realloc(S.set,2S.MaxSizek);
S.MaxSize=2S.MaxSize;
13.求两个集合的差集
此算法同求交集的算法类似，首先把存放结果的集合S变为一个空集，然后依次从S1n集合中取出每一个元素，利用它去查找S2集合，看是否存在，若不存在则把它写入差集Sn中，这样写入S中的元素仅属于S1而不属于S2。此算法的时间复杂度同样为O(ntimesm)。
voidDifferenceSet(Set&S1,Set&S2,Set&S)
inti;
ElemTypex;
S.len=0;//置集合S为一个空集
for(i=0;i<S1.len;i++)
x=S1.set[i];//用S1中的每个元素去查找S2集合
if(!FindSet(S2,x))
S.set[S.len]=x;S.len++;//把x插入S集合末尾
if(S.len==S.MaxSize)
intk=sizeof(ElemType);
S.set=(ElemType)realloc(S.set,2S.MaxSizek);
S.MaxSize=2S.MaxSize;
3.3集合的链接存储结构和操作实现
集合的顺序存储结构是通过数组实现的，而集合的链接存储结构是通过存储结点之间的n链接实现的，链接形成的结果称为链接表，通常采用单链表。n当一个集合利用单链表存储时，集合中的每个元素对应单链表中的一个结点，把这个n元素存储到相应结点的值域中。由于集合中的元素是无序的，所以在单链表中可以按任何
次序链接。通常,当向表示集合的单链表中插入一个元素结点时,为操作简便,把它插入到表头,即插入到第1个结点的前面,使它成为新的表头结点,而原来的表头结点成为第2个结点,此时只修改新插入结点的指针域,使其指向原来的表头结点,再修改表头指针,使其指向新插入的结点,从而完成结点的插入过程。当从单链表中删除一个结点时,就是把该结点的指针域的值(即后一结点的地址)赋给其前一结点的指针域即可,若它本身为表头结点,则应把该结点的指针域的值赋给表头指针。
表示集合的单链表的结点结构定义如下。
structSNode
ElemTypedata;
SNodenext;
;
其中SNode为结点类型,data为存储元素值的结点值域,next为存储下一个结点地址的指针域。
由于单链表中的结点通常是靠动态分配产生的,不需要事先分配存储空间,所以存储一个单链表只需要存储它的表头指针即可。由表头指针就能够访问该单链表。假定表头指针用HT表示,则HT应定义为:
SNodeHead;//集合单链表的表头指针
集合单链表的示意图如图3-2所示。
HTrightarrowboxeda_1rightarrowboxeda_2rightarrow...rightarrowboxeda_irightarrowboxeda_i+1rightarrow...rightarrowboxeda_n
图3-2集合单链表的示意图
按照集合的抽象数据类型的定义,假定集合存储采用单链表结构,由表头指针HT表示,下面给出对集合的各种操作在单链表上的实现。熟悉了第2章对用单链表表示的进行线性表操作的各种算法,以及上面面对顺序表(数组)表示的进行集合操作的各种算法后,同学们也不难写出下面面对用单链表表示的进行集合操作的各种算法。
section1.初始化集合为空
voidInitSet(SNode&HT)
HT=NULL;
section2.清除集合中的所有元素并释放占有的动态存储空间
voidClearSet(SNode&HT)
SNodep=HT,q;//p指向Head单链表
while(p!=NULL)//回收Head集合中的每个结点
q=p->next;//q指向p的后继结点
deletep;//删除p结点
p=q;//使p指向原来的后继结点
HT=NULL;//置Head为空
3.求出集合中元素个数
intLenthSet(SNodeHT)//求集合长度
intn=0;
while(HT!=NULL)
n++;
HT=HT->next;
returnn;
4.判断集合是否为空
boolEmptySet(SNodeHT)
returnHT==NULL;
5.判断一个元素是否属于集合
boolInSet(SNodeHT,ElemTypeitem)
while(HT!=NULL)
if(HT->data==item)returntrue;
elseHT=HT->next;
returnfalse;
6.输出集合中所有元素
voidOutputSet(SNodeHT)
while(HT!=NULL)
cout<<HT->data<<'';
HT=HT->next;
cout<<endl;
7.从集合中查找一个元素
boolFindSet(SNodeHT,ElemType&item)
//从集合单链表中顺序查找是否存在值为item的结点
while(HT!=NULL)
if(HT->data==item)break;
elseHT=HT->next;
//若存在由item带回已查找到的元素并返回真,否则返回假
if(HT!=NULL)
item=HT->data;returntrue;
elsereturnfalse;
8.修改集合中的一个指定元素
boolModifySet(SNodeHT,constElemType&item)
//从集合单链表中顺序查找是否存在值为item的结点
while(HT!=NULL)
if(HT->data==item)break;
elseHT=HT->next;
//若存在,由item修改已查找到的元素并返回真,否则返回假
if(HT!=NULL)
HT->data=item;returntrue;
elsereturnfalse;
9.向集合插入一个元素
boolInsertSet(SNode&HT,ElemTypeitem)
//建立值为item的新结点
SNodetp=newSNode;
tp->data=item;
//从单链表中顺序查找是否存在值为item的结点
SNodep=HT;
while(p!=NULL)
if(p->data==item)break;
elsep=p->next;
//若不存在则把新结点插入到表头并返回真,否则不插入返回假
```cpp
if(p==NULL)
tp->next=HT;HT=tp;returntrue;
elsereturnfalse;
10.从集合删除一个元素
boolDeleteSet(SNode&HT,ElemType&item)
//从单链表中顺序查找是否存在值为item的结点
SNodecp=HT,ap=NULL;
while(cp!=NULL)
if(cp->data==item)break;
elseap=cp;cp=cp->next;
//若不存在则返回假，表明删除成功
if(cp==NULL)returnfalse;
//由item带回待删除结点cp的完整值，若不需要带回可设item为值参
item=cp->data;
//从单链表中删除已找到的cp结点，对是否为表头应做不同处理
if(ap==NULL)HT=cp->next;
elseap->next=cp->next;
//删除cp结点后返回真
deletecp;
returntrue;
11.求两个集合的并集
voidUnionSet(SNodeHT1,SNodeHT2,SNode&HT)
//置并集的表头指针HT为空
HT=NULL;
//把HT1集合单链表复制到HT集合单链表中
SNodep=HT1;
while(p!=NULL)
//建立新结点并赋值为p->data
SNodenewp=newSNode;
newp->data=p->data;
//把新结点插入到HT集合单链表的表头
newp->next=HT;HT=newp;
//使p指向下一个结点
p=p->next;
//把HT2集合单链表中的每个元素插入到HT集合单链表中
```
p=HT2;
while(p!=NULL)
InsertSet(HT,p->data);
p=p->next;
12.求两个集合的交集
voidInterseSet(SNodeHT1,SNodeHT2,SNode&HT)
//置交集的表头指针HT为空
HT=NULL;
//把HT1集合与HT2集合中共同的元素插入到HT集合中
ElemTypex;
SNodep=HT2;
while(p!=NULL)
x=p->data;//将p->data赋给x
boolb=FindSet(HT1,x);//用x查找HT1集合
if(b)InsertSet(HT,x);//若查找成功则把x插入到HT集合中
p=p->next;//使p指向下一个结点
13.求两个集合的差集
voidDifferenceSet(SNodeHT1,SNodeHT2,SNode&HT)
//置差集的表头指针HT为空
HT=NULL;
//把存在于HT1集合而不存在于HT2集合中的元素插入到HT集合中
ElemTypex;
SNodep=HT1;
while(p!=NULL)
x=p->data;//将p->data赋给x
boolb=FindSet(HT2,x);//用x查找HT2集合
if(!b)InsertSet(HT,x);//若查找失败则把x插入到HT集合中
p=p->next;//使p指向下一个结点
同对线性表的存储一样，对集合除了可以进行顺序存储和链接存储外，还可以进行散列存储和索引存储，相应地也能够根据具体的运算要求编写出利用C++语言实现的算法，待以后学习过这两种存储结构后能够比较容易地编写出来。n在集合抽象数据类型中规定的各种操作只是一些典型的操作，当然在实际应用中还有
许多。如根据一个集合建立顺序存储结构或建立链接存储结构,从集合顺序表或单链表中查找出所有具有同一属性值的元素并输出出来,从任一存储结构的集合中查找具有最大或最小值的元素,把一个顺序表或单链表表示的集合按某一条件分解为两个集合等。读者只要掌握集合的典型操作,对其他任何操作的算法将不难编写出来。
section3.4稀疏矩阵
subsection3.4.1稀疏矩阵的定义
section1.稀疏矩阵的概念
为了说明什么是稀疏矩阵,首先要清楚矩阵的概念。矩阵(matrix)是一个具有m行timesn列的数表,共包含有mtimesn个数（元素）,每个元素处在确定行和列的交点位置上,都与一对行号和列号唯一对应。当一个矩阵中的行数和列数相同时,即m=n时则称为n阶矩阵或方阵。如图3-3(a)就是一个3times4的矩阵,它包含3行、4列,具有12个元素,每个元素都对应着唯一的行号和列号,如第1行与第1列交点位置上的元素5对应的行号和列号均为1,第2行与第4列交点位置上的元素9对应的行号和列号分别为2和4。beginarrayll1&21&5-2842&94-193&0721endarray(a)一般矩阵beginarraylll1&2&31&3005002&00-20003&1040604&0000005&00-1000endarray(b)稀疏矩阵
图3-3矩阵和稀疏矩阵
稀疏矩阵(sparsematrix)是矩阵中的一种特殊情况,其非零元素的个数远远小于零元素的个数。如图3-3(b)就是一个5times6的稀疏矩阵,该矩阵共有30个元素,其中非零元素为7个,占元素总数的7/30。在实际应用中,稀疏矩阵一般都比较大,非零元素所占的比例都比较小。如对于一个100times100的稀疏矩阵,若非零元素的个数为200,则非零元素占总元素个数的比例仅为1/50。
section2.稀疏矩阵的三元组线性表示
在计算机中存储矩阵的一般方法是采用二维数组,其优点是可以随机地访问任一个元素,因而能够较容易地实现矩阵的各种运算,如转置运算、加法运算、乘法运算等。但对于稀疏矩阵来说,采用二维数组的存储方法既浪费大量的存储单元用来存放零元素,又要在运算中花费大量的时间来进行零元素的无效计算,显然是不可取的。一种较好的方法是:只考虑存储占元素中极少数的非零元素。
对于稀疏矩阵中的每个非零元素，可用它所在的行号、列号以及元素值这三元组(i,j,a_ij)来表示。若把所有的三元组按照行号为主序（即为主关键字）、列号为辅序（即为次关键字，当行号相同时再考虑列号次序）进行排列，则就构成了一个表示稀疏矩阵的三元组线性表。图3-3(b)稀疏矩阵所对应的三元组线性表表示为：left((1,1,3),(1,4,5),(2,3,-2),(3,1,1),(3,3,4),(3,5,6),(5,3,-1)right)稀疏矩阵采用三元组线性表表示后，可以使用顺序或链接方式存储，从而比采用二维数组存储要大大地节省存储空间。
section3.稀疏矩阵的抽象数据类型
该抽象数据类型的数据部分为用三元组线性表表示的稀疏矩阵，操作部分所包含的操作与对一般矩阵所做的操作相同，通常为求一个稀疏矩阵的转置，计算两个矩阵的和，计算两个矩阵的乘积等。一个矩阵的转置结果仍是一个矩阵，该矩阵中的第i行与第j列交点位置上的元素等于被转置矩阵中第j行与第i列交点位置上的元素。两个矩阵的和仍然是一个矩阵，该矩阵中的第i行第j列位置上的元素等于两个相加矩阵中对应位置上的元素之和。两矩阵求和的条件是它们的行数和列数必须分别对应相同。两个矩阵的乘积仍然是一个矩阵，该矩阵中的第i行与第j列位置上的元素等于第1个乘数矩阵中的第i行与第2个乘数矩阵中的第j列上对应元素乘积之累加和。假定第1个乘数矩阵为A[m][n]，第2个乘数矩阵为B[n][p]，乘积结果矩阵为C[m][p]，则C中任一元素C[i][j]等于sum_k=1^n(A[i][k]timesB[k][j])，其中1leqileqm，1leqjleqp。两矩阵求积的条件是第1个矩阵的列数必须等于第2个矩阵的行数。
下面给出稀疏矩阵的抽象数据类型的定义。
ADTSparseMatrixis
Data:
采用顺序或链接方式存储的稀疏矩阵，假定其存储类型用SMatrix标识符表示
Operation:
//初始化稀疏矩阵M，使它成为不含任何元素的空矩阵
voidInitMatrix(SMatrix&M);
//求出稀疏矩阵M的转置矩阵并返回
SMatrixTranspose(SMatrix&M);
//求出M1和M2稀疏矩阵之和并返回
SMatrixAdd(SMatrix&M1,SMatrix&M2);
//求出M1和M2稀疏矩阵之乘积并返回
SMatrixMultiply(SMatrix&M1,SMatrix&M2);
//按照一定格式向稀疏矩阵M输入所对应的三元组线性表
voidInputMatrix(SMatrix&M,intm,intn);
//按照一定格式输出稀疏矩阵M
voidOutputMatrix(SMatrix&M);
endSparseMatrix
3.4.2稀疏矩阵的存储结构
稀疏矩阵的存储结构包括顺序存储结构和链接存储结构两种。在任一种存储结构中,除了存储三元组线性表中的所有元素之外，通常还需要存储稀疏矩阵的行数、列数和非零元素的个数这3个整型量。
1.顺序存储
稀疏矩阵的顺序存储就是对其相应的三元组线性表进行顺序存储。假定每个非零元素的三元组用如下记录结构定义。
structTriple
introw,col;
ElemTypeval;
;
其中,row和col用来分别存储元素的行号和列号,val用来存储元素值。
一个稀疏矩阵的顺序存储类型定义如下。
structSMatrix
intm,n,t;
Triplesm[MaxTerms+1];
;
其中,m、n和t域分别用来存储稀疏矩阵的行数、列数和非零元素的个数,sm数组域用来顺序存储每个三元组元素,假定下标为0的元素sm[0]不用,从下标为1起使用.MaxTerms为一个事先定义的全局常量,由它决定sm数组的大小,该数组最多能够存储MaxTerms个三元组元素。例如,若用SMatrix类型的对象存储图3-3(b)所示的稀疏矩阵,则m、n和t域的值应分别为5、6和7,MaxTerms常量应大于等于7,sm数组中的内容如图3-4所示。
下标
1|1|1|3|
2|1|4|5|
3|2|3|-2|
4|3|1|1|
5|3|3|4|
6|3|5|6|
7|5|3|-1|
|...|...|...|...|
MaxTerms|...|...|...|
图3-4稀疏矩阵的顺序存储结构
2.链接存储
稀疏矩阵的链接存储就是对其相应的三元组线性表进行链接存储。下面介绍两种链接存储方法。
(1)带行指针向量的链接存储。
在这种链接存储中,需要把具有相同行号的三元组结点按照列号从小到大的顺序链接成一个单链表,每个三元组结点的类型定义如下。
structTripleNode
introw,col;//存储行号和列号
ElemTypeval;//存储元素值
TripleNodenext;//指向同一行的下一个结点
;
稀疏矩阵中的每一行对应一个单链表,每一个单链表都有一个表头指针,为了把它们保存起来,便于访问每一个单链表,需要使用一个行指针向量(即一维数组),该向量中的第i个分量(即对应数组中下标为i的元素)用来存储稀疏矩阵中第i行所对应的单链表的表头指针。带行指针向量的链接存储类型定义如下。
structLMatrix
intm,n,t;
TripleNodevector[MaxRows+1];
;
其中,整数域mathrmm、mathrmn和mathrmt分别用来保存稀疏矩阵的行数、列数和非零元素的个数,vector数组(向量)域用来保存稀疏矩阵所对应的mathrmm个行单链表的表头指针,第0分量未用,第i行单链表的表头指针存于第i分量vector[i]中,MaxRows为全局变量,其值要大于等于所存储矩阵的行数。
利用LMatrix类型的对象存储图3-3(b)所示的稀疏矩阵,则链接存储结构如图3-5所示,其中每个单链表中的结点由动态分配链接而成。
分量编号行指针向量
1|->[113]->[145]
2|->[23-2]
3|->[311]->[334]->[356]
4
5|->[53-1]
图3-5带行指针向量的链接存储结构
(2)十字链接存储。
十字链接存储是既带行指针向量又带列指针向量的链接存储。在这种链接存储中,每个三元组结点既处于同一行的单链表中,又处于同一列的单链表中,即处于所在的行单链
表和列单链表的交点处。
在十字链接存储中，每个结点的类型可定义如下。
structCrossNode
introw,col;
ElemTypeval;
CrossNodedown,right;
;
其中row、col和val域分别用来存储非零元素的行号、列号和元素值，down域用来存储指向同一列下一个结点的指针，right域用来存储指向同一行下一个结点的指针，当然若不存在下一个结点，则相应的指针域为空值。
在稀疏矩阵的十字链接存储中，需要使用两个指针向量，一个是行指针向量，用来存储行单链表的表头指针，另一个是列指针向量，用来存储列单链表的表头指针。稀疏矩阵的十字链接存储类型定义如下。
structC1Matrix
intm,n,t;
CrossNoderv[MaxRows+1];
CrossNodecv[MaxColumns+1];
;
其中，全局常量MaxRows用来规定行指针向量的大小，全局常量MaxColumns用来规定列指针向量的大小，它们应分别大于等于所存稀疏矩阵的行数和列数。同样，在rv和cv向量中，下标为0的元素未用。
利用图3-3(b)所示的稀疏矩阵，则得到十字链接存储结构的示意图，如图3-6所示。
列向量123456
行向量
1[113]->[145]
2[23-2]
3[311]->[334]->[356]
4[53-1]
图3-6稀疏矩阵的十字链接存储结构
3.4.3稀疏矩阵的运算
1.初始化运算
稀疏矩阵的存储类型不同，其初始化过程也不同。
(1)对于SMatrix类型的对象，初始化过程如下。
voidInitMatrix(SMatrix&M)
M.m=0;M.n=0;M.t=0;
(2)对于LMatrix类型的对象，其初始化如下。
voidInitMatrix(LMatrix&M)
M.m=0;M.n=0;M.t=0;
for(inti=1;i<=MaxRows;i++)
M.vector[i]=NULL;
(3)对于CLMatrix类型的对象，初始化如下。
voidInitMatrix(CLMatrix&M)
M.m=0;M.n=0;M.t=0;
for(inti=1;i<=MaxRows;i++)
M.rv[i]=NULL;
for(i=1;i<=MaxColumns;i++)
M.cv[i]=NULL;
2.稀疏矩阵的输入
稀疏矩阵的输入应按照对应三元组线性表中三元组排列的次序输入，每行输入一个三元组，行号、列号和元素值之间用空格分开，最后以回车键结束。当输入完所有三元组后，以输入一个特殊的三元组(0,0,0)结束整个输入过程。假定稀疏矩阵采用SMatrix类型存储，下面给出相应的输入算法。其中，引用参数M表示SMatrix类型的稀疏矩阵，m和n分别表示矩阵的行数和列数。
voidInputMatrix(SMatrix&M,intm,intn)
M.m=m;M.n=n;
introw,col,val;
intk=0;
cin>>row>>col>>val;
```c
while(row!=0)
k++;
M.sm[k].row=row;
M.sm[k].col=col;
M.sm[k].val=val;
cin>>row>>col>>val;
M.t=k;
若稀疏矩阵采用十字链表存储，则相应的输入算法如下。
voidInputMatrix(CLMatrix&M,intm,intn)
M.m=m;M.n=n;
introw,col,val;
intk=0;
cin>>row>>col>>val;
while(row!=0)
k++;
CrossNodecp,newptr;
//建立一个新结点
newptr=newCrossNode;
newptr->row=row;
newptr->col=col;
newptr->val=val;
newptr->down=newptr->right=NULL;
//把新结点链接到所在行单链表的末尾
cp=M.rv[row];
if(cp==NULL)M.rv[row]=newptr;
else
while(cp->right!=NULL)cp=cp->right;
cp->right=newptr;
//把新结点链接到所在列单链表的末尾
cp=M.cv[col];
if(cp==NULL)M.cv[col]=newptr;
else
while(cp->down!=NULL)cp=cp->down;
cp->down=newptr;
//输入一个新三元组
cin>>row>>col>>val;
M.t=k;
```
请自行编写出采用带行指针向量的链接存储所对应的输入算法。
3.稀疏矩阵的输出
对于采用顺序存储的稀疏矩阵，按三元组线性表的格式输出，其输出算法如下。
voidOutputMatrix(SMatrix&M)
cout<<"(";
for(inti=1;i<M.t;i++)
cout<<"(<M.sm[i].row<<",";
cout<<M.sm[i].col<<",";
cout<<M.sm[i].val<<")"<<",";
if(M.t!=0)
cout<<"(<M.sm[M.t].row<<",";
cout<<M.sm[M.t].col<<",";
cout<<M.sm[M.t].val<<")";
cout<<")"<<endl;
对于采用其他存储结构的稀疏矩阵，不难写出其相应的输出算法。
4.稀疏矩阵的转置运算
以稀疏矩阵的顺序存储结构为例讨论稀疏矩阵的转置运算。
设图3-3(b)所示的稀疏矩阵命名为A，它所对应的顺序存储类型的对象命名为M，则图3-4就是该对象中数组sm中的内容。矩阵A的转置矩阵如图3-7(a)所示，其命名为B，用顺序存储类型的对象S来存储它，S中sm数组的内容如图3-7(b)所示。left[beginarrayrrrrr3&0&1&0&00&0&0&0&00&-2&4&0&-15&0&0&0&00&0&6&0&00&0&0&0&0endarrayright](a)A的转置矩阵beginarrayc|c|c|chlineS&textrow&textcol&textvalhline1&1&1&3hline2&1&3&1hline3&2&-2&hline4&3&3&4hline5&3&5&-1hline6&4&1&5hline7&5&3&6hlinevdots&&&hlineendarrayMaxTerms
(b)B的顺序存储结构
图3-7稀疏矩阵B和它的顺序存储结构
下面根据稀疏矩阵A的顺序存储对象M求它的转置矩阵的顺序存储对象S，来讨论进行稀疏矩阵转置运算的两种方法：普通转置方法和快速转置方法。
(1)普通转置方法。
普通转置方法要对M中的sm数组进行n次扫描(n为A的列数,即B的行数)才能完成。具体地说,第1次扫描col域的值等于1(即列为1)所在的三元组(即对应B中第1行非零元素)按照从上到下(因行号为从小到大,所以对应B中是列号从小到大的)的顺序,行列值互换写入到对象S的sm数组中,第2次扫描把col域的值等于2(即列为2)所在的三元组(即对应B中第2行非零元素)按照从上到下的顺序接着写入到对象S的sm数组中,以此类推。具体算法描述如下。
SMatrixTranspose(SMatrix&M)
SMatrixS;//用S暂存转置结果
InitMatrix(S);
intm,n,t;
//用m,n,t分别暂存M的行数、列数和非零元素的个数
m=M.m;n=M.n;t=M.t;
//分别置s的行数域、列数域和非零元素的个数域为n,m和t
S.m=n;S.n=m;S.t=t;
//若是矩矩阵(即非零元素的个数为0的矩阵)则转换完毕返回
if(t==0)returnS;
//按列进行每个元素的转换
intk=1;//用k指示S.sm数组中待存元素的下标
for(intcol=1;col<=n;col++)
//用col扫描M.sm数组中的col域
for(inti=1;i<=t;i++)
//用i指示M.sm数组中当前元素下标
if(M.sm[i].col==col)
S.sm[k].row=col;
S.sm[k].col=M.sm[i].row;
S.sm[k].val=M.sm[i].val;
k++;
returnS;//返回转置矩阵S
此算法的运行时间主要取决于最后的双重for循环,故算法的时间复杂度为O(ntimest),即同M的列数与非零元素的个数的乘积成正比。当稀疏矩阵接近一般矩阵时,非零元素的个数t等于矩阵中的行数m乘以列数n,此时算法的时间复杂度为O(mtimesn^2),它比采用二维数组存储时进行转置运算的时间复杂度O(mtimesn)要坏得多。因此,对于一般矩阵最好采用二维数组存储和运算。
(2)快速转置方法。
用快速转置的方法进行稀疏矩阵转置要对M中的sm数组进行两次扫描,第1次扫描统计出对应A矩阵中每一列(即对应转置矩阵B中每一行)非零元素的个数,由此求出每一列的第1个非零元素(即对应B中每一行的第1个非零元素)在S.sm数组中应有的位置,第2次扫描把数组M.sm中的每一个三元组,行列值互换写入到数组S.sm中确定的位置上。
设col表示A中元素的列号（即对应转置矩阵B中元素的行号），num和pot均表示具有n（n为A中的列数即B中的行数）个分量的向量，num向量的第col分量（即num[col]）用来统计第col列中的非零元素的个数，pot向量的第col分量（即pot[col]）用来指向第col列待转换的非零元素被存储在S.sm数组中的下标位置，显然pot向量的第col分量的初始值（即第col列的第一个非零元素被存储在S.sm数组中的下标位置）由下式计算。beginaligned
&pot[1]=1
&pot[col]=pot[col-1]+num[col-1]quad(2leqcolleqn)
endaligned根据稀疏矩阵A和顺序存储对象M，得到num向量的各分量值和pot向量的各分量初始值如表3-1所示。
表3-1num和pot向量初始值
||1|2|3|4|5|6|
|-------|---|---|---|---|---|---|
|col|1|2|3|4|5|6|
|num[col]|2|0|3|1|1|0|
|pot[col]|1|3|3|6|7|8|
结合图3-7进行分析，验证num和pot数组中各分量值的正确性，num数组中的第i个分量值等于稀疏矩阵B中第i行上非零元素的个数，pot数组中的第i个分量值等于B中第i行上第一个（即列号最小的）非零元素在S.sm数组中的下标位置。
用C++语言描述稀疏矩阵的快速转置方法的算法如下。
```cpp
SMatrixFastTranspose(SMatrix&M)
SMatrixS;//用S暂存转置结果
InitMatrix(S);
intm,n,t;
//用m,n,t分别暂存M的行数、列数和非零元素的个数
m=M.m;n=M.n;t=M.t;
//分别置S的行数域、列数域和非零元素的个数域为n,m和t
S.m=n;S.n=m;S.t=t;
//若是零矩阵(即非零元素的个数为0的矩阵)则转换完毕返回
if(t==0)returnS;
//为num和pot向量动态分配存储空间
intnum=newint[n+1];
intpot=newint[n+1];
//对num向量进行初始化,置每个分量为0
intcol,i;
for(col=1;col<=n;col++)num[col]=0;
//对第1遍扫描数组M.sm,统计出每一列(即转换后的每一行)非零元素的个数
for(i=1;i<=t;i++)
intj=M.sm[i].col;
num[j]++;
//计算每一列(即转换后的每一行)的第1个非零元素在S.sm中存储位置
```
pot[1]=1;
for(col=2;col<=n;col++)
pot[col]=pot[col-1]+num[col-1];
//对M.sm进行第2遍扫描,把每个元素行、列值互换写入到S.sm的确定位置
for(i=1;i<=t;i++)
intj=M.sm[i].col;//取待转换元素的列号
intk=pot[j];//取待转换元素在S.sm中的位置
S.sm[k].row=j;//以下3行存储被转换的元素
S.sm[k].col=M.sm[i].row;
S.sm[k].val=M.sm[i].val;
pot[j]++;//使pot[j]指向下—个位置
//删除动态分配的数组
delete[]num;
delete[]pot;
//返回转置矩阵S
returnS;
此算法的运行时间主要取决于4个for单重循环，故时间复杂度为O(n+t)，显然它比第一种转置算法的时间复杂度要好得多。当稀疏矩阵接近一般矩阵时，其时间复杂度变为O(mtimesn)，与采用二维数组表示时相同。当然进行每一个元素转换的运算步骤要比使用二维数组时的直接赋值（即b[i][j]=a[j][i]）操作要复杂一些。
section5.稀疏矩阵的加法运算
假定采用带行指针向量的存储结构进行稀疏矩阵的加法运算，设M1和M2为两个加数矩阵，M为和矩阵，即结果矩阵。两矩阵相加的前提条件是：两矩阵的大小相同，即行数和列数分别对应相等。两矩阵相加的结果仍为一个具有相同大小的矩阵，结果矩阵M中每个行单链表仍然要按列号有序，它是对M1和M2中对应行单链表的按列号有序的合并结果。当M1和M2中对应行单链表的两个结点分别具有相同的行号和列号时，若它们的元素值之和为0，则不在结果矩阵中建立结点，只有当其和不为0或者列号不同时，才需要在结果矩阵中建立结点。具体算法描述如下。
LMATRIXAdd(LMATRIX&M1,LMATRIX&M2)
LMATRIXM;//暂存运算结果，以便返回
InitMatrix(M);
//若两个矩阵尺寸不同，则给出错误信息并停止运行
if((M1.m!=M2.m)||(M1.n!=M2.n))
cerr<<"twomatrixmeasurementsaredifferent!"<<endl;
exit(1);
//把其中一个加数矩阵的尺寸赋给结果矩阵
M.m=M1.m;M.n=M1.n;
//若两个矩阵均为零矩阵，则无须计算返回M
if((M1.t==0)&&(M2.t==0))returnM;
//进行两矩阵相加产生和矩阵
intk=0;//用k统计结果矩阵中结点的个数
for(inti=1;i<=M1.m;i++)//循环的次数等于矩阵的行数
TripleNodep1,p2,p;
p1=M1.vector[i];//p1指向M1矩阵中第i行单链表的待相加的结点
p2=M2.vector[i];//p2指向M2矩阵中第i行单链表的待相加的结点
p=M.vector[i];//p指向M矩阵中第i行单链表的表尾结点
//当p1和p2均不为空时进行比较和加法运算，把结点复制到结果矩阵中
while((p1!=NULL)&&(p2!=NULL))
TripleNodenewptr=newTripleNode;
if(p1->col<p2->col)//赋值新结点，p1指针后移
newptr=p1;p1=p1->next;
elseif(p1->col>p2->col)//赋值新结点，p2指针后移
newptr=p2;p2=p2->next;
else//对具有相同列号的结点进行处理
if(p1->val+p2->val==0)//不建立新结点和链接
p1=p1->next;p2=p2->next;//p1和p2指针后移
continue;
else//新结点值为两结点值之和，p1和p2指针后移
newptr=p1;
newptr->val+=p2->val;
p1=p1->next;p2=p2->next;
newptr->next=NULL;//将新结点的指针域置空
//把新结点链接到结果矩阵的第i行单链表的表尾
if(p==NULL)M.vector[i]=newptr;
elsep->next=newptr;
p=newptr;//修改p指针，使之指向新的表尾
k++;//结果矩阵中的结点数加1
//endofwhile
//若p1不为空，则把剩余结点复制链接到结果矩阵中
while(p1!=NULL)
TripleNodenewptr=newTripleNode;
newptr=p1;
newptr->next=NULL;
if(p==NULL)M.vector[i]=newptr;
elsep->next=newptr;
p=newptr;
p1=p1->next;
```cpp
k++;
//endofwhile
//若p2不为空,则把剩余结点复制链接到结果矩阵中
while(p2!=NULL)
TripleNodenewptr=newTripleNode;
newptr=p2;
newptr->next=NULL;
if(p==NULL)M.vector[i]=newptr;
elsep->next=newptr;
p=newptr;
p2=p2->next;
k++;
//endofwhile
//endoffor
M.t=k;//置和矩阵中结点数
returnM;//返回和矩阵
在这个算法中，需要扫描M1和M2中的每一个结点，并建立新结点和把它链接到结果矩阵中相应行单链表的表尾，因为对每个结点的处理均为时间常量，其时间复杂度为O(1)，所以整个算法的时间复杂度为O(M1.t+M2.t)，即与两个加数矩阵中结点数（即非零元素个数）之和成正比。当稀疏矩阵相当稀疏时，即非零元素的个数t远远小于行列数的乘积m×n时，该算法的时间复杂度比采用二维数组表示时进行矩阵求和的时间复杂度O(mtimesn)要小得多。
section3.5广义表
subsection3.5.1广义表的定义
广义表(generalizedlist)简称表，它是线性表的推广。一个广义表是n(ngeqslant0)个元素的一个有限序列，当n=0时则称为空表。在一个非空的广义表中，其元素可以是某一确定类型的对象，这种元素被称为单元素；也可以是由单元素构成的表，这种元素被称为子表（或表元素）。显然，广义表的定义是递归的，广义表是一种递归的数据结构。
设a_i为广义表的第i个元素，则广义表的一般表示与线性表相同，具体如下。
[
(a_1,a_2,cdots,a_i,a_i+1,cdots,a_n)
]
其中，n表示广义表的长度，即广义表中所含元素的个数，ngeqslant0。
同线性表一样，也可以用一个标识符来命名一个广义表，如用LS命名上面的广义表，则为：
[
textLS=(a_1,a_2,cdots,a_i,a_i+1,cdots,a_n)
]
在广义表的讨论中，为了把单元素同表元素区别开来，一般用小写字母表示单元素，用大写字母表示表，如：
```
A=()
B=(e)
C=(a,(b,c,d))
D=(A,B,C)=((),(e),(a,(b,c,d)))
E=((a,(a,b)),((a,b),c))
其中，A是一个空表，其长度为0；B是一个只含有单元素e的表，其长度为1；C中有两个元素，一个是单元素a，另一个是表元素(b,c,d)，C的长度为2；D中有三个元素，其中每个元素又都是一个表，D的长度为3；E中只含有一个元素，该元素是一个表，该表中包含有三个元素，其中后两个元素又都是表。
若把每个表的名字（若有的话）写在其表的前面，则上面的五个广义表可相应地表示为：
A()
B(e)
C(a,(b,c,d))
D(A(),B(e),C(a,(b,c,d)))
E((a,(a,b)),((a,b),c))
若用圆圈和方框分别表示表和单元素，并用线段把表和它的元素（元素结点应在其表结点的下方）连接起来，则可得到一个广义表的图形表示。上面5个广义表的图形表示如图3-8所示。
可以看出，广义表的图形表示像倒着画的一棵树，树根结点代表整个广义表，各层树枝结点代表相应的子表，树叶结点代表单元素或空表。
一个表的深度是指该表中括号嵌套的最大次数，在图形表示中，则是从树根结点到每个树枝结点所经过的结点个数的最大值。如表A和B的深度为1，表C、D、E的深度分
别为2、3和4。
section3.5.2广义表的存储结构
广义表是一种递归的数据结构,因此很难为每个广义表分配固定大小的存储空间,所以其存储结构只好采用动态链接结构。
在一个广义表中,其数据元素有单元素和子表之分,所以在对应的存储结构中,其存储结点也有单元素结点和子表结点之分。对于单元素结点,应包括值域和指向其后继结点的指针域;对于子表结点,应包括指向子表中第一个结点的表头指针域和指向其后继结点的指针域。为了把广义表中的单元素结点和子表结点区别开来,还必须在每个结点中增设一个标志域,让标志域取两种不同的值,从而区分两种不同的结点。
根据分析,广义表中的结点类型在C++语言中可定义如下。
structGLNode
booltag;//标志域
union
ElemTypedata;//值域或子表的表头指针域
GLNodesublist;
;
GLNodenext;//指向后继结点的指针域
;
其中,tag作为标志域,其值为false时表示单元素结点,使用无名联合中的data域,用来存储元素值;其值为true时表示子表结点,使用无名联合中的sublist域,用来存储指向子表中第一个结点的指针,即子表的表头指针,通过它实现向子表的链接,即实现广义表的递归结构,结点中的next作为指向其后继结点的指针域,通过它把表中同一层的所有结点依次链接起来。
上述5个广义表的存储结构的示意图,如图3-9所示。
A=NULL
B→[0e∧]
D→[1∧]→[1]→[1∧]
E→[1∧]→[0a]→[1]→[0a]→[0b∧]→[1]→[0c∧]→[0d∧]
C[0a][1]∧
[0b]→[0c]→[0d∧]
[0e∧]→[0a]→[1]∧
[0b]→[0c]→[0d∧]
[0a]→[0b∧]
[0a]→[0b∧]
图3-9广义表的链接存储结构
若把整个广义表也同样用一个表结点来表示，则应在每个广义表的表头结点（即表中第一个结点）之前增加一个表结点（称此为表头附加结点），此表结点的sublist域指向表头结点，next域为空，表头指针则指向这个表结点。例如，若在广义表A,B,C的表头结点之前增加这样的表结点，对应的示意图如图3-10所示。
Arightarrow[1∧∧]Crightarrow[1∧∧]
Brightarrow[1∧∧][0arightarrow[1∧∧]]
[0e∧][0brightarrow[0crightarrow[0d∧]]
图3-10带表头附加结点的广义表的链存储结构
这种带表头附加结点的广义表表示，将给广义表的某些运算带来方便。
section3.5.3广义表的运算
广义表的运算主要有求广义表的长度和深度、向广义表插入元素和从广义表中查找或删除元素、建立广义表的存储结构、打印广义表等。由于广义表是一种递归的数据结构，所以对广义表的运算一般采用递归的算法。全面介绍广义表的各种运算的算法，超出了本课程的教学内容，这里只讨论其中一些算法。
section1.求广义表的长度
在广义表中，同一层次的每个结点是通过next域链接起来的，所以可把它看作是由next域链接起来的单链表。这样，求广义表的长度就是求单链表的长度，可以采用以前介绍的求单链表长度的方法求其长度。由于单链表的结构也是一种递归结构，即每个结点的指针域均指向一个单链表（称为该结点的后继单链表），它所指向的结点为该单链表的第一个结点（即表头结点），所以求单链表的长度也可以采用递归算法，即若单链表非空的话，其长度等于1加上表头结点的后继单链表的长度，若单链表为空，则长度为0，这是递归的终止条件。
求广义表长度的递归算法如下。
intLength(GLNodeGL)//求值参GL所指向的广义表的长度
if(GL!=NULL)
return1+Length(GL->next);
else
return0;
此算法每次被调用时，无论是从外部对它的非递归调用，还是从内部对它的递归调用，都需要给值参GL分配存储空间，用以存储由实参传来的指针值，所以算法的空间复杂度为O(n)，若采用非递归算法，其空间复杂度为O(1)，两者的时间复杂度均为O(n)，n为广义表的长度。这里介绍递归算法，是想通过这个简单的例子为后面介绍更复杂的递归算
法做准备。
2.求广义表的深度
广义表深度的递归定义是它等于所有子表中表的最大深度加1，若一个表为空或仅由单元素所组成，则深度为1。设dep表示任一子表的深度，max表示所有子表中表的最大深度，Depth表示广义表的深度，则有：textDepth=max+1因一个表不包含任何子表时，其深度为1，所以max的初值应为0。
求一个广义表深度的算法如下。
intDepth(GLNodeGL)//求值参GL所指向的广义表的深度
intmax=0;//给max赋初值0
while(GL!=NULL)
if(GL->tag==true)
intdep=Depth(GL->sublist);//递归调用求出子表的深度
if(dep>max)max=dep;//让max为同层求过子表深度的最大值
GL=GL->next;//使GL指向同一层的下一个结点
returnmax+1;//返回表的深度
从这个算法可以看出，当GL为一个空表或仅由单元素组成的线性表时，不进入下一层的递归调用，而结束本次调用并返回1，当GL含有子表时才会进入求子表深度的递归调用，返回后修改max的值，使之为所求过的本层次子表中深度的最大值，本层次的所有结点都扫描完毕后，结束本次调用并返回表的深度。
设一个广义表为:G=((),a,((b,c),d))它的存储结构如图3-11所示。
为了便于分析，在图中每个链接指针上都标明数字，假定它为该指针的具体值。
在第1次非递归调用和以后每次递归调用Depth算法时，系统都要在动态堆存储区中为值参GL，局部变量max和dep以及保存调用后的返回地址分配存储空间，每次调用结束按所保存的返回地址返回后，系统都释放为本次调用所分配的存储空间，从而使上一
层调用所分配的存储空间成为变量的当前存储空间。若以表头指针G作为实参去调用Depth算法，则在算法的执行过程中，动态堆栈的数据变化情况如图3-12所示。其中，用r表示返回地址域，第1次调用（即非递归调用，又称为第0次递归调用）后的返回地址用r1表示，以后每次递归调用的返回地址用r2表示。
(a)第0次递归调用
|GL|max|dep|r|
|---|---|---|---|
|10|0||r1|
(b)第1次递归调用
|GL|max|dep|r|
|---|---|---|---|
|∧|0||r2|
|10|0||r1|
(c)返回
|GL|max|dep|r|
|---|---|---|---|
|10|1|1|r1|
(d)GL指向20结点
|GL|max|dep|r|
|---|---|---|---|
|20|1|1|r1|
(e)GL指向30结点
|GL|max|dep|r|
|---|---|---|---|
|30|1|1|r1|
(f)第2次递归调用
|GL|max|dep|r|
|---|---|---|---|
|40|0||r2|
|30|1|1|r1|
(g)第3次递归调用
|GL|max|dep|r|
|---|---|---|---|
|50|0||r2|
|40|0||r2|
|30|1|1|r1|
(h)GL指向60结点
|GL|max|dep|r|
|---|---|---|---|
|60|0||r2|
|40|0||r2|
|30|1|1|r1|
(i)GL变为空
|GL|max|dep|r|
|---|---|---|---|
|∧|0||r2|
|40|0||r2|
|30|1|1|r1|
(j)返回
|GL|max|dep|r|
|---|---|---|---|
|40|1|1|r2|
|30|1|1|r1|
(k)GL指向70结点
|GL|max|dep|r|
|---|---|---|---|
|70|1|1|r2|
|30|1|1|r1|
(l)GL变为空
|GL|max|dep|r|
|---|---|---|---|
|∧|1|1|r2|
|30|1|1|r1|
(m)返回
|GL|max|dep|r|
|---|---|---|---|
|30|2|2|r1|
(n)GL变为空
|GL|max|dep|r|
|---|---|---|---|
|∧|2|2|r1|
(o)返回3
图3-12系统动态堆栈中数据的变化情况
可以分析出，该算法需要扫描广义表中的所有结点，对于单元素结点需要访问两次，一次为读取tag域值，另一次为读取next域值；对于子表结点需要访问3次，分别为读取tag、sublist和next域的值。所以此算法的时间复杂度为O(n)，其中n为广义表中所有结点的个数。该算法的空间复杂度为O(m)，m为广义表的深度。
3.建立广义表的存储结构
设广义表中的元素类型ElemType为字符类型char，每个单元素的值被限定为英文字母，广义表由键盘输入，其格式为：元素之间用一个逗号分隔，表元素的起止符号分别为左、右圆括号，空表在其圆括号内使用一个“”字符表示，最后使用一个分号作为整个广
义表的结束符号。如“(a,(),b,c,(d,(e)))”;就是一个符合上述规定的广义表输入格式。
建立广义表存储结构的算法同样是一个递归算法，该算法使用一个具有GLNode^类型的引用指针参数，用以返回所建广义表的表头指针，用GL表示。在算法的执行过程中，对于从键盘上输入的一个广义表，需要从头到尾扫描每一个字符，当碰到左括号时，表明它是一个表元素的开始，则应建立一个由GL指向的表结点，并用它的sublist域作为子表的表头指针进行递归调用，来建立子表的存储结构：当碰到一个英文字母时，表明它是一个单元素，则应建立一个由GL指向的单元素结点；当碰到一个“”字符时，表明它是一个空表，则应置GL为空。当建立了一个由GL指向的结点后，接着碰到逗号字符时，表明存在后继结点，需要建立当前结点（即由GL指向的结点）的后继表，当碰到右括号或分号字符时，表明当前所处理的表已结束，应置当前结点的next域为空。
根据广义表输入格式和建立存储结构的思路，可知所建立的广义表存储结构将带有表头附加结点，因为一开始就会遇到左括号，就会建立起整个表的表元素结点。若要建立不带表头附加结点的广义表存储结构，则只要使输入格式中省去最外层的一对圆括号即可。
根据分析，编写算法如下。
voidCreate(GLNode&GL)
charch;
//读入一个字符,此处只可能读入,左括号和英文字母
cin>>ch;
//若输入为,则置GL为空
if(ch=='')GL=NULL;
//若输入为左括号则建立由GL所指向的子表结点并递归构造子表
elseif(ch=='(')
GL=newGLNode;
GL->tag=true;
Create(GL->sublist);
//建立由GL所指向的单元素结点
else
GL=newGLNode;
GL->tag=false;
GL->data=ch;
//此处读入的字符必为逗号、右括号或分号
cin>>ch;
//若GL为空,此时输入的字符必然为')',则什么都不用做
if(GL==NULL);
//若输入为逗号则递归构造后继表
elseif(ch==',')Create(GL->next);
//若输入为右括号或分号则置GL的后继指针域为空
elseif((ch==')')||(ch==';'))GL->next=NULL;
该算法需要扫描输入广义表中的所有字符，并且处理每个字符都是简单的比较或赋值操作，其时间复杂度为O(1)，所以整个算法的时间复杂度为O(n)，n表示广义表中所有字符的个数。由于平均每两个字符可以生成一个表结点或单元素结点，所以n也可以看做生成的广义表中所有结点的个数。在这个算法中，既包含向子表的递归调用，也包含向后继表的递归调用，所以递归调用的最大深度（即动态堆栈的最大深度）不会超过生成的广义表中所有结点的个数，因此其空间复杂度也为O(n)。
4.打印输出广义表
根据以GL为带表头附加结点的广义表的表头指针，打印输出该广义表同样需要向子表递归调用和向后继表递归调用。当GL结点为元素结点时，则应首先输出作为一个表的起始符号的左括号，然后再输出以GL->sublist为表头指针的表；当GL结点为单元素结点时，则应输出该元素的值。当以GL->sublist为表头指针的表输出完毕后，应在其最后输出一个作为表终止符的右括号。当GL结点输出结束后，若存在后继结点，则应首先输出一个逗号作为分隔符，然后再递归输出由GL->next指针所指向的后继表。
打印输出一个广义表的算法描述如下，其中值参GL指向一个带有表头附加结点的广义表，GL也可采用指针引用参数。
voidPrint(GLNodeGL)
if(GL->tag==true)
cout<<'(';
if(GL->sublist==NULL)
cout<<'';
else
Print(GL->sublist);
cout<<')';
elsecout<<GL->data;
if(GL->next!=NULL)
cout<<',';
Print(GL->next);
该算法的时间复杂度和空间复杂度与建立广义表存储结构的情况相同，均为O(n)，n为广义表中所有结点的个数。
3.5.4简单程序举例
以上介绍的几种进行广义表运算的算法假定被保存在“广义表运算.cpp”程序文件中，现要求利用它们编写一个程序，首先建立广义表“(a,(b,(c)),((),((d,e))),f,(g))”的存储结构，然后输出该广义表，最后求该广义表的长度和深度。
该程序比较简单，如下所示。
```c
include<iostream.h>
include<stdlib.h>
typedefcharElemType;
structGLNode
booltag;
union
ElemTypedata;
GLNodesublist;
;
GLNodenext;
;
include"广义表运算.cpp"
voidmain()
GLNodeg=NULL;
Create(g);
Print(g);
cout<<endl;
cout<<"广义表的长度："<Length(g->sublist)><<endl;
cout<<"广义表的深度："<Depth(g->sublist)><<endl;
该程序运行后，从键盘上输入如下一行字符：(a,(b,(c)),((),((d,e))),f,(g));
则得到的输出结果如下:(a,(b,(c)),((),((d,e))),f,(g))广义表的长度：5
广义表的深度：4
习题3
【习题3-1】按要求进行稀疏矩阵运算。
已知一个稀疏矩阵，如图3-13所示。beginbmatrix
0&4&0&0&0&0&0
0&0&0&-3&0&0&1
8&0&0&0&0&0&0
0&0&0&5&0&0&0
0&-7&0&0&0&2&0
0&0&0&6&0&0&0
endbmatrix图3-13具有6行×7列的一个稀疏矩阵
```
1.写出它的三元组线性表。
2.给出它的顺序存储表示。
3.给出它的转置矩阵的三元组线性表和顺序存储表示。
4.给出对它进行快速转置时，num向量中各分量的值。
5.给出对它进行快速转置前和转置后，pot向量中各分量的值。
【习题3-2】按要求进行广义表运算。
画出下列每个广义表的带表头附加结点的链接存储结构图并分别计算它们的长度和深度。
1.A=()
2.B=(a,b,c)
3.C=(a,(b,c))
4.D=((a,b),(c,d))
5.E=(a,(b,(c,d)),(e))
6.F=((a,(b,(),c)),((d),e))
【习题3-3】写出下列每个主程序段的运行输出结果。
1.voidmain()
Seta;
InitSet(a);
ElemTyper[8]=1,5,90,5,7,25,34,16;
inti;
for(i=0;i<8;i++)InsertSet(a,r[i]);
ElemTypex=25,y=90;
DeleteSet(a,x);
DeleteSet(a,y);
OutputSet(a);
cout<<EmptySet(a)<''<LengthSet(a)<<endl;
2.voidmain()
ElemTyper[8]=1,5,90,5,7,25,34,16;
ElemTyper1[6]=5,60,16,30,34,8;
Seta;InitSet(a);
Setb;InitSet(b);
Setc;InitSet(c);
inti;
for(i=0;i<8;i++)InsertSet(a,r[i]);
for(i=0;i<6;i++)InsertSet(b,r1[i]);
UnionSet(a,b,c);
OutputSet(c);
IntersectSet(a,b,c);
OutputSet(c);
DifferenceSet(a,b,c);
OutputSet(c);
ClearSet(a);ClearSet(b);ClearSet(c);
3.voidmain()
ElemTyper[8]=1,5,90,5,7,25,34,16;
SNodea;
InitSet(a);
inti;
for(i=0;i<8;i++)InsertSet(a,r[i]);
OutputSet(a);
ElemTypex=34;
DeleteSet(a,x);
InsertSet(a,48);
x=5;DeleteSet(a,x);
OutputSet(a);
ClearSet(a);
4.voidmain()
SNodea;InitSet(a);
SNodeb;InitSet(b);
SNodec;InitSet(c);
inti;
ElemTyper[8]=1,5,90,5,7,25,34,16;
ElemTyper1[5]=5,60,16,30,8;
for(i=0;i<8;i++)InsertSet(a,r[i]);
for(i=0;i<5;i++)InsertSet(b,r1[i]);
UnionSet(a,b,c);
OutputSet(c);
InterseSet(a,b,c);
OutputSet(c);
【习题3-4】根据下列每个题目的要求编写算法。
1.比较两个集合的大小。若两集合长度不等则退出运行。在两集合长度相等的情况下，若各集合的元素值的累加和相等则认为它们相等，返回0；若第1个集合的元素值的累加和大于第2个集合的元素值的累加和，则认为第1个集合大于第2个集合，返回1；若第1个集合的元素值的累加和小于第2个集合的元素值的累加和，则认为第1个集合小于第2个集合，返回-1。
2.定义等于号运算符重载函数，比较两个集合是否相等。若两集合长度不等则退出运行。在两集合长度相等情况下，若各集合的元素值的累加和相等则认为它们相等，返回真；否则认为它们不等，返回假。
3.从键盘上输入一个三元组线性表，当输入(0,0,0)元素时结束，实现稀疏矩阵的带行指针向量的链接存储。
4.以三元组线性表的形式输出一个稀疏矩阵，其中稀疏矩阵采用的是带行指针向量的链接存储。
5.实现稀疏矩阵的十字链表存储的三元组线性表输出。
6.采用顺序存储方式实现稀疏矩阵M1和M2相加的运算，运算结果由引用参数M带回。
7.编写一个建立广义表链接存储结构的算法，广义表由字符串值参提供。
8.编写一个从广义表中查找单元素字符等于给定值的算法，若查找成功则返回真，否则返回假。
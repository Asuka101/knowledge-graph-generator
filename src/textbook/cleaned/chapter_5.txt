第5章树
section5.1树的概念
subsection5.1.1树的定义
树（tree）是树形结构的简称。它是一种重要的非线性数据结构。树或者是一棵空树，即不含有任何结点（元素），或者是一棵非空树，即至少含有一个结点。在一棵非空树中，它有且仅有一个称作根（root）的结点，其余所有结点被分为m棵(mgeq0)互不相交的子树（即称做根的子树），每棵子树（subtree）又同样是一棵树，并且每棵子树的根结点是整个树根结点的后继，而整个树根结点又是所有子树根结点的前驱。显然，树的定义是递归的，树是一种递归的数据结构。树的递归定义，将为以后实现树的各种运算提供方便。
一棵树T如图5-1(a)所示，它由根结点A和两棵子树T1和T2所组成，T1和T2如图5-1(b)和图5-1(c)所示；T1又由它的根结点B和三棵子树T11、T12和T13所组成，这3棵子树分别对应如图5-1(d)、图5-1(e)和图5-1(f)所示；T11和T13只含有根结点，不含于子树（或者说子树为空树），不可再分；T12又由它的根结点E和两棵只含有根结点的子树所组成，每棵子树的根结点分别为H和I；T2由它的根结点C和一棵子树所组成，该子树也只含有一个根结点G，不可再分。
n
begincenter
includegraphics[width=0.8textwidth]image.png
endcenter
n
在一颗树中，每个结点被定义为它的每个子树的根结点的前驱，而它的每个子树的根结点就成为它的后继。由此可用二元组给出树的定义：texttree=(K,R)K=leftk_imid1leqileqn,ngeq0,k_iintextElemTyperight
其中,n为树中结点数,n=0则为空树,n>0则为非空树。对于一棵非空树,关系R应满足下列条件。
(1)有且仅有一个结点没有前驱,该结点被称为树的根。
(2)除树根结点外,其余每个结点有且仅有一个前驱结点。
(3)包括树根结点在内的每个结点,可以有任意多个(含0个)后继。
上面的树mathrmT若采用二元组表示,则结点的集合K和K上二元关系R分别为:K=textA,B,C,D,E,F,G,H,Ir=<textA,B>,<textA,C>,<textB,D>,<textB,E>,<textB,F>,<textC,G>,<textE,H>,<textE,I>其中mathrmA结点无前驱结点,被称为树的根结点;其余每个结点有且仅有一个前驱结点;在所有结点中,mathrmB结点有三个后继结点,mathrmA结点和mathrmE结点分别有两个后继结点,mathrmC结点有一个后继结点,其余结点均没有后继结点。
在日常生活和计算机领域,树结构广泛存在。
【例5-1】可把一个家族看作一棵树,树中的结点为家族成员的姓名及相关信息,树中的关系为父子关系,即父亲是儿子的前驱,儿子是父亲的后继。一棵家族树,如图5.2(a)所示,王庭贵有两个儿子王万胜和王万利,王万胜又有3个儿子王家新、王家中和王家国。
【例5-2】可把一个地区或一个单位的组织结构看作一棵树,树中的结点为机构的名称及相关信息,树中的关系为上下级关系。如一个城市分为若干个区,每个区又分为若干个街道,每个街道又分为若干个居委会等。
【例5-3】可把一本书的结构看作一棵树,树中的结点为书、章、节的名称及相关信息,树中的关系为包含关系。一本书的结构,如图5.2(b)所示,根结点为书的名称数学,它包含3章,每章名称分别为加法、减法和乘法,加法一章又包含两节,分别为一位加和两位和,减法和乘法也分别包含若干节。
【例5-4】可把一个算术表达式表示成一棵树,运算符作为根结点,它的前后两个运算对象分别作为根的左、右两棵子树。如把算术表达式ab+(c-d/e)f表示成树,如图5-2(c)所示。
![图像内容]
(a)家族树
(b)书的结构树
(c)算术表达式树
图5-2树应用的例子
【例5-5】在计算机领域,每个逻辑盘上信息组织的目录结构就是一棵树,树中的结点为包含有目录名或文件名的每个目录项或文件项,树中的根目录用反斜线表示,根目录下包含有若干个子目录项和文件项,每个子目录下又包含有若干个子目录项和文件项,以
此类推，目录结构树如图5-3所示。
![目录结构树](attachment://image.png)
图5-3目录结构树
subsection5.1.2树的表示
树的表示方法有多种。图5-1、图5-2和图5-3中的树形表示法是其中的一种，也是最常用的一种，图5-1和图5-2中的结点是从上向下展开的，而图5-3中的结点是从左向右展开的。在树形表示法中，结点之间的关系是通过连线表示的，虽然每条连线上都不带有箭头（即方向），但它并不是无向的，而是有向的，其方向隐含为从上向下或从左向右，即连线的上方或左边结点是下方或右边结点的前驱，下方或左边结点是上方或右边结点的后继。树的另一种表示法是二元组表示法。除这两种之外，通常还有3种：一是集合图表示，每棵树对应一个圆形，圆内包含根结点和子树，图5-1所示的树T对应的集合图表示如图5-4(a)所示；二是凹入表示，每棵树的根对应着一个条形，子树的根对应着一个较短的条形，且树根在上，子树的根在下，树T的凹入表示，如图5-4(b)所示；三是广义表表示，每棵树的根作为由子树构成的表的名字而放在表的前面，图5-1中的树T的广义表示如图5-4(c)所示。
![树的其他几种表示](attachment://image2.png)
(a)集合图
(b)凹入表
A(B(D,E,(H,I),F),C(G))
(c)广义表
图5-4树的其他几种表示
5.1.3树的基本术语
1.结点的度和树的度
每个结点具有的子树数或者说后继结点数被定义为该结点的度（degree）。树中所有结点的度的最大值被定义为该树的度。在图5-1的树T中，B结点的度为3，A、E结点的度均为2，C结点的度为1，其余结点的度均为0。因所有结点的最大度为3，所以树T的度为3。
2.分支结点和叶子结点
在一棵树中，度等于0的结点称作叶子结点或终端结点，度大于0的结点称作分支结点或非终端结点。在分支结点中，每个结点的分支数就是该结点的度数，如对于度为1的结点，其分支数为1，所以被称之为单分支结点；对于度为2的结点，其分支数为2，所以被称之为双分支结点，其余类推。在树T中，D、H、I、F、G都是叶子结点；A、B、C、E是分支结点，其中C为单分支结点，A和E为双分支结点，B为三分支结点。
3.孩子结点、双亲结点和兄弟结点
在一棵树中，每个结点的子树的根，或者说每个结点的后继，被习惯地称为该结点的孩子、儿子或子女（child），相应地，该结点被称为孩子结点的双亲、父亲或父母（parent）。具有同一双亲的孩子互称兄弟（brothers）。一个结点的所有子树中的结点被称为该结点的子孙。一个结点的祖先则被定义为从树根结点到达该结点的路径上经过的所有结点。在树T中，B结点的孩子为D、E、F结点，双亲为A结点，D、E、F互为兄弟，B结点的子孙为D、E、H、I、F结点，I结点的祖先为A、B、E结点，对于树T中的其他结点亦可进行类似的分析。
由孩子结点和双亲结点的定义可知，在一棵树中，根结点没有双亲结点，叶子结点没有孩子结点，其余结点既有双亲结点也有孩子结点。在树T中，根结点A没有双亲，叶子结点D、H、I、F、G没有孩子。
4.结点的层数和树的深度
树既是一种递归结构，也是一种层次结构，树中的每个结点都处在一定的层数上。结点的层数（level）从树根开始定义，根结点为第1层，它的孩子结点为第2层，以此类推。树中所有结点的最大层数称为树的深度（depth）或高度（height）。在树T中，A结点处于第1层，B、C结点处于第2层，D、E、F、G结点处于第3层，H、I结点所处的第4层为树T中所有结点的最大层数，所以树T的深度为4。
5.有序树和无序树
若树中各结点的子树是按照一定的次序从左向右安排的，则称之为有序树，否则称之为无序树。如图5-5中的两棵树，若被看作无序树，则是相同的；n
若被看作有序树，则不同，因为根结点A的两棵子树的次序不同。又如，对于一棵反映父子关系的家族树，兄弟结点之间是按照排行大小有序的，所以它是一棵有序树。再如，对于一个机关或单位的机构设置树，若各层机构是按照一定的次序排列的，则为一棵有序树，否则为一棵无序树。因为任何无序树都可以当作任一次序的有序树来处理，所以以后若不特别指明，均认为树是有序的。
6.森林
森林是m(mgeqslant0)棵互不相交的树的集合。例如，对于树中每个分支结点来说，其子树的集合就是森林。在树T中，由A结点的子树所构成的森林为T1,T2，由B结点的子树所构成的森林为T11,T12,T13。
section5.1.4树的性质
【性质1】树中的结点数等于所有结点的度数加1。
证明：根据树的定义，在一棵树中，除树根结点外，每个结点有且仅有一个前驱结点，也就是说，每个结点与指向它的一个分支一一对应，所以除树根结点之外的结点数等于所有结点的分支数（即度数），从而可得树中的结点数等于所有结点的度数加1。
【性质2】度为k的树中第i层上至多有k^i-1个结点(igeqslant1)。
下面用数学归纳法证明：
对于第1层显然是成立的，因为树中的第1层上只有一个结点，即整个树的根结点，而由i=1代入k^i-1计算，也同样得到只有一个结点，即k^i-1=k^1-1=k^0=1；假设对于第i-1层(i>1)命题成立，即度为k的树中第i-1层上至多有k^(i-1)-1=k^i-2个结点，则根据树的度的定义，度为k的树中每个结点至多有k个孩子，所以第i层上的结点数至多为第i-1层上结点数的k倍，即至多为k^i-2timesk=k^i-1个，这与命题相同，故命题成立。
【性质3】深度为h的k叉树至多有frack^h-1k-1个结点。
证明：显然当深度为h的k叉树（即度为k的树）上每一层都达到最多结点数时，所有结点的总和才能最大，即整个k叉树具有最多结点数。sum_i=1^hk^i-1=k^0+k^1+k^2+cdots+k^h-1=frack^h-1k-1当一棵k叉树上的结点数等于frack^h-1k-1时，则称该树为满k叉树。例如，对于一棵深度为4的满二叉树，其结点数为2^4-1，即15；对于一棵深度为4的满三叉树，其结点数为frac3^4-12，即40。
【性质4】具有n个结点的k叉树的最小深度为leftlceillog_k(n(k-1)+1)rightrceil。
其中，公式两边的符号表示对内部的数值进行向上取整，即lceilxrceil是取大于等于x的最小整数，如lceil4rceil、lceil4.3rceil和lceil5.6rceil的值分别为4、5和6。同样一对lfloor和rfloor符号表示对内部的数值进行向下取整，lfloorxrfloor是取小于等于x的最大整数，如lfloor4rfloor、lfloor4.2rfloor和lfloor5.8rfloor的值分别为4、4和5。
证明：设具有n个结点的k叉树的深度为h，若在该树中前h-1层都是满的，即每1层的结点数都等于k^i-1个(1leqileqh-1)，第h层（即最后一层）的结点数可能满，也可能不满，则该树具有最小的深度。根据性质3，其深度h的计算公式为：frack^h-1-1k-1<nleqfrack^h-1k-1可变换为k^h-1<n(k-1)+1leqk^h以k为底取对数后得h-1<log_k(n(k-1)+1)leqh即log_k(n(k-1)+1)leqh<log_k(n(k-1)+1)+1因h只能是整数，所以h=leftlceillog_k(n(k-1)+1)rightrceil因此得到具有n个结点的一般k叉树的最小深度为leftlceillog_k(n(k-1)+1)rightrceil。
例如，对于二叉树，求最小深度的计算公式为leftlceillog_2(n+1)rightrceil，若n=20，则最小深度为5；对于三叉树，求最小深度的计算公式为leftlceillog_3(2n+1)rightrceil，若n=20，则最小深度为4。
section5.2二叉树
subsection5.2.1二叉树的定义
二叉树（binarytree）是指树的度为2的有序树。它是一种最简单、而且最重要的树，在计算机领域有着广泛的应用。二叉树的递归定义为：二叉树或者是一棵空树，或者是一棵由一个根结点和两棵互不相交的分别称做根的左子树和右子树所组成的非空树，左子树和右子树又同样都是一棵二叉树。
一棵二叉树BT如图5-6(a)所示，它由根结点A和左子树BT₁、右子树BT₂所组成，BT₁和BT₂分别如图5-6(b)和图5-6(c)所示；BT₁又由根结点B和左子树BT₁₁（只含有根结点D）、右子树BT₁₂（此为空树）所组成；对于BT₂树也可进行类似的分析。
(a)
(b)
(c)
图5-6二叉树
在二叉树中，每个结点的左子树的根结点被称之为左孩子（leftchild），右子树的根结点被称之为右孩子（rightchild）。在二叉树BT中，A结点的左孩子为B结点，右孩子为C
结点：B结点的左孩子为D结点，右孩子为空，或者说没有右孩子；C结点的左孩子为En结点，右孩子为F结点；F结点没有左孩子，右孩子为G结点，D、E、G结点为叶子结点，n其左、右孩子均为空。
section5.2.2二叉树的性质
二叉树具有下列一些重要性质。
【性质1】二叉树上终端结点数等于双分支结点数加1。
证明：设二叉树上终端结点数用n_0表示，单分支结点数用n_1表示，双分支结点数用nn_2表示，则总结点数为n_0+n_1+n_2；另一方面，在一棵二叉树中，所有结点的分支数（即度数）应等于单分支结点数加上双分支结点数的2倍，即等于n_1+2n_2。由树的性质1可得：n_0+n_1+n_2=n_1+2n_2+1quadtext即quadn_0=n_2+1例如，在二叉树BT中，度为2的结点数为2个，度为0的结点数为3个，它比度为n2的结点数正好多1个。
【性质2】二叉树上第i层上至多有2^i-1个结点（igeq1）。
证明：由树的性质2可知，度为k的树中第i层上至多有k^i-1个结点。对于二叉树，树n的度为2，将k=2代入k^i-1即可得到此性质。
【性质3】深度为h的二叉树至多有2^h-1个结点。
证明：由树的性质3可知，深度为h的k叉树至多有(k^h-1)/(k-1)个结点。对于二叉树，n树的度为2，将k=2代入(k^h-1)/(k-1)即可得到此性质。
在一棵二叉树中，当第i层的结点数为2^i-1个时，则称此层的结点数是满的，当树中的n每一层都满时，则称此树为满二叉树。由性质3可知，深度为h的满二叉树中的结点数n为2^h-1个。一棵深度为4的满二叉树，如图5-7（a）所示，其结点数为15。图中每个结点的值是用该结点的编号来表示的，编号从树根为1开始，按照层数从小到大、同一层从n左到右的次序进行。
在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或n者是在右边缺少连续若干个结点，则称此树为完全二叉树。由此可知，满二叉树是完全二n叉树的特例。一棵完全二叉树如图5-7（b）所示。它与等高度的满二叉树相比，在最后一n层的右边缺少了5个结点。该树中每个结点上面的数字为对该结点的编号，编号的方法同n满二叉树。
(a)满二叉树
(b)完全二叉树
图5-7满二叉树和完全二叉树
【性质4】对完全二叉树中编号为i的结点（1leqileqn,ngeq1,n为结点数）有如下性质。
(1)若编号为i的结点有左孩子，则左孩子结点的编号为2i；若编号为i的结点有右孩子，则右孩子结点的编号为2i+1。
(2)除树根结点外，若一个结点的编号为i，则它的双亲结点的编号为i/2，也就是说，当i为偶数时，其双亲结点的编号为i/2，它是双亲结点的左孩子；当i为奇数时，其双亲结点的编号为(i-1)/2，它是双亲结点的右孩子。
(3)若ileqlfloorn/2rfloor，即2ileqn，则编号为i的结点为分支结点，否则为叶子结点。
(4)若n为奇数，则每个分支结点都既有左孩子，又有右孩子；若n为偶数，则编号最大的分支结点（编号为n/2）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。例如，在图5-7(b)所示的完全二叉树中，因树中结点数n=10，所以编号小于等于5的结点为分支结点，大于5的结点为叶子结点。因n=10为偶数，所以编号为5的结点E只有左孩子K，没有右孩子，其余分支结点（即编号1sim4的结点）左、右孩子都有。对于编号为2的结点B来说，它的左孩子是编号为4的结点D，右孩子是编号为5的结点E，它的双亲是编号为1的结点。对于树中的其他结点也可进行类似的分析。
在有的教科书中，把完全二叉树中结点的编号从0开始定义，这样对于一个具有n个结点的完全二叉树来说，分支结点的编号为0simlfloorn/2rfloor-1，叶子结点的编号为lfloorn/2rfloorsimn-1；编号为i的左、右孩子结点的编号分别为2i+1和2i+2，双亲结点的编号为lfloor(i-1)/2rfloor。根据孩子结点的编号i可推出双亲结点的编号j，因为若i编号为左孩子，则2j+1=i，j就等于(i-1)/2，其值是一个整数，也可表示为lfloor(i-1)/2rfloor；若i编号为右孩子，则2j+2=i，j就等于i/2-1，因j只能是整数，所以i必然是偶数，则i/2-1的值与lfloor(i-1)/2rfloor的值相等。故对于除根结点之外的任何编号为i的结点，其双亲结点的编号必然为lfloor(i-1)/2rfloor。
那么，又是如何得到一个编号为i的左、右孩子结点的编号为2i+1和2i+2呢？这可用数学归纳法证明。当i等于0时，结论是成立的，根结点左、右孩子的编号分别为1和2，这与公式所求相同；对于编号为i的结点，其左、右孩子结点的编号为2i+1和2i+2是成立的，则对于编号为i+1的结点，其左、右孩子结点的编号应为2(i+1)+1和2(i+1)+2，也可写成2(i+1)+1和2(i+1)+2，所以命题成立。
【性质5】具有n个(n>0)结点的完全二叉树的深度为lceillog_2(n+1)rceil或lfloorlog_2nrfloor+1。
证明：设所求完全二叉树的深度为h，由完全二叉树的定义可知，它的前h-1层都是满的，最后一层可以满，也可以不满，由此得到如下不等式。2^h-1-1<nleq2^h-1可变换为2^h-1<n+1leq2^h取对数后得h-1<log_2(n+1)leqh即log_2(n+1)leqh<log_2(n+1)+1因h只能取整数，所以h=lceillog_2(n+1)rceil完全二叉树的深度h和结点数n的关系，还可表示为2^h-1leqn<2^h取对数后得
h-1leqslantoperatornamelbn<h即operatornamelbn<hleqslantoperatornamelbn+1因h只能取整数,所以h=lflooroperatornamelbnrfloor+1在一棵二叉树中,若除最后一层外,其余层都是满的,而最后一层上的结点可以任意分布,则称此树为理想平衡二叉树,简称理想平衡树或理想二叉树。显然,理想平衡树包含满二叉树和完全二叉树。完全二叉树中深度h和结点数n之间的关系,在理想平衡树中同样成立,因为性质5的证明结果实际上是根据理想平衡树的定义推导出来的。如图5-8(a)所示是一棵理想平衡树,但它不是完全二叉树;如图5-8(b)所示不是一棵理想平衡树,因它的最后两层都未满。
![image](attachment://ideal_balanced_tree.png)
(a)理想平衡树
![image](attachment://ordinary_binary_tree.png)
(b)普通二叉树
图5-8理想平衡树和普通二叉树
section5.2.3二叉树的抽象数据类型
二叉树的抽象数据类型的的数据部分为一棵二叉树,操作部分包括初始化二叉树、建立二叉树、遍历二叉树、查找二叉树、输出二叉树和清除二叉树等一些常用操作。下面给出二叉树的抽象数据类型的具体定义。
DATABinaryTreeis
Data:
采用任一种方式存储的二叉树,假定其存储类型用BTreeType标识符表示,
该类型的一个对象(即二叉树)用BT标识符表示
Operations
voidInitBTree(BTreeType&BT);
//初始化二叉树,即把它置为一棵空树
voidCreateBTree(BTreeType&BT,chara);
//根据广义表表示的二叉树建立对应的存储结构
boolEmptyBTree(BTreeType&BT);
//判断一棵二叉树是否为空,若是则返回true,否则返回false
voidTraverseBTree(BTreeType&BT);
//按照一定次序遍历一棵二叉树,使得每个结点的值均被访问一次
boolFindBTree(BTreeType&BT,ElemType&item);
//从二叉树中查找值为item的结点,若存在该结点则由item带回它的完整值
//并返回true,否则返回false表示查找失败
```plaintext
intBTreeDepth(BTreeType&BT);
//求出一棵二叉树的深度
voidPrintBTree(BTreeType&BT);
//按照树的一种表示方法输出一棵二叉树
voidClearBTree(BTreeType&BT);
//清除二叉树中的所有结点,使之变为一棵空树
endBinaryTree
section5.2.4二叉树的存储结构
同线性表一样,二叉树也有顺序和链接两种存储结构。
section1.顺序存储结构
顺序存储一棵二叉树时,首先对该树中每个结点进行编号,然后以各结点的编号为下标,把各结点的值对应存储到一个一维数组中。每个结点的编号与等深度的满二叉树中对应结点的编号相同,即树根结点的编号为1,接着按照从上到下和从左到右的次序,若一个结点的编号为i,则左、右孩子的编号分别为2i和2i+1。在如图5-9所示的二叉树中,各结点上方的数字就是该结点的编号。
(a)完全二叉树
(b)一般二叉树
图5-9带结点编号的二叉树
假定分别采用一维数组data1和data2来顺序存储图5-9(a)和图5-9(b)中的二叉树,则两数组中各元素的值如图5-10所示。
data1
|0|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|---|
||25|15|36|10|20|32|48|4|11|18|
data2
|0|1|2|3|4|5|6|7|8|9|10|11|12|13|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
||1|D|P|C|F|M|||E|H||N|
图5-10二叉树的顺序存储结构
在二叉树的顺序存储结构中,各结点之间的关系是通过下标计算出来的,因此访问每一个结点的双亲和左、右孩子（若有的话）都非常方便。如编号为i的结点（即下标为i的元素），其双亲结点的下标为lfloori/2rfloor；若存在左孩子，则左孩子结点的下标为2i；若存在右孩子，则右孩子结点的下标为2i+1。
```
二叉树的顺序存储结构对于存储完全二叉树是合适的，它能够充分利用存储空间，但对于一般二叉树，特别是对于那些单支结点较多的二叉树来说是很不合适的，因为可能只有少数存储位置被利用，而多数或绝大多数的存储位置空闲着。因此，对于一般二叉树通常采用下面介绍的链接存储结构。
section2.链接存储结构
在二叉树的链接存储中，通常采用的方法是，在每个结点中设置3个域：值域、左指针域和右指针域。其结点结构为：beginarray|c|c|c|hlinetextleft&textdata&textrighthlineendarray其中，data表示值域，用来存储对应的数据元素，left和right分别表示左指针域和右指针域，用来分别存储左孩子和右孩子结点的存储位置（即指针）。
链接存储的另一种方法是：在上面的结点结构中再增加一个parent指针域，用来指向其双亲结点。这种存储结构既便于查找孩子结点，也便于查找双亲结点，当然也带来存储空间的相应增加。
对于如图5-11(a)所示的二叉树，不带双亲指针的链接存储结构（称作二叉链表）如图5-11(b)所示，其中f1为指向树根结点的指针，简称树根指针或根指针；带双亲指针的链接存储结构（称作带双亲指针的二叉链表）如图5-11(c)所示，其中f2为树根指针。
(a)二叉树
(b)不带双亲指针的链接存储结构
(c)带双亲指针的链接存储结构
图5-11二叉树的链接存储结构
同单链表相同，二叉链表既可由独立分配的结点链接而成，也可由数组中的元素结点链接而成。若采用独立结点，则结点类型可定义为：
structBTreeNode
ElemTypedata;
BTreeNodeleft;
BTreeNoderight;
;
若采用元素结点，则结点类型可定义为：
structABTreeNode
ElemTypedata;
intleft,right;
;
在元素结点中，left和right域分别存储左、右孩子结点所在单元的下标，所以被定义为整型。为建立二叉链表而提供元素结点的数组类型可定义为：
typedefABTreeNodeABTList[BTreeMaxSize];
其中，BTreeMaxSize为全局整型常量，其值由用户事先定义，由它决定建立二叉链表的最大结点数。
设用ABTList类型的一维数组存储图5-11（b）所示的二叉链表，由于在链接存储中，结点之间的逻辑关系是通过指针实现的，所以各结点在数组中占用的下标位置可以按照任何一种次序安排，假定按照层数从小到大、同一层从左到右的次序为各结点分配存储位置，则得到该二叉链表的存储映像，如图5-12所示。
data|0|1|2|3|4|5|6|7|8|9|10|BTreeMaxSize-1
:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
A|B|D|C|E|H|F|G|I|||
left|1|2|4|5|0|7|0|0|0|||
right|10|3|0|6|0|8|9|0|0|11|0|
图5-12利用数组建立二叉树的链接存储结构
注意：元素结点从下标为1的位置起使用，下标为0的位置的左指针域通常用来存储树根指针，右指针域通常用来存储空链表的表头指针，空闲链表由空闲结点的right域链接而成。
在数组中建立二叉树的好处是：建立好后可以把整个数组写入到一个文件中保存起来，当需要时再从文件整体读入到数组中进行处理。
section5.3二叉树遍历
设二叉树由具有BTreeNode类型的、通过动态分配产生的独立结点链接而成，并设BT为指向树根结点的指针，从树根指针出发可以访问到树中的每一个结点，所以可以用树根指针来指定一棵二叉树。
二叉树的遍历是二叉树中最重要的运算。二叉树的遍历是指按照一定次序访问树中所有结点，并且每个结点的值仅被访问一次的过程。根据二叉树的递归定义，一棵非空二叉
树由根结点、左子树和右子树所组成，因此，遍历一棵非空二叉树的问题可分解为3个子问题：访问根结点、遍历左子树和遍历右子树。若分别用D、L和R表示上述3个子问题，则有DLR、LDR、LRD、DRL、RDL、RLD等6种次序的遍历方案。其中前3种方案都是先遍历左子树，后遍历右子树，而后3种则相反，都是先遍历右子树，后遍历左子树，由于二者对称，故我们只讨论前3种次序的遍历方案。熟悉了前3种，后3种也就迎刃而解了。
在遍历方案DLR中，因为访问根结点的操作在遍历左、右子树之前，故称之为前序（preorder）遍历或先根遍历。类似地，在LDR方案中，访问根结点的操作在遍历左子树之后和遍历右子树之前，故称之为中序（inorder）遍历或中根遍历；在LRD方案中，访问根结点的操作在遍历左、右子树之后，故称之为后序（postorder）遍历或后根遍历。显然，遍历左、右子树的问题仍然是遍历二叉树的问题，当二叉树为空时递归结束，所以很容易给出这3种遍历的递归算法。
1.前序遍历算法
voidPreOrder(BTreeNodeBT)
if(BT!=NULL)
cout<<BT->data<<'';//访问根结点
PreOrder(BT->left);//前序遍历左子树
PreOrder(BT->right);//前序遍历右子树
2.中序遍历算法
voidInOrder(BTreeNodeBT)
if(BT!=NULL)
InOrder(BT->left);//中序遍历左子树
cout<<BT->data<<'';//访问根结点
InOrder(BT->right);//中序遍历右子树
3.后序遍历算法
voidPostOrder(BTreeNodeBT)
if(BT!=NULL)
PostOrder(BT->left);//后序遍历左子树
PostOrder(BT->right);//后序遍历右子树
cout<<BT->data<<'';//访问根结点
在3种遍历算法中，访问根结点的操作可视具体应用情况而定，这里暂以打印根结点的值代之。当然若结点的值为用户定义的记录类型，则还必须依次输出结点值对象中的每个域的值。
以中序遍历算法为例，结合如图5-13所示的二叉树，分析其执行过程。
(a)二叉树
(b)链接存储结构
图5-13二叉树遍历
当从其他函数调用（此次称为第0次递归调用）中序遍历算法时，需要以指向树根A结点的指针mathrmAp作为实参，把它传递给算法中的值参mathrmBT，系统栈中应包括mathrmBT域和返回地址r域，设进行第0次递归调用后的返回地址为r0，中序遍历左子树后的返回地址（即执行cout语句的地址）为r1，中序遍历右子树后的返回地址（即算法结束的地址）为r2，并设指向每个结点的指针用该结点的值后缀小写字母p表示，如指向B结点的指针就用mathrmBp表示，则每次进行递归调用时的系统栈的变化状态，如图5-14所示。
|BT|r|
|---|---|
|||
|||
|||
|Ap|r0|
(a)A进栈
|BT|r|
|---|---|
|||
|||
|||
|Bp|r1|
|Ap|r0|
(b)B进栈
|BT|r|
|---|---|
|||
|||
|Cp|r1|
|Bp|r1|
|Ap|r0|
(c)C进栈
|BT|r|
|---|---|
||r1|
|Cp|r1|
|Bp|r1|
|Ap|r0|
(d)空指针进栈
|BT|r|
|---|---|
||r2|
|Cp|r1|
|Bp|r1|
|Ap|r0|
(e)输出C
|BT|r|
|---|---|
|||
|Dp|r2|
|Bp|r1|
|Ap|r0|
(f)输出B
|BT|r|
|---|---|
||r1|
|Dp|r2|
|Bp|r1|
|Ap|r0|
(g)空指针进栈
|BT|r|
|---|---|
||r2|
|Dp|r2|
|Bp|r1|
|Ap|r0|
(h)输入D
|BT|r|
|---|---|
|||
|||
|Ep|r2|
|Ap|r0|
(i)输出A
|BT|r|
|---|---|
||r1|
|Fp|r2|
|Ep|r2|
|Ap|r0|
(j)空指针进栈
|BT|r|
|---|---|
||r2|
|Fp|r2|
|Ep|r2|
|Ap|r0|
(k)输入E
|BT|r|
|---|---|
|||
|Gp|r1|
|Fp|r2|
|Ep|r2|
|Ap|r0|
(l)G进栈
|BT|r|
|---|---|
||r1|
|Gp|r1|
|Fp|r2|
|Ep|r2|
|Ap|r0|
(m)空指针进栈
|BT|r|
|---|---|
||r2|
|Gp|r1|
|Fp|r2|
|Ep|r2|
|Ap|r0|
(n)输出G
|BT|r|
|---|---|
|||
|||
|||
|Ap|r0|
(o)输出F
(p)返回到其他函数
图5-14对图5-13所示的二叉树执行中序遍历算法时系统栈的变化状态
由上述分析中序遍历算法的执行过程可知，打印出的结点序列为:
C,B,D,A,E,G,F
类似地，若按照前序遍历算法和后序遍历算法遍历图5-13所示的二叉树，则打印出的结点序列分别为:
A,B,C,D,E,F,G和C,D,B,G,F,E,A
在二叉树的三种递归遍历算法中，对于每个算法都访问到了每个结点的每一个域，并且每个结点的每一个域仅被访问一次。所以其时间复杂度均为O(n)，n表示二叉树中结点的个数。另外在执行每个递归遍历算法时，系统都要使用一个栈，栈的最大深度等于二叉树的深度加1，而二叉树的深度视其具体形态决定，若二叉树为理想平衡树或接近理想平衡树，则二叉树的深度大致为lceillog_2nrceil，所以其空间复杂度为O(log_2n)；若二叉树退化为一棵单支树（即最差的情况），则空间复杂度为O(n)，n同样为二叉树中的结点数。
上面所述的二叉树的遍历是按二叉树的递归结构进行的，另外，还可以按照二叉树的层次结构进行遍历，即按照从上到下、同一层从左到右的次序访问各结点。如图5-13所示的二叉树，按层遍历各结点的次序为:
A,B,E,C,D,F,G
按层遍历算法需要使用一个队列，开始时把整个树的根结点入队，然后每从队列中删除一个结点并输出该结点的值时，都把它的非空的左、右孩子结点入队，这样当队列空时算法结束。
4.按层遍历算法
此算法为一个非递归算法，具体描述如下。
voidLevelOrder(BTreeNodeBT)
//按层遍历由BT指针所指向的二叉树
constintMaxSize=30;//定义用于存储队列的数组长度
BTreeNodeq[MaxSize];//定义队列所使用的数组空间
intfront=0,rear=0;//定义队首指针和队尾指针，初始为空队
BTreeNodep;
if(BT!=NULL)
rear=(rear+1)%MaxSize;
q[rear]=BT;//将树根指针进队
while(front!=rear)
front=(front+1)%MaxSize;//使队首指针指向队首元素
p=q[front];
cout<<p->data<<'';//输出队首元素所指结点的值
if(p->left!=NULL)
rear=(rear+1)%MaxSize;
q[rear]=p->left;//若存在左孩子，则左孩子结点指针进队
if(p->right!=NULL)
//若存在右孩子,则右孩子结点指针进队
rear=(rear+1)%MaxSize;
q[rear]=p->right;
//whileend
在这个算法中，队列的最大长度不会超过二叉树中一层上的最多结点数，在定义队列数组时，要使数组的长度大于队列的最大长度，这样在结点进队时肯定不会发生溢出，因此也就不需要判断是否队满了。此算法的时间复杂度为O(n)，n表示二叉树中结点的个数。
section5.4二叉树其他运算
section1.初始化二叉树
voidInitBTree(BTreeNode&BT)//初始化二叉树,即把树根指针置空
BT=NULL;
section2.建立二叉树
二叉树的输入格式不同，建立二叉树的算法也不同，采用广义表表示的输入法，二叉树广义表表示的规定如下。
(1)每棵树的根结点作为由子树构成的表的名字而放在表的前面。
(2)每个结点的左子树和右子树用逗号分开，若只有右子树而没有左子树，则逗号不能省略。
例如，对于图5-11(a)所示的二叉树，其广义表表示为：A(B(C),D(E(F,G),H(I)))根据二叉树的广义表表示建立二叉树链接存储结构的基本思路是：从保存二叉树广义表的字符串a中输入每个字符，若遇到的是空格则不进行任何操作；若遇到的是字母（设以字母作为结点的值），则表明是结点的值，应为它建立一个新结点，并把该结点（若它不是整个树的根结点的话）作为左孩子（若k=1）或右孩子（若k=2）链接到其双亲结点上；若遇到的是左括号，则表明子表开始，应首先把指向它前面字母所在结点的指针（即根结点指针）进栈，以便括号内的子结点向双亲结点链接之用，然后把k置为1，因为左括号后面紧跟着的字母（若有的话）必为根结点的左孩子；若遇到的是右括号，则表明子表结束，应退栈；若遇到的是逗号，则表明以左孩子为根的子树处理完毕，应接着处理以右孩子为根的子树，所以要把k置为2。如此处理每一个字符，直到处理完所有字符为止。
建立二叉树的算法描述如下。
voidCreateBTree(BTreeNode&BT,chara)
//根据字符串a所给出的用广义表表示的二叉树建立对应的存储结构
constintMaxSize=10;//栈数组长度要大于等于二叉树的深度减1BTreeNodes[MaxSize];//s数组作为存储根结点指针的栈使用
inttop=-1;//top作为栈顶指针,初值为-1,表示空栈
BT=NULL;//把树根指针置为空,即从空树开始
BTreeNodep;//定义p为指向二叉树结点的指针
intk;//用k作为处理结点的左子树和右子树的标记
//k=1处理左子树,k=2处理右子树
inti=0;//用i扫描数组a中存储的二叉树广义表字符串
while(a[i])//每循环一次处理一个字符,直到扫描到字符串结束符'0'为止
switch(a[i])
case''://对空格不作任何处理
break;
case'(':
if(top==MaxSize-1)
cout<<"栈空间太小,请增加MaxSize的值!"<<endl;
exit(1);
top++;s[top]=p;k=1;
break;
case')':
if(top==-1)
cout<<"二叉树广义表字符串错!"<<endl;exit(1);
top--;break;
case',':
k=2;break;
default:
p=newBTreeNode;
p->data=a[i];p->left=p->right=NULL;
if(BT==NULL)BT=p;//作为根结点插入
else
if(k==1)s[top]->left=p;//作为左孩子插入
elses[top]->right=p;//作为右孩子插入
//switchend
i++;//为扫描下一个字符修改i值
在这个算法中，s栈的最大深度等于二叉树的深度减1，而二叉树的深度则等于广义表表示中圆括号嵌套的最大层数加1。所以当定义s栈的数组空间时，其长度（即下标上限
值）要大于等于二叉树的深度减1。该算法的时间复杂度为O(n),n表示二叉树广义表中字符的个数，由于平均每2sim3个字符具有一个元素字符，所以n也可以看作是二叉树中元素结点的个数。
3.检查二叉树是否为空
boolEmptyBTree(BTreeNodeBT)
//判断一棵二叉树是否为空,若为空则返回true,否则返回false
returnBT==NULL;
4.求二叉树深度
若一棵二叉树为空，则它的深度为0，否则它的深度等于左子树和右子树中的最大深度加1。设dep1为左子树的深度，dep2为右子树的深度，则二叉树的深度为:max(textdep1,textdep2)+1其中，max函数表示取参数中的大者。
求二叉树深度的递归算法如下。
intDepthBTree(BTreeNodeBT)
if(BT==NULL)
return0;//对于空树,返回0并结束递归
else
intdep1=DepthBTree(BT->left);//计算左子树的深度
intdep2=DepthBTree(BT->right);//计算右子树的深度
if(dep1>dep2)
returndep1+1;//返回树的深度
else
returndep2+1;
利用此算法求图5-13所示二叉树的深度，则得到的返回结果为4。
5.从二叉树中查找值为x的结点，若存在由x带回完整值并返回真，否则返回假
该算法类似于前序遍历的算法。若树为空则返回false结束递归。若树根结点的值就等于x的值，则把结点值赋给x后返回true结束递归，否则先向左子树查找；若找到则返回true结束递归，否则再向右子树查找；若找到则返回true结束递归；若左、右子树均未找到则返回false结束递归。具体算法描述为:
boolFindBTree(BTreeNodeBT,ElemType&x)
if(BT==NULL)returnfalse;//树为空返回假
else
```c
if(BT->data==x)/树根结点的值等于x则由x带回结点值并返回真/
x=BT->data;returntrue;
else
/向左子树查找若成功则继续返回真/
if(FindBTree(BT->left,x))returntrue;
/向右子树查找若成功则继续返回真/
if(FindBTree(BT->right,x))returntrue;
/左、右子树查找均失败则返回假/
returnfalse;
6.输出二叉树
输出二叉树就是根据二叉树的链接存储结构以某种树的表示形式打印出来，通常采用广义表的形式打印。用广义表表示一棵二叉树的规则是：根结点被放在由左、右子树组成的表的前面，而表是用一对圆括号括起来的。对于图5-13所示的二叉树，其对应的广义表表示为：A(B(C,D),E(F(G)))因此，用广义表的形式输出一棵二叉树时，应首先输出根结点，然后再依次输出它的左子树和右子树，不过在输出左子树之前要打印出左括号，在输出右子树之后要打印出右括号；另外，依次输出的左、右子树要至少有一个不为空，若均为空就没有输出的必要了。
由以上分析可知，输出二叉树的算法可在前序遍历算法的基础上作适当修改后得到，具体给出如下。
voidPrintBTree(BTreeNodeBT)
//输出二叉树的广义表表示
if(BT!=NULL)
cout<<'<'<<BT->data;//输出根结点的值
if(BT->left!=NULL||BT->right!=NULL)
cout<<'(';//输出左括号
PrintBTree(BT->left);//输出左子树
if(BT->right!=NULL)
cout<<',';//若右子树不为空则首先输出逗号分隔符
PrintBTree(BT->right);//输出右子树
cout<<')';//输出右括号
7.清除二叉树，使之变为一棵空树
要清除一棵二叉树必须先清除左子树，再清除右子树，最后删除（即回收）根结点并
```
把指向根结点的指针置空。由此可知它是一个递归过程，类似于后序递归遍历。
voidClearBTree(BTreeNode&BT)
if(BT!=NULL)
ClearBTree(BT->left);//删除左子树
ClearBTree(BT->right);//删除右子树
deleteBT;//释放根结点
BT=NULL;//置根指针为空
采用下面程序上机调试对二叉树运算的算法。
include<iostream.h>
include<stdlib.h>
typedefcharElemType;//定义二叉树结点值的类型为字符型
structBTreeNode
ElemTypedata;
BTreeNodeleft;
BTreeNoderight;
;
include"二叉树运算.cpp"//保存对二叉树各种运算的算法
voidmain()
BTreeNodebt;//定义指向二叉树结点的指针,并用它作为树根指针
InitBTree(bt);//初始化二叉树,即置树根指针bt为空
charb[50];//定义一个用于存放二叉树广义表的字符数组
cout<<"输入二叉树用广义表表示的字符串:"<<endl;
cin.getline(b,sizeof(b));//输入的字符串被放入b数组中
CreateBTree(bt,b);//建立以bt作为树根指针的二叉树的链接存储结构
PrintBTree(bt);cout<<endl;//以广义表形式输出二叉树
cout<<"前序:";PreOrder(bt);cout<<endl;
cout<<"中序:";InOrder(bt);cout<<endl;
```cpp
//后序遍历以bt为树根指针的二叉树
cout<<"后序:";PostOrder(bt);cout<<endl;
//按层遍历以bt为树根指针的二叉树
cout<<"按层:";LevelOrder(bt);cout<<endl;
//查找以bt为树根指针的二叉树中的一个结点
ElemTypex;
cout<<"输入一个待查字符:";
cin>>x;
if(FindBTree(bt,x))cout<<"查找字符"<x<>"成功!"<<endl;
elsecout<<"查找字符"<x<>"失败!"<<endl;
//求出以bt为树根指针的二叉树的深度
cout<<"深度:";cout<<DepthBTree(bt)<<endl;
//清除以bt为树根指针的二叉树
ClearBTree(bt);
屏幕显示结果如下。
输入二叉树用广义表表示的字符串:
a(b(c),d(e(f,g),h(,i)))
前序:abcdefghi
中序:cbafegdhi
后序:cbfgeihda
按层:abdcehfgi
输入一个待查字符:f
查找字符f成功!
深度:4
section5.5树的存储结构和运算
subsection5.5.1树的抽象数据类型
这里所说的树是指度大于等于3的树，通常称为多元树或多叉树。
树的抽象数据类型的数据部分为一棵普通的k叉树GT，它可以采用顺序、链接等任一种存储结构，设存储类型用GTREE标识符表示，操作部分包括初始化树、建立树、遍历树、查找树、输出树、清除树、判空树等一些常用运算。下面给出普通树的抽象数据类型的具体定义。
DATGeneralTreeis
Data:
一棵普通树GT,存储类型用标识符GTREE表示
```
Operations
voidInitGTree(GTREE&GT);
//初始化树,即把它置为一棵空树
voidCreateGTree(GTREE&GT,chara);
//根据广义表表示的树建立对应的存储结构
voidTraverseGTree(GTREEGT);
//按照一定次序遍历树,使得每个结点的值均被访问一次
boolFindGTree(GTREEGT,ElemType&item);
//从树中查找值为item的结点,若存在该结点则由item带回
//它的完整值并返回true,否则返回false表示查找失败
voidPrintGTree(GTREEGT);
//按照树的一种表示方法输出一棵树
boolEmptyGTree(GTREEGT);
//判断树是否为空,若是则返回true,否则返回false
voidClearGTree(GTREE&GT);
//清除树中的所有结点,使之变为一棵空树
endGeneralTree
section5.5.2树的存储结构
1.树的顺序存储结构
树的顺序存储结构需要使用一个一维数组,存储方法是:首先对树中每个结点进行编号,然后以各结点的编号为下标,把结点值对应存储到相应元素中。
若待存储的树的度为k,即它是一棵k叉树,则结点编号的规则为:树根结点的编号为1,然后按照从上到下、每一层再从左到右的次序依次对每个结点编号。若一个结点的编号为i,则k个孩子结点的编号依次为ktimesi-(k-2),ktimesi-(k-3),cdots,ktimesi+1。如对于3叉树,若双亲结点的编号为i,则3个孩子结点的编号依次为3timesi-1,3timesi,3timesi+1。又如对于4叉树,若双亲结点的编号为j,则4个孩子结点的编号依次为4timesj-2,4timesj-1,4timesj,4timesj+1。
若k叉树中一个结点的编号为j,则它的父亲结点的编号为(j-2)/k+1,即等于j-2除以k得到的整数商再加上1。如当k=3时,父结点的编号为(j-2)/3+1,若j=10,则父结点的编号为3。
树的顺序存储适合满树和完全树的情况,否则将非常浪费存储空间。故在实际应用中很少使用,本节也不做深入讨论。
2.树的链接存储结构
树的链接存储结构通常采用如下3种方式。
(1)标准方式。
在这种方式中,树中的每个结点除了包含有存储数据元素的值域外,还包含有k个指针域,用来分别指向k个孩子结点,或者说,用来分别链接k棵子树,其中k为树的度。结点的类型可定义为:
structGTreeNode
ElemTypedata;//结点值域
GTreeNodet[k];//结点指针域t[0]~t[k-1],k为事先定义的常量
;
(2)广义标准方式。
广义标准方式是在标准方式的每个结点中增加一个指向其双亲结点的指针域。结点的类型可定义为:
structPGTreeNode
ElemTypedata;//结点值域
PGTreeNodet[k];//结点指针域t[0]~t[k-1],k为事先定义的常量
PGTreeNodeparent//双亲指针
;
如图5-15(a)所示是一棵三叉树,其存储结构的标准形式如图5-15(b)所示;广义标准形式如图5-15(c)所示。
n
(a)三叉树
n
(b)标准形式
n
(c)广义标准形式
图5-15树的标准形式和广义标准形式的存储结构
(3)二叉树方式。
二叉树方式是指首先将树转换为对应的二叉树形式,然后再采用二叉链表存储这棵二叉树。
将树转换为二叉树的规则是：将树中每个结点的第1个孩子结点转换为二叉树中对应结点的左孩子，将第2个孩子结点转换为左孩子的右孩子，将第3个孩子结点转换为这个右孩子的右孩子。也就是说，转换后得到的二叉树中的每个结点及右孩子，在转换前的树中互为兄弟。对于图5-15(a)所示的树，对应的二叉树形式，如图5-16(a)所示；它的二叉链表，如图5-16(b)所示。
![image](attachment://tree_conversion.png)
(a)二叉树形式
(b)二叉链表
图5-16树的二叉树形式的存储结构
在树的以上3种链接存储表示方式中，标准方式和广义表示方式能够表示任何树，但二叉树方式一般只适合表示无序树，不能表示任一结点中缺少前面孩子，又存在后面孩子的那样有序树。
当然，树还有其他一些表示方法，但都较少使用，故不作介绍。
subsection5.5.3树的运算
树的运算包括建立树的存储结构、进行树的遍历、从树中查找结点值、求树的深度和输出树等。假定要讨论的树是k叉树，k被事先定义为整型符号常量，树的存储结构采用标准链接方式。
section1.建立树的存储结构
建立树的存储结构就是在内存中生成一棵树的标准方式的存储映象，即k叉链表。同二叉链表的生成过程一样，首先要确定输入树的方法，然后再写出相应的算法。仍采用广义表的形式输入，对于图5-15所示的三叉树，得到的广义表表示为：textA(B(D,E(H,J),F),C(G))其中，假定每个结点的非空子树都是靠前面、按序排列的子树，把所有空子树都留在后面。在实际情况中可能会出现缺少前面子树而存在后面子树的情况，此时用广义表示时空子树后面的逗号不能省略。
在树的生成算法中，需要设置两个栈，一个用来存储指向根结点的指针，以便孩子结点向双亲结点链接之用；另一个用来存储待链接的孩子结点的序号，以便能正确地链接到双亲结点的指针域。若这两个栈分别用s和d表示，s和d栈的深度不会大于整个树的深度。
树的生成算法与二叉树的生成算法类似，设结点值仍为字符类型char，整个k叉树用一个广义表形式的字符串a来表示，则具体算法描述如下。
voidCreateGTree(GTreeNode&GT,chara)
//根据广义表字符串a所给出的k叉树建立对应的存储结构
constintMS=10;//定义符号常量指定栈空间的大小
GTreeNodes[MS];//s数组作为存储树中结点指针的栈使用
intd[MS];//d数组作为存储孩子结点链接到双亲结点//指针域的序号的栈使用
inttop=-1;//top作为两个栈的栈顶指针
GT=NULL;//给树根指针置空
GTreeNodep;//定义p为指向树结点的指针
inti=0;//用i指示扫描字符串数组a中的当前字符位置
while(a[i])
//每循环一次处理一个字符，直到字符串结束符为止
switch(a[i])
case'':break;//对空格不做任何处理
case'(':
top++;s[top]=p;d[top]=0;
//p指针进s栈，0进d栈，表明待扫描的孩子结点//将链接到s栈顶元素所指结点的第一个指针域
break;
case')':
top--;
//s和d退栈
break;
case',':
d[top]++;
//待读入的孩子结点将链接到s栈顶元素//所指结点的下一个指针域
break;
default://此处处理的必然是字符元素
//根据a[i]字符生成新结点
p=newGTreeNode;
p->data=a[i];
for(inti=0;i<k;i++)p->t[i]=NULL;
//使p结点成为树根结点或链接到双亲结点对应的指针域
if(GT==NULL)GT=p;
elses[top]->t[d[top]]=p;
i++;
//准备处理下一个字符
2.树的遍历
树的遍历包括先根遍历（或称深度优先遍历）、后根遍历和按层遍历（或称广度优先遍历）3种。
先根遍历定义为：先访问根结点，然后从左到右依次先根遍历每棵子树，此遍历过程是一个递归过程。先根遍历图5-15所示的树，得到的结点序列为：
ABDEHIFCG
后根遍历：从左到右依次后根遍历根结点的每棵子树，然后再访问根结点，此遍历过程也是一个递归过程。后根遍历图5-15所示的树，得到的结点序列为：
DHIEFBGCA
按层遍历：先访问第1层结点（即树根结点），再从左到右访问第2层结点，依次按层访问，直到全树中的所有结点都被访问为止，或者说直到访问完最深一层结点为止。按层遍历图5-15所示的树，得到的结点序列为：
ABCDEFGHI
同二叉树的先序遍历算法类似，树的先根遍历算法如下。
voidPreRoot(GTreeNodeGT)//先根遍历一棵k叉树
if(GT!=NULL)
cout<<GT->data<<'';//访问根结点
for(inti=0;i<k;i++)
PreRoot(GT->t[i]);//递归遍历每一个子树
树的后根遍历算法如下。
voidPostRoot(GTreeNodeGT)//后根遍历一棵k叉树
if(GT!=NULL)
for(inti=0;i<k;i++)
PostRoot(GT->t[i]);//递归遍历每一个子树
cout<<GT->data<<'';//访问根结点
在树的按层遍历算法中，需要设置一个队列，假定用q表示，元素类型应定义为结点指针类型GTreeNode，算法开始时将q初始化为空，接着若树根指针不为空则入队；然后每从队列中删除一个元素（即为指向结点的指针）时，都输出它的值并且依次使非空的孩子指针入队，这样反复进行下去，直到队列为空时止。此算法是一个非递归算法，若使用的队列采用现成的顺序队列的定义和运算，算法的具体描述如下。
voidLayerOrder(GTreeNodeGT)
//按层遍历由GT指针所指向的k叉树
Queueq;//定义一个队列q,其元素类型应为GTreeNode
InitQueue(q);//初始化队列q
GTreeNodep;
if(GT!=NULL)EnQueue(q,GT);//非空的树根指针进队
while(!EmptyQueue(q))//当队列非空时执行循环
p=OutQueue(q);//从队列中删除一个结点指针
cout<<p->data<<'';
for(inti=0;i<k;i++)
if(p->t[i]!=NULL)
EnQueue(q,p->t[i]);
3.从树中查找结点值
此算法要求:当从树中查找值为item的结点时,若存在该结点则由item带回它的完整值并返回true,否则返回false表示查找失败。此算法类似树的先根遍历算法,它首先访问根结点,若相等则带回结点值并返回真,否则依次查找每个子树。具体算法描述如下。
boolFindGTree(GTreeNodeGT,ElemType&item)
if(GT==NULL)returnfalse;//树空返回假
else
if(GT->data==item)
item=GT->data;returntrue;
for(inti=0;i<k;i++)
if(FindGTree(GT->t[i],item))returntrue;
returnfalse;//查找不成功返回假
4.树的输出
要求输出为树的广义表形式。此算法同样类似于树的先根遍历算法,它首先输出树根结点的值,然后若存在非空子树则接着输出表的左括号及输出第一棵子树,再依次输出每个逗号和每棵子树,最后输出表的右括号。该算法描述如下。
voidPrintGTree(GTreeNodeGT)
//以广义表形式输出按标准方式存储的k叉树
if(GT!=NULL)
cout<<GT->data<<'';//输出根结点的值
```c
inti;
for(i=0;i<k;i++)
if(GT->t[i]!=NULL)break;
if(i<k)
cout<<'(';
PrintGTree(GT->t[0]);
for(i=1;i<k;i++)
cout<<',';
PrintGTree(GT->t[i]);
cout<<')';
5.求树的深度
树为空则深度为0，否则它等于所有子树的最大深度加1。为此设置一个整型变量，用来保存已求过的子树中的最大深度，当所有子树都求过后，返回该变量值加1。具体算法描述如下。
intGTreeDepth(GTreeNodeGT)
if(GT==NULL)return0;
else
intmax=0;
for(inti=0;i<k;i++)
intd=GTreeDepth(GT->t[i]);
if(d>max)max=d;
returnmax+1;
6.清除树中的所有结点，使之变为一棵空树
此算法类似于树的后根遍历，首先依次删除树根结点的所有子树，然后删除根结点并把指向根结点的指针置为空。该算法中的指向树根结点的参数GT必须是引用，这样才能作用于具体的实参。具体算法描述如下。
voidClearGTree(GTreeNode&GT)
if(GT!=NULL)
for(inti=0;i<k;i++)ClearGTree(GT->t[i]);
deleteGT;
GT=NULL;
```
上面讨论的树的一些运算都需要访问树中的所有结点，并且每个结点的值仅被访问一次，访问时也只是做些简单的操作，所以每个算法的时间复杂度均为O(n)，其中n表示树中的结点数。各算法的空间复杂度最好情况为O(logn)，最差情况为O(n)。
用下面程序调试对一般树运算的算法。
include<iostream.h>
include<stdlib.h>
constintk=3;//假定k定义为常数3
typedefcharDataType;//为了与队列中使用的元素类型ElemType相区别,树中的元素类型用标识符DataType表示
structGTreeNode//一般树中的结点类型
DataTypedata;//结点值域
GTreeNodet[k];//结点指针域t[0]~t[k-1]
;
typedefstructGTreeNodeElemType;//定义队列的元素类型
structQueue//队列的顺序存储类型
ElemTypequeue;//指向存储队列的数组空间
intfront,rear;//队首指针、队尾指针变量
intMaxSize;//queue数组长度
;
include"顺序队列运算.cpp"
include"一般树运算.cpp"//注意把查找算法中的ElemType修改为DataType
voidmain()
GTreeNodegt;
InitGTree(gt);
charb[50];
cout<<"输入一棵"<k<广义表字符串;"<<endl;
cin.getline(b,sizeof(b));//从键盘输入树的广义表字符串
CreateGTree(gt,b);//建立k叉树的链接存储结构
cout<<"先根遍历结果:";PreRoot(gt);cout<<endl;
cout<<"后根遍历结果:";PostRoot(gt);cout<<endl;
cout<<"按层遍历结果:";LayerOrder(gt);cout<<endl;
cout<<"按广义表形式输出的k叉树为:";
PrintGTree(gt);
cout<<endl;
cout<<"树的深度:";cout<<GTreeDepth(gt)<<endl;
cout<<"输入待查找的一个字符:";
charch;cin>>ch;
if(FindGTree(gt,ch))cout<<"查找成功!"<<endl;
elsecout<<"查找失败!"<<endl;
ClearGTree(gt);
得到的运行结果如下:
输入一棵3叉树的广义表字符串：
a(b(e,f(j)),c,d(g(k,l),h,i))
先根遍历结果：abefjcdgklhi
后根遍历结果：ejfbcklghida
按层遍历结果：abcdefghijkl
按广义表形式输出的k叉树为：aleft(bleft(_,e,fleft(_,j,_right)right),c,dleft(gleft(k,_,lright),h,iright)right)树的深度：4
输入待查找的一个字符：h
查找成功!
section习题5
【习题5-1】运算题。
1.已知一棵度为m的树中有n_1个度为1的结点，n_2个度为2的结点，cdots，n_m个度为m的结点，问树中有多少个叶子结点？
2.画出由3个结点a,b,c组成的所有不同结构的二叉树，请问共有多少种不同的结构?每一种结构又对应多少种不同的排列次序？
3.设一棵二叉树广义表表示为a(b(c),d(e,f))，分别写出对它进行先序、中序、后序、按层遍历的结果。
先序：
中序：
后序：
按层：
4.设一棵普通树的广义表表示为a(b(e),c(f(h,i,j),g),d)，分别写出先根、后根、按层遍历的结果。
先根：
后根：
按层：
5.已知一棵二叉树的先根和中根序列，求该二叉树的后根序列。
先根序列：A,B,C,D,E,F,G,H,I,J
中根序列：C,B,A,E,F,D,I,H,J,G
后根序列：
6.已知一棵二叉树的中根和后根序列，求该二叉树的高度和双支、单支及叶子结点数。
中根序列：c,b,d,e,a,g,i,h,j,f
后根序列：c,e,d,b,i,j,h,g,f,a
高度：双支：单支：叶子：
7.已知一棵二叉树在数组中的链接存储如下，写出该二叉树对应的广义表示。
data
left
right
|0|1|2|3|4|5|6|7|8|9|10|11|12|
|---|---|---|---|---|---|---|---|---|----|----|----|----|
||a|b|c|d|e|f|g|h|i|j|||
|1|2|0|4|0|6|0|8|0|0|0|12|0|
|11|5|3|0|0|7|0|9|10|0|0|0|0|
【习题5-2】算法分析题。
1.下面函数的功能是返回二叉树BT中值为X的结点所在的层数，请在划有横线的地方填写合适内容。
intNodeLevel(BTreeNodeBT,ElemTypeX)
if(BT==NULL)return0;//空树的层数为0
elseif(BT->data==X)return1;//根结点的层数为1
else
intc1=NodeLevel(BT->left,X);
if(c1>=1)______(1)______;
intc2=______(2)______;
if______(3)______;
//若树中不存在X结点则返回0
return0;
2.指出下面函数的功能。
BTreeNodeBTreeSwapX(BTreeNodeBT)
if(BT==NULL)returnNULL;
else
BTreeNodept=newBTreeNode;
pt->data=BT->data;
pt->right=BTreeSwapX(BT->left);
pt->left=BTreeSwapX(BT->right);
returnpt;
3.已知二叉树中的结点类型STreeNode定义如下。
structSTreeNodedatatypedata;STreeNodelchild,rchild,parent;;
其中，data为结点值域，lchild和rchild分别为指向左、右孩子结点的指针域，parent为指向父亲结点的指针域。根据下面函数的定义指出函数的功能。算法中参数ST指向一棵二叉树，X保存一个结点的值。
STreeNodePN(STreeNodeST,DataType&X)
if(ST==NULL)returnNULL;
else
StreeNodemt;
if(ST->data==X)returnST->parent;
elseif(mt=PN(ST->lchild,X))returnmt;
elseif(mt=PN(ST->rchild,X))returnmt;
returnNULL;
4.指出下面函数的功能。
voidBTC(BTreeNodeBT)
if(BT!=NULL)
if(BT->left!=NULL&BT->right!=NULL)
if(BT->left->data>BT->right->data)
BTreeNodet=BT->left;
BT->left=BT->right;
BT->right=t;
BTC(BT->left);
BTC(BT->right);
5.设BT指向一棵二叉树，该二叉树的广义表表示为a(b(a,d(f)),c(e,a(k)),b)，则依次使用BTC1(BT,'a',C)、BTC1(BT,'b',C)、BTC1(BT,'c',C)和BTC1(BT,'g',C)调用下面算法时，假定每次调用时C的初值均为0，引用变量C的带回值依次为(1)、(2)、(3)和(4)。
voidBTC1(BTreeNodeBT,charx,int&k)
if(BT!=NULL)
if(BT->data==x)k++;
BTC1(BT->left,x,k);
BTC1(BT->right,x,k);
6.下面函数的功能是从二叉树BT中查找值为x的结点，若查找成功则返回结点地址，否则返回空。请在划有横线的地方填合适内容。
BTreeNodeBTf(BTreeNodeBT,ElemTypex)
if(BT==NULL)____(1)____;
else
if(BT->data==x)____(2)____;
else
BTreeNodet;
```c
if(t=BTF(BT->left,x))______(3)______;
__________(4)________;
elsereturnNULL;
7.指出下面函数的功能。
voidpreserve(BTreeNodeBT,ElemTypea[],intn)
staticinti=0;
if(BT!=NULL)
preserve(BT->left,a,n);
a[i++]=BT->data;
preserve(BT->right,a,n);
【习题5-3】算法设计题。
1.根据下面函数声明编写求一棵二叉树BT中结点总数的算法，其值由函数返回。
intBTreeCount(BTreeNodeBT);
2.根据下面函数声明编写求一棵二叉树中叶子结点总数的算法，其值由函数返回。
intBTreeLeafCount(BTreeNodeBT);
3.根据下面函数声明编写判断两棵二叉树是否相等的算法，若相等则返回1，否则返回0。算法中参数T1和T2分别指向这两棵二叉树的根结点。当两棵树的结构完全相同并且对应结点的值也相同时才被认为相等。
intBTreeEqual(BTreeNodeT1,BTreeNodeT2);
4.根据下面函数声明编写交换一棵二叉树BT中所有左、右子树的算法。
voidBTreeSwap(BTreeNodeBT);
5.根据下面函数声明编写复制一棵二叉树BT的算法，并返回复制得到的二叉树的根结点指针。
BTreeNodeBTreeCopy(BTreeNodeBT);
6.根据下面函数声明编写从一棵二叉树BT中求出结点值大于X的结点个数的算法，并返回所求结果。
intBTreeCount(BTreeNodeBT,ElemTypex);
7.根据下面函数声明编写对二叉树进行中序遍历的非递归算法，在算法中定义一个数组和栈顶指针作为栈使用。
voidInorderN(BTreeNodeBT);
8.根据下面函数声明编写求一棵二叉树BT中所有结点数和叶子结点数的算法，其值分别由引用参
```
数C1和C2带回,C1和C2的初值均为0。
voidCount(BTreeNodeBT,int&C1,int&C2);
9.已知一棵具有n个结点的完全二叉树被顺序存储于一维数组的A[1]~A[n]元素中，根据下面函数声明编写一个算法，打印出编号为i的结点的双亲和所有孩子。.
voidRequest(charA[],intn,inti);
10.根据下面函数声明编写求一棵普通树GT中结点总数的算法。
intGTreeCount(GTreeNodeGT);
11.若一棵树是以二叉树的形式链接存储的，根据下面函数声明编写以广义表形式输出对应树的算法。
voidPrintGTree(BTreeNodeBT);
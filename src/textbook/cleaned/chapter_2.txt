第2章线性表
section2.1线性表的定义和抽象数据类型
subsection2.1.1线性表的定义
线性表（linearlist）是具有相同属性的数据元素的一个有限序列。该序列中所含元素的个数称为线性表的长度，用n表示，ngeq0。当n=0时，表示线性表是一个空表，即表中不包含任何元素。设序列中第i个元素为a_i(1leqileqn)，则线性表的一般表示为：(a_1,a_2,cdots,a_i,a_i+1,cdots,a_n)其中a_1为第1个元素，又称作表头元素，a_2为第2个元素，a_n为最后一个元素，又称作表尾元素。
一个线性表可以用一个标识符来命名，如用A命名上面的线性表，则A=(a_1,a_2,cdots,a_i,a_i+1,cdots,a_n)线性表中的元素通常是按照元素值或关键字有序排列的。也就是说，线性表中的元素是按照前后位置线性有序的，即第i个元素a_i在逻辑上是第i-1个元素a_i-1的后继，是第i+1个元素a_i+1的前驱，其中第1个元素a_1没有前驱，最后一个元素a_n没有后继。线性表是一种线性结构，用二元组表示为：textlinear_list=(A,R)其中，A=a_i|1leqileqn,ngeq0,a_iintextElemTypeR=rr=langlea_i,a_i+1rangle|1leqileqn-1对应的逻辑图如图2-1所示。
n(图2-1线性表的逻辑结构示意图)
线性表中使用的元素类型ElemType是一种通用数据类型标识符，可以通过typedef语句在使用前把它定义为任何一种具体类型。若把它定义为整数类型，则为：
typedefintElemType;
由线性表的定义可知，线性表的长度是可变的，当向线性表中插入一个元素时，其长度就增加1，当从线性表中删除一个元素时，其长度就减少1。
线性表是一种线性结构，反过来，任何线性数据结构都可以用线性表的形式表示出来，
这只要按照元素之间的逻辑关系把它们顺序排列即可。如对于第1章中列举的线性数据结构linearity可用线性表表示为:(05,01,03,08,02,07,04,06,09,10)因此，以后对线性表的讨论就代表了对任何线性数据结构的讨论。
在日常生活中所见到的各种各样的表都是线性表，如人事档案表、职工工资表、学生成绩表、图书目录表和列车时刻表等。这些表通常都是以关键字段（又称域或属性）的值的升序排列，如职工工资表按职工号字段的升序排列，学生成绩表按学生号字段的升序排列，列车时刻表按开出时间字段的升序排列。在一个线性表中若存在着按值的升序或降序排列的字段，则称该字段为有序字段，该线性表为有序表，否则若不存在任何有序字段，则为无序表。如对于一个字符串或由一篇文章所建立的文本文件，它也是一个线性表，其元素类型为字符，它们只是按照前后位置有序，而不是按照每个字符的ASCII码有序，所以为无序表。
下面给出几个线性表的具体例子：
B=('a','b','c','4','7','+','-','','/')
C=(25,38,12,49,63,54,20,18,34,47)
D=("BASIC","PASCAL","FORTRAN","COBOL","VC++","JAVA")
E=("序号","姓名","性别","年龄","单位","职称","联系电话","E-mail")
F=(a,b,c,d,e,f,g,h,i,j,k,x,y,z)
其中B中的元素为字符型；C中的元素为整型；D中的元素为字符串型；E中的元素也为字符串型；F中的元素可为任何类型，它同上面线性表A中的元素一样，每个元素都是用标识符抽象表示的，其目的是便于做一般性的考虑。
再如，对于第1章表1-1和表1-2，若只考虑各记录之间位置上的前后关系，即按职工号的升序排列次序，则均为一个线性表，每个线性表中的元素均为相应的记录类型。
subsection2.1.2线性表的抽象数据类型
线性表的抽象数据类型包括数据和操作两个部分。数据部分为一个线性表，假定用标识符L表示，它可以采用顺序、链接、散列、索引等任一种方法存储到计算机中，其存储类型用标识符ListType表示。操作部分为对线性表所做的各种操作（运算），包括：向线性表插入一个元素、从线性表中删除一个元素、求线性表长度、判断线性表是否为空等。在下面定义的线性表抽象数据类型中，只给出了对线性表的一些基本的和典型的操作，因为线性表的实际应用是丰富和广泛的，所以不可能也没有必要给出其所有操作。
ADTLinearListis
Data:
一个具有ListType类型的线性表L
Operation:
voidInitList(ListType&L);//初始化L为空
voidClearList(ListType&L);//清除L中的所有元素
intLengthList(ListType&L);//返回L的长度
boolEmptyList(ListType&L);//判断L是否为空
ElemTypeGetList(ListType&L,intpos);//返回L中第pos个元素的值
voidTraverseList(ListType&L);//遍历输出L中的所有元素
boolFindList(ListType&L,ElemType&item);//从L中查找并返回元素
boolUpdateList(ListType&L,constElemType&item);//修改L中元素
boolInsertList(ListType&L,ElemTypeitem,intpos);//向L插入元素
boolDeleteList(ListType&L,ElemType&item,intpos);//从L删除元素
voidSortList(ListType&L);//对L中的所有元素重新按给定条件排序
endLinearList
在上面对面线性表L的运算中，第3~7种运算不需要改变线性表的状态，所以在其参数说明前可以使用const保留字，拒绝在函数体中对线性表的修改，以保证数据的安全性，其余运算需要在函数体中改变线性表，所以不能使用此保留字。在插入运算中，item参数用来保存待插入的元素，pos参数用来给定插入条件，人为约定当posgeq1同时posleqn+1时，则把item插入到线性表中第pos个位置上，其中n表示线性表长度；当pos=-1时，则把item插入到线性表的末尾位置，即最后一个元素的后面位置；当pos=0时，则把线性表看作有序表，item被插入后仍保持有序。在删除运算中，item参数用来保存待删除元素的值或某个域的值，并保存和返回被删除元素的完整值，pos参数用来给定删除条件，人为约定当posgeq1同时posleqn时，则删除线性表中第pos个位置上的元素并通过item参数返回值；当pos=-1时，则删除线性表中的表尾元素，即最后一个元素并通过item参数返回值；当pos=0时，则删除线性表中第一个值或某个域的值等于item的元素并通过item参数返回值。
subsection2.1.3操作举例
【例2-1】设线性表L1=(25,38,19,42,33)，i=2,x=60,y=42，则对L1的一组操作及结果如下。
LengthList(L1);//返回L1的长度5
EmptyList(L1);//L1非空，返回false
GetList(L1,i);//返回L1中第i个元素的值，因i=2，所以返回值38
InsertList(L1,x,6);//向L1末尾插入x，L1变为(25,38,19,42,33,60)
InsertList(L1,54,1);//向L1表头插入元素54，L1变为(54,25,38,19,42,33,60)
DeleteList(L1,y,0);//删除L1中值为y的元素，L1变为(54,25,38,19,33,60)
DeleteList(L1,y,3);//删除L1中第3个元素，L1变为(54,25,19,33,60)
SortList(L1);//L1被改变为(19,25,33,54,60)
InsertList(L1,35,0);//插入35后L1变为(19,25,33,35,54,60)
【例2-2】课程（course）记录的结构为：
structcourse
charCname[20];//课程名称
intChour;//开课学时
intCterm;//开课学期
以课程记录为元素类型的一个线性表L2,如表2-1所示。
表2-1课程计划安排表
|课程名称|开课学时|开课学期|课程名称|开课学时|开课学期|
|---|---|---|---|---|---|
|高等数学|90|1|计算机组成原理|90|2|
|离散数学|72|2|程序设计基础|63|3|
|英语|72|1||||
对L2进行的一组操作如下，首先定义具有course记录结构的x、y、z和w对象并对其赋初值。
coursex=left("",72right);//给x的Chour域赋初值72
coursey=("程序设计基础");//给y的Cname域赋初值"程序设计基础"
coursez=left("text英语",80,1right);//给z赋初值left("text英语",80,1right)coursew=left("text数据结构",72,4right);//给w赋初值left("text数据结构",72,4right)GetList(L2,3);//返回值为("英语",72,1)
FindList(L2,x);//查找与x中开课学时相等的第一个元素并由x返回
//为了实现课程记录之间的直接比较,需要事先重载等于
//号运算符,使其实际上是在Chour域上进行比较
FindList(L2,y);//查找与y值中课程名称相等的第一个元素并由y返回
//为了实现课程记录之间的直接比较,也需要重载等于
//号运算符,使其实际上是在Cname域上进行比较
UpdateList(L2,z);//用z更新L2中课程名称为"英语"的第一个元素,使
//得该元素被修改为("英语",80,1)。在此函数体中若进行
//记录之间的直接比较,则也需要事先重载等于号运算符,
//使其实际上是进行课程名称之间的比较
InsertList(L2,w,6);//在L2末尾添加了一条w记录
DeleteList(L2,y,0);//从L2中删除与y的Cname域值相等的第一条记录,
//即删除L2中的第5条记录("程序设计基础",63,3)
SortList(L2);//假定按开课学时的升序排列,则排序后的结果如表2-2所示
表2-2对L2操作后的结果
|课程名称|开课学时|开课学期|课程名称|开课学时|开课学期|
|---|---|---|---|---|---|
|离散数学|72|2|高等数学|90|1|
|数据结构|72|4|计算机组成原理|90|2|
|英语|80|1||||
section2.2线性表的顺序存储和操作实现
subsection2.2.1线性表的顺序存储结构
线性表的存储结构有顺序、链接、索引、散列等多种方式,顺序存储结构是其中最简单、最常见的一种。线性表的顺序存储结构可叙述为:将线性表中的所有元素按照其逻辑
顺序依次存储到计算机存储器中的从指定存储位置开始的一块连续的存储空间中，线性表中的第一个元素的存储位置就是被指定存储空间中的开始存储位置，第i个元素(2leqileqn)被紧接着存储在第i-1个元素的存储位置的后面。
设线性表的元素类型为ElemType，则每个元素所占用存储空间的大小（即字节数）为sizeof(ElemType)，整个线性表所占用存储空间的大小为ntimessizeof(ElemType)，第i个元素的存储位置为a+(i-1)timessizeof(ElemType)，其中n表示线性表的长度，1leqileqn，a为整个线性表占用的存储空间的开始位置。
在C/C++语言中，定义了一个数组就定义了一块可供用户使用的连续存储空间，该存储空间的起始位置就是由数组名表示的地址常量。因此，线性表的顺序存储结构是利用数组来实现的，数组的基本类型就是线性表中元素的类型，数组的大小（又称数组长度，它等于数组中包含的元素个数，亦即存储元素的位置数）要大于等于线性表的长度。线性表中的第1个元素被存储在数组的起始位置，即下标为0的位置上，第2个元素被存储在下标为1的位置上，以此类推，第n个元素（即最后表尾元素）被存储在下标为n-1的位置上。用具有ElemType类型的数组list[MaxSize]存储线性表A=(a_1,a_2,cdots,a_i,a_i+1,cdots,a_n)，则A所对应的顺序存储结构如图2-2所示。
begintabularc|c
hline下标位置&数组（线性表）存储空间
hline0&a_1
hline1&a_2
hlinevdots&vdots
hlinei-1&a_i
hlinei&a_i+1
hlinevdots&vdots
hlinen-1&a_n
hlinevdots&vdots
hlineMaxSize-1&
hline
endtabular
图2-2线性表的顺序存储结构示意图
数组list下标的上界MaxSize决定了所有线性表的最大长度，当线性表的长度大于MaxSize时，其尾部多余的元素将无法被存储，发生这种情况时需要重新分配存储空间，使得MaxSize的值更大一些。
在定义一个线性表的顺序存储类型时，需要定义一个数组来存储线性表中的所有元素和定义一个整型变量来存储线性表的长度。假定数组用list[MaxSize]表示，整型变量用size表示，则元素类型为ElemType的线性表的顺序存储类型可描述为：
ElemTypelist[MaxSize];
intsize;
为了便于进行线性表的操作，可以把用于存储线性表元素的数组和存储线性表长度的变量统一说明在一个记录类型中，设该记录类型用List表示，则定义如下。
structList
ElemTypelist[MaxSize];
;
intsize;
;
若要对存储线性表的数组空间采用动态分配，并且其数组长度能够按需要增加，则可以定义出如下的List类型:
structList
ElemTypelist;//存线性表元素的动态存储空间的指针
intsize;//存线性表长度
intMaxSize;//规定list数组的长度
;
当初始化此类型的一个线性表时，要使list指针指向大小为MaxSize的动态数组空间。
subsection2.2.2顺序存储下的线性表操作的实现
在顺序存储方式下，在线性表抽象数据类型中所列出的每一个操作的具体实现如下。
section1.初始化线性表
初始化线性表需要完成动态存储空间的初始分配，并且把线性表置为空。
voidInitList(List&L)
//初始定义数组长度为10,以后可增减,或者附加一个形参给定初始数组长度
L.MaxSize=10;
//动态存储空间分配
L.list=newElemType[L.MaxSize];
if(L.list==NULL)
cout<<"动态可分配的存储空间用完,退出运行!"<<endl;
exit(1);
//置线性表长度为0,即为空表
L.size=0;
此算法中的if语句用于判断动态分配是否成功，若成功L.list指针非空，若分配失败，即系统中没有存储空间可供动态分配，则L.list指针值为空。当分配失败时通过执行此语句退出程序运行。现在计算机系统中，操作系统功能强大，内存和外存空间都能够用于动态存储分配，所以通常不会出现动态存储分配失败的情况。所以，在编程时通常省略对动态存储分配失败情况的处理语句。在此情况下，若出现动态存储分配失败，系统会自动停止运行程序。
section2.删除线性表中的所有元素，使之成为一个空表
此操作需要释放动态存储空间，并且把线性表的长度置0。
voidClearList(List&L)
if(L.list!=NULL)
delete[]L.list;
L.list=NULL;
L.MaxSize=0;
L.size=0;
3.得到线性表的长度
intLengthList(List&L)
returnL.size;
4.检查线性表是否为空
boolEmptyList(List&L)
returnL.size==0;
若线性表L为空，则返回真，否则返回假。
5.得到线性表中指定序号为pos的元素
ElemTypeGetList(List&L,intpos)
if(pos<1||pos>L.size)//若pos越界则退出程序
cerr<<"posisoutrange!"<<endl;
exit(1);
returnL.list[pos-1];//返回线性表中第pos个元素的值
若所给的pos值不存在越界问题，则可直接使用表达式L.list[pos-1]从线性表L中取出第pos个元素。如要取出线性表L中第5个元素，则表示为L.list[4]。
6.遍历一个线性表
遍历一个线性表就是从线性表的第1个元素起，按照元素之间的逻辑顺序，依次访问每一个元素，并且每个元素只被访问一次，直到访问完所有元素为止。在顺序存储方式下，线性表中元素之间的存储顺序与其逻辑顺序相同，因为一个元素的后继元素被紧接着存储在该元素所在位置的下一个存储位置上。若一个元素在数组存储空间中的存储位置为下标
i,则它的后继元素的存储位置必为下标i+1。所以遍历一个线性表就是依次访问list[0]~list[n-1]中的每一个元素，并且每个元素仅被访问一次。当访问一个元素时，可根据需要作任意处理，在我们的算法中且以打印该元素的值代之。若线性表中的元素类型为记录类型，则打印元素的值需要有对该类型重载插入操作符（<）函数的支持。
voidTraverseList(List&L)
for(inti=0;i<L.size;i++)
cout<<L.list[i]<<'';
cout<<endl;
当然，对于记录类型，若在此函数的cout输出语句中是依次输出元素的每一个域的值，而不是把元素作为整体输出，则不需要重载插入操作符。
7.从线性表中查找具有给定值的第1个元素
boolFindList(List&L,ElemType&item)
for(inti=0;i<L.size;i++)
if(L.list[i]==item)
item=L.list[i];
returntrue;
returnfalse;
当从线性表L中查找到与item的值或某个域的值相等的元素时，则由item返回该元素的整体值，并由该函数返回真，表明查找成功，否则由函数返回假，表明查找失败。
当元素类型ElemType为记录类型时，调用此函数必须要有对该类型进行等于号(==)重载的支持，若没有，则应该修改if条件表达式，使比较在相应的域上进行，并且此域必须为简单数据类型。另外，若用于比较的元素类型或某个域的类型为字符串，则需要使用字符串比较函数strcmp，因为使用等于号直接比较的是指针的值，而不是比较所指的字符串。如当ElemType为字符串类型(char)时，if条件表达式应修改为：
(strcmp(L.list[i],item)==0)
8.更新线性表中具有给定值的第1个元素
boolUpdateList(List&L,constElemType&item)
for(inti=0;i<L.size;i++)
if(L.list[i]==item)
L.list[i]=item;//进行修改（更新）赋值操作
returntrue;
returnfalse;
该函数与FindList函数的定义类似,FindList函数是在查找成功后由item带回元素的值,而UpdateList函数是在查找成功后,用item的值修改元素的值。
在线性表查找和更新算法中,运行时间主要取决于比较元素的次数,当第1个元素list[0]等于待查找或更新的元素时,则只需要比较一次就结束操作,对应的时间复杂度为O(1),这是最好的情况;当前n-1元素比较均不成立,只有比较到最后一个元素list[n-1](n为线性表的长度L.size)才等于待查找或更新的元素时,则需要经过n次比较完成操作,对应的时间复杂度为O(n),这是最差的情况:当元素值互不相同,并且都有相同的概率left(text即平均概率frac1nright)等于待查找或更新的元素时,则需要比较元素的平均次数为frac1nsum_i=1^ni=fracn+12,对应的时间复杂度为O(n),这是平均情况。当经过依次同线性表中所有n个元素比较后,仍找不到与给定值相等的元素,则表明查找失败,算法执行returnfalse语句后结束,此种情况下的时间复杂度同样为O(n)。所以无论查找成功或失败,顺序查找线性表的时间复杂度均为O(n)。
section9.向线性表中按给定条件插入一个元素
当该函数的pos参数为0时,则需要实现在有序表上的插入,并且要保证插入新元素后仍为一个有序表。在有序表上查找插入位置最简单和常用的方法是顺序比较法,它从第1个元素起,依次取出每一个元素同待插入的元素item进行比较,当item小于某一个元素的值时比较结束,此元素位置就是item的插入位置。若比较到表尾后仍满足不了条件,表明item大于所有元素,则应把item插入到表尾,成为新的表尾元素。另外,当元素类型为记录时,则必须对该类型进行小于号重载后才能实现item<L.list[i]的直接比较。
例如,一个有序表为A=(25,36,40,48,55,72,83),当向其中插入16时,其插入位置为表头,即第1个元素25的位置;当向其中插入50时,其插入位置为55元素的位置;当向其中插入92时,其插入位置在表尾,即最后一个元素83的后面位置。
当该函数的pos参数等于-1,要求把item插入到线性表的表尾,即第L.size+1个元素的位置上。
当该函数的pos参数为大于等于1,同时小于等于线性表长度加1时,则直接把item插入到线性表的第pos个元素的位置上。
在线性表的第pos个元素的位置插入一个新元素前,还要检查存储线性表的动态数组空间是否具有空闲位置,若没有,则要扩大原有的空间。
为了实现在第pos个元素的位置插入新元素,还要把从该位置开始的其后所有元素均后移一个位置,以使空出第pos个元素的位置,用于写入新元素。
完成插入后,要使线性表的长度域增1,然后返回真结束算法。
根据以上分析编写出此算法如下。
boolInsertList(List&L,ElemTypeitem,intpos)
```cpp
//检查pos值是否有效,若无效则无法插入,返回假
if(pos<-1||pos>L.size+1)
cout<<"pos值无效!"<<endl;returnfalse;
//求出按值有序插入时item的插入位置,使之保存到pos中
inti;
if(pos==0)
for(i=0;i<L.size;i++)
if(item<L.list[i])break;
pos=i+1;//pos中保存新插入的元素的序号
//得到表尾插入位置,被保存在pos中
elseif(pos==-1)pos=L.size+1;
//若线性表存储空间用完,则重新分配大一倍的存储空间
if(L.size==L.MaxSize)
intk=sizeof(ElemType);//计算每个元素存储空间的长度
L.list=(ElemType)realloc(L.list,2L.MaxSizek);
//线性表动态存储空间扩展为原来的2倍,原内容不变
if(L.list==NULL)
cout<<"动态可分配的存储空间用完,退出运行!"<<endl;
exit(1);
L.MaxSize=2L.MaxSize;//把线性表空间大小修改为新的长度
//待插入位置及所有后续位置元素,从后向前依次后移一个位置
for(i=L.size-1;i>=pos-1;i--)
L.list[i+1]=L.list[i];
//把item的值赋给已空出的、下标为pos-1的位置,它为第pos个元素位置
L.list[pos-1]=item;
//线性表长度增1
L.size++;
//返回真表示插入成功
returntrue;
在这个算法中,运行时间主要花费在第2步为寻找插入位置所需的比较元素的次数和第5步为空出插入位置所需的移动元素的次数。新元素插入的下标位置为i,则元素的比较次数为i+1次,元素的移动次数为n-i次(n为线性表的长度L.size),两者相加为n+1次。也就是说,当进行有序插入时,不管新元素插入在什么位置上,进行元素比较和移动的总次数不变,均为n+1,当进行按位置插入时,只需要考虑移动元素的次数,在插入所有位置概率相等情况下,平均移动次数为frac1n+1sum_i=0^n(n-i)=fracn2,所以此算法的时间复杂度为O(n)。特殊地,当规定在表尾插入时,其时间复杂度为O(1)。
```
10.从线性表中删除符合给定条件的第1个元素
此算法同插入元素的算法类似，具体描述如下。
boolDeleteList(List&L,ElemType&item,intpos)
//检查线性表是否为空，若是则无法删除，返回假
if(L.size==0)
cout<<"线性表为空，删除无效!"<<endl;
returnfalse;
//检查pos值是否有效，若无效则无法删除，返回假
if(pos<-1||pos>L.size)
cout<<"pos值无效!"<<endl;returnfalse;
//求出按值删除时item的删除位置，使之保存到pos中
inti;
if(pos==0)
for(i=0;i<L.size;i++)
if(item==L.list[i])break;
if(i==L.size)returnfalse;//无元素可删返回假
pos=i+1;
//得到被表尾元素的序号，被保存在pos中
elseif(pos==-1)pos=L.size;
//把被删除元素的值赋给变参item带回
item=L.list[pos-1];
//将待删除元素位置后面的所有的元素，从前向后依次前移一个位置
for(i=pos;i<L.size;i++)
L.list[i-1]=L.list[i];
//线性表长度减1
L.size--;
//若线性表存储空间空余太多，则进行适当缩减
if((float)(L.size)/L.MaxSize<0.4&&L.MaxSize>10)
intk=sizeof(ElemType);//计算每个元素存储空间的长度
L.list=(ElemType)realloc(L.list,L.MaxSizek/2);
//线性表动态存储空间缩减为原来的一半
L.MaxSize=L.MaxSize/2;//把线性表空间大小修改为新的长度
//返回真表示删除成功
returntrue;
在这个算法中，运行时间主要花费在第3步为寻找删除元素位置所需的比较元素的次数和第6步为填补删除元素位置所需的移动元素的次数上。被删除元素的下标位置为i，
则元素的比较次数为i+1次,元素的移动次数为n-i-1次(n为线性表的长度L.size),两者相加为n次。也就是说,当进行按值删除时,不管删除什么位置上的元素,进行元素比较和移动的总次数不变,均为n,当进行按位置删除元素时,只需要考虑移动元素的次数,在删除所有位置上元素概率相等情况下,平均移动次数为frac1nsum_i=0^n-1(n-i-1)=fracn-12,所以此算法的时间复杂度为O(n)。特殊地,当规定删除表尾元素时,其时间复杂度为O(1)。
11.对线性表进行排序
对线性表进行排序就是按照元素的值或某个域的值的升序(或降序)排列元素,使之成为一个有序表。对顺序存储的线性表(数组)进行排序的方法很多,本小节只介绍一种简单的插入排序方法,其他方法将在第10章中专门讨论。
插入排序的方法是:把线性表list[0]~list[n-1]中共n个元素看作一个有序表和一个无序表,开始时有序表中只有一个元素list[0](一个元素总是认为是有序的),无序表中含有n-1个元素list[1]~list[n-1],以后每次从无序表中取出第1个元素,把它插入到前面有序表中的合适位置,使之成为一个新的有序表,这样有序表就增加了一个元素,无序表就减少了一个元素,经过n-1次后,有序表中含有n个元素,无序表变为一个空表,整个线性表就成为了一个有序表。
如何在第i次(1leqileqn-1)把无序表中的第1个元素list[i]插入到前面有序表list[0]~list[i-1]中呢?一种方法是:从有序表表尾元素list[i-1]开始,依次向前使每一个元素list[j](0leqj<i-1)同x(用来临时保存list[i]的值)进行比较,若x<list[j],则把list[j]后移一个位置,直到x>=list[j]或j<0为止,此时已空出的下标为i+1的位置就是x的插入位置,把x的值插入到list[j+1]即可。
假定一个线性表为(42,65,80,74,28,44,36,65),则插入排序的过程,如图2-3所示,其中中括号内表示每次排序后得到的有序表,中括号后面为待排序的无序表。beginarraylllllllll0&1&2&3&4&5&6&7hline42&65&80&74&28&44&36&65endarray(1)[4265]807428443665
(2)[426580]7428443665
(3)[42657480]28443665
(4)[2842657480]443665
(5)[284244657480]3665
(6)[28364244657480]65
(7)[2836424465657480]
图2-3线性表插入排序过程
用C++语言描述插入排序算法如下。
voidSortList(List&L)//对L中的所有元素重新按给定条件排序
inti,j;
ElemTypex;
for(i=1;i<L.size;i++)//共循环n-1次
x=L.list[i];//把无序表中的第1个元素暂存x
for(j=i-1;j>=0;j--)//向前顺序进行比较和移动
if(x<L.list[j])L.list[j+1]=L.list[j];
elsebreak;
L.list[j+1]=x;//把x写入到已经空出的j+1位置
在插入排序中，共需要进行n-1次元素的插入，每次插入最少需比较一次和移动两次元素，最多需比较i次和移动i+2次元素，平均需比较fraci+12次和移动fraci2+2次元素。若分别用C_min、C_max和C_textave表示元素的总比较次数的最小值、最大值和平均值，用M_min、M_max和M_textave表示元素的总移动次数的最小值、最大值和平均值，则它们的值分别为:beginaligned
&C_min=sum_i=1^n-11=n-1
&C_max=sum_i=1^n-1i=frac12n(n-1)
&C_textave=sum_i=1^n-1fraci+12=frac14left(n^2+n-2right)
endalignedbeginaligned
&M_min=sum_i=1^n-12=2(n-1)
&M_max=sum_i=1^n-1(i+2)=frac12left(n^2+3n-4right)
&M_textave=sum_i=1^n-1left(fraci2+2right)=frac14left(n^2+7n-8right)
endaligned所以插入排序算法在最好情况下的时间复杂度为O(n)，在平均和最差情况下的时间均为O(n^2)。
利用现成的向线性表插入元素的InsertList算法，也可以很方便地编写出SortList排序算法。该算法需要首先定义一个临时线性表并进行初始化，接着将形参线性表L中的每一个元素通过InsertList算法依次插入到临时线性表中，最后把临时线性表赋给L。用C++语言描述如下。
voidSortList(List&L)
Lista;
InitList(a);
for(inti=0;i<L.size;i++)
InsertList(a,L.list[i],0);
ClearList(L);
L=a;
该算法的时间复杂度同上面插入排序算法相同，均为O(n^2)。
调试上述算法的程序如下。
include<iostream.h>
include<stdlib.h>
typedefintElemType;
structList
ElemTypelist;//存线性表元素的动态存储空间的指针
intsize;//存线性表长度
intMaxSize;//规定list数组的长度
;
//添加上面介绍的11个算法
voidmain()
inta[12]=3,6,9,12,15,18,21,24,27,30,33,36;
inti;ElemTypex;
Listt;
InitList(t);
for(i=0;i<12;i++)InsertList(t,a[i],i+1);
InsertList(t,48,13);InsertList(t,40,0);
cout<<GetList(t,4)<<''<<GetList(t,9)<<endl;
TraverseList(t);
cout<<"输入待查找的元素值：";
cin>>x;
if(FindList(t,x))cout<<"查找成功!"<<endl;
elsecout<<"查找失败!"<<endl;
cout<<"输入待删除元素的值：";
cin>>x;
if(DeleteList(t,x,0))cout<<"删除成功!"<<endl;
elsecout<<"删除失败!"<<endl;
for(i=0;i<6;i++)
DeleteList(t,x,i+1);
TraverseList(t);
cout<<"按值插入，输入待插入元素的值：";
cin>>x;
if(InsertList(t,x,0))cout<<"插入成功!"<<endl;
elsecout<<"插入失败!"<<endl;
TraverseList(t);
cout<<"线性表长度:"<<LengthList(t)<<endl;
if(EmptyList(t))cout<<"线性表为空!"<<endl;
elsecout<<"线性表不空!"<<endl;
ClearList(t);
运行这个程序，得到的一次运行结果如下。
1227
3691215182124273033364048
输入待查找的元素值:21
查找成功!
输入待删除元素的值:15
删除成功!
6122127334048
按值插入,输入待插入元素的值:8
插入成功!
68122127334048
线性表长度:8
线性表不空!
仔细分析此结果，增强对算法的理解。
2.3线性表应用举例
用线性表来管理一个商品库存表。商品库存表已经保存在文本文件a:goods.dat中，每个商品记录包含有4项内容：商品代号、商品名称、最低库存量和当前库存量。商品库存表中的具体内容如表2-3所示。
表2-3商品库存表
|商品代号|商品名称|最低库存量|当前库存量|
|----------|--------------|------------|------------|
|Y-12|toothbrush|10|25|
|F-13|soap|20|48|
|W-01|toiletpaper|10|36|
|M-48|towel|15|90|
|C-24|chinacup|10|52|
|S-05|schoolbag|5|20|
可以事先通过调用下面函数在A盘上建立库存表文件。
voidSetupGoodsFile(charfname)
ofstreamofstr(fname);//定义输出文件流对象ofstr
if(!ofstr)
cerr<<"File'goods'nocreate!"<<endl;
exit(1);
chara[30];
for(inti=0;i<6;i++)
cin.getline(a,30);
ofstr<<a<<endl;
ofstr.close();
在此函数中，for循环体每循环一次，要求从键盘上输入一条商品记录，每个域值之间
用空格分开,最后以按下回车键结束,该条记录被存入到字符数组a中,然后被写入到文件中。
根据商品库存表中商品记录的结构,可定义记录类型如下。
structgoods
charcode[5];//商品代号
charname[15];//商品名称
intminq;//最低库存量
intcurq;//当前库存量
;
通过typedef语句将该类型定义为线性表的通用元素类型ElemType。
typedefgoodsElemType;
在商品库存表中,以商品代号域作为查找字段域,则对应的重载等于号运算符的函数定义为:
booloperator==(constElemType&e1,constElemType&e2)
return(strcmp(e1.code,e2.code)==0);
同样,在插入和排序算法中使用的小于号运算符需如下的重载函数支持:
booloperator<(constElemType&e1,constElemType&e2)
return(strcmp(e1.code,e2.code)==-1);
用于打印输出使用的插入操作符也需要进行重载,定义如下:
ostream&operator<<(ostream&ostr,constElemType&x)
ostr.setf(ios::left);//设置每个区域内按左对齐显示
ostr<<setw(6)<<x.code<<setw(12)<<x.name;
ostr<<setw(4)<<x.minq<<setw(4)<<x.curq<<endl;
returnostr;
对商品库存表的管理就是首先把它读入到内存线性表中,接着对它进行必要的处理,然后把处理后的结果写回到文件中。对商品库存表的处理假定包括如下选项。
(1)打印（遍历）库存表。
(2)按商品代号修改记录的当前库存量,若查找到对应的记录,则从键盘上输入其修正量,把它累加到当前库存量域后,再把该记录写回原有位置,若没有查找到对应的记录,则表明是一条新记录,应接着从键盘上输入该记录的商品名称、最低库存量和当前库存量的值,然后把该记录追加到库存表中。
(3)按商品代号删除指定记录。
(4)按商品代号对库存表中的记录排序。
在顺序存储方式下对线性表的各种操作函数假定包含在list.cpp程序文件中,则实现库存表管理的完整程序如下。
//程序2-1.cpp
include<iostream.h>
include<stdlib.h>
include<iomanip.h>
include<string.h>
include<fstream.h>
structgoods//商品记录类型
charcode[5];//商品代号
charname[15];//商品名称
intminq;//最低库存量
intcurq;//当前库存量
;
typedefgoodsElemType;
structList
ElemTypelist;//存线性表元素的动态存储空间的指针
intsize;//存线性表长度
intMaxSize;//规定list数组的长度
;
booloperator>=(constElemType&e1,constElemType&e2)
return(strcmp(e1.code,e2.code)==0);
booloperator<(constElemType&e1,constElemType&e2)
return(strcmp(e1.code,e2.code)==-1);
ostream&operator<<(ostream&ostr,constElemType&x)
ostr.setf(ios::left);//设置每个区域内按左对齐显示
ostr<<setw(6)<<x.code<<setw(12)<<x.name;
ostr<<setw(4)<<x.minq<<setw(4)<<x.curq<<endl;
returnostr;
```cpp
include"list.cpp"
voidSetupGoodsList(List&L,charfname)
//把文件中所存商品表顺序读入内存线性表中以便处理
ifstreamifstr(fname,ios::in|ios::nocreate);
if(!ifstr)
cerr<<"File'goods'notfound!"<<endl;
exit(1);
goodsg;
inti=1;
while(ifstr>>g.code)
ifstr>>g.name>>g.minq>>g.curq;
InsertList(L,g,i++);
ifstr.close();
voidWriteGoodsFile(charfname,List&L)
//把线性表中所存的商品表重新写回到文件中
ofstreamofstr(fname);
if(!ofstr)
cerr<<"File'goods'nocreate!"<<endl;
exit(1);
goodsg;
intn=LenthList(L);
for(inti=1;i<=n;i++)
g=GetList(L,i);
ofstr<<g.code<<""<<g.name<<""
<<g.minq<<""<<g.curq<<endl;
ofstr.close();
voidmain()
ListL2;//说明一个线性表L2
InitList(L2);//初始化L2
SetupGoodsList(L2,"a:goods.dat");//读文件到线性表
inti,flag=1;
while(flag)//当flag为真时执行循环
cout<<"1打印整个库存表"<<endl;
cout<<"2修改库存表中的记录"<<endl;
```
cout<<"3删除库存表中的记录"<<endl;
cout<<"4对库存表排序"<<endl;
cout<<"5结束处理过程"<<endl;
cout<<"输入你的选择:";
cin>>i;
while(i<1||i>5)
cout<<"请重新输入选择(1-5):";
cin>>i;
cout<<endl;
switch(i)
case1:
TraverseList(L2);//打印
break;
case2://修改
goodsg;
intx;
cout<<"输入待修改的商品代号:";
cin>>g.code;
if(FindList(L2,g))
cout<<"输入该商品的修正量:";
cin>>x;
g.curq+=x;
if(UpdateList(L2,g))cout<<"完成更新!"<<endl;
else
cout<<"输入新商品记录的其余字段的内容:"<<endl;
cin>>g.name>>g.minq>>g.curq;
InsertList(L2,g,LengthList(L2)+1);
cout<<"新记录已被插入到表尾!"<<endl;
break;
case3://删除
cout<<"输入待删除商品的商品代号:";
cin>>g.code;
if(DeleteList(L2,g,0))
cout<<"代号为"<<g.code<<">"的记录被删除!"<<endl;
elsecout<<"代号为"<<g.code<<">"的记录不存在!"<<endl;
break;
case4://排序
SortList(L2);
cout<<"商品表中的记录已按商品代号排序!"<<endl;
break;
case5://结束
cout<<"本次处理结束,再见!"<<endl;
flag=0;
WriteGoodsFile("a:goods.dat",L2);//把线性表写回文件
同学们可以上机运行此程序并分析运行结果。
section2.4线性表的链接存储结构
section1.链接存储的概念
顺序存储和链接存储是数据的两种最基本的存储结构。在顺序存储中，每个存储结点只含有所存元素本身的信息，元素之间的逻辑关系是通过数组下标位置简单计算出来的。如在线性表的顺序存储中，若一个元素存储在对应数组中的下标位置为i，则它的前驱元素在对应数组中的下标位置为i-1，它的后继元素在对应数组中的下标位置为i+1。在链接存储中，每个存储结点不仅含有所存元素本身的信息，而且含有元素之间逻辑关系的信息，其存储结点（简称结点）的结构如图2-4所示。
begintabular|c|c|c|c|c|
hlinedata&p_1&p_2&cdots&p_m
hline
endtabularhline
图2-4结点的结构
其中data表示值域，用来存储一个元素，p_1,p_2,cdots,p_m(mgeqslant1)均为指针域，每个指针域的值为其对应的后继元素或前驱元素所在结点（以后简称为后继结点或前驱结点）的存储位置。通过结点的指针域（又称为链域）可以访问到对应的后继结点或前驱结点，该后继结点或前驱结点称为指针域（链域）所指向（或链接）的结点。若一个结点中的某个指针域不需要指向任何结点，则令它的值为空，即数值0，用常量NULL表示。
在数据的顺序存储中，由于每个元素的存储位置都可以通过简单计算得到，所以可以随机存取数据中的任一元素，对任一元素的存取时间都相同，这是一种随机存取机制；而在数据的链接存储中，由于每个元素的存储位置是保存在它的前驱结点或后继结点中的，所以只有当访问到其前驱结点或后继结点后才能够按指针访问到该结点，这是一种顺序存取机制。
数据的链接存储表示又称为链表。当链表中的每个结点只含有一个指针域时，则被称为单链表，否则被称为多链表。
section2.线性表的链接存储
由于线性表中的每个元素至多只有一个前驱元素和一个后继元素，即数据元素之间是1：1的逻辑关系，所以当进行链接存储时，一种最简单也最常用的方法是：在每个结点中除包含有数值域外，只设置一个指针域，用以指向其后继结点，这样构成的链表被称为线性单向链接表，简称单向链表或单链表；另一种可以采用的方法是：在每个结点中除包
含有数值域外，设置有两个指针域，分别用以指向其前驱结点和后继结点，这样构成的链接表被称为线性双向链接表，简称双向链表或双链表。单链表和双链表都是线性链表。
设一个线性表为：A=(a_1,a_2,cdots,a_i,a_i+1,cdots,a_n)若分别用单链表和双链表表示，则对应的存储结构如图2-5所示。
(a)单链表
(b)双链表
图2-5线性表的链接存储结构示意图
每个结点的指针域同它所指向的后继结点或前驱结点用一个带箭头的线段相连接，表示该指针域的值为所指向结点的存储位置。若一个指针域的值为空（即NULL），则在图形中通常用符号“∧”表示。由于线性表中的第1个元素无前驱元素，最后一个元素无后继元素，所以在对应的链接存储中，第1个结点的前驱指针域为空，最后一个结点的后继指针域为空。
在单链表中，由于每个结点只包含有一个指向后继结点的指针，所以当访问过一个结点后，只能接着访问它的后继结点，而无法访问它的前驱结点。在双向链表中，由于每个结点既包含有一个指向后继结点的指针，又包含有一个指向前驱结点的指针，所以当访问过一个结点后，既可以依次向后访问每一个结点，也可以依次向前访问每一个结点。
在线性表的链接存储中，存储第1个元素的结点称为表头结点，存储最后一个元素的结点称为表尾结点，其余为中间结点。每个链接表都需要设置一个指针指向表头结点，被称为表头指针。虽然表头指针只指向表头结点，但从表头指针出发，沿着结点的链（即指针域的值）可以依次访问到每一个结点，所以通常就以表头指针来命名一个链接表。若单链表的表头指针为H，双链表的表头指针为B，则可分别称它们为H单链表和B双链表。
在线性表的顺序存储中，逻辑上相邻的元素，其对应的存储位置也相邻，所以当进行插入或删除运算时，通常需要平均移动半个表的元素，这是相当费时的操作。在线性表的链接存储中，逻辑上相邻的元素，其对应的存储位置是通过指针来链接的，因而每个结点的存储位置可以任意安排，不必要求相邻，所以当进行插入或删除运算时，只需修改相关结点的指针域即可，这是既方便又省时的操作，灵活性强。由于链接表的每个结点带有指针域，因而在存储空间上比顺序存储要付出较大的代价。
3.在单链表上的插入和删除操作
在单链表中插入和删除结点，如图2-6所示。
在a结点（即存放元素a的结点的简称；另外，有时也用该结点的地址称该结点，把a结点称为p结点，即p指针所指向的结点）的后面插入b结点的前后状态，其插入操作的过程如下。
(1)将a结点指针域的值q（即指向后继c结点的指针）赋给b结点的指针域。
(2)将指向b结点的指针（即指针变量s的值）赋给a结点的指针域。cdotsrightarrowprightarrow[a]rightarrowqrightarrow[c]rightarrowcdotsquadcdotsrightarrowprightarrow[a]rightarrowsrightarrow[b]rightarrowqrightarrow[c]rightarrowcdots(a)插入结点前
(b)插入结点后
图2-6在单链表中插入结点的示意图
注意:在单链表的表头插入一个新结点，则首先要吧原表头指针赋给新结点的指针域，然后再把新结点的存储位置赋给表头指针变量。
思考：在单链表的表尾插入一个新结点，情况又如何呢？它同在中间或表头插入的情况有何异同？
从单链表中删除x结点后面的y结点的前后状态，如图2-7所示，其删除操作的过程如下。cdotsrightarrowprightarrow[x]rightarrowqrightarrow[y]rightarrowrrightarrow[z]rightarrowcdotsquadcdotsrightarrowprightarrow[x]rightarrowrrightarrow[z]rightarrowcdotssrightarrow[y]
(a)删除结点前
(b)删除结点后
图2-7从单链表中删除结点的示意图
(1)将x结点指针域的值q（即指向后继y结点的指针）赋给一个临时指针变量s，以便处理和回收该结点。
(2)将y结点的指针域的值r（即指向后继z结点的指针）赋给x结点的指针域。
注意：从单链表中删除表头结点，则首先要把表头指针赋给一个临时指针变量，以便处理和回收该结点，然后再把原表头结点指针域的值（即指向原表头后继结点的指针）赋给表头指针变量，使其下一个结点成为新的表头结点。
思考：若从单链表中删除表尾结点，情况又如何呢？它同删除中间或表头结点的情况有何异同？
4.单链表中的结点类型
In单链表中，每个结点的类型用LNode表示，它包括存储元素的数值域，用data表示，其类型用通用类型标识符ElemType表示，还包括存储后继元素位置的指针域，用next表示，其类型为指向本身结点的指针类型LNode，则LNode类型的定义如下。
structLNode
ElemTypedata;
LNodenext;
;
因为每个指针类型的大小等于一个整型(int)的大小（即4个字节），所以LNode类型的大小等于元素类型的大小sizeof(ElemType)加上4个字节。若ElemType表示int，则LNode类型的大小为8个字节，也就是说，每个LNode类型的结点（对象）占用8个字节的存储空间。
程序2-2是使用LNode类型的一个实例。从键盘上输入的三个数值依次为5、10和8，则该程序的运行结果也是5、10和8。
//程序2-2.cpp
include<iostream.h>
typedefintElemType;//规定元素类型为整型
structLNode
ElemTypedata;
LNodenext;
;//定义单链表结点
voidmain()
LNodex,y,z;//定义LNode类型的三个结点x,y和z
LNodep=&x;//定义LNode类型的指针变量p并初始指向x结点
cin>>x.data>>y.data>>z.data;//给x,y,z的数值域输入数据
x.next=&y;y.next=&z;z.next=NULL;//把x,y,z链接为单链表
while(p!=NULL)//从表头开始输出每个结点的值（即数据域的值）
cout<<p->data<<"";//输出指针p所指向的结点的值
p=p->next;//使p指向链表中的下一个结点
cout<<endl;
程序2-3同上面程序2-2具有相同的功能，都是建立一个具有三个结点的单链表，然后再依次输出单链表中每个结点的值。但在程序2-2中，单链表中的每个结点为静态结点，即由静态分配所产生的结点，而在程序2-3中，单链表中的每个结点为动态结点，即由动态分配所产生的结点。
//程序2-3.cpp
include<iostream.h>
typedefintElemType;//规定元素类型为整型
structLNode
ElemTypedata;
LNodenext;
;//定义单链表结点类型
voidmain()
LNodep,q,p1;
p1=newLNode;//动态产生结点并将其地址赋给p和p1指针
for(inti=0;i<3;i++)
q=newLNode;//q指向一个新的动态结点
```cpp
cin>>q->data;//从键盘输入一个整数赋给q结点的值域
p->next=q;//将q结点链接到p结点之后
p=q;//使p指针后移,指向后继新结点q
p->next=NULL;//置链表的最后一个结点的指针域为空
p=p1->next;//链表的表头结点为p1结点的指针域所指向的结点
while(p!=NULL)
cout<<p->data<<"";//输出p结点的值,即其数值域的值
p=p->next;//使p指向链表中的下一个结点
cout<<endl;
单链表中的结点既可以来自静态或动态产生的独立结点（如以上两个程序所示），也可以来自静态或动态产生的数组中的元素（结点），若来自数组中的结点（元素），则next域指向的是后继结点所在的下标，所以它应被定义为整数类型。用ALNode表示数组中结点的类型，则对应的定义如下。
structALNode
ElemTypedata;
intnext;
;
由数组中的结点构造单链表的所属数组类型可定义如下。
typedefALNodeALinkList[MaxSize];
ALinkList被定义为包含有MaxSize个元素的、元素类型为ALNode的数组类型。由该类型的对象（即数组）构造单链表时，通常下标为0的元素不作为单链表中的结点使用，而是用它的指针域保存表头指针，这样，数组最多能够提供MaxSize-1个结点。另外，当一个结点无后继结点时，其指针域应被赋予数值0，表示空指针。
利用ALinkList类型的数组构成单链表的情况，如图2-8(a)所示。表头指针为下标0位置中next域的值4，单链表的结构示意图，如图2-8(b)所示。表头指针用f表示，每个指针上标出的数值就是该指针的具体值。
begintabular|c|c|c|c|c|c|c|c|c|c|c|
hlinedata&0&1&2&3&4&5&6&7&8&(cdots)
hlinenext&4&3&8&6&7&2&0&5&1&
hline
endtabular
(a)数组构成的单链表
frightarrow44rightarrow75rightarrow50rightarrow57rightarrow62rightarrow68rightarrow75rightarrow83rightarrow94rightarrow0
(b)单链表的结构
图2-8利用数组建立单链表示意图
```
可以看出，该单链表中各数据元素之间的逻辑顺序如下。44,50,57,62,68,75,83,94由数组建立一个单链表时，通常将所有空闲元素链接起来构成一个空闲单链表，空闲单链表的表头指针也需要用一个元素结点的指针域保存起来，假定使用1号（即下标为1）的指针域。在这种数组中链接存储的线性表的长度至多为MaxSize-2，因为0号和1号元素均被表头指针所占有。当对整个数组进行初始化时，不仅置单链表为空，即把0赋给0号元素的指针域，而且将全部MaxSize-2个空闲结点链接起来构成空闲单链表，同时把它的表头指针（即2）赋给1号元素的指针域。对数组进行初始化后的情况，如图2-9所示。
begintabular|c|c|c|c|c|c|c|c|c|c|
hlinedata&0&1&2&3&4&5&6&7&MaxSize-1
hlinenext&0&2&3&4&5&6&7&8&0
hline
endtabular
图2-9空闲单链表
向数组中的单链表插入一个新元素时，首先从空闲表中取出（即删除）表头结点作为保存新元素的结点使用，然后再把该结点按条件插入到单链表中；当从数组中的单链表删除一个元素结点时，首先从单链表中取出这个结点，然后再把该结点插入到空闲单链表的表头。
数组中的元素单链表和空闲单链表的结点总数，在任何时候都等于MaxSize-2，当空闲单链表为空时，则元素单链表为满，此时无法再向它插入新结点。
例如，在下面的数组中，链接存储的线性表为(35,68,57,26,70)，空闲单链表中依次包含有3,5,8号元素结点，MaxSize=10，如图2-10所示。
begintabular|c|c|c|c|c|c|c|c|c|c|
hlinedata&0&1&2&3&4&5&6&7&8
hlinenext&4&3&6&5&2&8&9&0&0
hline
endtabular
图2-10元素和空闲单链表
5.双向链表中的结点类型和插入与删除操作
对于双向链表也可进行以上对单链表那样的讨论，若双向链表采用独立结点构成，则结点类型定义为:
structDNode
ElemTypedata;
DNodeleft;
DNoderight;
;
若双向链表采用数组中的元素结点构成，则结点类型应定义为:
structADNode
ElemTypedata;
intleft;
intright;
;
其中，DNode和ADNode为结点类型标识符，该类型包含有3个域：数值域（data），左指针域（left）和右指针域（right），left域用于指向前驱结点，right域用于指向后继结点。
设p和q分别是具有DNode类型的指针变量，若在双向链表中p结点之后插入一个q结点，则需要修改4个指针域的值，操作步骤如下。
(1)使p结点的后继结点成为q结点的后继结点。
q->right=p->right;
(2)若p结点有后继结点，则使q结点成为该结点的前驱结点。
if(p->right)p->right->left=q;
(3)使p结点成为q结点的前驱结点。
q->left=p;
(4)使q结点成为p结点的后继结点。
p->right=q;
插入过程如图2-11所示。
(a)插入结点
(b)插入过程
(c)插入完成后的链接
图2-11在双向链表中插入结点的示意图
若删除双向链表中p指针所指向的结点，假定p结点前后都存在着结点，则只需要修改两个指针，其操作步骤如下。
(1)修改p结点的前驱结点的右指针，使之指向p结点的后继结点。
p->left->right=p->right;
(2)修改p结点的后继结点的左指针域，使之指向p结点的前驱结点。
p->right->left=p->left;
(3)回收p结点。
deletep;
删除过程如图2-12所示。
(a)删除前的状态
(b)删除过程
(c)删除后的状态
图2-12在双向链表中删除结点的示意图
6.带表头附加结点的线性链表
在线性表的链接存储中,为了方便在表头插入和删除结点,使得与在其他地方所做的操作相同,需要在表头结点(即保存第一个元素的结点)的前面增加一个结点,把它称之为表头附加结点,此时表头附加结点的指针域指向表头结点,而表头指针由原来指向第一个元素的结点改为指向表头附加结点。仍以存储以前给出的线性表A为例,如图2-13所示。此时单链表中指向第一个结点的指针为H->next,双向链表中指向第一个结点的指针为B->right。
Hrightarrowfboxsquarerightarrowfboxa_1rightarrowfboxa_2rightarrowcdotsrightarrowfboxa_n
(a)带表头附加结点的单链表
Brightarrowfboxtrianglerightarrowfboxa_1rightarrowfboxa_2rightarrowcdotsrightarrowfboxa_n
(c)带表头附加结点的双向链表
Hrightarrowfboxsquare
(b)带表头附加结点的空单链表
Brightarrowfboxtriangle
(d)带表头附加结点的空双向链表
图2-13带表头附加结点的单链表和双向链表
7.循环链表
在单链表中,让表尾结点(即最后一个结点)的指针域指向表头结点或表头附加结点(若采用的话);在双向链表中,若让表尾结点的右指针域指向表头结点或表头附加结点,而让表头结点或表头附加结点的左指针域指向表尾结点,则就构成了循环链表。带有表头附加结点的循环单链表和循环双向链表,如图2-14所示。
Hrightarrowfboxsquarerightarrowfboxa_1rightarrowfboxa_2rightarrowcdotsrightarrowfboxa_n
(a)循环单链表
Brightarrowfboxsquarerightarrowfboxa_1rightarrowfboxa_2rightarrowcdotsrightarrowfboxa_n
(c)循环双向链表
Hrightarrowfboxsquare
(b)循环单链空表
Brightarrowfboxsquare
(d)循环双向空表
图2-14带表头附加结点的循环单链表和循环双向链表
对于由数组元素结点构成的单链表,其下标为0的元素结点的指针域保存元素单链表的表头指针,所以该结点成为元素单链表的附加表头结点,而元素单链表的最后一个结点的指针域为0表示空指针,它正好是表头附加结点的下标,由此构成带表头附加结点的循环单链表。空闲表的最后一个结点的指针域被置为整数0表示空指针,若被置为整数1则可构成带表头附加结点的循环空闲表。
对于独立分配存储空间的结点,通常由指针所指向,若使用的指针为p,则p就表示该结点,p->data和p->next就分别表示该结点的数值域和指针域。对于数组中的元素结点,它是由数组名和下标值标识的,假定数组名为a,下标值为k,则a[k]就表示该结点,a[k].data和a[k].next就分别表示该结点的数值域和指针域,元素单链表的表头指针为a[0].next,空闲单链表的表头指针为a[1].next。了解独立结点和元素结点在访问上的差别后,学会在独立结点所构成的单链表上进行各种运算的算法,也就不难写出对元素单链表进行各种运算的算法。
section2.5线性表操作在单链表上的实现
每个单链表都有一个表头指针,用HL表示,由表头指针可以访问到单链表中的任何结点,所以要对单链表进行操作,必须给出表头指针。假定以HL为表头指针的单链表是由LNode类型的动态结点所组成,并且不带有表头附加结点,下面给出对线性表抽象数据类型中列举的每一操作在单链表上的具体实现,即C++语言算法描述。
section1.初始化单链表
voidInitList(LNode&HL)
HL=NULL;//置单链表为空
section2.删除单链表中的所有结点,使之成为一个空表
删除单链表中的所有结点,需要遍历单链表,通过delete操作释放被访问的每一个结点所占的存储空间,然后把表头指针置为空。
voidClearList(LNode&HL)
LNodecp;//将用cp(currentpointer)指向待处理结点
LNodenp;//将用np(nextpointer)指向cp的后继结点
cp=HL;//表头指针赋给cp
while(cp!=NULL)
np=cp->next;//保存下一个结点的地址
deletecp;//删除当前结点,即被处理的结点
cp=np;//使下一个结点成为当前结点
HL=NULL;//置单链表为空
3.得到单链表的长度
由于在单链表的构成中,没有给出单链表的长度,所以此算法需要遍历单链表,对被访问的结点进行计数,最后返回计数值。
intLenthList(LNodeHL)
inti=0;//用来统计单链表中结点的个数
while(HL!=NULL)//遍历单链表,统计结点数
i++;
HL=HL->next;
returni;//返回单链表长度
因为该运算需要访问单链表中的每个结点,不改变表头指针,即不会改变单链表的状态,所以定义表头指针HL为值参。对于指针值参只需要占用一个字(即4个字节)的存储空间,它与使用引用参数传送时需要保存实参地址所需要的存储空间大小相同,由此不会增加存储空间和传送参数值时间。对于上面第1和第2种操作,由于需要通过函数体操作修改调用函数时的实际表头指针的值,所以必须被定义为引用参数。
4.检查单链表是否为空
boolEmptyList(LNodeHL)
returnHL==NULL;
5.得到单链表中第pos个结点中的元素
要访问单链表中的第pos个结点,必须从表头开始依次访问过该结点之前的所有结点后才能够实现,即只能够采用顺序存取,而不能够随机存取任一个结点。
ElemTypeGetList(LNodeHL,intpos)
if(pos<1)
cerr<<"posisoutrange!"<<endl;
exit(1);
inti=0;//统计已遍历的结点数,i初值为0
while(HL!=NULL)//遍历到第pos个结点或表为空时止
i++;
if(i==pos)break;
HL=HL->next;
if(HL!=NULL)//返回结点值
returnHL->data;
else
cerr<<"posisoutrange!"<<endl;
exit(1);
6.遍历一个单链表
遍历一个单链表并打印出每个结点的值。
voidTraverseList(LNodeHL)
while(HL!=NULL)//从表头开始依次输出每个结点的值
cout<<HL->data<<"";
HL=HL->next;
cout<<endl;
7.从单链表中查找出等于给定值的第1个元素
boolFindList(LNodeHL,ElemType&item)
while(HL!=NULL)
if(HL->data==item)//查找成功由item带回完整值
item=HL->data;
returntrue;
elseHL=HL->next;//HL指向后继结点
returnfalse;
8.更新单链表中等于给定值的第1个元素
boolUpdateList(LNodeHL,constElemType&item)
while(HL!=NULL)//查找元素
if(HL->data==item)break;
elseHL=HL->next;
if(HL==NULL)returnfalse;//没有被更新的元素，返回假
else
HL->data=item;//更新元素
returntrue;
9.向单链表中按给定条件插入一个元素
其插入过程如下。
(1)判定pos的值,若小于-1则表明pos值无效,返回假。
(2)为新插入元素动态分配结点并赋值。
(3)根据pos的值所表示的不同条件,寻找新结点的插入位置,为此需要从表头开始顺序查找新元素的插入位置,在查找过程中必须保留当前待比较结点的地址及其前驱结点的地址,以便插入时使用。
(4)在插入位置上完成插入新结点操作,即把新结点链接到当前结点和前驱结点之间。若插入的位置为表头,则需要做特殊处理。
boolInsertList(LNode&HL,ElemTypeitem,intpos)
//pos值小于-1返回假
if(pos<-1)
cout<<"pos值无效!"<<endl;returnfalse;
//为item元素建立新结点
LNodenewptr;
newptr=newLNode;
newptr->data=item;
//寻找新结点的插入位置
LNodecp=HL;//用cp指向当前结点(即待查结点),初始指向表头
LNodeap=NULL;//用ap(aheadpointer)指向cp的前驱结点,初始为空
if(pos==0)//按值寻找插入位置
while(cp!=NULL)
if(item<cp->data)break;//找到新元素插入位置,退出循环
else
ap=cp;//ap和cp指针均后移,实现顺序向后比较
cp=cp->next;
elseif(pos==-1)//查找表尾位置
while(cp!=NULL)ap=cp;cp=cp->next;
else//按序号pos的值寻找插入位置
inti=0;
while(cp!=NULL)
i++;
if(i==pos)break;//找到新元素插入位置,退出循环
else
ap=cp;cp=cp->next;
```cpp
if(cp==NULL&&i+1<pos)
cout<<"pos值超出单链表长度加1!"<<endl;
returnfalse;
//完成新结点插入操作
if(ap==NULL)
newptr->next=HL;//把新结点插入到表头
HL=newptr;
else
//把新结点插入到非表头位置，即插入到ap和cp结点之间
newptr->next=cp;//cp指针也可能为空,此时为表尾
ap->next=newptr;
returntrue;
10.从单链表中删除符合给定条件的第1个元素
删除算法的执行步骤如下。
(1)若单链表为空则返回假。
(2)若pos值小于-1时则返回假。
(3)根据pos的值所表示的条件从单链表中查找被删除的结点，为此需要从单链表中顺序查找，直到查找成功或失败为止。在查找过程中需要保留待比较的当前结点和前驱结点的地址，以便删除结点时使用。
(4)删除查找到的结点，对表头结点和非表头结点要做不同处理。
(5)回收被删除结点的存储空间。
(6)删除成功返回真。
boolDeleteList(LNode&HL,ElemType&item,intpos)//从L删除元素
//单链表为空，无法删除，返回假
if(HL==NULL)
cerr<<"单链表为空，删除操作无效!"<<endl;
returnfalse;
//pos值小于-1返回假
if(pos<-1)
cout<<"pos值无效!"<<endl;returnfalse;
//寻找被删除的元素结点
LNodecp=HL;//用cp指向当前结点(即待查结点)，初始指向表头
LNodeap=NULL;//用ap(aheadpointer)指向cp的前驱结点，初始为空
if(pos==0)//按值查找被删除结点
```
```cpp
while(cp!=NULL)
if(item==cp->data)break;//找到被删除结点cp,退出循环
else
ap=cp;
cp=cp->next;
if(cp==NULL)
cout<<"单链表中没有相应的结点可删除!"<<endl;
returnfalse;
elseif(pos==-1)
while(cp->next!=NULL)ap=cp;cp=cp->next;
else
inti=0;
while(cp!=NULL)
i++;
if(i==pos)break;//找到被删除结点cp,退出循环
else
ap=cp;
cp=cp->next;
if(cp==NULL)
cout<<"pos值无效!"<<endl;returnfalse;
//删除cp所指向的结点
if(ap==NULL)HL=HL->next;//删除表头结点
elseap->next=cp->next;//删除非表头结点,也可以是表尾结点
//回收被删除结点的存储空间
deletecp;
//删除成功返回真
returntrue;
11.对单链表进行数据排序
假定待排序的单链表由表头指针HL所指向，对结点值按照从小到大次序进行排序链接时，首先建立一个空的单链表，然后把HL中的每个结点取出并按值依次插入到新建立的单链表中，最后由引用参数HL带回新建单链表的表头指针。下面就是对单链表进行的插入排序算法。
voidSortList(LNode&HL)
```
```c
//建立一个反映排序结果的新单链表并初始化为空
LNodeSL;
InitList(SL);
//从待排序的HL单链表中依次取出每个结点,按值插入到新单链表中
LNoder=HL;//r指向待取出排序的一个结点,初始为HL表头结点
while(r!=NULL)
//为新插入的r结点在SL中顺序查找找出插入位置
LNodet=r->next;//t指向r的后继结点
LNodecp=SL;//用cp初始指向SL单链表的表头
LNodeap=NULL;//用ap指向cp的前驱结点,初始为空
while(cp!=NULL)
if(r->data<cp->data)break;//找到被插入点,退出循环
else
ap=cp;//ap和cp指针均后移,实现顺序向后比较
cp=cp->next;
//实现插入操作
if(ap==NULL)
r->next=SL;//把r结点插入到表头
SL=r;
else
r->next=cp;//把r结点插入ap和cp结点之间
ap->next=r;//cp可能为空,则r成为SL的表尾
//使r指向原单链表的下一个结点
r=t;
//由引用参数带回新单链表的表头指针
HL=SL;
在上面对单链表进行的11种操作算法中，第1、4种算法的时间复杂度为O(1)；第2、3及5~10种算法的时间复杂度为O(n)；第11种算法的时间复杂度为O(n^2)。若只在单链表的表头插入或删除结点，其时间复杂度均为O(1)。上述每个算法的空间复杂度均为O(1)。由于对单链表的插入和删除元素的操作只进行元素的比较，不进行元素的移动，而对顺序存储的线性表操作既需要元素的比较，又需要元素的移动，所以当处理的数据量较大，同时每个数据占用的字节数较多时，在相同数量级的情况下，顺序表操作往往比单链表操作要花费更多的时间。
要上机调试上述对单链表操作的算法，只要对本章第2节的调试程序稍加修改即可。主要是把顺序表List类型定义替换为LNode结点类型定义，把主函数中的表对象t的类型List替换为LNode。
对于由数组中元素结点构成的单链表，其操作算法与上述独立结点构成的单链表的情
```
况类似,下面仅给出初始化单链表、按值插入元素和按值删除元素的算法,其他算法不难由同学们写出。
(1)初始化单链表。
voidInitList(ALinkListAL)//参数说明等同于ALNodeAL[MaxSize]
//将循环单链表置空,下标0结点为表头附加结点
AL[0].next=0;
//结点依次链接构成空闲链接表
for(inti=2;i<MaxSize-1;i++)
AL[i].next=i+1;
//将带表头附加结点的空闲链接表的最后结点的指针域置空
AL[MaxSize-1].next=0;
//下标为1结点的指针域指向空闲链接表的第1个结点
AL[1].next=2;
(2)向有序单链表按值插入一个元素。
boolInsertList(ALinkListAL,constElemType&item)
intnewptr;
newptr=AL[1].next;//从空闲表中取出表头结点
if(newptr==0)
cerr<<"没有空闲结点可用!"<<endl;
returnfalse;
AL[1].next=AL[newptr].next;//空闲表的第2个结点成为新的表头结点
AL[newptr].data=item;//item的值赋给被插结点的值域
intap,cp;
ap=0;cp=AL[0].next;//分别给ap和cp赋初值
while(cp!=0)//查找新结点的插入位置
if(item<AL[cp].data)break;
else
ap=cp;cp=AL[cp].next;
AL[newptr].next=cp;//插入时不用特殊处理表头情况
AL[ap].next=newptr;
returntrue;
(3)从单链表中删除等于给定值的第1个元素。
boolDeleteList(ALinkListAL,ElemType&item)
//单链表为空,无法删除元素,返回假
if(AL[0].next==0)
cerr<<"Linkedlistisanempty!"<<endl;
returnfalse;
//查找被删除的结点及前驱结点
intap,cp;
ap=0;cp=AL[0].next;
while(cp!=0)
if(AL[cp].data==item)break;
elseap=cp;cp=AL[cp].next;
//若不存在被删除的元素则返回假
if(cp==0)
cerr<<"Deletedelementisnotexist!"<<endl;
returnfalse;
//从单链表中删除查找到的下标为cp的结点，不用特殊考虑表头情况
AL[ap].next=AL[cp].next;
//把删除的结点插入到空闲表的表头
AL[cp].next=AL[1].next;
AL[1].next=cp;
//删除成功返回数值假
returnfalse;
2.6多项式计算
subsection2.6.1多项式表示与求值
多项式表示与求值是线性表应用的一个典型实例。
由数学知识可知，一个多项式P(x)的一般表示为：P(x)=a_0+a_1x^1+a_2x^2+cdots+a_nx^n其中，n为整数，ngeqslant0，a_nneq0，a_0sima_n-1中的每个系数可以为0，也可以不为0。
section1.多项式的第1种线性表表示与运算
为了处理P(x)，可把所有项的系数用一个线性表来表示：(a_0,a_1,a_2,cdots,a_n)把这个线性表用顺序存储结构或链接存储结构保存起来，就可以进行多项式的有关运算。若采用顺序存储结构，对应的List类型的对象为P，其中P.list[]按x指数的升序存储相应的系数，即存储上面线性表，P.size存储多项式中的项数，它等于x的最高次幂加1，则求此多项式值的算法描述如下。
doublePolySum1(List&P,doublex)
//用sum计算累加和，首先把常数项a_0的值赋给它作为其初值
doublesum=P.list[0];
//用w计算x的次幂，初值为1
doublew=1;
//累加计算多项式的值
for(inti=1;i<P.size;i++)
w=x;//计算出x的i次幂
sum+=P.list[i]w;//把一个新项a_ix^i的值累加到sum中
//返回求出的多项式的值
returnsum;
若多项式线性表采用链接存储结构，则求值算法描述如下。
doublePolySum1(LNodeP,doublex)
LNodet=P;//用t指向多项式单链表的表头结点
doublesum=t->data;//用sum计算累加和，初值为常数项a_0的值
doublew=1;//用w计算x的次幂，初值为1
t=t->next;//t指向第二个结点，即值为a_1的结点
while(t!=NULL)
w=x;//使w累乘xsum+=t->dataw;//把一个新项的值累加到sum中
t=t->next;//使t指向下—个结点
returnsum;//返回求出的多项式的值
假定一个多项式为5+3x^2-6x^3+2x^5，对应的线性表为(5,0,3,-6,0,2)，若采用链接存储，计算程序如下。
include<iostream.h>
include<stdlib.h>
typedefdoubleElemType;
structLNode
ElemTypedata;//定义单链表结点类型
LNodenext;
;
//单链表有关操作的函数定义
voidmain()
```cpp
LNodea;
InitList(a);
ElemTyper[6]=5,0,3,-6,0,2;
inti;
for(i=5;i>=0;i--)InsertList(a,r[i],1);
cout<<"线性表a:";
TraverseList(a);
cout<<"线性表长度:"<<LengthList(a)<<endl;
doubley=PolySum1(a,2);
cout<<"x值为2时的多项式值:"<<y<<endl;
ClearList(a);
```
在主函数的for语句中，按r数组元素排列的逆序依次在单链表的表头插入，正好能够得到按指数升序链接的单链表。这样建立的单链表，其时间复杂度为O(n)。若把数组r中的元素依次插入到单链表的表尾，其建立成的单链表的时间复杂度为O(n^2)。此程序的运行结果为：
线性表a:503-602
线性表长度:6
x值为2时的多项式值:33
section2.多项式的第2种线性表表示与运算
在一个多项式中，往往会出现许多缺项。如P(x)=1+6x^5-3x^12+7x^60，其中只有4项，缺少57项，或者说57项的系数均为0。若仍采用上述定义形式的线性表，将浪费存储空间和运算时间，是不可取的。为此，通常采用另一种形式的线性表来表示，该线性表中的每个元素对应多项式中的一个非零项，每个元素包含两个域：系数域（coef）和指数域（exp），用来分别表示对应项的系数和x的指数，并且线性表中的元素应按照指数的升序排列，它是按指数有序的一个有序表。P(x)多项式的这种线性表表示为：(1,0,6,5,-3,12,7,60)将线性表中的元素类型定义为Term结构类型，则描述为：
```cpp
structTerm
doublecoef;//系数
intexp;//指数
;
```
通过使用如下的定义语句将Term类型与通用的线性表元素类型ElemType对应起来。
```cpp
typedefTermElemType;
```
利用顺序存储结构存储这种线性表的多项式求值的算法如下。
```cpp
doublePolySum2(List&P,doublex)
```
```cpp
//给作为累加变量的sum赋初值为0
doublesum=0;
//累加计算多项式的值
for(inti=0;i<P.size;i++)
inty=P.list[i].exp;//把一个新项的x的指数赋给y
sum+=P.list[i].coefpow(x,y);//把新项的值累加到sum中
//返回所求结果
returnsum;
在函数中使用的pow(x,y)是求x的y次幂的函数,该函数定义在math.h头文件中。利用链接存储结构存储这种线性表的多项式求值的算法如下。
doublePolySum2(LNodeP,doublex)
LNodet=P;
doublesum=0;
while(t!=NULL)
inty=t->data.exp;
sum+=t->data.coefpow(x,y);
t=t->next;
returnsum;
用下面程序来调用求顺序存储的多项式值的算法。由于把结构类型Term作为线性表中的元素类型ElemType使用,所以在整个程序中必须包含相应的运算符重载函数的定义,使得元素之间的小于、等于、插入等运算是有效的。当然不通过运算符重载也是可行的,则需要修改相应操作的算法,使之进行比较的是元素的某个域的值(如exp域的值),而不是整个元素值,依次输出元素的每个域的值,而不是整个结构元素的值。
include<iostream.h>
include<stdlib.h>
include<math.h>
structTerm
doublecoef;//系数
intexp;//指数
;
typedefTermElemType;
structList
ElemTypelist;//存线性表元素的动态存储空间的指针
intsize;//存线性表长度
intMaxSize;//规定list数组的长度
;
```
booloperator!=(constElemType&e1,constElemType&e2)
returne1.exp!=e2.exp;
booloperator<(constElemType&e1,constElemType&e2)
returne1.exp<e2.exp;
ostream&operator<<(ostream&ostr,constElemType&x)
ostr<<x.coef<<''<<x.exp<<'';
returnostr;
include"list.cpp"//该程序文件保存着对线性表各种操作的算法
doublePolySum2(List&P,doublex)
//如上面给出的函数定义
voidmain()
Lista1,a2;
InitList(a1);InitList(a2);
Termr1[4]=5,0,3,2,-6,3,2,5;
Termr2[4]=1,0,6,5,-3,12,7,60;
inti;
for(i=0;i<4;i++)//把r1中的每个元素依次插入线性表a1的表尾
InsertList(a1,r1[i],-1);
for(i=0;i<4;i++)//把r2中的每个元素依次插入线性表a2的表尾
InsertList(a2,r2[i],-1);
cout<<"线性表a1:";
TraverseList(a1);
cout<<"线性表a2:";
TraverseList(a2);
doubley1=PolySum2(a1,2);
doubley2=PolySum2(a2,2);
cout<<y1<<''<<y2<<endl;
ClearList(a1);ClearList(a2);
执行这个程序得到的结果为:
线性表a1:5032-6325
线性表a2:1065-312760
338.07045e+018
2.6.2两个多项式相加
下面以多项式的链接存储结构为例讨论两个多项式P_1和P_2相加的算法，返回它们的和多项式。
两个多项式相加就是使对应项相加，若另一个多项式中没有对应项（即指数相同的项），则把它直接复制到结果中。如：
[P_1(x)=5+3x^2-6x^3+2x^5]
[P_2(x)=3+4x-2x^2+3x^3-2x^5+9x^6]P_1、P_2的相加结果为P_3(x)=8+4x+x^2-3x^3+9x^6。
因为每个单链表都是按指数域的值有序的单链有序表，所以此相加过程就是两个单链有序表的合并过程，当然要遵循多项式相加的合并规则。
1.实现相加运算的第1种算法
设计此题的算法时，首先将两个指针t1和t2分别指向两个多项式单链表p1和p2的表头结点，并定义和初始化一个新的单链表p3作为结果单链表；然后当t1和t2所指结点非空时，比较它们的指针域值的大小，将较小的一个结点的值插入到p3单链表中，若两者相等，则将系数域的值相加，当不为零时同归一结点的指数域的值组成一个元素值插入到p3单链表中，让t1和t2指针后移，以便向下继续比较和处理；最后当出现有一个单链表处理结束时，把另一个单链表中未处理的每个结点的值插入到p3单链表中。由此得到的算法如下。
LNodePolyAdd1(LNodep1,LNodep2)
//定义表示结果多项式的单链表p3并初始化为空
LNodep3;
InitList(p3);
//分别定义t1和t2指针，初始分别指向p1和p2单链表
LNodet1=p1,t2=p2;
//当两个表同时不空时的处理过程
while(t1&&t2)
//将t1所指结点的值按指数有序插入到p3单链表中，实际是插到表尾
if(t1->data.exp<t2->data.exp)
InsertList(p3,t1->data,1);
t1=t1->next;
//将t2所指结点的值按指数有序插入到p3单链表中
elseif(t2->data.exp<t1->data.exp)
InsertList(p3,t2->data,-1);
t2=t2->next;
//将t1和t2所指结点的值合并后按指数有序插入到p3单链表中
else
doublea=t1->data.coef+t2->data.coef;
if(a!=0)
Termitem=a,t1->data.exp;
InsertList(p3,item,-1);
t1=t1->next;
t2=t2->next;
//将p1单链表中的剩余结点复制到p3单链表中
while(t1!=NULL)
InsertList(p3,t1->data,-1);
t1=t1->next;
//将p2单链表中的剩余结点复制到p3单链表中
while(t2!=NULL)
InsertList(p3,t2->data,-1);
t2=t2->next;
//返回结果单链表的表头指针p3
returnp3;
在这个算法中，t1rightarrowdata.exp<t2rightarrowdata.exp和t2rightarrowdata.exp<t1rightarrowdata.exp表达式也可以分别改写为t1rightarrowdata<t2rightarrowdata和t2rightarrowdata<t1rightarrowdata，因为进行两个Term结构对象小于号重载运算符函数比较的是其相应的指数域。
此算法依次扫描两个单链表中的每个结点，每次把一个结点的值或两个对应结点的合并值按指数有序插入到结果单链表中，因为每次插入的指数值都大于结果单链表中已有结点的值，所以只要依次插入到表尾即可。设两个加数多项式的单链表长度分别为m和n，则扫描过程的时间复杂度为O(m+n)，每次插入过程的时间复杂度也为O(m+n)，因为每次都插入到结果单链表的表尾，所以整个算法的时间复杂度为O((m+n)^2)。
section2.实现相加运算的第2种算法
每次向结果单链表插入时不是调用插入算法InsertList，而是设法记住结果单链表的表尾结点的位置，直接把新结点链接到表尾，这样插入每个结点的时间复杂度为O(1)，整个算法的时间复杂度就变为O(m+n)，从而大大提高了算法的时间效率，算法如下。
LNodePolyAdd2(LNodep1,LNodep2)
//定义结果单链表p3，并让它指向附加表头结点，这会使处理方便
LNodep3;
p3=newLNode;
//分别定义t1,t2和t3指针，初始分别指向p1,p2和p3单链表
LNodet1=p1,t2=p2,t3=p3;
//当两个表同时不空时的处理过程
while(t1&&t2)
//将t1所指结点的值赋给t3结点的值域，t1指针后移
if(t1->data.exp<t2->data.exp)
t3=t3->next=newLNode;//在p3尾部插入新结点并使t3指向它
t3->data=t1->data;
t1=t1->next;
//将t2所指结点的值赋给t3结点的值域，t2指针后移
elseif(t1->data.exp>t2->data.exp)
t3=t3->next=newLNode;
t3->data=t2->data;
t2=t2->next;
//将两结点合并后的值赋给t3结点的值域，t1和t2指针同时后移
else
doublea=t1->data.coef+t2->data.coef;
if(a!=0)
Termitem=a,t1->data.exp;
t3=t3->next=newLNode;
t3->data=item;
t1=t1->next;
t2=t2->next;
//将p1单链表中的剩余结点复制到p3单链表中
while(t1)
t3=t3->next=newLNode;
t3->data=t1->data;
t1=t1->next;
//将p2单链表中的剩余结点复制到p3单链表中
while(t2)
t3=t3->next=newLNode;
t3->data=t2->data;
t2=t2->next;
//将p3单链表的表尾结点的指针域置空
t3->next=NULL;
//让t3指向p3所指的附加表头结点，以便删除
t3=p3;
//使p3指向结果单链表的第1个元素结点
p3=t3->next;
```c
//释放原附加表头结点
deletet3;
//返回结果单链表的表头指针p3
returnp3;
算法中使用的p3单链表是带有表头附加结点的单链表,这给插入运算带来方便,不需要对空表时的插入做特殊处理,待整个运算完成后再把附加表头结点删除,使p3单链表又成为一般形式的单链表。对带有表头附加结点的单链表进行删除也同样方便,删除表头结点和删除其他位置结点的操作完全相同,因为始终不需要修改表头指针。
可以使用下面的主函数调用上面的多项式加法函数。
voidmain()
LNodea,b;
InitList(a);InitList(b);
Termra[4]=5,0,3,2,-6,3,2,5;
Termrb[6]=3,0,4,1,-2,2,3,3,-2,5,9,6;
inti;
for(i=3;i>=0;i--)InsertList(a,ra[i],1);//每次插入到表头
for(i=5;i>=0;i--)InsertList(b,rb[i],1);//每次插入到表头
cout<<"线性表a:";
TraverseList(a);
cout<<"线性表b:";
TraverseList(b);
LNodec=PolyAdd2(a,b);//或者使用PolyAdd1(a,b)调用
cout<<"线性表c:";
TraverseList(c);
ClearList(a);ClearList(b);ClearList(c);
程序执行后的结果如下:
线性表a:5032-6325
线性表b:3041-2233-2596
线性表c:804112-3396
习题2
【习题2-1】分析程序。
在下面的每个程序段中,线性表La的类型为List,元素类型ElemType为int,假定每个程序段是连续执行的,试写出每个程序段执行后所得到的线性表La。
1.inti;
ListLa;
InitList(La);
```
inta[]=48,26,57,34,62,79;
for(i=0;i<6;i++)
InsertList(La,a[i],1);
TraverseList(La);
2.ClearList(La);
InitList(La);
for(i=0;i<6;i++)
InsertList(La,a[i],0);
TraverseList(La);
3.intx;
InsertList(La,56,0);
DeleteList(La,x,1);
DeleteList(La,x,1);
InsertList(La,x,-1);
TraverseList(La);
4.for(i=1;i<=3;i++)
intx=GetList(La,i);
if(x%2==0)DeleteList(La,x,0);
TraverseList(La);
5.ClearList(La);
InitList(La);
for(i=0;i<6;i++)
InsertList(La,a[i],-1);
x=a[5];
DeleteList(La,x,0);
SortList(La);
InsertList(La,a[5]/2,0);
TraverseList(La);
ClearList(La);
【习题2-2】画出由执行算法生成的单链表的示意图。
对于习题2-1的前4个语段，假定La的类型为构造单链表的数组类型ALinkList，元素类型ElemType仍为int，并假定每个程序段是连续执行的，试画出每个程序段执行后所得到的单链表的示意图，要求在示意图的每个指针上注明具体数值。
【习题2-3】编写对具有List类型的线性表进行处理的算法。
1.从线性表中删除具有最小值的元素并由函数返回，空出的位置由最后一个元素填补，若线性表为空则显示出错信息并退出运行。
2.从线性表中删除其值在给定值s和t之间（要求s小于t）的所有元素。
3.从有序表中删除其值在给定值s和t（要求s小于t）之间的所有元素。
4.将两个有序表合并成一个新的有序表并由变量返回。
5.从线性表中删除所有其值重复的元素，使所有元素的值均不同。如对于线性表(2,8,9,2,5,6,8,7,2)，则执行此算法后变为(2,8,9,5,6,7)。
【习题2-4】编写对具有LNode结点类型的单链表进行处理的算法。
1.将一个单链表按逆序链接，若原单链表中存储元素的次序为a_1,a_2,cdots,a_n，则逆序链接后变为a_n,a_n-1,cdots,a_1。
2.从单链表中查找出所有元素的最大值，该值由函数返回，若单链表为空，则显示出错信息并停止运行。
3.统计出单链表中结点的值等于给定值x的结点个数。
4.根据一维数组a[n]建立一个单链表，使单链表中元素的次序与a[n]中元素的次序相同，并使该算法的时间复杂度为O(n)。
5.将两个有序单链表合并成一个有序单链表，合并后使原有单链表为空。
6.根据两个有序单链表生成一个新的有序单链表，原有单链表保持不变。两个有序单链表中的元素为(2,8,10,20)和(3,8,9,15,16)，则生成的新单链表中的元素为(2,3,8,8,9,10,15,16,20)。
7.根据一个元素类型为整型的单链表生成两个单链表，使得第一个单链表中包含原单链表中所有元素值为奇数的结点，使得第二个单链表中包含原单链表中所有元素值为偶数的结点，原有单链表保持不变。
【习题2-5】编写解决约瑟夫问题的算法。
编写一个算法，分别使用带表头附加结点的循环单链表、一般循环单链表（提示：设立指向表尾结点的指针将方便操作）、顺序存储的线性表解决约瑟夫(Josephus)问题。其问题是：设有n个人围坐在一张圆桌周围，先从某个人开始从1报数，数到m的人出列（即离开座位，不参加以后的报数），然后从出列的下一个人开始重新从1报数，数到m的人又出列，如此下去直到所有人都出列为止，试求出它们的出列次序。
例如，当n=8,m=4时，若从第1个人（每个人的编号依次为1,2,cdots,n）开始报数，则得到的出列次序为：4,8,5,2,1,3,7,6。
此算法要求以n、m和s（从第s个人开始第1次报数）作为值参。
【习题2-6】修改算法。
对在单链表上的插入算法进行适当修改，编写在带表头附加结点的循环单链表上实现插入元素的算法。
【习题2-7】编写对结点类型为DNode的双向循环链表进行处理的算法。
1.向双向循环链表的末尾插入一个值为x的结点。
2.从双向循环链表中删除值为x的结点。
3.向双向循环链表的第i个结点位置插入一个值为x的结点。
【习题2-8】根据下面要求编写算法。
有一种带表头附加结点的链表，每个结点含3个域：data、next和range，其中data为整型值域，next和range均为指针域，所有结点已经由next域链接起来。试编一算法，利用range域把所有结点按照其值从小到大的顺序链接起来，由此域链接得到的单链表的表头指针保存在表头附加结点的range域中。
【习题2-9】编程实现下列功能。
1.根据习题2-8对结点的要求生成一个具有10个整数元素结点的、带表头附加结点的、根据next域链接的链表，元素值采用随机函数产生。
2.根据next域链接的次序输出链表中每个结点的值。
3.调用按习题2-8要求编写的算法。
4.根据range域链接的次序输出链表中每个结点的值。
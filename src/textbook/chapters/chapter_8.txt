第8章 图的应用

图在工程技术和日常生活中有着广泛地应用，常常都涉及到求图的最小生成树、最短路径、拓扑序列、关键路径等对图的特定运算的问题。本章就这些运算的方法和算法进行深入讨论。

\section*{8.1 图的生成树和最小生成树}

\subsection*{8.1.1 生成树和最小生成树的概念}

在一个连通图$G$中，如果取它的全部顶点和一部分边构成一个子图$G'$，即：$V(G')=V(G) \text { 和 } E(G') \subseteq E(G)$若边集$E(G')$中的边将图中的所有顶点连通又不形成回路，则称子图$G'$是原图$G$的一棵生成树。

既连通图$G$中的全部$n$个顶点又没有回路的子图$G'$（即生成树）必含有$n-1$条边。要构造子图$G'$，首先从图$G$中任取一个顶点加入$G'$中，此时$G'$中只有一个顶点，假定具有一个顶点的图是连通的，以后每向$G'$中加入一个顶点，都要加入以该顶点为一个端点，以已连通的顶点之中的一个顶点为另一个端点的一条边，这样既连通了该顶点又不会产生回路，进行$n-1$次后，就向$G'$中加入了$n-1$个顶点和$n-1$条边，使得$G'$中的$n$个顶点既连通又不产生回路。

在图$G$的一棵生成树$G'$中，若再增加一条边，就会出现一条回路。这是因为此边的两个端点已连通，再加入此边后，这两个端点间有两条路径，因此就形成了一条回路，子图$G'$也就不再是生成树了。同样，若从生成树$G'$中删去一条边，就使得$G'$变为非连通图。因为此边的两个端点是靠此边唯一连通的，删除此边后，必定使这两个端点分属于两个连通分量中，使$G'$变成了具有两个连通分量的非连通图。

同一个图可以有不同的生成树。如图 8-1(b)、图 8-1(c)、图 8-1(d) 所示都是图 8-1(a) 的生成树。在每棵生成树中都包含有 8 个顶点和 7 条边，它们的差别只是边的选取不同。

在这 3 棵生成树中，图 8-1(b) 所示生成树是从图中顶点$v_0$出发利用深度优先搜索遍历得到的，被称为深度优先生成树；生成树图 8-1(c) 所示是从顶点$v_0$出发利用广度优先搜索遍历得到的，被称为广度优先生成树；生成树图 8-1(d) 所示是任意一棵生成树。当然图 8-1(a) 的生成树远不止这几种，只要能连通所有顶点而又不产生回路的子图都是它的生成树。由于连通图的生成树使用最少的边连通了图中的所有顶点，所以它又是能够连通图中所有顶点的极小连通子图。

对于一个连通网（即无向连通带权图，假定每条边上的权均为大于零的实数）来说，生成树不同，每棵树的权（即树中所有边上的权值总和）也可能不同。如图 8-2 (a) 所示是一个连通网，如图 8-2 (b)、图 8-2 (c)、图 8-2 (d) 所示是它的三棵生成树，每棵树的权都不同，它们分别为 57、53 和 38。具有权最小的生成树称为图的最小生成树（minimum spanning tree）。通过后面将要介绍的构造最小生成树的算法可知，图 8-2 (d) 所示就是图 8-2 (a) 所示的最小生成树。

\n

求图的最小生成树具有实际意义。例如，若一个连通网表示城市之间的通信系统，网的顶点代表城市，网的边代表城市之间架设通信线路的造价，各城市之间的距离不同，地理条件不同，其造价也不同，即边上的权不同，现在要求既连通所有城市又使总造价最低，这就是一个求图的最小生成树的问题。

求图的最小生成树的算法主要有两个：普里姆（Prim）算法和克鲁斯卡尔（Kruskal）\n算法。下面分别进行讨论。

\section*{8.1.2 普里姆算法}

假设$G=(V, E)$是一个具有$n$个顶点的连通网，$T=(U, TE)$是$G$的最小生成树，其中，\n$U$是$T$的顶点集，$TE$是$T$的边集，$U$和$TE$的初值均为空集。算法开始时，首先从$V$中任\n取一个顶点（取$v_0$），将它并入$U$中，此时$U=\{v_0\}$，然后只要$U$是$V$的真子集（即$U \subset V$），\n就从那些其一个端点已在$T$中，另一个端点仍在$T$外的所有边中，找一条最短（即权值最\n小）边，假定为$(i, j)$，其中$v_i \in U$，$v_j \in (V-U)$，并把该边$(i, j)$和顶点$j$分别并入$T$的边集\n$TE$和顶点集$U$，如此进行下去，每次往生成树里并入一个顶点和一条边，直到$n-1$次后就\n把所有$n$个顶点都并入到生成树$T$的顶点集中，此时$U=V$，$TE$中含有$n-1$条边，$T$就是最后\n得到的最小生成树。

普里姆算法的关键之处是：每次如何从生成树$T$中到$T$外的所有边中，找出一条最短\n边。例如，在第$k$次 ($1 \leq k \leq n-1$) 前，生成树$T$中已有$k$个顶点和$k-1$条边，此时$T$中到$T$\n外的所有边数为$k(n-k)$，当然它包括两顶点间没有直接边相连，其权值被看做为常量\nMaxValue 的边在内，从如此多的边中查找最短边，其时间复杂度为$O(k(n-k))$，显然是很费\n时的。是否有一种好的方法能够降低查找最短边的时间复杂度呢？回答是肯定的，它能\n够使查找最短边的时间复杂度降低到$O(n-k)$。方法是：设在进行第$k$次前已经保留着从$T$\n中到$T$外每一顶点（共$n-k$个顶点）的一条最短边，进行第$k$次时，首先从这$n-k$条最\n短边中，找出一条最短的边，它就是从$T$中到$T$外的所有边中的最短边，设为$(i, j)$，此\n步需进行$n-k$次比较；然后把边$(i, j)$和顶点$j$分别并入$T$中的边集$TE$和顶点集$U$中，此时\n$T$外只有$n-(k+1)$个顶点，对于其中的每个顶点$t$，若$(j, t)$边上的权值小于已保留的从原$T$\n中到顶点$t$的最短边的权值，则用$(j, t)$修改之，使从$T$中到$T$外顶点$t$的最短边为$(j, t)$，\n否则原有最短边保持不变，这样，就把第$k$次后从$T$中到$T$外每一顶点$t$的各一条最短边\n都保留下来了，为进行第$k+1$次运算做好了准备，此步需进行$n-k-1$次比较。所以，利用\n此方法求第$k$次的最短边共需比较$2(n-k)-1$次，即时\n间复杂度为$O(n-k)$。

对于图 8-2 (a) 所示生成树，它的邻接矩阵如图 8-3\n所示，若从$v_0$出发利用普里姆算法构造最小生成树$T$，\n在其过程中，每次（第 0 次为初始状态）向$T$中并入一\n个顶点和一条边后，顶点集$U$、边集$TE$（每条边的后\n面为该边的权）以及从$T$中到$T$外每个顶点的各一条最\n短边所构成的集合（设用$LW$表示）的状态如下。\n

第 0 次$U=\{0\}$\n$TE=\{\}$\n$LW=\{(0,1)8,(0,2)\infty,(0,3)5,(0,4)\infty,(0,5)\infty,(0,6)\infty\}$\n

第 1 次$U=\{0,3\}$\n$TE=\{(0,3)5\}$\n$LW=\{(3,1)3,(0,2)\infty,(0,4)\infty,(3,5)7,(3,6)15\}$\n

第2次$U=\{0,3,1\}$TE=\{(0,3)5,(3,1)3\}$LW=\{(1,2)12,(1,4)10,(3,5)7,(3,6)15\}$第3次$U=\{0,3,1,5\}$TE=\{(0,3)5,(3,1)3,(3,5)7\}$LW=\{(5,2)2,(5,4)9,(3,6)15\}$第4次$U=\{0,3,1,5,2\}$TE=\{(0,3)5,(3,1)3,(3,5)7,(5,2)2\}$LW=\{(2,4)6,(3,6)15\}$第5次$U=\{0,3,1,5,2,4\}$TE=\{(0,3)5,(3,1)3,(3,5)7,(5,2)2,(2,4)6\}$LW=\{(3,6)15\}$第6次$U=\{0,3,1,5,2,4,6\}$TE=\{(0,3)5,(3,1)3,(3,5)7,(5,2)2,(2,4)6,(3,6)15\}$LW=\{\}$每次对应的图形如图8-4(b)～图8-4(h)所示，其中粗实线表示新加入到$TE$集合中的边，细实线表示已加入到$TE$集合中的边，虚线表示$LW$集合中的边，但权值为MaxValue的边实际上是不存在的，所以没被画出。

(a) 连通网
(b) 第0次
(c) 第1次
(d) 第2次
(e) 第3次
(f) 第4次
(g) 第5次
(h) 第6次

图8-4 利用普里姆算法求图的最小生成树的示意图

如图 8-4 (h) 所示就是最后得到的最小生成树, 它同图 8-2 (d) 是完全一样的, 所以图 8-2 (d) 是图 8-2 (a) 的最小生成树。

通过以上分析可知，在构造最小生成树的过程中，在进行第$k$次$(1 \leq k \leq n-1)$前，边集$TE$中的边数为$k-1$条，从$T$中到$T$外每一顶点的最短边集$LW$中的边数为$n-k$条，$TE$和$LW$中的边数总和为$n-1$条。为了保存这$n-1$条边，设用至少具有$n-1$个元素的边集数组类型（即 edgeset 类型）的对象 CT 来存储，其中 CT 的前$k-1$个元素（即 CT[0]~CT[k-2]）保存$TE$中的边，后$n-k$个元素（即 CT[k-1]~CT[n-2]）保存$LW$中的边。在进行第$k$次时，首先从下标为$k-1$~$n-2$的元素（即$LW$中的边）中查找出权值最小的边，设为 CT[m]；接着把边 CT[k-1]与 CT[m]对调，确保在第$k$次后 CT 的前$k$个元素保存着$TE$中的边，后$n-k-1$个元素保存着$LW$中的边；然后再修改$LW$中的有关边，使得从$T$中到$T$外每一顶点的各一条最短边被保存下来。这样经过$n-1$次运算后，CT 中就按序保存着最小生成树中的全部$n-1$条边。

根据分析，编写利用普里姆算法产生图的最小生成树的算法描述如下。

void Prim(adjmatrix GA, edgeset CT, int n)
    //利用普里姆算法从顶点 v_0 出发求出用邻接矩阵 GA 表示的图的
    //最小生成树，最小生成树的边集存于数组 CT 中
{
    int i,j,k,min,t,m,w;
    //给 CT 赋初值，对应第 0 次的 LW 值
    for(i=0; i<n-1; i++) {
        CT[i].fromvex=0;
        CT[i].endvex=i+1;
        CT[i].weight=GA[0][i+1];
    }
    //进行 n-1 次循环，每次求出最小生成树中的第 k 条边
    for(k=1; k<n; k++)
    {
        //从 CT[k-1]~CT[n-2]（即 LW）中查找最短边 CT[m]
        min=MaxValue;
        m=k-1;
        for(j=k-1; j<n-1; j++)
            if(CT[j].weight<min) {
                min=CT[j].weight;
                m=j;
            }
        //把最短边对调到第 k-1 下标位置
        edge temp=CT[k-1];
        CT[k-1]=CT[m];
        CT[m]=temp;
        //把新加入最小生成树 T 中的顶点序号赋给 j
        j=CT[k-1].endvex;
        //修改 LW 中的有关边，使 T 中到 T 外的每一个顶点各保持

//一条到目前为止最短的边
for(i=k; i<n-1; i++) {
    t=CT[i].endvex;
    w=GA[j][t];
    if(w<CT[i].weight) {
        CT[i].weight=w;
        CT[i].fromvex=j;
    }
} //内 for end
} //外 for end

若利用图 8-3 所示的邻接矩阵调用此算法，则得到的边集数组 CT 中的内容如表 8-1 所示。

表 8-1 边集数组

\begin{tabular}{c|c|c|c|c|c|c}
\hline CT & 0 & 1 & 2 & 3 & 4 & 5 \\
\hline fromvex & 0 & 3 & 3 & 5 & 2 & 3 \\
\hline endvex & 3 & 1 & 5 & 2 & 4 & 6 \\
\hline weight & 5 & 3 & 7 & 2 & 6 & 15 \\
\hline
\end{tabular}

8.1.3 克鲁斯卡尔算法

假设$G=(V, E)$是一个具有$n$个顶点的连通网，$T=(U, TE)$是$G$的最小生成树，$U$的初值等于$V$，即包含有$G$中的全部顶点，$TE$的初值为空。此算法的基本思想是：将图$G$中的边按权值从小到大的顺序依次选取，若选取的边使生成树$T$不形成回路，则把它并入$TE$中，保留作为$T$的一条边；若选取的边使生成树$T$形成回路，则将其舍弃，如此进行下去，直到$TE$中包含有$n-1$条边为止，此时的$T$即为最小生成树。

以如图 8-5(a)所示为例来说明此算法。设此图是用边集数组表示的，且数组中各边是按权值从小到大的顺序排列的，若没有按序排列，则可通过调用排序算法，使之成为有序，如图 8-5(b)所示，这样按权值从小到大选取各边就转换成按边集数组中下标次序选取各边。当选取前 3 条边时，均不产生回路，应保留作为生成树$T$的边，如图 8-5(b)所示；选第 4 条边(2,3)时，将与已保留的边形成回路，应舍去；接着保留(1,5)边，舍去(3,5)边；取到(0,1)边并保留后，保留的边数已够 5 条（即$n-1$条），此时必定将全部 6 个顶点连通起来，如图 8-5(c)所示，它就是图 8-5(a)的最小生成树。

实现克鲁斯卡尔算法的关键之处是：如何判断欲加入$T$中的一条边是否与生成树中已保留的边形成回路。这可将各项点划分为不同集合的方法来解决，每个集合中的顶点表示一个无回路的连通分量。算法开始时，由于生成树的顶点集等于图$G$的顶点集，边集为空，所以$n$个顶点分属于$n$个集合，每个集合中只有一个顶点，表明顶点之间互不连通。例如对于图 8-5(a)，其六个集合为：$\{0\}, \{1\}, \{2\}, \{3\}, \{4\}, \{5\}$

(a) 连通网

(b) 取到三条边

(c) 最小生成树

(d) 边集数组

图 8-5 克鲁斯卡尔算法求最小生成树的示意图

当从边集数组中按次序选取一条边时, 若它的两个端点分属于不同的集合, 则表明此边连通了两个不同的连通分量, 因每个连通分量无回路, 所以连通后得到的连通分量仍不会产生回路, 此边应保留作为生成树的一条边, 同时把端点所在的两个集合合并成一个, 即成为一个连通分量; 当选取的一条边的两个端点同属于一个集合时, 此边应放弃, 因同一个集合中的顶点是连通无回路的, 若再加入一条边则必产生回路。在上述例子中, 当选取(0,4)、(1,2)、(1,3)这三条边后, 顶点的集合则变成如下 3 个:$\{0,4\}, \{1,2,3\}, \{5\}$下一条边(2,3)的两端点同属于一个集合, 故舍去, 再下一条边(1,5)的两端点属于不同的集合, 应保留, 同时把两个集合$\{1,2,3\}$和$\{5\}$合并成一个$\{1,2,3,5\}$, 以此类推, 直到所有顶点同属于一个集合, 即进行了$n-1$次合并, 保留了$n-1$条生成树的边为止。

为了用 C++语言编写出利用克鲁斯卡尔算法求图的最小生成树的具体实现, 设 GE 是具有 edgeset 类型的边集数组, 并假定每条边是按照权值从小到大的顺序存放的; 再设 CT 也是一个具有 edgeset 类型的边集数组, 用该数组存储依次所求得的生成树中的每一条边; 另外, 还要设一个具有 bool 类型的一个二维数组, 用 s[n][n]表示, 它的每一行元素用来保存相应连通子图所在的顶点集合, 若该行中的下标为 t 的元素为真, 则表明顶点$v_t$属于这个集合。

根据以上分析, 给出克鲁斯卡尔算法的具体描述如下。

void Kruskal(edgeset GE, edgeset CT, int n)
    //求边集数组 GE 所示图的最小生成树, 树中每条边依次存于数组 CT 中
{
    int i,j;
    //定义具有 n*n 个元素的动态分配的二维数组 s
    bool**s=new bool*[n];
    for(i=0;i<n;i++) s[i]=new bool[n];
    //初始化 s 集合, 使每一个顶点分属于对应集合
    for(i=0; i<n; i++) {

```cpp
for(j=0; j<n; j++)
    if(i==j) s[i][j]=true;
    else s[i][j]=false;
}
//定义相应变量
int k=1;      //k表示待获取的最小生成树中的边数,初值为1
int d=0;      //d表示在GE中待扫描边元素的下标位置,初值为0
int m1,m2;    //m1和m2分别保存一条边的两个顶点所在集合的序号
//进行n-1次循环,得到最小生成树中的n-1条边
while(k<n)
{
    for(i=0; i<n; i++)
    {
        //求出边GE[d]的两个顶点所在集合的序号m1和m2
        if(s[i][GE[d].fromvex]==true) m1=i;
        if(s[i][GE[d].endvex]==true) m2=i;
    }
    if(m1!=m2)
    {
        //若两集合序号不等,则表明GE[d]是生成树中的一条边
        //应将它加入到数组CT中
        CT[k-1]=GE[d];
        k++;
        for(j=0; j<n; j++)
        {
            //合并两个集合,并将另一个置为空集
            s[m1][j]=s[m1][j] || s[m2][j];
            s[m2][j]=false;
        }
    }
    d++;       //d后移一个位置,以便扫描GE中的下一条边
}
//释放为s动态分配的数组空间
for(i=0;i<n;i++) delete[] s[i];
delete[] s;
}

若利用图8-5(d)所示的边集数组调用此算法,则最后得到的CT数组如表8-2所示。

表8-2 数组CT

\begin{tabular}{c|c|c|c|c|c|}
\hline
CT & 0 & 1 & 2 & 3 & 4 \\
\hline
fromvex & 0 & 1 & 1 & 1 & 0 \\
\hline
endvex & 4 & 2 & 3 & 5 & 1 \\
\hline
weight & 4 & 5 & 8 & 12 & 18 \\
\hline
\end{tabular}

以上两个算法的时间复杂度均为$O(n^2)$,普里姆算法的空间复杂度为$O(1)$,克鲁斯卡尔算法的空间复杂度为$O(n^2)$。
```

当一个连通网中不存在权值相同的边时，无论采用什么方法得到的最小生成树都是唯一的，但若存在着相同权值的边则得到的最小生成树可能不唯一，当然最小生成树的权是相同的。

\section*{8.2 最短路径}

\subsection*{8.2.1 最短路径的概念}

由图的概念可知，在一个图中，若从一顶点到另一项点存在着一条路径(本节只讨论无回路的简单路径)，则路径长度为该路径上所经过的边的数目，它也等于该路径上的顶点数减1。由于从一项点到另一项点可能存在着多条路径，每条路径上所经过的边数可能不同，即路径长度不同，把路径长度最短(即经过的边数最少)的那条路径叫做最短路径，其路径长度叫做最短路径长度或最短距离。

图的最短路径问题不只是对无权图而言的，若图是带权图，则把从一个顶点$i$到图中其余任一个顶点$j$的一条路径上所经过边的权值之和定义为该路径的带权路径长度，从$v_i$到$v_j$可能不止一条路径，把带权路径长度最短（即其值最小）的那条路径也称做最短路径，其权值也称做最短路径长度或最短距离。

如图 8-6 所示，从$v_0 \sim v_4$共有 3 条路径：$\{0, 4\}$、$\{0, 1, 3, 4\}$和$\{0, 1, 2, 4\}$，其带权路径长度分别为 30, 23 和 38，可知最短路径为$\{0, 1, 3, 4\}$，最短距离为 23。

(a) 带权图

(b) 邻接矩阵

图 8-6 带权图和对应的邻接矩阵

实际上，这两类最短路径问题可合并为一类，只要把无权图上的每条边标上数值为1的权就归属于有权图了，所以在以后的讨论中，若不特别指明，均认为是求带权图的最短路径问题。

求图的最短路径问题用途很广。例如，若用一个图表示城市之间的运输网，图的顶点代表城市，图上的边表示两端点对应城市之间存在着运输线，边上的权表示该运输线上的运输时间或单位重量的运费，考虑到两城市间的海拔高度不同，流水方向不同等因素，将造成来回运输时间或运费的不同，所以这种图通常是一个有向图。如何能够使从一城市到另一城市的运输时间最短或者运费最省呢？这就是一个求两城市间的最短路径问题。

求图的最短路径问题包括两个方面：求图中一顶点到其余各项点的最短路径；求图中

每对顶点之间的最短路径。下面分别进行讨论。

\section*{8.2 .2 从一顶点到其余各顶点的最短路径}

对于一个具有$n$个顶点和$e$条边的图$G$, 从某一项点$v_i$(称此为源点) 到其余任一项点$v_j$(称此为终点) 的最短路径, 可能是它们之间的边$(i,j)$或$\langle i,j\rangle$, 也可能是经过$k$个$(1 \leq k \leq n-2$, 最多经过除源点和终点之外的所有顶点) 中间顶点和$k+1$条边所形成的路径。在图 8-6 中, 从$v_0$到$v_1$的最短路径就是它们之间的有向边$\langle 0,1\rangle$, 其长度为 3; 从$v_0$到$v_4$的最短路径经过两个中间点$v_1$和$v_3$以及 3 条有向边$\langle 0,1\rangle,\langle 1,3\rangle$和$\langle 3,4\rangle$, 其长度为 23。

那么, 如何求出从源点$i$到图中其余每一个顶点的最短路径呢? 狄克斯特拉 (Dijkstra) 于 1959 年提出了解决此问题的一般算法, 具体做法是按照从源点到其余每一顶点的最短路径长度的升序依次求出从源点到各顶点的最短路径及长度, 每次求出从源点$i$到一个终点$m$的最短路径及长度后, 都要以该顶点$m$作为新考虑的中间点, 用$v_i$到$v_m$的最短路径和最短路径长度对$v_i$到其他尚未求出最短路径的那些终点的当前最短路径及长度作必要地修改, 使之成为当前新的最短路径和最短路径长度, 当进行$n-2$次 (因最多考虑$n-2$个中间点) 后算法结束。

狄克斯特拉算法需要设置一个集合, 用$S$表示, 其作用是保存已求得最短路径的终点序号, 它的初值中只有一个元素, 即源点$i$, 以后每求出一个从源点$i$到终点$m$的最短路径, 就将该顶点$m$并入$S$集合中, 以便作为新考虑的中间点; 还需要设置一个具有权值类型的一维数组$\text { dist}[n]$, 该数组中的第$j$个元素$\text { dist}[j]$用来保存从源点$i$到终点$j$的目前最短路径长度, 它的初值为$(i,j)$或$\langle i,j\rangle$边上的权值, 若$v_i$到$v_j$没有边, 则权值为 MaxValue, 以后每考虑一个新的中间点时,$\text { dist}[j]$的值可能变小; 另外, 再设置一个与$\text { dist}$数组相对应的、类型为 edgenode* 的一维指针数组 path, 该数组中的第$j$个元素$\text { path}[j]$指向一个单链表, 该单链表中保存着从源点$i$到终点$j$的目前最短路径, 即一个顶点序列, 当$v_i$到$v_j$存在着一条边时, 则$\text { path}[j]$初始指向由顶点$i$和$j$构成的单链表, 否则$\text { path}[j]$的初值为空。

此算法的执行过程是: 首先从$S$集合以外的顶点 (即待求出最短路径的终点) 所对应的$\text { dist}$数组元素中, 查找出其值最小的元素, 假定为$\text { dist}[m]$, 该元素值就是从源点$i$到终点$m$的最短路径长度 (证明从略), 对应$\text { path}$数组中的元素$\text { path}[m]$所指向的单链表链接着从源点$i$到终点$m$的最短路径, 即经过的顶点序列或称边序列; 接着把己求得最短路径的终点$m$并入集合$S$中; 然后以$v_m$作为新考虑的中间点, 对$S$集合以外的每个顶点$j$, 比较$\text { dist}[m]+\text { GA}[m][j]$($\text { GA}$为图$G$的邻接矩阵) 与$\text { dist}[j]$的大小, 若前者小于后者, 表明加入了新的中间点$v_m$之后, 从$v_i$到$v_j$的路径长度比原来变短, 应用它替换$\text { dist}[j]$的原值, 使$\text { dist}[j]$始终保持到目前为止最短的路径长度, 同时把$\text { path}[m]$单链表复制到$\text { path}[j]$上, 并在其后插入$v_j$结点, 使之构成从源点$i$到终点$j$的目前最短路径。重复$n-2$次上述运算过程, 即可在$\text { dist}$数组中得到从源点$i$到其余每个顶点的最短路径长度, 在$\text { path}$数组中得到相应的最短路径。

为了简便起见, 可采用一维数组$s[n]$来保存已求得最短路径的终点的集合$S$, 具体做法是: 若顶点$j$在集合$S$中, 则令数组元素$s[j]$的值为真, 否则为假。这样, 当判断一个顶点$j$是否在集合$S$以外时, 只要判断对应的数组元素$s[j]$是否为假即可。

例如，对于图 8-6 来说，若求从源点$v_0$到其余各顶点的最短路径，则开始时 3 个一维数组 s,dist 和 path 的值如表 8-3 所示。

表 8-3 初始状态

\begin{tabular}{c|c|c|c|c|c|}
\hline & 0 & 1 & 2 & 3 & 4 \\
\hline s & 1 & 0 & 0 & 0 & 0 \\
\hline dist & 0 & 3 &$\infty$&$\infty$& 30 \\
\hline path & &$v_{0}, v_{1}$& & &$v_{0}, v_{4}$\\
\hline
\end{tabular}

开始进行第 1 次运算，求出从源点$v_0$到第 1 个终点的最短路径。首先从 s 元素为 0 的对应 dist 元素中，查找出值最小的元素，求得 dist[1]的值最小，所以第 1 个终点为$v_1$，最短距离为 dist[1]=3，最短路径为 path[1]={0,1}，接着把 s[1]置为真(1)，表示$v_1$已加入 S 集合中，然后以$v_1$为新考虑的中间点，对 s 数组中元素为假(0)的每个顶点 j（此时$2 \leq j \leq 4$）的目前最短路径长度 dist[j]和目前最短路径 path[j]进行必要的修改，因 dist[1]+GA[1][2]=3+25=28，小于 dist[2]=$\infty$，所以将 28 赋给 dist[2]，将 path[1]并上$v_2$后赋给 path[2]，同理因 dist[1]+GA[1][3]=3+8=11，小于 dist[3]=$\infty$，所以将 11 赋给 dist[3]，将 path[1]并上$v_3$后赋给 path[3]，最后再看从$v_0$到$v_4$，以$v_1$作为新考虑的中间点的情况，由于$v_1$到$v_4$没有出边，所以 GA[1][4]=$\infty$，故 dist[1]+GA[1][4]不小于 dist[4]，因此 dist[4]和 path[4]无需修改，应维持原值。至此，第 1 次运算结束，3 个一维数组的当前状态如表 8-4 所示。

表 8-4 得到终点$v_1$\begin{tabular}{c|c|c|c|c|c|}
\hline & 0 & 1 & 2 & 3 & 4 \\
\hline s & 1 & 1 & 0 & 0 & 0 \\
\hline dist & 0 & 3 & 28 & 11 & 30 \\
\hline path & &$v_{0}, v_{1}$&$v_{0}, v_{1}, v_{2}$&$v_{0}, v_{1}, v_{3}$&$v_{0}, v_{4}$\\
\hline
\end{tabular}

接着进行第 2 次运算，求出从源点$v_0$到第 2 个终点的最短路径。首先从 s 数组中元素为 0 的对应 dist 元素中，查找出值最小的元素，求得 dist[3]的值最小，所以第 2 个终点为$v_3$，最短距离为 dist[3]=11，最短路径为 path[3]={0,1,3}，接着把 s[3]置为 1，然后以$v_3$作为新考虑的中间点，对 s 中元素为 0 的每个顶点 j（此时$j=2,4$）的 dist[j]和 path[j]进行必要的修改，因 dist[3]+GA[3][2]=11+4=15，小于 dist[2]=28，所以将 15 赋给 dist[2]，将 path[3]并上$v_2$后赋给 path[2]，同理，因 dist[3]+GA[3][4]=11+12=23，小于 dist[4]=30，所以将 23 赋给 dist[4]，将 path[3]并上$v_4$后赋给 path[4]。至此，第 2 次运算结束，3 个一维数组的当前状态如表 8-5 所示。

表 8-5 得到终点$v_3$\begin{tabular}{c|c|c|c|c|c|}
\hline & 0 & 1 & 2 & 3 & 4 \\
\hline s & 1 & 1 & 0 & 1 & 0 \\
\hline dist & 0 & 3 & 15 & 11 & 23 \\
\hline path & &$v_{0}, v_{1}$&$v_{0}, v_{1}, v_{3}, v_{2}$&$v_{0}, v_{1}, v_{3}$&$v_{0}, v_{1}, v_{3}, v_{4}$\\
\hline
\end{tabular}

然后进行第 3 次运算，求出从源点$v_0$到第 3 个终点的最短路径。首先从 s 中元素为

0 的对应 dist 元素中, 查找出值最小的元素为$dist[2]$，所以求得第 3 个终点为$v_2$，最短距离为$dist[2]=15$，最短路径为$path[2]=(0,1,3,2)$，接着把$s[2]$置为 1，然后以$v_2$作为新考虑的中间点，对$s$中元素为 0 的每个顶点$j$（此时只有$v_4$一个）的$dist[j]$和$path[j]$进行必要的修改，因$dist[2]+GA[2][4]=15+10=25$，大于$dist[4]=23$，所以无需修改，原值不变。至此，第 3 次运算结束，3 个一维数组的当前状态如表 8-6 所示。

表 8-6 得到终点$v_2$\begin{tabular}{|c|c|c|c|c|c|}
\hline & 0 & 1 & 2 & 3 & 4 \\
\hline \multirow{3}{*}{ s } & \multicolumn{5}{|c|}{\begin{tabular}{l} 
0 \\
1
\end{tabular}} \\
\hline dist & 0 & 3 & 15 & 11 & 23 \\
\hline path & &$v_0,v_1$&$v_0,v_1,v_3,v_2$&$v_0,v_1,v_3$&$v_0,v_1,v_3,v_4$\\
\hline
\end{tabular}

由于图中有 5 个顶点，只需运算 3 次，即$n-2$次，虽然此时还有一个顶点未加入 S 集合中，但它的最短路径及最短距离已经最后确定，所以整个运算结束。最后在$dist$中得到从源点$v_0$到每个顶点的最短路径长度，在$path$中得到相应的最短路径。

如果用图形表示上述过程中每次运算的结果，则对应的图形分别如图 8-7(b)～图 8-7(e)所示，其中实线有向边所指向的顶点为集合 S 中的顶点，虚线有向边所指向的顶点为集合 S 外的顶点；S 集合中的顶点上所标数值为从源点$v_0$到该顶点的最短路径长度，从源点$v_0$到该顶点所经过的有向边为从$v_0$到该顶点的最短路径；S 集合外的顶点上所标数值为从源点$v_0$到该顶点的目前最短路径长度，从$v_0$到该顶点所经过的有向边为从$v_0$到该顶点的目前最短路径。为了便于对照分析，把图 8-6(a)重画于图 8-7(a)中。

(a) 带权图

(b) 初始状态

(c) 得到终点$v_1$(d) 得到终点$v_3$(e) 得到终点$v_2$图 8-7 利用狄克斯特拉算法求最短路径的图形说明

根据以上分析和举例，不难给出狄克斯特拉算法的描述如下。

void Dijkstra(adjmatrix GA, int dist[], 
              edgenode* path[], int i, int n)
    //利用狄克斯德拉算法求图GA中从顶点i到其余每个顶点间的
    //最短距离和最短路径，它们分别被存于数组dist和path中
{
    int j,k,w,m;
    //定义作为集合使用的动态数组s
    bool*s=new bool[n];
    //分别给s,dist和path数组赋初值
    for(j=0; j<n; j++) {
        if(j==i) s[j]=true; else s[j]=false;
        dist[j]=GA[i][j];
        if(dist[j]<MaxValue && j!=i) {
            edgenode*p1=new edgenode;
            edgenode*p2=new edgenode;
            p1->adjvex=i; p2->adjvex=j; p2->next=NULL;
            p1->next=p2; path[j]=p1;
        }
        else
            path[j]=NULL;
    }
    //共进行n-2次循环，每次求出从源点i到终点m的最短路径及长度
    for(k=1; k<=n-2; k++)
    {
        //求出第k个终点m
        w=MaxValue; m=i;
        for(j=0; j<n; j++)
            if(s[j]==false && dist[j]<w) {
                w=dist[j]; m=j;
            }
        //若条件成立，则把顶点m并入集合S中，否则退出循环，因为剩余
        //的顶点，其最短路径长度均为MaxValue，无需再计算下去
        if(m!=i) s[m]=true;
        else break;
        //对s元素为false的对应dist和path中的元素作必要修改
        for(j=0; j<n; j++)
            if(s[j]==false && dist[m]+GA[m][j]<dist[j]) {
                dist[j]=dist[m]+GA[m][j];
                PATH(path, m, j);  //调用此函数，由到顶点m的最
                                    //短路径和顶点j构成到顶点j的目前最短路径
            }
    }
}

PATH 函数的定义如下。

void PATH (edgenode *path, int m, int j)
{
    //由到顶点$m$的最短路径和顶点$j$构成到顶点$j$的目前最短路径
    edgenode *p,*q,*s;
    //把顶点$j$的当前最短路径清除掉
    p=path[j];
    while(p!=NULL) {
        path[j]=p->next;
        delete p;
        p=path[j];
    }
    //把到顶点$m$的最短路径复制过来到顶点$j$的最短路径上
    p=path[m];
    while(p!=NULL) {
        q=new edgenode;
        q->adjvex=p->adjvex;
        if(path[j]==NULL) path[j]=q;
        else s->next=q;
        s=q;
        p=p->next;
    }
    //把顶点$j$加入到 path[j]单链表的最后，形成新的目前最短路径
    q=new edgenode;
    q->adjvex=j;
    q->next=NULL;
    s->next=q;
}

*8.2.3 每对顶点之间的最短路径

求图中每对顶点之间的最短路径是指把图中任意两个顶点$v_i$和$v_j(i \neq j)$之间的最短路径都计算出来。若图中有$n$个顶点，则共需要计算$n(n-1)$条最短路径。解决此问题有两种方法：第 1 种是分别以图中的每个顶点为源点共调用$n$次狄克斯特拉算法，因狄克斯特拉算法的时间复杂度为$O(n^2)$，所以此方法的时间复杂度为$O(n^3)$；第 2 种是采用下面介绍的弗洛伊德（Floyd）算法，此算法的时间复杂度仍为$O(n^3)$，但比较简单。

弗洛伊德算法从图的邻接矩阵开始，按照顶点$v_0,v_1,\cdots,v_{n-1}$的次序，分别以每个顶点$v_k(0 \leq k < n-1)$作为新考虑的中间点，在第$k-1$次运算得到的$A^{(k-1)}(A^{(-1)})$为图的邻接矩阵$GA$的基础上，求出每对顶点$v_i$到$v_j$的目前最短路径长度$A^{(k)}[i][j]$，计算公式为：$A^{(k)}[i][j]=\min(A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]) \quad (0 \leq i \leq n-1, \; 0 \leq j \leq n-1)$其中，$\min$函数表示取其参数表中的较小值，参数表中的前项表在第$k-1$次运算后得到的从$v_i$到$v_j$的目前最短路径长度，后项表示考虑以$v_k$作为新的中间点所得到的从$v_i$到$v_j$

的路径长度。若后项小于前项，则表明以$v_k$作为中间点（不排除已经以$v_0,v_1,\cdots,v_{n-1}$中的
一部分作为其中间点）使得从$v_i$到$v_j$的路径长度变短，所以应把它的值赋给$A^{(k)}[i][j]$，否则把$A^{(k-1)}[i][j]$的值赋给$A^{(k)}[i][j]$。总之，使$A^{(k)}[i][j]$保存第$k$次运算后得到的从$v_i$到$v_j$的
目前最短路径长度。当$k$从0取到$n-1$后，矩阵$A^{(n-1)}$就是最后得到的结果，其中每个元素$A^{(n-1)}[i][j]$就是从顶点$v_i$到$v_j$的最短路径长度。

对于上面的计算公式，当$i=j$时变为：$A^{(k)}[i][i]=\min(A^{(k-1)}[i][i], A^{(k-1)}[i][k]+A^{(k-1)}[k][i]) \quad (0\leq i\leq n-1)$若$k=0$，则参数表中的前项$A^{(-1)}[i][i]=GA[i][i]=0$，后项$A^{(-1)}[i][0]+A^{(-1)}[0][i]$必定大于等于0，所以$A^{(0)}$中的对角线元素同$A^{(-1)}$中的对角线元素一样，均为0。同理，当$k=1,2,\cdots,n-1$时，$A^{(k)}$中的对角线元素也均为0。

对于上面的计算公式，当$i=k$或$j=k$时分别变为：$\begin{aligned}
A^{(k)}[k][j] &= \min(A^{(k-1)}[k][j], A^{(k-1)}[k][k]+A^{(k-1)}[k][j]) \quad (0\leq j\leq n-1) \\
A^{(k)}[i][k] &= \min(A^{(k-1)}[i][k], A^{(k-1)}[i][k]+A^{(k-1)}[k][k]) \quad (0\leq i\leq n-1)
\end{aligned}$每个参数表中的后一项都由它的前一项加上$A^{(k-1)}[k][k]$所组成，因$A^{(k-1)}[k][k]=0$，所
以$A^{(k)}[k][j]$和$A^{(k)}[i][k]$分别取上一次的运算结果$A^{(k-1)}[k][j]$和$A^{(k-1)}[i][k]$的值，也就是说，
矩阵$A^{(k)}$中的第$k$行和第$k$列上的元素均取上一次运算的结果。

下面以如图8-8(a)所示中每对顶点之间的最短路径长度为例来说明弗洛伊德算法的运算过程。
\n
(a) 有向带权图
(b) 邻接矩阵
(c) 第0次运算结果
(d) 第1次运算结果
(e) 第2次运算结果
(f) 第3次运算结果

图8-8 弗洛伊德算法求最短路径的运算过程

(1) 令$k$取0，即以$v_0$作为新考虑的中间点，对图8-8(b)所示$A^{(-1)}$中的每对顶点之
间的路径长度进行必要的修改后得到第0次运算结果$A^{(0)}$，如图8-8(c)所示。在$A^{(0)}$中，
第0行和第0列用虚线框起来表示$i=k$和$j=k$的情况，它们同对角线上的元素一样为$A^{(-1)}$中的对应值，对于其他6个元素，若$v_i$通过新中间点$v_0$然后到$v_j$的路径长度$A^{(-1)}[i][0]+
A^{(-1)}[0][j]$小于原来的路径长度$A^{(-1)}[i][j]$，则用前者修改之，否则仍保持原值。因$v_2$到$v_1$的路径长度$A^{(-1)}[2][1]=5$，通过新中间点$v_0$后变短，即为$A^{(-1)}[2][0]+A^{(-1)}[0][1]=3+1=4$，

所以被修改为 4 , 对应的路径为$\{2,0,1\}$; 同样,$v_{2}$到$v_{3}$的路径长度通过新中间点$v_{0}$后也由 8 变为 7 , 所以被修改为 7 , 对应的路径为$\{2,0,3\}$; 剩余的 4 对顶点的路径长度, 因加入$v_{0}$作为新中间点后仍不变短, 所以保持原值不变。

(2) 令$k=1$, 即以$v_{1}$作为新考虑的中间点, 对$A^{(0)}$中每对顶点之间的路径长度进行必要的修改后得到第 1 次运算结果$A^{(1)}$, 如图 8-8 (d) 所示。此时第 1 行和第 1 列同对角线的元素一样, 取上一次的值, 对于其他 6 个元素, 若$v_{i}$通过新中间点$v_{1}$然后到$v_{j}$的路径长度$A^{(0)}[i][1]+A^{(0)}[1][j]$小于原来的路径长度$A^{(0)}[i][j]$, 则用前者修改之, 否则仍保持原值。因$v_{0}$到$v_{2}$的路径长度$A^{(0)}[0][2]=\infty$, 通过新中间点$v_{1}$后变短, 即为$A^{(0)}[0][1]+A^{(0)}[1][2]=$1+9=10$, 所以被修改为 10 , 对应的路径为$\{0,1,2\}$;$v_{0}$到$v_{3}$的路径长度$A^{(0)}[0][3]=4$, 通过新中间点$v_{1}$后变短, 即为$A^{(0)}[0][1]+A^{(0)}[1][3]=1+2=3$, 所以也被修改为 3 , 对应的路径为$\{0,1,3\}$;$v_{2}$到$v_{3}$的路径长度$A^{(0)}[2][3]=7$, 通过新中间点$v_{1}$后也变短, 即为$A^{(0)}[2][1]+$A^{(0)}[1][3]=4+2=6$, 所以在第一次被修改的基础上又重新被修改为 6 , 对应的路径为$A^{(0)}[2][1]$的路径$\{2,0,1\}$并上$A^{(0)}[1][3]$的路径$\{1,3\}$, 即为$\{2,0,1,3\}$; 剩余 3 对顶点的路径长度, 因加入新中间点$v_{1}$后不变短, 所以仍保持原值不变。

(3) 令$k=2$, 即以$v_{2}$作为新考虑的中间点, 对$A^{(1)}$中每对顶点的路径长度进行必要地修改, 得到第 2 次运算的结果, 如图 8-8(e) 所示。同上两次的分析过程一样, 请读者分析这一次结果。

(4) 令$k=3$, 即以$v_{3}$作为新考虑的中间点, 这也是最后一个要考虑的中间点, 在$A^{(2)}$的基础上进行运算, 得到的运算结果$A^{(3)}$, 如图 8-8(f) 所示, 也请读者自行分析。$A^{(3)}$中的每个元素$A^{(3)}[i][j]$的值就是图 8-8(a) 中顶点$v_{i}$到$v_{j}$的最短路径长度。当然相应的最短路径也可以, 通过另设一个矩阵记录下来。

通过以上分析可知, 在每次运算中, 对$i=k, j=k$或$i=j$的那些元素无需进行计算,因为它们不会被修改, 对于其余元素, 只有满足$A^{(k-1)}[i][k]+A^{(k-1)}[k][j]<A^{(k-1)}[i][j]$的元素才会被修改, 即把小于号左边的两个元素之和赋给$A^{(k)}[i][j]$, 在这两个元素中, 前者是列号等于$k$, 后者是行号等于$k$, 所以它们在进行第$k$次运算的整个过程中, 其值都不会改变,即为上一次运算的结果, 故每一次运算都可以在原数组上 “就地” 进行, 即用新修改的值替换原值即可, 不需要使用两个数组交替进行。

假设有$n$个顶点的一个带权图$G$的邻接矩阵用 GA 表示, 与 GA 同类型的, 求每对顶点之间最短路径长度的二维数组用 A 表示, A 的初值等于 GA。弗洛伊德算法需要在 A 上进行$n$次运算, 每次以$v_{k}(0 \leq k \leq n-1)$作为一个新考虑的中间点, 求出每对顶点之间的当前最短路径长度, 最后一次运算后, A 中的每个元素 A[i][j] 就是图 G 中从顶点$v_{i}$到顶点$v_{j}$的最短路径长度。利用 C++语言编写弗洛伊德算法如下, 假定在该算法中不需要记录每对顶点之间的最短路径, 只需要记录每对顶点之间的最短长度。

void Floyd(adjmatrix GA, adjmatrix A, int n)

//利用弗洛伊德算法求 GA 表示的图中每对顶点之间的最短长度

//对应保存于二维数组 A 中

{
int i,j,k;

```cpp
//给二维数组 A 赋初值, 它等于图的邻接矩阵 GA
for(i=0; i<n; i++)
    for(j=0; j<n; j++)
        A[i][j]=GA[i][j];
//依次以每个顶点作为中间点, 逐步优化数组 A
for(k=0; k<n; k++)
    for(i=0; i<n; i++)
        for(j=0; j<n; j++) {
            if(i==k || j==k || i == j) continue;
            if(A[i][k]+A[k][j]<A[i][j])
                A[i][j]=A[i][k]+A[k][j];
        }

}

用下面程序调试弗洛伊德算法。

#include<iostream.h>
#include<stdlib.h>
#include<strstrea.h> //使用字符串流所需的系统头文件
#include<string.h>

typedef int VertexType; //定义顶点值的类型
typedef int WeightType; //定义边上权值的类型

const int MaxVertexNum=10; //定义图的最多顶点数
const WeightType MaxValue=1000; //定义无边上的特定权值

typedef VertexType vexlist[MaxVertexNum]; //定义 vexlist 为存储顶点信息的数组类型
typedef int adjmatrix[MaxVertexNum][MaxVertexNum]; //定义 adjmatrix 为存储邻接矩阵的数组类型

#include"采用邻接矩阵存储的图的常用运算.cpp"

void Floyed(adjmatrix GA, adjmatrix A, int n)
{
    弗洛伊德算法, 函数定义同上
}

void main()
{
    int n,k1,k2;
    cout<<"输入待处理图的顶点数:";
    cin>>n;
}
```

cout<<"输入图的有无向和有无权选择 (0 为无, 非 0 为有):";\ncin>>k1>>k2;\nadjmatrix ga;\nInitMatrix(ga,k2);\ncout<<"输入图的边集:"<<endl;\nchar* a=new char[100];\n//cin>>a; //输入一个图的边集\nstrcpy(a,"{<0,1>1,<0,3>4,<1,2>9,<1,3>2,<2,0>3,<2,1>5,");\nstrcat(a,"<2,3>8,<3,2>6}"); //字符数组 a 中保存图 8-8（a）的边集\nCreateMatrix(ga,n,a,k1,k2);\ncout<<"以二元组形式输出邻接矩阵 ga:"<<endl;\nPrintMatrix(ga,n,k1,k2);\nadjmatrix gb;\nInitMatrix(gb,k2);\nFloyed(ga,gb,n); //每对顶点的最短路径保存在 gb 中\ncout<<"以二元组形式输出邻接矩阵 gb:"<<endl;\nPrintMatrix(gb,n,k1,k2);\n}\n\n程序运行结果如下。\n\n输入待处理图的顶点数:4\n输入图的有无向和有无权选择 (0 为无, 非 0 为有):1 1\n输入图的边集:\n以二元组形式输出邻接矩阵 ga:\nV={0,1,2,3}\nE={<0,1>1,<0,3>4,<1,2>9,<1,3>2,<2,0>3,<2,1>5,<2,3>8,<3,2>6,}\n以二元组形式输出邻接矩阵 gb:\nV={0,1,2,3}\nE={<0,1>1,<0,2>9,<0,3>4,<1,0>11,<1,2>8,<1,3>2,<2,0>3,<2,1>4,\n<2,3>6,<3,0>9,<3,1>10,<3,2>6,}\n\n\section*{8.3 拓扑排序}\n\n\subsection*{8.3.1 拓扑排序的概念}\n\n一个较大的工程经常被分成许多子工程，把这些子工程称做活动（activity）。在整个工程中，有些子工程（活动）必须在其他有关子工程完成之后才能开始，也就是说，一个子工程的开始是以它的所有前序子工程的结束为先决条件的，但有些子工程没有先决条件，可以安排在任何时间开始。为了形象地反映出整个工程中各个子工程（活动）之间的先后关系，可用一个有向图来表示，图中的顶点代表活动（子工程），图中的有向边代表活动的

先后关系，即有向边的起点的活动是终点活动的前序活动，只有当起点活动完成之后，其终点活动才能进行。通常，把这种顶点表示活动、边表示活动间先后关系的有向图称做顶点活动网（Activity On Vertex network, AOV network）。

例如，一个计算机专业的学生必须完成如图 8-9 所示的全部课程。

\begin{tabular}{c c c}
\hline 课程代号 & 课程名称 & 先修课程 \\
\hline C1 & 高等数学 & 无 \\
C2 & 程序设计基础 & 无 \\
C3 & 离散数学 & C1,C2 \\
C4 & 数据结构 & C3,C5 \\
C5 & 算法语言 & C2 \\
C6 & 编译技术 & C4,C5 \\
C7 & 操作系统 & C4,C9 \\
C8 & 普通物理 & C1 \\
C9 & 计算机原理 & C8 \\
\hline
\end{tabular}

图 8-9 课程表

这里用课程代表活动，学习一门课程就表示进行一项活动，学习每门课程的先决条件是学完它的全部先修课程。学习《数据结构》课程就必须安排在学完它的两门先修课程《离散数学》和《算法语言》之后。学习《高等数学》课程则可以随时安排，因为它是基础课程，没有先修课。用 AOV 网来表示这种课程安排的先后关系，如图 8-10 所示。图中的每个顶点代表一门课程，每条有向边代表起点对应的课程是终点对应课程的先修课。从图中可以清楚地看出各课程之间的先修和后续的关系。如课程 C5 的先修课为 C2，后续课程为 C4 和 C6；C6 的先修课为 C4 和 C5，它无后续课。

一个 AOV 网应该是一个有向无环图，即不应该带有回路，因为若带有回路，则回路上的所有活动都无法进行。如图 8-11 所示是一个具有三个顶点的回路，由$<$A,B$>$边可得 B 活动必须在 A 活动之后，由$<$B,C$>$边可得 C 活动必须在 B 活动之后，所以推出 C 活动必然在 A 活动之后，但由$<$C,A$>$边可得 C 活动必须在 A 活动之前，从而出现矛盾，使每一项活动都无法进行。这种情况若在程序中出现，则称为死锁或死循环，是应该必须避免的。

\begin{tabular}{ccc}
\includegraphics[width=0.4\textwidth]{image1.png} & \multicolumn{2}{c}{\includegraphics[width=0.2\textwidth]{image2.png}} \\
图 8-10 AOV 网 & \multicolumn{2}{c}{图 8-11 三个顶点的回路}
\end{tabular}

在 AOV 网中，若不存在回路，则所有活动可排列成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，把此序列叫做拓扑序列（topological order），由 AOV

网构造拓扑序列的过程叫做拓扑排序（topological sort）。AOV网的拓扑序列不是唯一的，满足上述定义的任一线性序列都称做它的拓扑序列。例如，下面的3个序列都是图8-10的拓扑序列，当然还可以写出许多。

(1) C1,C8,C9,C2,C3,C5,C4,C7,C6。

(2) C2,C1,C3,C5,C4,C6,C8,C9,C7。

(3) C1,C2,C3,C8,C9,C5,C4,C6,C7。

由AOV网构造出拓扑序列的实际意义是：如果按照拓扑序列中的顶点次序，在开始每一项活动时，能够保证它的所有前驱活动都已完成，从而使整个工程顺序进行，不会出现冲突的情况。

由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。

(1) 选择一个入度为0的顶点并输出之。

(2) 从网中删除此顶点及所有出边。

循环结束后，若输出的顶点数小于网中的顶点数，则输出“有回路”信息，否则输出的顶点序列就是一种拓扑序列。

如图8-12(a)所示为例，来说明拓扑排序算法的执行过程。

(1) 在图8-12(a)中$v_0$和$v_1$的入度都为0，不妨选择$v_0$并输出之，接着删去顶点$v_0$及出边<0,2>，得到的结果如图8-12(b)所示。

(2) 在图8-12(b)中只有一个入度为0的顶点$v_1$，输出$v_1$，接着删去$v_1$和它的三条出边<1,2>,<1,3>和<1,4>，得到的结果如图8-12(c)所示。

(3) 在图8-12(c)中$v_2$和$v_4$的入度都为0，不妨选择$v_2$并输出之，接着删去$v_2$及两条出边<2,3>和<2,5>，得到的结果如图8-12(d)所示。

(4) 在图8-12(d)上依次输出顶点$v_3$、$v_4$和$v_5$，并在每个顶点输出后删除该顶点及出边，操作都很简单，不再赘述。

\n
(a) AOV网

\n
(b) 删除$v_0$后

\n
(c) 删除$v_1$后

\n
(d) 删除$v_2$后

\n
图8-12 拓扑排序的图形说明

8.3.2 拓扑排序算法

为了利用 C++语言在计算机上实现 AOV 网的拓扑排序, AOV 网采用邻接表表示较方便。如对于图 8-12 (a), 对应的邻接表, 如图 8-13 所示。

![image](attachment://figure_8_13.png)

图 8-13 图 8-12（a）的链接表

在拓扑排序算法中, 需要设置一个包含$n$个元素的一维整型数组, 设用$\mathbf{d}$表示, 用它来保存 AOV 网中每个顶点的入度值。如对于图 8-12 (a), 得到数组$\mathbf{d}$的初始值为:

![image](attachment://array_d.png)

在进行拓扑排序中, 为了把所有入度为 0 的顶点都保存起来, 而且又便于插入、删除以及节省存储, 最好的方法是把它们链接成一个栈。另外, 在保存入度的数组$\mathbf{d}$中, 当一个顶点$v_i$的入度为 0 时, 下标为$i$的元素$\mathbf{d}[i]$的值为 0 , 该元素也就空闲下来了, 正好可利用它作为链栈中的一个结点使用, 保存下一个入度为 0 的顶点的序号, 这样就可以把所有入度为 0 的顶点通过数组$\mathbf{d}$中的对应元素静态地链接成一个栈。对于被删除入边而新产生的入度为 0 的顶点就压入此栈, 输出一个入度为 0 的顶点就是删除栈顶元素。在这个链栈中, 栈顶指针 top 指向一个入度为 0 的顶点, 其值是数组$\mathbf{d}$中下一个入度为 0 的元素的下标, 此处元素的值又是数组$\mathbf{d}$中另一个入度为 0 的元素的下标, 以此类推, 最后一个入度为 0 元素的值为 -1 , 表示为栈底。

根据如图 8-13 所示的邻接表, 建立的入度为 0 的初始栈的过程如下。
(1) 开始置链栈为空, 即给链栈指针 top 赋初值为 -1 。

top=-1;

(2) 将入度为 0 的元素$\mathbf{d}[0]$进栈,$\mathbf{d}[0]=\text { top; } \operatorname{top}=0 ;$此时 top 指向$\mathbf{d}[0]$元素, 表示顶点$v_0$的入度为 0 , 而$\mathbf{d}[0]$的值为 -1 , 表明为栈底。
(3) 将入度为 0 的元素$\mathbf{d}[1]$进栈, 即:

d[1]=top; top=1;

此时 top 指向 d[1]元素，表示顶点$v_1$的入度为 0，而 d[1]的值为 0，表明下一个入度为 0 的元素为 d[0]，即对应下一个入度为 0 的顶点为$v_0$，d[0]的值为 -1，所以此栈当前有两个元素 d[1]和 d[0]。

（4）因 d[2]~d[5]的值均不为 0，即对应的$v_2 \sim v_5$的入度均不为 0，所以它们均不进栈。至此，初始栈建立完毕，得到的数组 d 为:

\[
\begin{array}{|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
-1 & 0 & 2 & 2 & 1 & 3 \\
\hline
\end{array}
\]$\uparrow$top=1

由此可知，数组 d 具有两方面功能：存储所有顶点的入度；链接入度为 0 的顶点形成链栈。

将入度为 0 的顶点利用上述链栈链接起来后，拓扑算法中循环执行的“选择一个入度为 0 的顶点并输出之”，可通过输出栈顶指针 top 所代表的顶点序号来实现；“从 AOV 网中删除刚输出的顶点（假定为$v_j$，其中 j 等于 top 的值）及所有出边”，可通过首先做退栈处理，使 top 指向下—个入度为 0 的元素，然后遍历$v_j$的邻接表，分别把所有邻接点的入度减 1，若减 1 后的入度为 0 则令该元素进栈等操作来实现。此外，该循环的终止条件“直到不存在入度为 0 的顶点为止”，可通过判断栈空来实现。

对于图 8-12 (a)，当删除由 top 值所代表的顶点$v_1$及所有出边后，数组 d 变为:

\[
\begin{array}{|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
-1 & 0 & 1 & 1 & 0 & 3 \\
\hline
\end{array}
\]$\uparrow$top=4

当依次删除 top 所表示的每个顶点及所有出边后，数组 d 的变化分别如图 8-14 所示。

\[
\begin{array}{|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
-1 & 0 & 1 & 1 & 0 & 2 \\
\hline
\end{array}
\]$\uparrow$top=0

(a) 删除顶点$v_4$及所有出边

\[
\begin{array}{|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
-1 & 0 & -1 & -1 & 0 & 1 \\
\hline
\end{array}
\]$\uparrow$top=3

(c) 删除顶点$v_2$及所有出边

\[
\begin{array}{|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
-1 & 0 & -1 & 1 & 0 & 2 \\
\hline
\end{array}
\]$\uparrow$top=2

(b) 删除顶点$v_0$及所有出边

\[
\begin{array}{|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
-1 & 0 & -1 & -1 & 0 & -1 \\
\hline
\end{array}
\]$\uparrow$top=5

(d) 删除顶点$v_3$及所有出边

图 8-14 数组 d 变化示意图

当删除顶点$v_5$及所有出边后，top 的值为 -1，表示栈空，至此此算法执行结束，得到的拓扑序列为: 1,4,0,2,3,5。

根据以上分析，给出拓扑排序算法的具体描述如下。

void Toposort(adjlist GL, int n) //对用邻接表 GL 表示的有向图进行拓扑排序
{

int i,j,k,top,m=0;          //m用来统计拓扑序列中的顶点数
edgenode*p;
//定义存储图中每个顶点入度的一维整型数组 d
int*d=new int[n];
//初始化数组 d 中的每个元素值为 0
for(i=0; i<n; i++) d[i]=0;
//利用数组 d 中的对应元素统计出每个顶点的入度
for(i=0; i<n; i++) {
    p=G[i];
    while(p!=NULL) {
        j=p->adjvex; d[j]++; p=p->next;
    }
}
//初始化用于链接入度为 0 的元素的栈的栈顶指针 top 为-1
top=-1;
//建立初始栈
for(i=0; i<n; i++)
    if(d[i]==0) { d[i]=top; top=i;}
//每循环一次删除一个顶点及所有出边
while(top!=-1) {
    j=top;
    top=d[top];
    cout<<j<<' ';
    m++;
    p=G[j];
    while(p!=NULL) {
        k=p->adjvex;
        d[k]--;
        if(d[k]==0) {
            d[k]=top; top=k;
        }
        p=p->next;
    }
}
cout<<endl;
//当输出的顶点数小于图中的顶点数时, 输出有回路信息
if(m<n) cout<<"The network has a cycle!"<<endl;
delete []d;                  //删除动态分配的数组 d

拓扑排序实际上是对邻接表表示的图 G 进行遍历的过程，依次访问入度为 0 顶点的邻接表，若 AOV 图没有回路，则需要扫描邻接表中的所有边结点，加上在算法开始时，为建立入度数组 d 需要访问表头向量中的每个域和单链表中的每个结点，所以此算法的时间复杂度为$O(n+e)$。

\section*{8.4 关键路径}

\subsection*{8.4.1 顶点事件的发生时间}

与上节 AOV 网相对应的是 AOE 网, 即边表示活动的网络。它与 AOV 网比较, 更具有实用价值, 通常用它表示一个工程的计划或进度。

AOE 网是一个有向带权图, 图中的边表示活动 (子工程), 边上的权表示该活动的持续时间(duration time), 即完成该活动所需要的时间; 图中的顶点表示事件, 每个事件是活动之间的转接点, 即表示它的所有入边活动到此完成, 所有出边活动从此开始。AOE 网中有两个特殊的顶点 (事件), 一个称作源点, 表示整个工程的开始, 亦即最早活动的起点, 显然它只有出边, 没有入边; 另一个称作汇点, 表示整个工程的结束, 亦即最后活动的终点, 显然它只有入边, 没有出边。除这两个顶点外, 其余顶点都既有入边, 也有出边, 是入边活动和出边活动的转接点。在一个 AOE 网中, 若包含有$n$个事件, 通常令源点为第 0 个事件 (假定从 0 开始编号), 汇点为第$n-1$个事件, 其余事件的编号 (即顶点序号) 分别从$1 \sim n-2$。

如图 8-15 所示是一个 AOE 网, 该网中包含有 11 项活动和 9 个事件。如边$<0,1>$表示活动$a_1$, 持续时间 (即权值) 为 6 , 若以天为单位, 即$a_1$需要 6 天完成, 它以$v_0$事件为起点, 以$v_1$事件为终点; 边$<4,6>$和$<4,7>$分别表示活动$a_7$和$a_8$, 它们的持续时间分别为 9 天和 7 天, 它们均以$v_4$事件为起点, 但分别以$v_6$和$v_7$事件为终点。该网中的源点和汇点分别为第 0 个事件$v_0$和最后一个事件$v_8$, 它们分别表示整个工程的开始和结束。

![image]

图 8-15 一个 AOE 网

对于一个 AOE 网, 待研究的问题是:

(1) 整个工程至少需要多长时间完成?

(2) 哪些活动是影响工程进度的关键?

在 AOE 网中, 一个顶点事件的发生或出现必须在它的所有入边活动 (或称前驱活动) 都完成之后, 也就是说, 只要有一个入边活动没有完成, 该事件就不可能发生。显然, 一个事件的最早发生时间是它的所有入边活动, 或者说最后一个入边活动刚完成的时间。同样, 一个活动的开始必须在它的起点事件发生之后, 也就是说, 一个顶点事件没有发生时, 它的所有出边活动 (或称后继活动) 都不可能开始。显然一个活动的最早开始时间是它的起

点事件的最早发生时间。

若用$\mathrm{ve}[j]$表示顶点$v_{j}$事件的最早发生时间, 用$\mathrm{e}[i]$表示$v_{j}$一条出边活动$a_{i}$的最早开始时间，则有$\mathrm{e}[i]=\mathrm{ve}[j]$。对于 AOE 网中的源点事件来说，因为它没有入边，所以随时都可以发生，整个工程的开始时间就是它的发生时间，亦即最早发生时间，通常把此时间定义为 0 ，即$\mathrm{ve}[0]=0$，从此开始推出其他事件的最早发生时间。在图 8-15所示的 AOE 网中，$v_{4}$事件的发生必须在$a_{4}$和$a_{5}$活动都完成之后，而$a_{4}$和$a_{5}$活动的开始又必须分别在$v_{1}$和$v_{2}$事件的发生之后，$v_{1}$和$v_{2}$事件的发生又必须分别在$a_{1}$和$a_{2}$活动的完成之后，因$a_{1}$和$a_{2}$的活动都起于源点，其最早开始时间均为 0 ，所以$a_{1}$和$a_{2}$的完成时间分别为 6 和 4 ，这也分别是$v_{1}$和$v_{2}$的最早发生时间，以及$a_{4}$和$a_{5}$的最早开始时间，故$a_{4}$和$a_{5}$的完成时间分别为 7 和 5 ，由此可知，$v_{4}$事件的最早发生时间为 7 ，即所有入边活动中最后一个完成的时间。

从以上分析可知，一个事件的发生有待于它的所有入边活动的全部完成，而每个入边活动的开始和完成又有待于前驱事件的发生，而每个前驱事件的发生又有待于它们的所有入边活动的完成……总之，一个事件发生在从源点到该顶点的所有路径上的活动都完成之后，显然，其最早发生时间应等于从源点到该顶点的所有路径上的最长路径长度。这里所说的路径长度是指带权路径长度，即等于路径上所有活动的持续时间之和。如从源点$v_{0}$到顶点$v_{4}$共有两条路径，长度分别为 7 和 5 ，所以$v_{4}$的最早发生时间为 7 。从源点$v_{0}$到汇点$v_{8}$有多条路径，通过分析可知，其最长路径长度为 18 ，所以汇点$v_{8}$的最早发生时间为 18 。汇点事件的发生，表明整个工程中的所有活动都已完成，所以完成图 8-15 所对应的工程至少需要 18 天。

现在接着讨论如何从源点$v_{0}$的最早发生时间 0 出发，求出其余各事件的最早发生时间。求一个事件$v_{k}$的最早发生时间（即从源点$v_{0} \sim v_{k}$的最长路径长度）的常用方法是：由它的每个前驱事件$v_{j}$的最早发生时间（即从源点$v_{0} \sim v_{j}$的最长路径长度）分别加上相应入边$<j$,$k>$上的权，其值最大者就是$v_{k}$的最早发生时间。由此可知，必须按照拓扑序列中的顶点次序（即拓扑有序）求出各个事件的最早发生时间，才能保证在求一个事件的最早发生时间时，它的所有前驱事件的最早发生时间都已求出。

设$\mathrm{ve}[k]$表示$v_{k}$事件的最早发生时间，$\mathrm{ve}[j]$表示$v_{k}$的一个前驱事件$v_{j}$的最早发生时间，$\operatorname{dut}(<j, k>)$表示边$<j, k>$上的权，$p$表示$v_{k}$顶点所有入边的集合，则 AOE 网中每个事件$v_{k}(0 \leqslant k \leqslant n-1)$的最早发生时间可由下式，按照拓扑有序计算出来。$\mathrm{ve}[k]=\max \left\{\mathrm{ve}[j]+\operatorname{dut}(<j, k>)\right\} \quad(1 \leqslant k \leqslant n-1,<j, k> \in p, \mathrm{ve}[0]=0)$按照此公式和拓扑有序计算出图 8-15 所示的 AOE 网中每个事件的最早发生时间如下。
\begin{aligned} & \mathrm{ve}[0]=0 \\ & \mathrm{ve}[1]=\mathrm{ve}[0]+\operatorname{dut}(<0,1>)=0+6=6 \\ & \mathrm{ve}[2]=\mathrm{ve}[0]+\operatorname{dut}(<0,2>)=0+4=4 \\ & \mathrm{ve}[3]=\mathrm{ve}[0]+\operatorname{dut}(<0,3>)=0+5=5 \\ & \mathrm{ve}[4]=\max \left\{\mathrm{ve}[1]+\operatorname{dut}(<1,4>), \mathrm{ve}[2]+\operatorname{dut}(<2,4>)\right\} \\ & =\max \{6+1,4+1\}=7 \\ & \mathrm{ve}[5]=\mathrm{ve}[3]+\operatorname{dut}(<3,5>)=5+2=7 \\ & \mathrm{ve}[6]=\mathrm{ve}[4]+\operatorname{dut}(<4,6>)=7+9=16 \end{aligned}

$\mathrm{ve}[7]=\max \{\mathrm{ve}[4]+\operatorname{dut}(<4,7>), \mathrm{ve}[5]+\operatorname{dut}(<5,7>)\}$=\max \{7+7,7+4\}=14$\mathrm{ve}[8]=\max \{\mathrm{ve}[6]+\operatorname{dut}(<6,8>), \mathrm{ve}[7]+\operatorname{dut}(<7,8>)\}$=\max \{16+2,14+4\}=18$最后得到的 ve(8)就是汇点的最早发生时间，从而可知整个工程至少需要 18 天完成。

在不影响整个工程按时完成的前提下，一些事件可以不在最早发生时间发生，而允许向后推迟一些时间发生，把最晚必须发生的时间叫做该事件的最迟发生时间。同样，在不影响整个工程按时完成的前提下，一些活动可以不在最早开始时间开始，而允许向后推迟一些时间开始，把最晚必须开始的时间叫做该活动的最迟开始时间。AOE 网中的任一个事件若在最迟发生时间仍没有发生或任一项活动在最迟开始时间仍没有开始，则必将影响整个工程的按时完成，使工期拖延。若用$\mathrm{vl}[k]$表示顶点$v_{k}$事件的最迟发生时间，用$\mathrm{I}[i]$表示$v_{k}$的一条入边$<j, k>$上活动$a_{i}$的最迟开始时间，用$\operatorname{dut}(<j, k>)$表示$a_{i}$的持续时间，则有$I[i]=\mathrm{vl}[k]-\operatorname{dut}(<j, k>)$因$a_{i}$活动的最迟完成时间也就是它的终点事件$v_{k}$的最迟发生时间，所以$a_{i}$的最迟开始时间应等于$v_{k}$的最迟发生时间减去$a_{i}$的持续时间，或者说，要比$v_{k}$的最迟发生时间提前$a_{i}$所需要的时间开始。

为了保证整个工程的按时完成，所以把汇点的最迟发生时间定义为它的最早发生时间，即$\mathrm{vl}[n]=\mathrm{ve}[n]$。其他每个事件的最迟发生时间应等于汇点的最迟发生时间减去从该事件的顶点到汇点的最长路径长度，或者说，每个事件的最迟发生时间比汇点的最迟发生时间所提前的时间应等于从该事件的顶点到汇点的最长路径上所有活动的持续时间之和。求一个事件$v_{j}$的最迟发生时间的常用方法是：由它的每个后继事件$v_{k}$的最迟发生时间分别减去相应出边$<j, k>$上的权，其值最小者就是$v_{j}$的最迟发生时间。由此可知，必须按照逆拓扑有序求出各个事件的最迟发生时间，这样才能保证在求一个事件的最迟发生时间时，它的所有后继事件的最迟发生时间都已求出。

设$\mathrm{vl}[j]$表示待求的$v_{j}$事件的最迟发生时间，$\mathrm{vl}[k]$表示$v_{j}$的一个后继事件$v_{k}$的最迟发生时间，$\operatorname{dut}(<j, k>)$表示边$<j, k>$上的权，$s$表示$v_{j}$顶点的所有出边的集合，则 AOE 网中每个事件$v_{j}(0 \leqslant j \leqslant n-1)$的最迟发生时间由下式，按照逆拓扑有序计算出来。$\mathrm{vl}[j]=\left\{\begin{array}{l}\mathrm{ve}[n-1] \\ \min \{\mathrm{vl}[k]-\operatorname{dut}(<j, k>)\}\end{array} \quad(j=n-1)\right.$(0 \leqslant j \leqslant n-2,<j, k> \in s)$按照此公式和逆拓扑有序计算得出图 8-15 所示的 AOE 网中每个事件的最迟发生时间如下。$\begin{aligned} & \mathrm{vl}[8]=\mathrm{ve}[8]=18 \\ & \mathrm{vl}[7]=\mathrm{vl}[8]-\operatorname{dut}(<7,8>)=18-4=14 \\ & \mathrm{vl}[6]=\mathrm{vl}[8]-\operatorname{dut}(<6,8>)=18-2=16 \\ & \mathrm{vl}[5]=\mathrm{vl}[7]-\operatorname{dut}(<5,7>)=14-4=10 \\ & \mathrm{vl}[4]=\min \{\mathrm{vl}[7]-\operatorname{dut}(<4,7>), \mathrm{vl}[6]-\operatorname{dut}(<4,6>)\} \\ & =\min \{14-7,16-9\}=7 \\ & \mathrm{vl}[3]=\mathrm{vl}[5]-\operatorname{dut}(<3,5>)=10-2=8 \end{aligned}$

$\mathrm{vl}[2]=\mathrm{vl}[4]-\operatorname{dut}(<2,4>)=7-1=6$\mathrm{vl}[1]=\mathrm{vl}[4]-\operatorname{dut}(<1,4>)=7-1=6$\begin{aligned} \mathrm{vl}[0] & =\min \{\mathrm{vl}[1]-\operatorname{dut}(<0,1>), \mathrm{vl}[2]-\operatorname{dut}(<0,2>), \mathrm{vl}[3]-\operatorname{dut}(<0,3>)\} \\ & =\min \{6-6,6-4,8-5\}=0 \end{aligned}$\section*{8.4 .2 计算关键路径的方法和算法}

AOE 网中每个事件的最早发生时间和最迟发生时间计算出来后, 可根据它们计算出每个活动的最早开始时间和最迟开始时间。设事件$v_{j}$的最早发生时间为$\mathrm{ve}[j]$, 它的一个后继事件$v_{k}$的最迟发生时间为$\mathrm{vl}[k]$, 则边$<j, k>$上的活动$a_{i}$的最早开始时间$\mathrm{e}[i]$和最迟开始时间$[i]$的计算公式重新列出如下。$\left\{\begin{array}{l}\mathrm{e}[i]=\mathrm{ve}[j] \\\mathrm{l}[i]=\mathrm{vl}[k]-\operatorname{dut}(<j, k>)\end{array}\right.$根据此计算公式可计算出 AOE 网中每一个活动$a_{i}$的最早开始时间$\mathrm{e}[i]$, 最迟开始时间$[i]$和开始时间余量$[i]-\mathrm{e}[i]$。如图 8-16 所示列出了图 8-15 中每一活动的这 3 个时间。

|$a_{i}$|$a_{1}$|$a_{2}$|$a_{3}$|$a_{4}$|$a_{5}$|$a_{6}$|$a_{7}$|$a_{8}$|$a_{9}$|$a_{10}$|$a_{11}$|
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|$\mathrm{e}[i]$| 0 | 0 | 0 | 6 | 4 | 5 | 7 | 7 | 7 | 16 | 14 |
|$[i]$| 0 | 2 | 3 | 6 | 6 | 8 | 7 | 7 | 10 | 16 | 14 |
|$[i]-\mathrm{e}[i]$| 0 | 2 | 3 | 0 | 2 | 3 | 0 | 0 | 3 | 0 | 0 |

图 8-16 计算出的图 8-15 中每个活动的 3 个时间

其中, 有些活动的开始时间余量不为 0 , 表明这些活动不在最早开始时间开始, 至多向后拖延相应的开始时间余量所规定的时间开始也不会延误整个工程的进展。如对于活动$a_{5}$, 它最早可以从整个工程开工后的第 4 天开始, 至多向后拖延两天, 即从第 6 天开始。有些活动的开始时间余量为 0 , 表明这些活动只能在最早开始时间开始, 并且必须在持续时间内按时完成, 否则将拖延整个工期。把开始时间余量为 0 的活动称为关键活动, 由关键活动所形成的从源点到汇点的每一条路径称为关键路径。由图 8-15 中的关键活动构成两条关键路径为$\{0,1,4,6,8\}$和$\{0,1,4,7,8\}$, 如图 8-17 所示。

![Picture 1]

项活动的开始时间余量为 0, 故它们都是关键活动。

求一个 AOE 网的关键路径后, 可通过加快关键活动 (即缩短它的持续时间) 来实现缩短整个工程的工期。但并不是加快任何一个关键活动都可以缩短其整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到这个目的。例如，加快图 8-17 中关键活动$a_{11}$的速度，使之由 4 天完成变为 3 天完成，则不能使整个工程的工期由 18 天变为 17，因为另一条关键路径$\{0,1,4,6,8\}$中不包括活动$a_{11}$，这只能使它所在的关键路径$\{0,1,4,7,8\}$变为非关键路径。而活动$a_1$和$a_4$是包括在所有的关键路径中的，若活动$a_1$由 6 天变为 4 天完成，则整个工程的工期可由 18 天缩短为 16 天。另一方面，关键路径是可以变化的，提高某些关键活动的速度可能使原来的非关键路径变为新的关键路径，因而关键活动的速度提高是有限度的。例如，图 8-15 中关键活动$a_1$由 6 改为 4 后，路径$\{0,2,4,6,8\}$和$\{0,2,4,7,8\}$都变成了关键路径，此时，再提高$a_1$的速度也不能使整个工程的工期提前。

下面给出用邻接表 GL 表示一个 AOE 网的求关键路径的算法。

void Cripath(adjlist GL, int n) //求邻接表 GL 表示的AOE网的关键路径
{
    int i,j,k;
    edgenode*p;
    //动态定义具有n个元素的三个一维整型数组v,ve和vl
    int*v=new int[n];          //保存拓扑排序的顶点序列
    int*ve=new int[n];         //保存每个事件的最早发生时间
    int*vl=new int[n];         //保存每个事件的最迟发生时间
    //调用拓扑排序算法,使排序结果存于数组 v 中
    Toposort(GL,v,n);          //需对上一节介绍的此算法做必要的修改, 即在
                                //参数表中增加int v[]一项,把输出语句更换为v[m]=j即可
                                //给每个事件的最早发生时间置初值 0
    for(i=0; i<n; i++) ve[i]=0;
                                //求出每个事件的最早发生时间
    for(i=0; i<n; i++) {
        j=v[i];
        p=GL[j];
        while(p!=NULL) {
            k=p->adjvex;
            if(ve[k]<ve[j]+p->weight) ve[k]=ve[j]+p->weight;
            p=p->next;
        }
    }
                            //把每个事件的最迟发生时间都置为ve[n-1],以作为它们的初值
    for(i=0; i<n; i++) vl[i]=ve[n-1];
                            //求出每个事件的最迟发生时间
    for(i=n-1; i>=0; i--) {
        j=v[i];
        p=GL[j];
        while(p!=NULL) {

```cpp
k=p->adjvex;
if(vl[j]>vl[k]-p->weight) vl[j]=vl[k]-p->weight;
p=p->next;
}
//输出AOE网中每一个活动的最早开始时间,最迟开始时间以及开始时间余量
for(i=0; i<n; i++) {
    p=GL[i];
    while(p!=NULL) {
        j=p->adjvex;
        cout<<'<i<'<<i<<','<<j<<'>';
        //输出有向边<i,j>,用它表示该边上的活动ak
        cout<<"ve["<<i<<"]";
        cout<<vl[j]-p->weight<<" ";
        cout<<vl[j]-p->weight-ve[i]<<endl;//输出ak的开始时间余量
        p=p->next;
    }
}

求关键路径算法的时间复杂度同拓扑排序算法一样，也为$O(n+e)$，$n$和$e$分别表示图的顶点数和边数。

利用下面程序调试图的拓扑排序算法和关键路径算法。

#include<iostream.h>
#include<stdlib.h>
#include<strstrea.h>

const int MaxVertexNum=20;
typedef int WeightType;
struct edgenode {
    int adjvex;
    WeightType weight;
    edgenode* next;
};
typedef edgenode* adjlist[MaxVertexNum];

#include"采用邻接表存储的图的常用运算.cpp"

void Toposort(adjlist GL, int v[], int n)
{
    //对用邻接表GL表示的有向图进行拓扑排序
}

void Cripath(adjlist GL, int n)
{   //求邻接表GL表示的AOE网的关键路径
}
```

```cpp
void main()
{
    int n,k1,k2;
    cout<<"输入待处理图的顶点数：";
    cin>>n;
    cout<<"输入图的有无向和有无权选择（0为无，非0为有）：";
    cin>>k1>>k2;
    adjlist gl;
    InitAdjjoin(gl);
    cout<<"输入图的边集：";
    char*a=new char[100];
    cin>>a;
    CreateAdjjoin(gl,n,a,k1,k2);
    Cripath(gl,n);
}

程序的一次输入和运行结果如下。

输入待处理图的顶点数:9

输入图的有无向和有无权选择（0为无，非0为有）：1 1

输入图的边集：{$\{<0,1>6,<0,2>4,<0,3>5,<1,4>1,<2,4>1,<3,5>2,<4,6>9,<4,7>7,$<5,7>4,<6,8>2,<7,8>4\}$}$<0,3>0,3,3$<0,2>0,2,2$<0,1>0,0,0$<1,4>6,6,0$<2,4>6,6,2$<3,5>5,8,3$<4,7>7,7,0$<4,6>7,7,0$<5,7>7,10,3$<6,8>16,16,0$<7,8>14,14,0$习题 8

【习题 8-1】运算题。

1. 如图 8-18 所示，针对有向图操作如下。
(1) 画出最小生成树并求出它的权。
(2) 从顶点$v_0$出发，根据普里姆算法求出最小生成树的过程中，把依次得到的各条边按序写出来。
(3) 根据克鲁斯卡尔算法求出最小生成树的过程中，把依次得到的各条边按序写出来。

2. 如图 8-19 所示，利用狄克斯特拉算法求从顶点$v_0$到其余各顶点的最短路径，并画出对应的图形表示。
```

图 8-18 无向带权图

图 8-19 有向带权图

3. 已知一个图的二元组表示为:$V=\{0,1,2,3,4,5,6,7\}$E=\{(0,1)8,(0,3)2,(0,5)10,(1,2)6,(1,4)20,(1,6)12,(2,4)10,$(2,7)15,(3,5)7,(3,6)7,(4,7)4,(5,6)6,(6,7)8\}$（1）按照克鲁斯卡尔算法求最小生成树，写出依次得到的各条边。

（2）按照迪杰斯特拉算法求从顶点 0 到其余各顶点的最短路径。

4. 如图 8-20 所示，利用弗洛伊德算法求每对顶点之间的最短路径，即仿照图 8-8 的运算过程，给出从邻接矩阵出发每加入一个中间点后矩阵的变化。

5. 如图 8-21 所示，试给出一种拓扑序列，若在它的邻接表存储结构中，每个顶点邻接表中的边结点都是按照终点序号从大到小链接的，则按此给出唯一一种拓扑序列。

图 8-20 有向带权图

图 8-21 AOV 网

6. 一个 AOV 网的二元组表示为:$V=\{0,1,2,3,4,5,6,7,8,9,10\}$E=\{<0,2>,<0,4>,<1,2>,<1,5>,<2,4>,<3,5>,<4,6>,<4,7>,<5,7>,<6,8>,$<7,6>,<7,8>,<7,9>,<8,10>,<9,10>\}$在此 AOV 网的邻接表存储中，若各项点邻接表中的边结点是按照邻接顶点序号从大到小链接的，请写出按此邻接表和介绍的拓扑排序算法得到的拓扑序列。

提示：先画出图形再运算。

7. 如图 8-22 所示的AOE网，求：

（1）每个事件的最早发生时间和最迟发生时间。

（2）完成整个工程至少需要多长时间。

（3）每项活动的最早开始时间和最迟开始时间以及开始时间余量。

（4）画出由所有关键活动所构成的图。

（5）哪些活动加速可使整个工程提前完成？

图 8-22 AOE 网

【习题 8-2】算法设计题。

1. 采用简单插入排序方法对图的边集数组 GE 中的所有边，按边的权值的升序进行排序，排序结果仍存于 GE 中。

2. 修改 Kruskal 算法，在算法内部使用具有 adjlist 类型的一个邻接表 s 代替二维数组 s，用一个单链表 s[i] 表示一个集合，若一个顶点属于这个集合，则对应该单链表中的一个结点，该结点的 adjvex 域的值为该顶点序号。

3. 编写一个程序调试上面第 1 和第 2 小题的两个算法。

4. 编写一个程序，调试一个带权图的狄克斯特拉算法，以及对邻接矩阵常用运算的算法。


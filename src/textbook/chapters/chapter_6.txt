第6章 特殊二叉树

特殊二叉树包括二叉搜索树、堆、哈夫曼树、线索二叉树和平衡二叉树等，它们都有着不同的应用。本章将讨论特殊二叉树的定义、结构和运算特点。

\section*{6.1 二叉搜索树}

\subsection*{6.1.1 二叉搜索树的定义}

二叉搜索树（binary searching tree）又称二叉排序树（binary sorting tree），它或是一棵空树，或者是一棵具有如下特性的非空二叉树。

（1）若它的左子树非空，则左子树上所有结点的关键字均小于根结点的关键字。

（2）若它的右子树非空，则右子树上所有结点的关键字均大于（若允许具有相同的关键字的结点存在，则大于等于）根结点的关键字。

（3）左、右子树本身又各是一棵二叉搜索树。

在二叉搜索树中，当每个结点的元素类型为简单类型时，则结点的关键字就是该结点的值；当每个结点的元素类型为记录类型时，则结点的关键字为该结点的某一个域的值。如当元素的类型为整型时，则结点的关键字就是该结点的值即整数；当元素的类型为学生记录类型时，则每个学生的学号（即记录中的一个域）就是相应结点的关键字。在算法描述中，以结点的值的比较作为其关键字的比较，实际情况可能进行的是关键字域的比较，若在C++语言环境下运行，可通过关系操作符的重载，使其真正比较的是记录的关键字。

由二叉搜索树的定义可知，在一棵非空的二叉搜索树中，其结点的关键字是按照左子树、根和右子树有序的，所以对它进行中序遍历得到的结点序列必然是一个有序序列。

如图 6-1 所示是一棵二叉搜索树，树中每个结点的关键字都大于它的左子树中所有结点的关键字，而小于它的右子树中所有结点的关键字。对此树进行中序遍历得到的结点序列为：$12, 15, 18, 23, 26, 30, 52, 63, 74$可见此序列是一个有序序列。

\begin{center}
\includegraphics[width=0.5\textwidth]{image.png}
\end{center}

图 6-1 二叉搜索树

\subsection*{6.1.2 二叉搜索树的抽象数据类型}

二叉搜索树的抽象数据类型中的数据部分是一棵二叉搜索树，它可以具有同一般二叉树一样的任何存储结构，操作部分除了已经讨论过的对一般二叉树的操作外，还具有对二叉搜索树的一

些常用操作，即搜索（查找）、更新、插入和删除元素的操作。假定二叉搜索树中的结点类型为 BTreeNode，指向二叉搜索树的树根结点的指针为 BST，则对二叉搜索树 BST 的查找、更新、插入和删除元素的操作声明如下。

bool Find(BTreeNode*BST, ElemType&item);
bool Update(BTreeNode*BST, const ElemType&item);
void Insert(BTreeNode*&BST, const ElemType&item);
bool Delete(BTreeNode*&BST, const ElemType&item);

查找函数 find 从二叉搜索树 BST 中查找等于给定值 item 的元素，若查找成功则返回 true，并由 item 带回该元素的值，否则返回 false。更新函数 Update 从二叉搜索树 BST 中查找等于给定值 item 的元素，若查找成功则用 item 的值更新该元素并返回 true，否则返回 false。插入函数 Insert 向二叉搜索树 BST 中插入一个元素 item，使得插入后仍保持为一棵二叉搜索树。删除函数 Delete 从二叉搜索树中删除等于给定值 item 的结点，若删除成功则返回 true，否则返回 false。

\section*{6.1 .3 二叉搜索树的运算}

1. 查找

根据二叉搜索树的定义，查找等于给定值 item 的元素时，若二叉搜索树为空，则表明查找失败，应返回假。否则，若 item 等于当前树根结点的值，则表明查找成功，应由引用参数 item 带回根结点的值并返回真；若 item 小于根结点的值，则继续在根的左子树中查找；若 item 大于根结点的值，则继续在根的右子树中查找。这是一个递归查找过程，其递归算法描述如下。

bool Find(BTreeNode*BST, ElemType&item)
//从二叉搜索树中查找等于给定值 item 的元素
{
    if(BST==NULL) return false; //查找失败返回假
    else {
        if(item==BST->data) { //若查找成功则带回元素值并返回真
            item=BST->data;
            return true;
        }
        else if (item<BST->data) //向左子树继续查找
            return Find(BST->left, item);
        else //向右子树继续查找
            return Find(BST->right, item);
    }
}

由于此递归算法中的递归调用属于末尾递归的调用，即递归调用语句是函数体中最后一条可执行语句，每次递归调用返回后不执行任何语句又返回到上一层，因此原先保存在数据堆栈中的信息都是没有用处的。所以为了避免无效花费在进出数据栈操作上的时间和

使用数据栈的空间，相应的非递归算法如下。

bool Find1(BTreeNode*BST, ElemType& item) //二叉搜索树查找的非递归算法
{
    while(BST!=NULL) {
        if(item==BST->data) {
            item=BST->data; return true;
        }
        else if(item<BST->data) BST=BST->left;
        else BST=BST->right;
    }
    return false;
}

从图 6-1 所示的二叉搜索树中查找关键字为 23 的元素时, 首先用 23 同根结点 30 进行比较, 因为$23<30$, 所以向 30 的左子树继续查找; 再用 23 同当前根结点 15 进行比较, 因为$23>15$, 所以向 15 的右子树继续查找; 再用 23 同当前根结点 23 进行比较, 因为相等,所以由 item 带回该结点的值并返回真, 整个查找过程就此结束。若从图 6-1 中查找关键字为 48 的元素时, 其查找过程为: 首先用 48 同根结点 30 进行比较, 因为$48>30$, 所以向 30 的右子树继续查找; 再用 48 同当前根结点 52 进行比较, 因为$48<52$, 所以向 52 的左子树继续查找, 此时左子树为空, 所以返回假, 表明查找失败, 整个查找过程就此结束。

在二叉搜索树上进行查找的过程中, 给定值 item 同树中结点比较的次数最少为一次 (即树根结点就是待查的结点), 最多为树的深度, 所以平均查找次数要小于等于树的深度。若二叉搜索树是一棵理想平衡树或接近理想平衡树, 则进行查找的时间复杂度为$O(\log n)$; 若退化为一棵单支树（最极端和最差的情况），则其时间复杂度为$O(n)$。对于一般情况, 其时间复杂度可大致看作$O(\log n)$。因此在二叉搜索树上查找比在集合或线性表上进行顺序查找的时间复杂度$O(n)$要好得多, 这正是构造二叉搜索树的优势所在。二叉搜索树查找的递归算法的空间复杂度平均情况为$O(\log n)$, 最差情况为$O(n)$, 非递归算法的空间复杂度为$O(1)$。

2. 更新

二叉搜索树的更新算法与查找算法基本相同, 区别仅有两点: 一是在更新算法中当查找到待更新的元素时, 应将 item 的值赋给该元素, 而在查找算法中是将该元素的值赋给 item 带回; 二是在更新算法中参数 item 可以为变参 (即引用参数), 也可以为值参, 并且在参数说明的前面可以加或不加常量标识符 const, 而在查找算法中参数 item 只能为变参, 并且不能加常量标识符 const。请同学们编写此更新算法。

3. 插入

根据二叉搜索树的定义, 向二叉搜索树中插入元素 item 的过程为: 若二叉树为空, 则由 item 元素生成的新结点将作为根结点插入; 否则, 若 item 小于根结点, 则将新结点插入到根的左子树上, 若 item 大于等于 (若不允许具有相同值的结点存在, 则对等于情况应

作单独处理）根结点，则将新结点插入到根的右子树上。显然插入过程是递归的，对应的递归算法描述如下。

void Insert(BTreeNode*& BST, const ElemType&item)
{
    if (BST==NULL)
    {
        //把按照 item 元素生成的新结点链接到已找到的插入位置
        BTreeNode* p=new BTreeNode;
        p->data=item;
        p->left=p->right=NULL;
        BST=p;
    }
    else if (item<BST->data)                      //向左子树中插入元素
        Insert(BST->left, item);
    else
        Insert(BST->right, item);                 //向右子树中插入元素
}

此算法中的树根指针参数 BST 必须说明为引用，因为当它为空时需要由它带回树根指针，或者在递归时由它提供新插入结点的链接位置。

同一叉搜索树的递归查找算法一样，此算法也属于末尾递归的调用，所以为了消除末尾递归，减少算法运行的时间和空间，也可编写出对应的非递归算法（注意：消除末尾递归不需要使用栈）。对于插入过程的非递归算法，需要首先查找插入位置，然后再进行插入。查找插入位置从树根结点开始，若树根指针为空，则新结点就是树根结点；否则，若 item 小于根结点，则沿着根的左指针在左子树上继续查找插入位置，若 item 大于等于根结点，则沿着根的右指针在右子树上继续查找插入位置，当查找到一个结点（设由 parent 指针所指向）的左指针或右指针为空时，则这个空的指针位置就是新元素结点的插入位置。

在进行插入时，若原树为空，则将新结点指针赋给 BST，该新结点就成为树根结点；否则，将新结点赋给 parent 结点的左指针域或右指针域，作为该结点的左孩子或右孩子。插入过程的非递归算法具体描述如下。

void Insert1(BTreeNode*&BST, const ElemType&item)
{
    //为插入新元素寻找插入位置，定义指针 t 指向当前待比较的结点，初始
    //指向树根结点，定义指针 parent 指向 t 结点的双亲结点，初始为 NULL
    BTreeNode* t=BST,*parent=NULL;
    while(t!=NULL) {
        parent=t;
        if(item<t->data) t=t->left;
        else t=t->right;
    }
    //建立值为 item, 左、右指针域为空的新结点
    BTreeNode* p=new BTreeNode;
    p->data=item;

p->left=p->right=NULL;
//将新结点插入到二叉搜索树 BST 中
if(parent==NULL) BST=p;
else if(item<parent->data) parent->left=p;
else parent->right=p;

二叉搜索树插入算法的时间和空间复杂度, 与其查找和更新算法完全相同。

利用二叉搜索树的插入算法, 可以很容易地编写出生成一棵具有$n$个结点的二叉搜索树的算法, 设生成二叉搜索树的$n$个元素由数组提供, 则算法描述如下。

void CreateBSTree(BTreeNode*& BST, ElemType a[], int n)
    //利用数组中的$n$个元素建立二叉搜索树的算法
{
    BST=NULL;
    for(int i=0; i<n; i++)
        Insert(BST, a[i]);
}

在一般情况下, 此算法的时间复杂度为$O(n \times \lg n)$。

若建立二叉搜索树的一组元素的关键字为:$(38,26,62,94,35,50,28,55)$按照上述算法, 每插入一个结点后得到的二叉搜索树如图 6-2 所示。

(a) 插入 38 (b) 插入 26 (c) 插入 62 (d) 插入 94 (e) 插入 35
(f) 插入 50 (g) 插入 28 (h) 插入 55

图 6-2 二叉搜索树的生成过程

4. 删除

二叉搜索树的删除比插入要复杂一些, 因为被插入的结点都是被链接到树中的叶子结点上, 因而不会破坏树的原有结构, 也就是说, 不会破坏树中原有结点之间的链接关系。

从二叉搜索树上删除结点（元素）则不同，它可能删除的是叶子结点，也可能删除的是分支结点，当删除分支结点时，就破坏了原有结点之间的链接关系，需要重新修改指针，使得删除后仍为一棵二叉搜索树。

结合如图 6-3 (a) 所示的二叉搜索树，分 3 种情况介绍删除结点的操作。

(a) 二叉搜索树

(b) 删除 G 和 M 后

(c) 删除 D 结点后

(d) 删除 L 结点后

图 6-3 二叉搜索树的删除

(1) 删除叶子结点。

此种删除操作很简单，只要将其双亲结点链接到它的指针去掉（即置为空）。如删除图 6-3 (a) 树中叶子结点 A 时，把 D 结点的左指针域置空；删除叶子结点 W 时，把 S 结点的右指针域置空。

(2) 删除单支结点。

这种删除操作也比较简单，因为该结点只有左子树或右子树一支，也就是说，其后继只有一个：左孩子或右孩子。删除该结点时，只要将后继指针链接到它所在的链接位置即可。如删除图 6-3 (a) 树中单支结点 G 时，将 G 的左指针（即指向 F 结点的指针）赋给 D 结点的右指针域即可；删除单支结点 M 时，将 M 的右指针（即指向 S 结点的指针）赋给 L 结点的右指针域即可；删除这两个结点后，得到的二叉搜索树，如图 6-3 (b) 所示。

(3) 删除双支结点。

这种删除比较复杂，因为待删除的结点有两个后继指针，需要妥善处理。删除这种结点的第 1 种方法是：首先把它的右子树链接到它的中序前驱结点（即中序序列中处于它前面的一个结点）的右指针域，此中序前驱结点必是它的左子树中“最右下”的一个右指针为空（左指针可能为空，也可能不为空）的结点，在图 6-3 (a) 树中双支结点 D 的中序前驱为 A 结点，双支结点 L 的中序前驱为 G 结点；然后把它的左子树链接到它所在的链接位置。如在图 6-3 (a) 树中删除双支结点 D 时，则首先把 D 的右子树链接到 A 结点的右

指针域，然后把 D 的左子树链接到 L 的左指针域，删除 D 结点后得到的二叉搜索树如图 6-3 (c) 所示。这种方法往往容易增加树的深度，使树的结构变坏，所以通常采用下面介绍的第 2 种方法。

删除双支结点的第 2 方法是：首先把它的中序前驱结点的值赋给该结点的值域，然后再删除它的中序前驱结点，因为它的中序前驱结点的右指针为空，所以只要把中序前驱结点的左指针链接到中序前驱结点所在的链接位置即可。如删除图 6-3 (a) 树中双支结点 D 时，首先把它的中序前驱结点 A 的值赋给 D 结点的值域，然后把 A 结点的左指针（此时为空）链接到 D 结点的左指针域，删除 D 结点后得到的二叉搜索树，如图 6-3 (c) 所示。又如，若从图 6-3 (a) 树中删除根结点 L，因为 L 是双支结点，所以首先把它的中序前驱结点 G 的值赋给 L 结点的值域，然后把 G 结点的左指针（此时指向 F 结点）链接到 D 结点的右指针域，删除 L 结点后得到的二叉搜索树，如图 6-3 (d) 所示。

采用以上方法从二叉搜索树中删除结点后，得到的仍然是一棵二叉搜索树。

从二叉搜索树中删除结点的算法可以是递归的，也可以是非递归的，下面只给出递归算法，读者可以编写出相应的非递归算法。

```
bool Delete(BTreeNode*&BST, const ElemType&item)
    //从二叉搜索树 BST 中删除值为 item 的结点，树根指针必须为引用
{
    //树为空，未找到待删除元素，返回假表示删除成功
    if (BST==NULL) return false;
    //待删除元素小于树根结点值，继续在左子树中删除
    if (item<BST->data) return Delete(BST->left, item);
    //待删除元素大于树根结点值，继续在右子树中删除
    if (item>BST->data) return Delete(BST->right, item);
    BTreeNode*temp=BST;
    //待删除元素等于树根结点值且左子树为空，将右子树作为整棵树并返回真
    if (BST->left==NULL) {
        BST=BST->right; delete temp; return true;
    }
    //待删除元素等于树根结点值且右子树为空，将左子树作为整棵树并返回真
    else if (BST->right==NULL) {
        BST=BST->left; delete temp; return true;
    }
    //待删除元素等于树根结点值且左、右子树均不为空时的处理情况
    else {
        //中序前驱结点就是左孩子结点时，把左孩子结点值赋给树根结点，
        //然后从左子树中删除根结点
        if (BST->left->right==NULL) {
            BST->data=BST->left->data;
            return Delete(BST->left, BST->left->data);
        }
        //找出中序前驱结点，即左子树的右下角结点，把该结点值赋给树根结点，
        //然后从以中序前驱结点为根的树上删除根结点
        else {
```

BTreeNode* p1=BST,*p2=BST->left;
while(p2->right!=NULL) {p1=p2; p2=p2->right;}
BST->data=p2->data;
return Delete(p1->right, p2->data);

}

二叉搜索树的查找、插入、删除元素的运算都具有相同的时间复杂度，都与具体二叉搜索树的深度成正比，时间复杂度的平均情况为$O(\log n)$，最差情况为$O(n)$；它们的空间复杂度，对于递归算法来说，平均情况为$O(\log n)$，最差情况为$O(n)$，对于非递归算法来说均为$O(1)$。

可以采用下面程序调试对二叉搜索树各种运算的算法。

#include<iostream.h>
#include<stdlib.h>
//定义二叉搜索树结点值的类型为整型
typedef int ElemType;
//定义二叉搜索树结点类型
struct BTreeNode {
    ElemType data;
    BTreeNode* left;
    BTreeNode* right;
};

#include"二叉树运算.cpp"
#include"二叉搜索树运算.cpp" //保存对二叉搜索树运算的算法

void main()
{
    ElemType x;
    //定义指向二叉搜索树结点的指针，并用它作为树根指针
    BTreeNode* bst;
    //初始化二叉搜索树，即置树根指针bst为空
    InitBTree(bst);
    //定义数组a并初始化
    ElemType a[10]={30,50,20,40,25,70,54,23,80,92};
    //利用数组a建立树根指针为bst的二叉搜索树
    CreateBSTree(bst,a,10);
    //以广义表形式输出二叉搜索树
    PrintBTree(bst); cout<<endl;
    //求出以bst为树根指针的二叉搜索树的深度
    cout<<"深度：" ; cout<<DepthBTree(bst)<<endl;
    //中序遍历以bst为树根指针的二叉搜索树

cout<<"中序: "; InOrder(bst); cout<<endl;
                                //从二叉搜索树中查找一个结点
cout<<"输入一个待查找的整数值:";
cin>>x;
if(Find1(bst,x)) cout<<"查找元素"<<x<<"成功!"<<endl;
else cout<<"查找元素"<<x<<"失败!"<<endl;
                        //向二叉搜索树中插入一个结点
cout<<"输入一个待插入结点的整数值:";
cin>>x;
Insert1(bst,x);
                            //从二叉搜索树中删除一个结点
cout<<"输入一个待删除结点的值:";
cin>>x;
if(Delete(bst,x)) cout<<"删除元素"<<x<<"成功!"<<endl;
else cout<<"删除元素"<<x<<"失败!"<<endl;
                    //再以广义表形式输出二叉搜索树
PrintBTree(bst); cout<<endl;
                //再次中序遍历以bst为树根指针的二叉搜索树
cout<<"中序: "; InOrder(bst); cout<<endl;
                        //清除以bst为树根指针的二叉树
ClearBTree(bst);

程序的一次运行结果如下。$30(20(,25(23)),50(40,70(54,80(,92))))$深度: 5
中序: 20 23 25 30 40 50 54 70 80 92
输入一个待查找的整数值:70
查找元素70 成功!
输入一个待插入结点的整数值:15
输入一个待删除结点的值:30
删除元素30 成功!$25(20(15,23),50(40,70(54,80(,92))))$中序: 15 20 23 25 40 50 54 70 80 92

6.2 堆

6.2.1 堆的定义

堆(heap)分为小根堆和大根堆两种, 对于一个小根堆, 它是具有如下特性的一棵完全二叉树。
（1）若树根结点存在左孩子，则根结点的值 (或某个域的值) 小于等于左孩子结点的值 (或某个域的值)。
（2）若树根结点存在右孩子，则根结点的值 (或某个域的值) 小于等于右孩子结点的值

(或某个域的值)。

(3) 以左、右孩子为根的子树又各是一个堆。

大根堆的定义与上述类似, 只要把小于等于改为大于等于就得到了。

由堆的定义可知, 若一棵完全二叉树是堆, 则该树中以每个结点为根的子树也都是一

个堆。

如图 6-4 所示分别为一个小根堆和一个大根堆。根据堆的定义可知, 堆顶结点, 即整个完全二叉树的根结点, 对于小根堆来说具有最小值, 对于大根堆来说具有最大值。图 6-4 (a) 是一个小根堆, 堆中的最小值为堆顶结点的值 18, 图 6-4 (b) 是一个大根堆,堆中的最大值为堆顶结点的值 74。若用堆来表示优先级队列, 则堆顶结点具有最高的优先级, 每次做删除操作要删除堆顶结点。$\begin{aligned} & \text { (a) 小根堆 } \\ & \text { (b) 大根堆 } \end{aligned}$图 6-4 小根堆和大根堆

\section*{6.2 .2 堆的抽象数据类型}

堆的抽象数据类型中的数据部分是按任一种存储结构表示的堆, 用标识符 HBT 表示,其存储类型用标识符 HeapType 表示。堆的抽象数据类型中的操作部分通常为: 向堆中插入一个元素、从堆中删除堆顶元素、初始化一个堆、清除一个堆和判断一个堆是否为空等。堆的抽象数据类型的具体定义如下。

ADT HEAP is
Data:
具有 HeapType 类型的一个堆 HBT
Operations:
void InitHeap(HeapType& HBT); // 初始化一个堆为空
void ClearHeap(HeapType& HBT); // 清除一个堆, 使之变为空
bool EmptyHeap(HeapType& HBT); // 判断一个堆是否为空
void InsertHeap(HeapType& HBT, ElemType item); // 向堆中插入元素
ElemType DeleteHeap(HeapType& HBT); // 从堆中删除堆顶元素并返回
end HEAP

\section*{6.2 .3 堆的存储结构}

堆同一般二叉树一样既可采用顺序存储, 也可采用链接存储。但由于堆是一棵完全二

叉树, 所以适宜采用顺序存储, 这样能够充分利用其存储空间。

对堆进行顺序存储时, 首先要对堆中的所有结点进行编号, 然后再以编号为下标存储到指定数组的对应元素中。为了利用数组的 0 号元素, 堆中结点的编号从 0 而不是从 1 开始, 当然编号次序仍然按照从上到下、同一层从左到右进行, 若堆中含有$n$个结点, 则编号范围为$0 \sim n-1$。

堆中的结点从 0 开始编号后, 编号为 0 至$\lfloor n / 2\rfloor-1$的结点为分支结点, 编号为$\lfloor n / 2\rfloor \sim n-1$的结点为叶子结点; 当$n$为奇数则每个分支结点既有左孩子又有右孩子, 当$n$为偶数则编号最大的一个分支结点只有左孩子没有右孩子; 对于每个编号为$i$的分支结点, 其左孩子结点的编号为$2i+1$, 右孩子结点的编号为$2i+2$; 除编号为 0 的堆顶结点外, 对于其余编号为$i$的结点, 其双亲结点的编号为$\lfloor(i-1)/2\rfloor$。

对于图 6-4 所示的堆, 对应的顺序存储结构, 如图 6-5 所示。$\begin{array}{|c|c|c|c|c|c|c|c|c|c|}\hline 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\hline 18 & 26 & 35 & 73 & 48 & 60 & & & & \\\hline\end{array}$(a) 图 6-4 (a) 的存储结构$\begin{array}{|c|c|c|c|c|c|c|c|c|c|}\hline 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\hline 74 & 53 & 42 & 25 & 36 & 35 & 20 & 18 & 22 & \\\hline\end{array}$(b) 图 6-4 (b) 的存储结构

图 6-5 堆的顺序存储结构

根据此存储结构可以验证给出的双亲和左、右孩子结点之间的下标关系。

当一个堆采用顺序存储结构时, 需要定义一个元素类型为 ElemType、长度为 MaxSize 的一个数组来存储堆中的所有元素, 还需要定义一个整型变量, 用以存储堆的长度, 即堆中当前包含的结点数。设存储堆元素的数组名用 heap 表示, 存储堆长度的变量名用 len 表示, 并且把它们连同存储空间大小 MaxSize 一起定义在一个结构类型中, 结构类型名用 Heap 表示, 则该类型定义为:

struct Heap {
    ElemType* heap; // 定义指向动态数组空间的指针
    int len;        // 定义保存堆长度的变量
    int MaxSize;    // 用于保存初始化时所给的动态数组空间的大小
};

6.2.4 堆的运算

在堆的抽象数据类型中列出的每一种操作的具体算法描述如下。对于插入和删除算法将以小根堆为例给出, 当为大根堆时只是相应条件中的比较操作符不同, 其余都相同。

1. 初始化堆

void InitHeap(Heap& HBT) // 置 HBT 为一个空堆

{
    HBT.MaxSize=10;                           //初始定义数组长度为 10,以后可增减
    HBT.heap=new ElemType[HBT.MaxSize];      //动态分配存储堆的数组空间
    if(!HBT.heap) {
        cout<<"用于动态分配的内存空间用完, 退出运行!"<<endl;
        exit(1);
    }
    HBT.len=0;                                //设置 len 域的初值为 0
}

2. 清除堆

void ClearHeap(Heap&HBT)                      //清除 HBT,使之成为一个空堆
{
    if(HBT.heap!=NULL) {
        delete[] HBT.heap;
        HBT.heap=NULL;
        HBT.len=0;
        HBT.MaxSize=0;
    }
}

3. 检查一个堆是否为空

bool EmptyHeap(Heap&HBT)                      //判断 HBT 是否为空,是返真,否返假
{
    return HBT.len==0;
}

4. 向堆中插入一个元素

向堆中插入一个元素时, 首先将该元素写入到堆尾, 即堆中最后一个元素的后面, 亦即下标为$len$的位置上, 然后经调整为一个新堆。由于在原有堆上插入一个新元素后, 可能使以该元素为根的子树不为堆, 从而使整个树不为堆, 所以必须进行调整使之仍为一个堆。调整的方法很简单, 若新元素小于双亲结点的值, 就让它们互换位置; 新元素换到双亲位置后, 使得以该位置为根的子树成为堆, 但新元素可能还小于此位置的双亲结点的值, 从而使以上一层的双亲结点为根的子树不为堆, 还需要按上述方法继续调整, 这样持续传递上去, 直到以新位置的双亲结点为根的子树仍为一个堆或者调整到堆顶为止, 此时得到的整个树又成为一个堆。

对于图 6-4 (a) 所示的堆, 若向它插入一个新元素 50 时, 由于它不小于双亲结点的值 35, 所以以 35 为根的子树仍为一个堆, 从而使整个二叉树仍然是一个堆, 此次插入不需要作任何调整。插入新元素 50 后得到的堆, 如图 6-6 (a) 所示。

(a) 插入 50
(b) 插入 30
(c) 插入 15

图 6-6 堆的插入

对于图 6-4 (a) 所示的堆, 若向它插入一个新元素$30$, 由于它小于双亲结点的值$35$,所以需要将$30$与$35$对调位置, 对调后因新元素$30$不小于其双亲元素$18$, 所以调整结束,得到的整个二叉树为一个堆, 插入结果如图 6-6 (b) 所示。

对于图 6-4 (a) 所示的堆, 若向它插入的一个新元素为$15$, 由于它小于双亲元素$35$,所以需要将$15$与$35$对调位置, 对调后因新元素$15$小于其双亲元素$18$, 所以又需要将$15$与$18$对调位置, 此时新元素被调整到了堆顶位置, 所以调整结束, 得到的插入后结果如图 6-6 (c) 所示。

向堆中插入一个元素的算法描述如下。

void InsertHeap(Heap& HBT, ElemType item) //向小根堆 HBT 中插入元素
{
//堆满时重分配大一倍的存储空间并进行相应操作
if(HBT.len==HBT.MaxSize) {
int k=sizeof(ElemType);
HBT.heap=(ElemType*) realloc(HBT.heap, 2*HBT.MaxSize*k); //计算每个元素存储空间的长度
//堆动态存储空间扩展为原来的 2 倍, 原内容自动保持不变
if(HBT.heap==NULL) {
cout<<"动态可分配的存储用完, 退出运行!"<<endl;
exit(1);
}
HBT.MaxSize=2*HBT.MaxSize; //把堆空间大小修改为新的长度
}
//用 i 指向待调整元素的位置, 初始指向新元素所在的堆尾位置
int i=HBT.len;
//寻找新元素的最终位置, 每次使双亲元素下移一层
while(i!=0) {
int j=(i-1)/2; //j 指向下标为 i 的元素的双亲元素
if(item>=HBT.heap[j]) break; //比较调整结束退出循环
HBT.heap[i]=HBT.heap[j]; //双亲元素下移
i=j; //改变调整元素的位置为其双亲位置
}
//把新元素调整到最终位置, 并使堆的长度增 1
HBT.heap[i]=item;
HBT.len++;
}

此算法的运行时间主要取决于 while 循环的执行次数，它等于新元素向双亲位置逐层上移的次数，此次数最多等于整个树的深度减 1，所以算法的时间复杂度为$O(\log n)$，其中$n$表示堆的大小。

5. 从堆中删除元素

从堆中删除元素就是删除堆顶元素并使之返回。堆顶元素被删除后，留下的堆顶位置应由堆尾元素来填补，这样既保持了顺序存储结构又不需要移动其他任何元素。把堆尾元素素移动到堆顶位置后，它可能不小于左、右孩子结点，使整个二叉树不为堆，所以需要一个调整过程，使之变为含有$n-1$个元素的堆（删除前为$n$个元素）。调整过程首先从树根结点开始，若树根结点的值大于两个孩子结点中的最小值，就将它与具有最小值的孩子结点互换位置，使得根结点的值小于两个孩子结点的值；原树根结点被对调到一个孩子位置后，可能使以该位置为根的子树又不为堆，因而又需要使新元素向孩子一层调整，如此调整下去，直到以调整后的位置为根的子树成为一个堆或调整到叶子结点为止。

对于图 6-4(a)所示的堆，当从中删除顶点元素 18 时，需要把堆尾元素 60 写入到堆顶位置成为堆顶元素，由于 60 大于两个孩子中的最小值 26，所以应互换 60 和 26 的位置，60 被移到新位置后，又大于两个孩子中的最小值 48，所以接着同 48 互换位置，此时 60 已被调整到叶子结点，所以调整完成后得到的完全二叉树又成为一个堆，如图 6-7 所示。
![image](attachment://figure_6_7.png)
图 6-7 堆的删除

若图 6-4(a)所示堆的顶元素不是 60 而是 45，则进行删除操作时把 45 写入到堆顶位置后，因 45 大于两个孩子中的最小值 26，所以需把它对调到左孩子 26 的位置，此时它小于两个孩子中的最小值 48，表明以 45 所在的新位置为根的子树已经成为一个堆，至此调整结束。

从堆中删除元素的算法描述如下。

```
ElemType DeleteHeap(Heap& HBT)    //从小根堆 HBT 中删除堆顶元素并返回
{
    if(HBT.len==0) {              //若为空堆，则显示出错误信息并退出运行
        cerr<<"堆为空，退出运行!"<<endl;
        exit(1);
    }
    ElemType temp=HBT.heap[0];    //将堆顶元素暂存 temp 以便返回
    HBT.len--;                    //堆的长度减 1
    if(HBT.len==0) return temp;   //若删除操作后变为空堆则返回
    ElemType x=HBT.heap[HBT.len]; //将待调整的堆尾元素暂存 x 中
    int i=0;                      //用 i 指向待调整元素的位置，初始指向堆顶位置
    int j=1;                      //用 j 指向 i 的左孩子位置，初始指向下标 1 的位置
    while(j<=HBT.len-1) {         //寻找待调整元素的最终位置
        //若右孩子存在并且较小，应使 j 指向右孩子
        if(j<HBT.len-1 && HBT.heap[j]>HBT.heap[j+1]) j++;
```

//若条件成立则调整结束，退出循环
if (x<=HBT.heap[j]) break;
//孩子元素上移到双亲位置
HBT.heap[i]=HBT.heap[j];
//使i和j分别指向下一层结点
i=j; j=2*i+1;
}
HBT.heap[i]=x; //把待调整元素放到最终位置
return temp; //返回原堆顶元素

此算法的运行时间主要取决于 while 循环的执行次数，它等于堆顶新元素向孩子位置逐层下移的次数，此次数最多等于整个树的深度减 1，所以堆删除算法的时间复杂度同插入算法相同，均为$O(\log n)$。

在解决实际问题时，若每次只需要取出（即删除）具有最小值的元素，则适合采用堆这种数据结构，因为其插入和删除元素的时间复杂度均为$O(\log n)$。若采用线性表来实现这种功能，其插入和删除元素的时间复杂度将均为$O(n)$。

在计算机操作系统中，管理一个共享资源就需要使用一个堆，把等待使用该资源的所有用户按照优先级号组织起来，优先级最高的用户一定处于堆首位置，系统每次从这个堆中取出(删除)堆顶元素并为之服务，需要使用该资源的新用户被加入到等待使用该资源的堆中。

使用堆的一个完整程序如下，请读者阅读和分析。

#include<iostream.h>
#include<stdlib.h>
typedef int ElemType; //定义元素类型为整型
struct Heap {
    ElemType*heap; //定义堆的顺序存储类型
    int len;
    int MaxSize;
};

#include"堆运算.cpp" //假定在 heap.cpp 中保存着堆运算的各种算法

void main()
{
    int a[8]={23,56,40,62,38,55,10,16};
    Heap b; //定义一个堆b
    InitHeap(b); //初始化堆b
    int i,x;
    //向堆b中依次插入数组a中的每一个元素

for(i=0;i<8;i++) InsertHeap(b,a[i]);
//按下标位置依次输出堆中的每个元素
for(i=0;i<7;i++) cout<<b.heap[i]<<',';
cout<<b.heap[7]<<endl;
//依次删除堆顶元素并显示出来，直到堆空为止
while (!EmptyHeap(b)) {
    x=DeleteHeap(b);
    cout<<x;
    if (!EmptyHeap(b)) cout<<',';
}
cout<<endl;
ClearHeap(b);

请通过堆的图示操作过程验证下面运行结果的正确性。

10,16,23,38,56,55,40,62
10,16,23,38,40,55,56,62

\section*{6.3 哈夫曼树}

\subsection*{6.3.1 基本术语}

1. 路径和路径长度

在一棵树中存在着一个结点序列$k_1,k_2,\cdots,k_j$，使得$k_i$是$k_{i+1}$的双亲$(1 \leq i < j)$，则称此结点序列是从$k_1$到$k_j$的路径，因树中每个结点只有一个双亲结点，所以它也是这两个结点之间的唯一路径。从$k_1$到$k_j$所经过的分支数称为这两点之间的路径长度，它等于路径上的结点数减 1。在图 6-3(a)所示的二叉树中，从树根结点 L 到叶子结点 P 的路径为结点序列 L,M,S,P，路径长度为 3。

2. 结点的权和带权路径长度

在许多应用中，常常将树中的结点赋上一个有着某种意义的实数，称此实数为该结点的权。结点的带权路径长度规定为从树根结点到该结点之间的路径长度与该结点上权的乘积。

3. 树的带权路径长度

树的带权路径长度定义为树中所有叶子结点的带权路径长度之和，通常记为：$\text{WPL}=\sum_{i=1}^{n} w_i l_i$

其中，$n$表示叶子结点的数目，$w_i$和$l_i$分别表示叶子结点$k_i$的权值和树根结点到$k_i$之间的路径长度。

4. 哈夫曼树

哈夫曼树（Huffman tree）又称做最优二叉树。它是$n$个带权叶子结点构成的所有二叉树中，带权路径长度 WPL 最小的二叉树。因为构造这种树的算法是最早由哈夫曼于 1952 年提出的，所以被称为哈夫曼树。

例如，有 4 个叶子结点 a, b, c, d，分别带权为 9, 4, 5, 2，由它们构成的三棵不同的二叉树（当然还有其他许多种）分别如图 6-8 (a) ~ 图 6-8 (c) 所示。

(a) 带权二叉树之一
(b) 带权二叉树之二
(c) 带权二叉树之三

图 6-8 由四个叶子结点构成的三棵不同的带权二叉树

每一棵二叉树的带权路径长度 WPL 分别为：
① WPL =$9 \times 2 + 4 \times 2 + 5 \times 2 + 2 \times 2 = 40$；
② WPL =$4 \times 1 + 2 \times 2 + 5 \times 3 + 9 \times 3 = 50$；
③ WPL =$9 \times 1 + 5 \times 2 + 4 \times 3 + 2 \times 3 = 37$。

其中，③树的 WPL 最小，稍后便知，此树就是哈夫曼树。

因此，在$n$个带权叶子结点所构成的二叉树中，满二叉树或完全二叉树不一定是最优二叉树。权值越大的结点离树根越近的二叉树才是最优二叉树。

\section*{6.3 .2 构造哈夫曼树}

构造最优二叉树的算法具体叙述如下。

(1) 根据与$n$个权值$\{w_1, w_2, \cdots, w_n\}$对应的$n$个结点构成具有$n$棵二叉树的森林$F=\{T_1, T_2, \cdots, T_n\}$其中，每棵二叉树$T_i (1 \leq i \leq n)$都只有一个权值为$w_i$的根结点，其左、右子树均为空。

(2) 在森林$F$中选出两棵根结点的权值最小的树作为一棵新树的左、右子树，且置新树的根结点的权值为其左、右子树上根结点的权值之和。

(3) 从$F$中删除构成新树的那两棵树，同时把新树加入$F$中。

(4) 重复 (2) 和 (3) 步，直到$F$中只含有一棵树为止，此树便是哈夫曼树。

若仍采用图 6-8 中的 4 个带权叶子结点来构造一棵哈夫曼树，按照上述算法，则构造过程如图 6-9 所示，其中图 6-9 (d) 就是最后生成的哈夫曼树，它的带权路径长度为 37，由此可知，图 6-8 (c) 是一棵哈夫曼树。

(a) 四棵树
(b) 三棵树

(c) 两棵树
(d) 一棵树

图 6-9 构造哈夫曼的过程

在构造哈夫曼树的过程中, 当每次由两棵权值最小的树生成一棵新树时, 新树的左子树和右子树可以任意安排, 这样将会得到具有不同结构的多个哈夫曼树, 但它们都具有相同的带权路径长度。为了使得到的哈夫曼树的结构尽量唯一, 通常规定生成的哈夫曼树中每个结点的左子树根结点的权小于等于右子树根结点的权。上述哈夫曼树的构造过程就是依照这一规定进行的。

根据上述构造哈夫曼树的方法可以写出相应的用 C++语言描述的算法如下。

BTreeNode* CreateHuffman(ElemType a[], int n)
    //根据数组 a 中 n 个权值建立一棵哈夫曼树, 返回树根指针
{
    BTreeNode** b,*q;
    //动态分配一个由 b 指向的指针数组
    b=new BTreeNode*[n];
    int i,j;
    //初始化 b 指针数组, 使每个指针元素指向 a 数组中对应元素的结点
    for(i=0; i<n; i++) {
        b[i]=new BTreeNode;
        b[i]->data=a[i]; b[i]->left=b[i]->right=NULL;
    }
    //进行 n-1 次循环建立哈夫曼树
    for(i=1; i<n; i++) {
        //用 k1 表示森林中具有最小权值的树根结点的下标
        //用 k2 表示森林中具有次最小权值的树根结点的下标
        int k1=-1,k2;
        //让 k1 初始指向森林中第一棵树, k2 初始指向森林中第二棵树
        for(j=0; j<n; j++) {
            if(b[j]!=NULL & k1==-1) {k1=j;continue;}
            if(b[j]!=NULL) {k2=j;break;}
        }

}
//从当前森林中求出最小权值树和次最小权值树
for(j=k2; j<n; j++) {
    if(b[j]!=NULL) {
        if(b[j]->data<b[k1]->data) {k2=k1;k1=j;}
        else if(b[j]->data<b[k2]->data) k2=j;
    }
}
//由最小权值树和次最小权值树建立一棵新树，q指向树根结点
q=new BTreeNode;
q->data=b[k1]->data+b[k2]->data;
q->left=b[k1]; q->right=b[k2];
//将指向新树的指针赋给b指针数组中k1位置，k2位置为空
b[k1]=q; b[k2]=NULL;
}
//删除动态建立的数组b
delete []b;
//返回整个哈夫曼树的树根指针
return q;
}

在一颗哈夫曼树的生成过程中，每次都由两棵子树构成一棵树，对于$n$个叶子结点共需要构成$n-1$棵子树。所以，在一棵哈夫曼树中只存在双支结点和叶子结点，若叶子结点为$n$个，则双支结点必为$n-1$个。

根据哈夫曼树求出带权路径长度的算法如下。

ElemType WeightPathLength(BTreeNode*FBT, int len)
{
    //根据FBT指针所指向的哈夫曼树求出带权路径长度，len初值为0
    if(FBT==NULL) return 0; //空树则返回0
    else {
        //访问到叶子结点时返回该结点的带权路径长度，其中值参len
        //保存当前被访问结点的路径长度
        if(FBT->left==NULL && FBT->right==NULL) {
            return FBT->data*len;
        }
        //访问到非叶子结点时进行递归调用，返回左、右子树的带权
        //路径长度之和，向下深入一层时len值增1
        else {
            return WeightPathLength(FBT->left,len+1)+
                   WeightPathLength(FBT->right,len+1);
        }
    }
}

\section*{6.3 .3 哈夫曼编码}

哈夫曼树的应用很广, 哈夫曼编码就是其中的一种, 下面简要介绍。

在电报通信中, 电文是以二进制的 0、1 序列传送的。在发送端需要将电文中的字符序列转换成二进制的 0、1 序列（即编码），在接收端又需要把接收到的 0、1 序列转换成对应的字符序列（即译码）。

最简单的二进制编码方式是等长编码。若电文中只使用 A、B、C、D、E、F 这 6 种字符，若进行等长编码，则需要二进制的三位，可依次编码为 000、001、010、011、100、101。若用这 6 个字符作为 6 个叶子结点，生成一棵二叉树，让该二叉树中每个分支结点的左、右分支分别用 0 和 1 编码，从树根结点到每个叶子结点的路径上所经分支的 0、1 编码序列应等于该叶子结点的二进制编码，则对应的编码二叉树，如图 6-10 所示。
![A] (A) [B] (B) [C] (C) [D] (D) [E] (E) [F] (F)

图 6-10 编码二叉树

通常，电文中每个字符的出现频率（即次数）一般是不同的。在一份电文中，这 6 个字符的出现频率依次为：4、2、6、8、3、2，则电文被编码后的总长度$L$可由下式计算：$L=\sum_{i=1}^{n} c_{i} l_{i}$其中，$n$表示电文中使用的字符数，$c_{i}$和$l_{i}$分别表示对应字符$k_{i}$在电文中的出现频率和编码长度。因此，可求出$L$为：$L=\sum_{i=1}^{6}\left(c_{i} \times 3\right)=3 \times(4+2+6+8+3+2)=75$可知，采用等长编码时，传送电文的总长度为 75。

那么，如何能缩短传送电文的总长度，从而节省传送时间呢？若采用不等长编码，让出现频率高的字符具有较短的编码，让出现频率低的字符具有较长的编码，这样有可能缩短传送电文的总长度。采用不等长编码要避免译码的二义性或多义性。假设用 0 表示字符 D，用 01 表示字符 C，则当接收到编码串…01…，并译到字符 0 时，是立即译出对应的字符 D，还是接着与下一个字符 1 一起译为对应的字符 C，这就产生了二义性。因此，若对某一字符集进行不等长编码，则要求字符集中任一字符的编码都不能是其他字符编码的前缀。符合此要求的编码叫做无前缀编码。显然等长编码是无前缀编码，这从等长编码所对应的编码二叉树也可直观地看出，任一叶子结点都不可能是其他叶子结点的双亲，也就是说，只有当一个结点是另一个结点的双亲时，该结点的字符编码才会是另一个结点的字符编码的前缀。

为了使不等长编码成为无前缀编码，可用该字符集中的每个字符作为叶子结点生成一棵编码二叉树。为了获得传送电文的最短长度，可将每个字符的出现频率作为字符结点的权值赋予该结点上，求出此树的最小带权路径长度就等于求出了传送电文的最短长度。因

此，求传送电文的最短长度问题就转化为求由字符集中的所有字符作为叶子结点，由字符的出现频率作为其权值所产生的哈夫曼树的问题。

由上例生成的编码哈夫曼树如图 6-11 所示。由编码哈夫曼树得到的字符编码称作哈夫曼编码。其中，A、B、C、D、E、F 这 6 个字符的哈夫曼编码依次为：00,1010,01,11,100,1011。电文的最短传送长度为：$L = WPL = \sum_{i=1}^{6} w_i l_i \\
= 4 \times 2 + 2 \times 4 + 6 \times 2 + 8 \times 2 + 3 \times 3 + 2 \times 4 \\
= 61$显然，计算结果比等长编码所得到的传送电文总长度 75 要小得多。

对求哈夫曼树带权路径长度的算法略加修改，就可以得到求哈夫曼编码的算法。具体如下。

void HuffManCoding(BTreeNode* FBT, int len)
    //根据 FBT 指针所指向的哈夫曼树输出每个叶子的编码，len 初值为 0
{
    static int a[10]; //数组的长度要至少等于哈夫曼树的深度减 1
    if (FBT != NULL) {
        //访问到叶子结点时输出其保存在数组 a 中的 0 和 1 序列编码
        if (FBT->left == NULL && FBT->right == NULL) {
            cout << "结点权值为" << FBT->data << "的编码:";
            for (int i = 0; i < len; i++) cout << a[i] << ' ';
            cout << endl;
        }
        //访问到非叶子结点时分别向左、右子树递归调用，并分别把分支上的 0、1 编码保存到数组 a 的对应元素中，向下深入一层时 len 值增 1
        else {
            a[len] = 0; HuffManCoding(FBT->left, len + 1);
            a[len] = 1; HuffManCoding(FBT->right, len + 1);
        }
    }
}

采用如下程序调试对哈夫曼树的算法。

#include<iostream.h>
#include<stdlib.h>

typedef int ElemType;
struct BTreeNode {
    ElemType data;

```cpp
BTreeNode* left;
BTreeNode* right;
};

#include "二叉树运算.cpp"

//根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针
BTreeNode* CreateHuffman(ElemType a[], int n); //补充函数定义

//根据 FBT 指针所指向的哈夫曼树求出带权路径长度，len 初值为 0
ElemType WeightPathLength(BTreeNode* FBT, int len); //补充函数定义

//根据 FBT 指针所指向的哈夫曼树输出每个叶子的编码，len 初值为 0
void HuffManCoding(BTreeNode* FBT, int len); //补充函数定义

void main()
{
    int n,i;
    BTreeNode* fbt=NULL;

    //输入哈夫曼树中叶子结点数
    cout<<"输入待构造的哈夫曼树中带权叶子结点数 n:";
    cin>>n;

    //用数组 a 保存从键盘输入的 n 个叶子结点的权值
    ElemType*a=new ElemType[n];
    cout<<"输入"<<n<<"个整数作为权值:";
    for(i=0; i<n; i++) cin>>a[i];

    //根据数组 a 建立哈夫曼树
    fbt=CreateHuffman(a,n);

    //以广义表形式输出哈夫曼树
    cout<<"广义表形式的哈夫曼树:";
    PrintBTree(fbt);
    cout<<endl;

    //输出哈夫曼树的权值，即带权路径长度
    cout<<"哈夫曼树的权:";
    cout<<WeightPathLength(fbt,0)<<endl;

    //输出哈夫曼编码，即每个叶子结点所对应的 0,1 序列
    cout<<"树中每个叶子的哈夫曼编码:"<<endl;
    HuffManCoding(fbt,0);
    ClearBTree(fbt);
}

程序的一次运行结果如下。

输入待构造的哈夫曼树中带权叶子结点数 n:6
输入 6 个整数作为权值:3 9 5 12 6 15
广义表形式的哈夫曼树:50(21(9,12),29(14(6,8(3,5)),15))
哈夫曼树的权:122
```

树中每个叶子的哈夫曼编码:

结点权值为 9 的编码:$0 \ 0$结点权值为 12 的编码:$0 \ 1$结点权值为 6 的编码:$1 \ 0 \ 0$结点权值为 3 的编码:$1 \ 0 \ 1 \ 0$结点权值为 5 的编码:$1 \ 0 \ 1 \ 1$结点权值为 15 的编码:$1 \ 1$*6.4 线索二叉树

\subsection{6.4.1 二叉树的线索化}

对二叉树进行某种遍历得到的结点序列, 可以看作一个线性表。在该线性表中, 除第一个结点外, 每个结点有且仅有一个前驱, 除最后一个结点外, 每个结点有且仅有一个后继。为了同在二叉树中所具有的结点前驱 (即双亲) 和后继 (即孩子) 区别开来, 在容易混淆的地方, 通常把遍历序列中结点的前驱或后继冠以某种遍历的名称, 如把中序序列中结点的前驱称作中序前驱, 结点的后继称作中序后继。对于如图 6-12 所示的二叉树, 中序遍历的结点序列为 B、G、D、A、E、H、C、F, 其中 B 结点为中序遍历得到的线性序列的表头结点, 它没有前驱, 其中序后继为 G 结点, A 结点的中序前驱为 D 结点, 中序后继为 E 结点等。

对于一棵具有$n$个结点的二叉树, 对应的二叉链表中共有$2n$个指针域, 其中$n-1$个用于指向除树根结点以外的其余$n-1$个结点, 另有$n+1$个指针域空闲着。若把每个结点中空着的左指针域和右指针域用于分别指向某种遍历次序的前驱结点和后继结点, 则在遍历这种二叉树时, 可由此信息直接找到在该遍历次序下的前驱结点或后继结点, 从而比递归遍历提高了遍历速度、节省了建立系统栈所使用的存储空间。这种在结点的空指针域中存放的该结点在某次遍历次序下的前驱结点或后继结点的指针叫做线索 (thread), 其中在空的左指针域中存放的指向其前驱结点的指针叫做左线索或前驱线索, 在空的右指针域中存放的指向其后继结点的指针叫做右线索或后继线索。对一棵二叉树中的所有结点的空指针域按照某种遍历次序加线索的过程叫做线索化, 被线索化了的二叉树称做线索二叉树。如图 6-12 (b) 所示是对图 6-12 (a) 的二叉树加中序线索而得到的中序线索二叉树。

\n
(a) 二叉树
(b) 加中序线索后的二叉树

图 6-12 中序线索二叉树

在一个线索二叉树中，为了区别各个结点的左、右指针域所存放的是孩子指针，或是线索，必须在结点结构中增加两个线索标志域，一个是左线索标志域，用$ltag$表示，另一个是右线索标志域，用$rtag$表示。$ltag$和$rtag$只需取两种值，以区别其对应的指针域保存的是孩子指针，或是线索，取真时指向线索，取假时指向孩子。

增加线索标志域后的二叉树结点结构如下。

| Left | ltag | data | rtag | right |

该结点结构的类型定义为:

struct TTreeNode {
    ElemType data; // 值域
    bool ltag, rtag; // 线索标志域
    TTreeNode* left; // 左指针域
    TTreeNode* right; // 右指针域
};

如图 6-13 所示是图 6-12 的中序线索二叉树的链接存储结构。

![图 6-13 索引二叉树的链接存储结构]

对一棵结点类型为 TTreeNode 的二叉树进行线索化时，该二叉树的初始状态应为：每个结点的线索标志域均为假（0），若一个结点有左孩子或右孩子，则相应的指针域指向孩子，否则为空，以便在线索化的过程中加入线索。

对一棵二叉树进行某种遍历次序的线索化，显然就是对该二叉树进行这种遍历的过程，只不过在访问根结点时，不是简单地打印根结点的值，而是对指针域为空的结点加线索，具体做法如下。

(1) 若前驱结点不为空，或者说当前结点不是序列中的第 1 个结点，同时前驱结点的右线索标志域为真（表示此结点的右指针域为空）时，则将当前结点的指针赋给前驱结点的右指针域，即给前驱结点加右线索。

(2) 若当前结点的左指针域为空，则将左线索标志域置真，同时把前驱结点的指针赋给当前结点的左指针域，即给当前结点加左线索。

(3) 若当前结点的右指针域为空，则将右线索标志域置为真，以便当访问到下一个（即后继）结点时，给它加右线索。

(4) 将当前结点指针赋给保存前驱结点指针的变量，以便当访问下一个结点时，此当前结点成为前驱结点。

设$pre$是用来保存前驱结点指针的引用参数，初始为空；设$HBT$是用来保存当前结点指针的值参，初始指向待线索化的一棵二叉树的根结点，下面给出对二叉树进行中序线索化即建立中序线索的算法，它是在中序遍历算法的基础上改造而成的。

void InThread(TTreeNode* HBT, TTreeNode*& pre)
{
    // 对二叉树 HBT 加中序线索
    if (HBT != NULL) {
        if (HBT->ltag == false)
            InThread(HBT->left, pre);  // 左子树非空时给左子树加中序线索

        if (pre != NULL && pre->rtag == true)
            pre->right = HBT;          // 给前驱结点加后继线索

        if (HBT->left == NULL) {
            HBT->ltag = true;
            HBT->left = pre;           // 给当前结点加前驱线索
        }

        if (HBT->right == NULL)
            HBT->rtag = true;          // 给右指针域为空的结点加右线索标记

        pre = HBT;                     // 把刚访问过的当前结点置为前驱结点

        if (HBT->rtag == false)
            InThread(HBT->right, pre); // 右子树非空时给右子树加中序线索
    }
}

在对二叉树进行中序线索化的算法中，若把对左子树加线索的条件语句放到对右子树加线索的条件语句之上，则得到前序线索化的算法，所建立的线索为前序线索；若把对右子树加线索的条件语句放到对左子树加线索的条件语句之下，则得到后序线索化的算法，所建立的线索为后序线索。

若在该函数中不使用$pre$参数，也可以在函数体的开始位置加上如下语句替代。

static TTreeNode* pre = NULL;

利用下面算法向带线索标志域的二叉搜索树插入元素，但不进行中序线索的链接。

void InsertThreed(TTreeNode*& HBT, const ElemType& item)
{
    // 向带线索的二叉搜索树插入元素，但不链接线索
    if (HBT == NULL) {
        TTreeNode* p = new TTreeNode;
        p->data = item;
        p->left = p->right = NULL;
        p->ltag = p->rtag = 0;
        HBT = p;
    } else if (item < HBT->data)      // 向左子树中插入元素
}

InsertThreed(HBT->left, item);
else
    InsertThreed(HBT->right, item);

利用下面算法建立带线索标志域的二叉搜索树，但不进行中序线索链接。

void CreateThreed(TTreeNode*&HBT, ElemType a[], int n)
{
    HBT=NULL;
    for(int i=0; i<n; i++)
        InsertThreed(HBT, a[i]);
}

带线索标志域的二叉搜索树建立后，随时可以调用 InThread 算法，建立其中序线索。若要向带线索的二叉搜索树中插入结点，并且要进行实际的线索链接，则应采用下面插入算法。

void InsertThreed1(TTreeNode*&HBT, const ElemType&item)
{
    //向带线索的二叉搜索树插入元素，并进行线索链接
    //为新结点寻找插入位置
    TTreeNode*t=HBT,*parent=NULL;
    while(t!=NULL) {
        parent=t;
        if(item<t->data)
            if(t->ltag==false) t=t->left; else t=NULL;
        else
            if(t->rtag==false) t=t->right; else t=NULL;
    }
    //建立值为 item 的新结点
    TTreeNode*p=new TTreeNode;
    p->data=item;
    p->ltag=p->rtag=true;  //叶子结点的左、右孩子指针均为线索
    //将新结点插入到线索二叉搜索树 HBT 中
    if(parent==NULL) {
        p->left=p->right=NULL;  //作为树根结点插入
        HBT=p;
    }
    else if (item<parent->data) {
        p->left=parent->left;  //作为左孩子结点插入
        parent->ltag=false;  //置双亲的左线索标志域为假
        parent->left=p;  //新结点链接为双亲的左孩子
        p->right=parent;  //双亲结点成为新结点的后继
    }
    else {
        p->right=parent->right;  //作为右孩子结点插入
        parent->rtag=false;  //置双亲的右线索标志域为假
        parent->right=p;  //新结点链接为双亲的右孩子
        p->left=parent;  //双亲结点成为新结点的前驱
    }
}

parent->rtag=false; //置双亲的右线索标志域为假
parent->right=p; //新结点链接为双亲的右孩子
p->left=parent; //双亲结点成为新结点的前驱
}

利用 InsertThread1 算法建立一棵带线索的二叉搜索树的算法如下。

void CreateThread1(TTreeNode*&HBT, ElemType a[], int n)
//利用数组中的 n 个元素建立带线索的二叉搜索树的算法
{
    HBT=NULL;
    for(int i=0; i<n; i++)
        InsertThread1(HBT, a[i]);
}

\section*{6.4.2 利用线索进行遍历}

以中序线索为例来讨论这个问题。首先讨论一下如何在中序线索二叉树上寻找一个结点 p（即指针 p 所指向的结点）的中序后继结点，它分为如下两种情况。

(1) 若 p 结点的右线索标志域为真，则表明$p->right$为右线索，它直接指向 p 的中序后继结点。

(2) 若 p 的右线索标志域为假，则表明$p->right$指向右孩子结点，p 的中序后继结点必是其右子树中第一个中序遍历到的结点，因此从 p 的右孩子开始，沿左指针链往下查找，直到找到一个没有左孩子（即左线索标志域为 1）的结点为止，该结点是 p 的右子树中“最左下”的结点，它就是 p 的中序后继结点。如图 6-14所示，p 的中序后继结点是$R_k (k \geq 1)$，$R_k$可能是叶子结点，也可能是只含有右子树的单支结点；另外，若$k=1$，则表示 p 的右孩子$R_1$是 p 的中序后继结点。

(a) 二叉树表示

(b) 二叉链表表示

图 6-14 求中继后继结点示意图

根据以上分析，给出在中序线索二叉树上求结点 p 的中序后继的算法如下。

TTreeNode* InorderNext (TTreeNode*p) //返回 p 结点的中继后继结点
{
    if(p->rtag==true)
        return p->right;
    else {
        p=p->right;
        while(p->ltag==false) p=p->left;
        return p;
    }
}

有了求中序后继结点的算法，就不难写出在中序线索二叉树上进行中序遍历的算法。此算法可叙述为：首先从根结点起沿左指针链往下查找，直到找到一个左线索标志域为真的结点为止，该结点的左指针域必为空，它就是整个中序序列的第一个结点；然后打印该结点，接着利用上述求中序后继结点的算法得到下一个结点，以此类推，直到中序后继结点为空时止。

设 HBT 为具有 TTreeNode*指针类型的一个值参，初始指向一棵中序线索二叉树的根结点，则对此树进行中序遍历的算法可描述如下。

void ThInorder (TTreeNode*HBT) //按中序线索遍历二叉树 HBT
{
    if(HBT!=NULL) {
        while(HBT->ltag==false)
            HBT=HBT->left; //查找出中序遍历中的第一个结点
        do {
            cout<<HBT->data<<' '; //输出结点的值
            HBT=InorderNext(HBT); //查找出 HBT 结点的中序后继结点
        } while(HBT!=NULL); //当 HT 为空时算法结束
    }
}

利用线索进行二叉树遍历的时间复杂度为$O(n)$，空间复杂度为$O(1)$。实际运行时间要少于不加线索的情况。

以广义表形式输出一棵线索二叉树的算法如下。

void PrintTTreel (TTreeNode*HBT)
{
    if(HBT!=NULL) {
        cout<<HBT->data; //输出根结点的值
        if(HBT->ltag==false || HBT->rtag==false) {
            cout<<'('; //输出左括号
            if(HBT->ltag==false)
                PrintTTreel(HBT->left); //输出左子树
            if(HBT->rtag==false) {
                cout<<','; //若右子树不为空则首先输出逗号分隔符
                PrintTTreel(HBT->right); //输出右子树

}
cout<<(')'); //输出右括号
}

利用下面程序调试上述每个算法。

#include<iostream.h>
#include<stdlib.h>

typedef int ElemType; //定义二叉树结点值的类型为整型

struct TTreeNode {
    ElemType data; //值域
    bool ltag, rtag; //线索标志域
    TTreeNode* left; //左指针域
    TTreeNode* right; //右指针域
};

#include"线索二叉树运算.cpp"

void main()
{
    TTreeNode*hbt=NULL,*pre=NULL,*hbt1=NULL;
    ElemType a[10]={30,50,20,40,25,70,54,23,80,92};
    CreateThreed(hbt,a,10);
    InThread(hbt,pre);
    PrintTTree1(hbt);cout<<endl;
    cout<<"中序: "; ThInorder(hbt); cout<<endl;
    CreateThreed1(hbt1,a+3,7);
    PrintTTree1(hbt1);cout<<endl;
    cout<<"中序: "; ThInorder(hbt1); cout<<endl;
}

该程序的运行结果如下:

$30(20(,25(23)),50(40,70(54,80(,92))))$中序:$20 \ 23 \ 25 \ 30 \ 40 \ 50 \ 54 \ 70 \ 80 \ 92$40(25(23),70(54,80(,92)))$中序:$23 \ 25 \ 40 \ 54 \ 70 \ 80 \ 92$*6.5 平衡二叉树

平衡二叉树（balanced binary tree）是对二叉搜索树的一种改进。二叉搜索树有一个缺陷，那就是树的结构事先无法预料，随机性很大，它只与结点的值和插入次序有关，往往得到的是一棵很不“平衡”的二叉树，即树的高度与相同结点数的理想平衡树相差甚远，在最坏的情况下，有可能变为一棵单支二叉树，其高度与结点数相同，相当于一个单链表，对其运算的时间复杂度由正常的$O(\log n)$变为$O(n)$，从而部分或全部地丧失了利用二叉搜索树组织数据的优点。为了克服二叉搜索树的这个缺陷，需要在插入和删除结点时对树的结构进行必要的调整，使二叉搜索树的结构始终处于一种较平衡的状态，当然它没有理想平衡树那样绝对的平衡。若要使二叉搜索树调整成理想平衡树那样的结构，将会使调整运算变得很复杂，使调整带来的好处得不偿失。

\subsection{6.5.1 平衡二叉树的定义}

平衡二叉树简称平衡树，是由阿德尔森-维尔斯基和兰迪斯（Adelson-Velskii and Landis）于 1962 年首先提出的，所以又称为 AVL 树。若一棵二叉树中每个结点的左、右子树的高度至多相差 1，则称此树为平衡的。把二叉树中每个结点的左子树高度减去右子树高度定义为该结点的平衡因子（balance factor）。因此，平衡树中每个结点的平衡因子只能是 1、0 或 -1。如图 6-15 (a) 所示是一棵平衡二叉树，如图 6-15 (b) 和图 6-15 (c) 所示分别是一棵非平衡树，每个结点上方所标数字为该结点的平衡因子。

\n
(a) 平衡二叉树
(b) 非平衡二叉树例 1
(c) 非平衡二叉树例 2

图 6-15 带平衡因子的二叉树

虽然平衡树的平衡性比理想平衡树要差一些，但理论上已经证明：具有$n$个结点的平衡树的高度在任何情况下决不会比具有相同结点数的理想平衡树高出45%以上。因此，在平衡树上进行查找运算虽比理想平衡树要慢一些，但通常比任意生成的二叉排序树快得多，当然，其时间复杂度的数量级表示仍为$O(\log n)$。

当向一棵平衡树插入一个新结点时，插入后，某些结点的左、右子树的高度不变，就不会影响这些结点的平衡因子，因而也不会因为这些结点造成不平衡；若插入后某些结点的左子树高度增加1（右子树高度增加1的情况与之类似），则就影响了这些结点的平衡因子，具体分为如下3种情况。

(1) 若插入前一部分结点的左子树高度$h_L$与右子树高度$h_R$相等，即平衡因子为0，则插入后将使平衡因子变为1，但仍符合平衡的条件，不必对它们加以调整。

(2) 若插入前一部分结点的$h_L$小于$h_R$，即平衡因子为-1，则插入后将使平衡因子变为0，平衡更加改善，不必对它们进行调整。

(3) 若插入前一部分结点的$h_L$大于$h_R$，即平衡因子为1，则插入后将使平衡因子变为2，破坏了平衡树的限制条件，需对它们加以调整，使整个二叉排序树恢复为平衡树。

若插入后，某些结点的右子树高度增加1，则也分为相应的3种情况，对于第1种情况，平衡因子将由0变为-1，不必进行调整；对于第2种情况是平衡因子由-1变为-2，则必须对它们进行调整；对于第3种情况是平衡因子由1变为0，平衡更加改善，也不必进行调整。

向平衡树中插入一个结点后破坏了其平衡性，首先要找出最小不平衡子树，然后再调整这个子树中有关结点之间的链接关系，使之成为新的平衡子树。当然，调整前后该子树的二叉搜索树性质不变，即调整前后得到的中序序列要完全相同。稍后便知，最小不平衡子树被调整为平衡子树后，原有其他所有不平衡子树无需调整，整个二叉搜索树就又成为一棵平衡树。

所谓最小不平衡子树是指以离插入结点最近、且平衡因子绝对值大于1的结点做根的子树。在图6-15(b)中，以值为30的结点做根的子树是该树的最小不平衡子树，分别以20和36做根的不平衡子树不是最小不平衡子树；在图6-15(c)中，以值为32的结点做根的子树是该树的最小不平衡子树，当然它也是唯一一个不平衡子树。

\section*{6.5.2 平衡二叉树的调整}

为了便于讨论，不妨设最小不平衡子树的根结点用A表示，则调整该子树的操作可归纳为下列4种。

\section*{1. LL型调整操作}

在A结点的左孩子（用B表示）的左子树上插入结点，使得A结点的平衡因子由1变为2而引起的不平衡所进行的调整操作。调整过程如图6-16所示，图中用长方框表示子树，用长方框的高度表示子树的高度，用带阴影的小方框表示被插入的结点。图6-16(a)为插入前的平衡子树，$\alpha$、$\beta$和$\gamma$的子树高度均为$h$（$h \geq 0$，若$h=0$，则它们均为空树），A结点和B结点的平衡因子分别为1和0。图6-16(b)为在B的左子树$\alpha$上插入一个新结点，

使以A为根的子树成为最小不平衡子树的情况。图6-16(c)为调整后成为新的平衡子树的情况。调整规则是：将A的左孩子B向右上旋转代替A成为原不平衡子树的根结点，将A结点向下旋转成为B的右子树的根结点，而B的原右子树β则作为A结点的左子树。此调整过程需要修改3个指针，如图6-16(c)中的箭头所示，一是将原指向结点A的指针修改为指向结点B；二是将B的右指针修改为指向结点A；三是将A的左指针修改为指向B的原右子树的根结点。另外，还需要修改A和B结点的平衡因子，应均被置为0。

(a) 插入前
(b) 插入后
(c) 调整后

图6-16 LL型调整操作示意图

从图6-16可以看出，调整前后对应的中序序列相同，即为αβBAγ，所以经调整后仍保持了二叉搜索树的特性不变。

如图6-17所示是LL型搜索调整的两个实例，其中，图6-17(a)、图6-17(b)、图6-17(c)为一例，此处A结点为9，B结点为6，α、β、γ均为空树；图6-17(d)、图6-17(e)、图6-17(f)为另一例，此处A结点为50，B结点为45，α、β、γ分别为只含有一个结点30、48、60的子树。

(a) 插入前
(b) 插入3后
(c) LL调整后

(d) 插入前
(e) 插入20后
(f) LL调整后

图6-17 LL调整实例

2. RR型调整操作

在A结点的右孩子（用B表示）的右子树上插入结点，使得A结点的平衡因子由-1变为-2而引起的不平衡所进行的调整操作，调整过程如图6-18所示。图6-18(a)为插入前的平衡子树，$\alpha$、$\beta$、$\gamma$子树的高度相同，均为$h(h\geq0)$，A结点和B结点的平衡因子分别为-1和0；图6-18(b)为在B结点的右子树$\gamma$上插入一个新结点，使以A为根的子树成为最小不平衡子树的情况；图6-18(c)为调整后重新恢复平衡的情况。调整规则是：将A的右孩子B向左上旋转代替A成为原最小不平衡子树的根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树$\beta$则作为A结点的右子树。此调整过程同LL型调整过程对称，要修改的3个指针如图6-18(c)中的箭头所示。同样，进行RR型调整前后，仍保持着二叉搜索树的特性不变。另外，在插入前和调整后，其子树高度均为$h+2$，由插入所引起的上层其他结点的不平衡将自动消失。

(a) 插入前
(b) 插入后
(c) 调整后

图6-18 RR型调整操作示意图

3. LR型调整操作

在A结点的左孩子（用B表示）的右子树上插入结点，使得A结点的平衡因子由1变为2而引起的不平衡所进行的调整操作，调整过程如图6-19所示。图6-19(a)为插入前的平衡子树，$\beta$和$\gamma$子树的高度均为$h(h\geq0)$，$\alpha$和$\delta$子树的高度均为$h+1$，特别地若$\alpha$和$\delta$子树为空树时，则B结点的右子树也同时为空，此时C结点将是被插入的新结点。插入前A结点和B结点的平衡因子分别为1和0，若C结点存在，则C结点的平衡因子为0。图6-19(b)为在B结点的右子树上插入一个新结点（当B的右子树为空时，则为C结点，否则为C的左子树或右子树上带阴影的结点，图中给出在左子树$\beta$上插入的情况，若在右子树$\gamma$上插入，情况类似），使得以A为根的子树成为最小不平衡子树的情况，此处A结点和B结点的平衡因子是按相反方向变化的，而不像前两种调整操作那样，都是按同一方向变化的。图6-19(c)为调整后的情况。调整规则是：将A的左孩子的右子树的根结点C提升到A结点的位置；将B结点作为C的左子树的根结点，而C结点的原左子树$\beta$则作为B结点的右子树；将A结点作为C的右子树的根结点，而C结点的原右子树则作为A结点的左子树。此调整过程比前两种要复杂，需修改5个指针，如图6-19(c)中的箭头所示。

(a) 插入前
(b) 插入后
(c) 调整后

图 6-19 LR 型调整操作示意图

可以看出, 调整前后对应的中序序列相同, 即为$\alpha \mathrm{B} \beta \mathrm{C} \gamma \mathrm{A} \delta$, 只是链接次序不同罢了,但没有影响其二叉搜索树的特性。另外，在插入前和调整后的子树高度不改变。

如图 6-20 所示是 LR 型调整操作的两个实例，其中图 6-20 (a)、图 6-20 (b)、图 6-20 (c)为一例, 此处 A 结点为 9, B 结点为 3, C 结点为 6, 它是新插入的结点,$\alpha$、$\beta$、$\gamma$、$\delta$均为空树; 图 6-20 (d)、图 6-20 (e)、图 6-20 (f) 为另一例, 此处 A 结点为 85, B 结点为 74, C 结点为 80,$\alpha$和$\delta$子树分别只含有一个结点 65 和 92,$\beta$和$\gamma$均为空。

(a) 插入前
(b) 插入 6 后
(c) LR 调整后

(d) 插入前
(e) 插入 78 后
(f) LR 调整后

图 6-20 LR 型调整实例

4. RL 型调整操作

在 A 结点的右孩子的左子树上插入结点, 使 A 结点的平衡因子由 -1 变为 -2 而引起的

不平衡所进行的调整操作，调整过程如图 6-21 所示。它同$\mathrm{LR}$型调整过程对称，请读者分析调整过程。

(a) 插入前
(b) 插入后
(c) 调整后

图 6-21 RL型调整操作示意图

在上述每一种调整操作中，以 A 为根的最小不平衡子树的高度在插入结点前和调整后相同，因此对其所有祖先结点的平衡性不会产生任何影响，即原有的平衡因子不变。故按照上述方法将最小不平衡子树调整为平衡子树后，整个二叉搜索树就成为了一棵新的平衡树。

下面用一组关键字为$(46,15,20,35,28,58,18,50,54)$生成一棵平衡的二叉搜索树，生成过程如图 6-22 所示。

(a) 插 46 (b) 插 15 (c) 插入 20 后 LR
(d) 插 35 (e) 插入 28 后 LL (f) 插入 58 后 RR
(g) 插 18 (h) 插入 50 后 RL 型调整 (i) 插 54

图 6-22 建立平衡二叉树实例

在二叉搜索树的插入和删除运算中，采用平衡树的优点是：使树的结构较好，从而提高查找运算的速度。缺点是：使插入和删除运算变得复杂化，从而降低它们的运算速度。在每次插入或删除运算中，不仅要进行插入和删除结点的操作，而且要检查是否存在有最小不平衡子树，若存在，则需要对最小不平衡子树中有关指针进行修改。因此，采用平衡树，适合于那种对二叉搜索树一经建立就很少进行插入和删除运算，而主要是进行查找运算的应用场合。

对二叉搜索树删除结点而引起的不平衡而进行的调整操作比插入结点的情况还要复杂，当调整完最小不平衡子树后，还可能引起祖先结点中的不平衡，还需要继续向上调整。平衡二叉树的插入和删除算法是在二叉搜索树算法的基础上修改而成的，是比较复杂的，有关这方面的内容超出了教学要求，故本节不做介绍。
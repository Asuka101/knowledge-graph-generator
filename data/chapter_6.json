{
  "entities": [
    {
      "type": "数据结构",
      "ID": "06DS001",
      "name": "特殊二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "包括二叉搜索树、堆、哈夫曼树、线索二叉树和平衡二叉树等特定类型的二叉树，它们具有特殊的结构或性质以适应不同的应用场景。本章讨论其定义、结构和运算特点。",
        "存储开销": "依赖具体类型及实现，通常为O(n)",
        "核心特性": "基于二叉树结构，带有额外约束或优化，如有序性、堆序性、最优路径长度、线索化、平衡性等。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS002",
      "name": "二叉搜索树",
      "attributes": {
        "难度": "中等",
        "内容": "又称二叉排序树。空树或非空二叉树，特性：若左子树非空，则左子树所有结点关键字小于根；若右子树非空，则右子树所有结点关键字大于(或等于)根；左右子树本身也是二叉搜索树。中序遍历得到有序序列。支持查找、更新、插入、删除操作。",
        "存储开销": "O(n) - 链式存储",
        "核心特性": "有序性（中序遍历），支持高效查找、插入、删除（平均 O(log n)，最坏 O(n)）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS003",
      "name": "堆",
      "attributes": {
        "难度": "中等",
        "内容": "分为小根堆和大根堆。一种完全二叉树。小根堆：根结点值小于等于左右孩子结点值，左右子树也是堆。大根堆：根结点值大于等于左右孩子结点值。堆顶元素是最小（小根堆）或最大（大根堆）值。常用于实现优先级队列。",
        "存储开销": "O(n) - 通常顺序存储",
        "核心特性": "堆序性（父节点与子节点关系），完全二叉树结构，高效插入/删除极值（O(log n)）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS004",
      "name": "哈夫曼树",
      "attributes": {
        "难度": "中等",
        "内容": "又称最优二叉树。n个带权叶子结点构成的所有二叉树中带权路径长度(WPL)最小的二叉树。用于哈夫曼编码。构造过程涉及合并权值最小的树。",
        "存储开销": "O(n) - 链式存储",
        "核心特性": "最优性（WPL最小），无前缀编码特性，用于数据压缩。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS005",
      "name": "线索二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "对二叉树进行线索化，利用结点的空指针域存放该结点在某种遍历次序下的前驱或后继结点的指针（线索）。需要增加标志域区分指针和线索。便于非递归遍历。",
        "存储开销": "O(n) - 链式存储，增加标志域开销",
        "核心特性": "利用空闲指针，支持快速查找前驱/后继，便于非递归遍历。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS006",
      "name": "平衡二叉树",
      "attributes": {
        "难度": "高级",
        "内容": "又称AVL树。一种自平衡的二叉搜索树，通过旋转操作（LL, RR, LR, RL）保持任何结点的左右子树高度差不超过1（平衡因子为-1, 0, 1）。保证了查找、插入、删除操作的 O(log n) 最坏时间复杂度。",
        "存储开销": "O(n) - 链式存储，需额外存储平衡因子",
        "核心特性": "自平衡，保持有序性，保证对数时间复杂度。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS007",
      "name": "二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "每个结点最多有两个子树（左子树和右子树）的树结构。是各种特殊二叉树的基础。",
        "存储开销": "O(n) - 链式或顺序存储",
        "核心特性": "递归定义，层次结构，每个结点最多两个子节点。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS008",
      "name": "完全二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "一种二叉树，除最后一层外，其余层都是满的，且最后一层的结点都连续集中在最左边。适合用顺序存储结构表示。堆是基于完全二叉树定义的。",
        "存储开销": "O(n) - 尤其适合顺序存储",
        "核心特性": "结构规整，结点编号与数组下标有固定关系。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG001",
      "name": "中序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "遍历二叉树的一种方式，顺序为：遍历左子树 -> 访问根结点 -> 遍历右子树。对二叉搜索树进行中序遍历可得到有序序列。线索二叉树利用线索优化中序遍历。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) (递归) 或 O(1) (线索化/迭代)",
        "设计思想": "递归，栈",
        "适用场景": "获取有序序列（BST），树的基础操作。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG002",
      "name": "二叉搜索树查找",
      "attributes": {
        "难度": "入门",
        "内容": "在二叉搜索树中查找特定值的元素。利用BST特性：若目标值小于根，则在左子树查找；若大于根，则在右子树查找。有递归和非递归实现。",
        "时间复杂度": "平均 O(log n), 最坏 O(n)",
        "空间复杂度": "递归 O(log n) / O(n), 非递归 O(1)",
        "设计思想": "比较，分治，递归/迭代",
        "适用场景": "在BST中定位元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG003",
      "name": "二叉搜索树更新",
      "attributes": {
        "难度": "入门",
        "内容": "在二叉搜索树中查找特定值的元素，并用新值更新该元素（通常指非关键字的数据域）。算法与查找类似，找到后执行更新操作。",
        "时间复杂度": "平均 O(log n), 最坏 O(n)",
        "空间复杂度": "递归 O(log n) / O(n), 非递归 O(1)",
        "设计思想": "查找定位，修改",
        "适用场景": "修改BST中结点的数据。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG004",
      "name": "二叉搜索树插入",
      "attributes": {
        "难度": "入门",
        "内容": "向二叉搜索树中插入一个新元素，同时保持BST的性质。查找合适的插入位置（必然是叶子结点位置），然后插入新结点。有递归和非递归实现。",
        "时间复杂度": "平均 O(log n), 最坏 O(n)",
        "空间复杂度": "递归 O(log n) / O(n), 非递归 O(1)",
        "设计思想": "查找定位，链接新结点",
        "适用场景": "向BST添加新元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG005",
      "name": "二叉搜索树删除",
      "attributes": {
        "难度": "中等",
        "内容": "从二叉搜索树中删除指定值的结点，并保持BST性质。分情况处理：删除叶子结点、删除单分支结点、删除双分支结点（通常用中序前驱或后继替换，然后递归删除替换结点）。",
        "时间复杂度": "平均 O(log n), 最坏 O(n)",
        "空间复杂度": "递归 O(log n) / O(n), 非递归 O(1)",
        "设计思想": "查找定位，分类讨论，结点替换/链接调整",
        "适用场景": "从BST移除元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG006",
      "name": "堆插入",
      "attributes": {
        "难度": "入门",
        "内容": "向堆中插入一个新元素，保持堆的性质（小根堆或大根堆）。将新元素添加到堆尾（数组末尾），然后向上调整（Sift-up），与父结点比较交换，直到满足堆性质或到达堆顶。",
        "时间复杂度": "O(log n)",
        "空间复杂度": "O(1)",
        "设计思想": "末尾添加，向上调整（Sift-up）",
        "适用场景": "向堆添加元素，优先级队列入队。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG007",
      "name": "堆删除",
      "attributes": {
        "难度": "入门",
        "内容": "从堆中删除堆顶元素（最小值或最大值），保持堆的性质。用堆尾元素替换堆顶，然后向下调整（Sift-down），与较小/较大的子结点比较交换，直到满足堆性质或到达叶子结点。",
        "时间复杂度": "O(log n)",
        "空间复杂度": "O(1)",
        "设计思想": "替换堆顶，向下调整（Sift-down）",
        "适用场景": "获取并移除堆中极值元素，优先级队列出队。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG008",
      "name": "哈夫曼树构造",
      "attributes": {
        "难度": "中等",
        "内容": "根据n个带权叶子结点构造哈夫曼树的算法。重复选择权值最小的两棵树合并为一棵新树，新树权值为两者之和，直到只剩一棵树。通常使用优先队列（基于堆）实现选择最小权值。",
        "时间复杂度": "O(n log n) (使用堆)",
        "空间复杂度": "O(n)",
        "设计思想": "贪心算法",
        "适用场景": "构建最优二叉树以用于哈夫曼编码等。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG009",
      "name": "哈夫曼编码",
      "attributes": {
        "难度": "中等",
        "内容": "一种利用哈夫曼树进行的可变长、无前缀编码方法。用于数据压缩，频率高的字符编码短，频率低的字符编码长。通过遍历哈夫曼树生成，左分支约定为0，右分支约定为1（反之亦可）。",
        "时间复杂度": "O(n) (遍历树生成编码)",
        "空间复杂度": "O(n) (存储编码)",
        "设计思想": "贪心（基于哈夫曼树构造），树遍历",
        "适用场景": "无损数据压缩。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG010",
      "name": "二叉树线索化",
      "attributes": {
        "难度": "中等",
        "内容": "对二叉树进行某种遍历（如中序），在遍历过程中修改结点的空指针域，使其指向该遍历序列中的前驱或后继结点。需要辅助标志位区分指针域是指向孩子还是线索。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) (递归) 或 O(1) (迭代)",
        "设计思想": "树遍历，指针修改",
        "适用场景": "创建线索二叉树以优化后续的遍历操作。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG011",
      "name": "线索二叉树中序遍历",
      "attributes": {
        "难度": "中等",
        "内容": "利用线索二叉树中的线索（前驱和后继指针）进行非递归的中序遍历。首先找到最左结点，然后通过后继线索或右子树的最左结点依次访问所有结点。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)",
        "设计思想": "利用线索指针迭代",
        "适用场景": "高效非递归中序遍历线索二叉树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG012",
      "name": "平衡二叉树调整",
      "attributes": {
        "难度": "高级",
        "内容": "在平衡二叉树（AVL树）插入或删除结点导致失衡后，通过旋转操作（LL、RR、LR、RL型调整）恢复平衡。调整目标是使最小不平衡子树恢复平衡，进而使整棵树平衡。",
        "时间复杂度": "O(1) (单次旋转) 或 O(log n) (查找失衡点+旋转)",
        "空间复杂度": "O(1)",
        "设计思想": "旋转操作，维持平衡因子约束",
        "适用场景": "维护AVL树的平衡性质，保证操作效率。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON001",
      "name": "路径",
      "attributes": {
        "难度": "入门",
        "内容": "树中一个结点到另一个结点的结点序列 k_1, k_2, ..., k_j，使得 k_i 是 k_{i+1} 的双亲 (1 <= i < j)。树中任意两点之间的路径是唯一的。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON002",
      "name": "路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "路径上所经过的分支（边）数，等于路径上的结点数减1。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON003",
      "name": "结点的权",
      "attributes": {
        "难度": "入门",
        "内容": "赋给树中结点的具有某种特定意义的数值（通常为实数）。例如在哈夫曼树中代表字符出现的频率。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON004",
      "name": "结点的带权路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "从树根结点到该结点之间的路径长度与该结点上权的乘积。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON005",
      "name": "树的带权路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "树中所有叶子结点的带权路径长度之和，通常记为 WPL (Weighted Path Length)。WPL = Σ(w_i * l_i)，其中 w_i 是叶子结点的权，l_i 是根到该叶子的路径长度。哈夫曼树旨在最小化WPL。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON006",
      "name": "前驱线索",
      "attributes": {
        "难度": "中等",
        "内容": "在线索二叉树中，存放在结点空左指针域中，指向该结点在特定遍历次序（如中序）下的前驱结点的指针。也称左线索。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON007",
      "name": "后继线索",
      "attributes": {
        "难度": "中等",
        "内容": "在线索二叉树中，存放在结点空右指针域中，指向该结点在特定遍历次序（如中序）下的后继结点的指针。也称右线索。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON008",
      "name": "平衡因子",
      "attributes": {
        "难度": "中等",
        "内容": "定义为二叉树中结点的左子树高度减去右子树高度。在平衡二叉树（AVL树）中，平衡因子只能是 -1, 0, 或 1。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "06CON009",
      "name": "最小不平衡子树",
      "attributes": {
        "难度": "中等",
        "内容": "在因插入或删除导致失衡的AVL树中，以离插入/删除结点最近、且平衡因子绝对值大于1的结点为根的子树。是进行平衡调整的目标子树。",
        "教学视频": "未知",
        "教学材料": "未知",
        "思政点": "未知"
      }
    }
  ],
  "relations": [
    {
      "type": "继承",
      "ID": "06REL001",
      "source": "06DS002",
      "target": "06DS001"
    },
    {
      "type": "继承",
      "ID": "06REL002",
      "source": "06DS003",
      "target": "06DS001"
    },
    {
      "type": "继承",
      "ID": "06REL003",
      "source": "06DS004",
      "target": "06DS001"
    },
    {
      "type": "继承",
      "ID": "06REL004",
      "source": "06DS005",
      "target": "06DS001"
    },
    {
      "type": "继承",
      "ID": "06REL005",
      "source": "06DS006",
      "target": "06DS001"
    },
    {
      "type": "继承",
      "ID": "06REL006",
      "source": "06DS001",
      "target": "06DS007"
    },
    {
      "type": "继承",
      "ID": "06REL007",
      "source": "06DS002",
      "target": "06DS007"
    },
    {
      "type": "继承",
      "ID": "06REL008",
      "source": "06DS003",
      "target": "06DS008"
    },
    {
      "type": "继承",
      "ID": "06REL009",
      "source": "06DS008",
      "target": "06DS007"
    },
    {
      "type": "继承",
      "ID": "06REL010",
      "source": "06DS004",
      "target": "06DS007"
    },
    {
      "type": "变体",
      "ID": "06REL011",
      "source": "06DS005",
      "target": "06DS007"
    },
    {
      "type": "继承",
      "ID": "06REL012",
      "source": "06DS006",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL013",
      "source": "06ALG002",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL014",
      "source": "06ALG003",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL015",
      "source": "06ALG004",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL016",
      "source": "06ALG005",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL017",
      "source": "06ALG001",
      "target": "06DS002"
    },
    {
      "type": "操作绑定",
      "ID": "06REL018",
      "source": "06ALG001",
      "target": "06DS007"
    },
    {
      "type": "操作绑定",
      "ID": "06REL019",
      "source": "06ALG006",
      "target": "06DS003"
    },
    {
      "type": "操作绑定",
      "ID": "06REL020",
      "source": "06ALG007",
      "target": "06DS003"
    },
    {
      "type": "操作绑定",
      "ID": "06REL021",
      "source": "06ALG008",
      "target": "06DS004"
    },
    {
      "type": "使用",
      "ID": "06REL022",
      "source": "06ALG009",
      "target": "06DS004"
    },
    {
      "type": "操作绑定",
      "ID": "06REL023",
      "source": "06ALG010",
      "target": "06DS005"
    },
    {
      "type": "操作绑定",
      "ID": "06REL024",
      "source": "06ALG011",
      "target": "06DS005"
    },
    {
      "type": "操作绑定",
      "ID": "06REL025",
      "source": "06ALG012",
      "target": "06DS006"
    },
    {
      "type": "理论依赖",
      "ID": "06REL026",
      "source": "06DS004",
      "target": "06CON005"
    },
    {
      "type": "理论依赖",
      "ID": "06REL027",
      "source": "06CON005",
      "target": "06CON004"
    },
    {
      "type": "理论依赖",
      "ID": "06REL028",
      "source": "06CON004",
      "target": "06CON002"
    },
    {
      "type": "理论依赖",
      "ID": "06REL029",
      "source": "06CON004",
      "target": "06CON003"
    },
    {
      "type": "理论依赖",
      "ID": "06REL030",
      "source": "06CON002",
      "target": "06CON001"
    },
    {
      "type": "理论依赖",
      "ID": "06REL031",
      "source": "06DS005",
      "target": "06CON006"
    },
    {
      "type": "理论依赖",
      "ID": "06REL032",
      "source": "06DS005",
      "target": "06CON007"
    },
    {
      "type": "理论依赖",
      "ID": "06REL033",
      "source": "06DS006",
      "target": "06CON008"
    },
    {
      "type": "理论依赖",
      "ID": "06REL034",
      "source": "06ALG012",
      "target": "06CON009"
    },
    {
      "type": "理论依赖",
      "ID": "06REL035",
      "source": "06CON008",
      "target": "06DS007"
    }
  ]
}
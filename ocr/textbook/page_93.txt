3. 得到单链表的长度

由于在单链表的构成中, 没有给出单链表的长度, 所以此算法需要遍历单链表, 对被访问的结点进行计数, 最后返回计数值。

int LenthList (LNode* HL)
{
    int i=0;                          //用来统计单链表中结点的个数
    while(HL!=NULL)                  //遍历单链表, 统计结点数
    {
        i++;
        HL=HL->next;
    }
    return i;                        //返回单链表长度
}

因为该运算需要访问单链表中的每个结点, 不改变表头指针, 即不会改变单链表的状态, 所以定义表头指针 HL 为值参。对于指针值参只需要占用一个字 (即 4 个字节) 的存储空间, 它与使用引用参数传送时需要保存实参地址所需要的存储空间大小相同, 由此不会增加存储空间和传送参数值时间。对于上面第 1 和第 2 种操作, 由于需要通过函数体操作修改调用函数时的实际表头指针的值, 所以必须被定义为引用参数。

4. 检查单链表是否为空

bool EmptyList (LNode* HL)
{
    return HL==NULL;
}

5. 得到单链表中第 pos 个结点中的元素

要访问单链表中的第$pos$个结点, 必须从表头开始依次访问过该结点之前的所有结点后才能够实现, 即只能够采用顺序存取, 而不能够随机存取任一个结点。

ElemType GetList (LNode* HL, int pos)
{
    if(pos<1) {
        cerr<<"pos is out range!"<<endl;
        exit(1);
    }
    int i=0;                         //统计已遍历的结点数, i 初值为 0
    while(HL!=NULL) {               //遍历到第 pos 个结点或表为空时止
        i++;
        if(i==pos) break;
        HL=HL->next;
    }
}

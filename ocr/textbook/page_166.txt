default:
    return 0;            //定义在栈中的左括号和栈底字符的优先级为0
}

在这个转换算法中, 中缀算术表达式中的每个字符均需要扫描一遍, 对于从 S1 中扫描得到的每个运算符, 最多需要进行入 R 栈、出 R 栈和写入 S2 后缀表达式这三次操作,对于从 S1 中扫描得到的每个数字或小数点, 只需要把它直接写入到 S2 后缀表达式即可。所以, 此算法的时间复杂度为$O(n)$,$n$为后缀表达式中字符的个数。该算法需要使用一个运算符栈, 需要的深度不会超过中缀表达式中运算符的个数, 所以此算法的空间复杂度至多为$O(n)$。

利用表达式的后缀表示和堆栈技术只需要两遍扫描就可完成中缀算术表达式的计算,显然比直接进行中缀算术表达式计算的扫描次数要少得多。

在上述讨论的中缀算术表达式求值的两个算法中, 把中缀表示转换为后缀表示的算法需要使用一个字符栈, 而进行后缀表达式求值的算法又需要使用一个浮点数栈, 这两个栈的元素类型不同, 所以栈的类型无法作为全局量来定义, 栈运算的函数也无法适应这种要求。为了解决这个问题, 必须把 Stack 栈类型定义为模板类, 把栈运算的函数定义为该类的公用成员函数, 通过调用成员函数来实现栈的运算。这里对此不作深入讨论, 留给读者练习。

采用下面程序调试上述中缀转后缀的算法。

#include<iostream.h>
#include<stdlib.h>

typedef char ElemType;
struct Stack {
    ElemType *stack;              //存栈元素
    int top;                      //存栈顶元素的下标位置
    int MaxSize;                  //存 stack 数组长度,亦即所能存储栈的最大长度
};

#include"顺序栈运算.cpp"

int Precedence(char op) { }
void Change(char* s1, char* s2) { } //给出函数具体定义

void main()
{
    char a[30];
    char b[30];
    cout<<"请输入一个中缀算术表达式: "<endl;
    cin.getline(a,sizeof(a));
    Change(a,b);
}

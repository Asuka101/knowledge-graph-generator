如图 8-4 (h) 所示就是最后得到的最小生成树, 它同图 8-2 (d) 是完全一样的, 所以图 8-2 (d) 是图 8-2 (a) 的最小生成树。

通过以上分析可知，在构造最小生成树的过程中，在进行第$k$次$(1 \leq k \leq n-1)$前，边集$TE$中的边数为$k-1$条，从$T$中到$T$外每一顶点的最短边集$LW$中的边数为$n-k$条，$TE$和$LW$中的边数总和为$n-1$条。为了保存这$n-1$条边，设用至少具有$n-1$个元素的边集数组类型（即 edgeset 类型）的对象 CT 来存储，其中 CT 的前$k-1$个元素（即 CT[0]~CT[k-2]）保存$TE$中的边，后$n-k$个元素（即 CT[k-1]~CT[n-2]）保存$LW$中的边。在进行第$k$次时，首先从下标为$k-1$~$n-2$的元素（即$LW$中的边）中查找出权值最小的边，设为 CT[m]；接着把边 CT[k-1]与 CT[m]对调，确保在第$k$次后 CT 的前$k$个元素保存着$TE$中的边，后$n-k-1$个元素保存着$LW$中的边；然后再修改$LW$中的有关边，使得从$T$中到$T$外每一顶点的各一条最短边被保存下来。这样经过$n-1$次运算后，CT 中就按序保存着最小生成树中的全部$n-1$条边。

根据分析，编写利用普里姆算法产生图的最小生成树的算法描述如下。

void Prim(adjmatrix GA, edgeset CT, int n)
    //利用普里姆算法从顶点 v_0 出发求出用邻接矩阵 GA 表示的图的
    //最小生成树，最小生成树的边集存于数组 CT 中
{
    int i,j,k,min,t,m,w;
    //给 CT 赋初值，对应第 0 次的 LW 值
    for(i=0; i<n-1; i++) {
        CT[i].fromvex=0;
        CT[i].endvex=i+1;
        CT[i].weight=GA[0][i+1];
    }
    //进行 n-1 次循环，每次求出最小生成树中的第 k 条边
    for(k=1; k<n; k++)
    {
        //从 CT[k-1]~CT[n-2]（即 LW）中查找最短边 CT[m]
        min=MaxValue;
        m=k-1;
        for(j=k-1; j<n-1; j++)
            if(CT[j].weight<min) {
                min=CT[j].weight;
                m=j;
            }
        //把最短边对调到第 k-1 下标位置
        edge temp=CT[k-1];
        CT[k-1]=CT[m];
        CT[m]=temp;
        //把新加入最小生成树 T 中的顶点序号赋给 j
        j=CT[k-1].endvex;
        //修改 LW 中的有关边，使 T 中到 T 外的每一个顶点各保持

以中序遍历算法为例，结合如图 5-13 所示的二叉树，分析其执行过程。

(a) 二叉树

(b) 链接存储结构

图 5-13 二叉树遍历

当从其他函数调用（此次称为第0次递归调用）中序遍历算法时，需要以指向树根A结点的指针$\mathrm{Ap}$作为实参，把它传递给算法中的值参$\mathrm{BT}$，系统栈中应包括$\mathrm{BT}$域和返回地址$r$域，设进行第0次递归调用后的返回地址为$r0$，中序遍历左子树后的返回地址（即执行 cout语句的地址）为$r1$，中序遍历右子树后的返回地址（即算法结束的地址）为$r2$，并设指向每个结点的指针用该结点的值后缀小写字母$p$表示，如指向 B 结点的指针就用$\mathrm{Bp}$表示，则每次进行递归调用时的系统栈的变化状态，如图 5-14 所示。

| BT | r |
| --- | --- |
|  |  |
|  |  |
|  |  |
| Ap | r0 |

(a) A 进栈

| BT | r |
| --- | --- |
|  |  |
|  |  |
|  |  |
| Bp | r1 |
| Ap | r0 |

(b) B 进栈

| BT | r |
| --- | --- |
|  |  |
|  |  |
| Cp | r1 |
| Bp | r1 |
| Ap | r0 |

(c) C 进栈

| BT | r |
| --- | --- |
|  | r1 |
| Cp | r1 |
| Bp | r1 |
| Ap | r0 |

(d) 空指针进栈

| BT | r |
| --- | --- |
|  | r2 |
| Cp | r1 |
| Bp | r1 |
| Ap | r0 |

(e) 输出 C

| BT | r |
| --- | --- |
|  |  |
| Dp | r2 |
| Bp | r1 |
| Ap | r0 |

(f) 输出 B

| BT | r |
| --- | --- |
|  | r1 |
| Dp | r2 |
| Bp | r1 |
| Ap | r0 |

(g) 空指针进栈

| BT | r |
| --- | --- |
|  | r2 |
| Dp | r2 |
| Bp | r1 |
| Ap | r0 |

(h) 输入 D

| BT | r |
| --- | --- |
|  |  |
|  |  |
| Ep | r2 |
| Ap | r0 |

(i) 输出 A

| BT | r |
| --- | --- |
|  | r1 |
| Fp | r2 |
| Ep | r2 |
| Ap | r0 |

(j) 空指针进栈

| BT | r |
| --- | --- |
|  | r2 |
| Fp | r2 |
| Ep | r2 |
| Ap | r0 |

(k) 输入 E

| BT | r |
| --- | --- |
|  |  |
| Gp | r1 |
| Fp | r2 |
| Ep | r2 |
| Ap | r0 |

(l) G 进栈

| BT | r |
| --- | --- |
|  | r1 |
| Gp | r1 |
| Fp | r2 |
| Ep | r2 |
| Ap | r0 |

(m) 空指针进栈

| BT | r |
| --- | --- |
|  | r2 |
| Gp | r1 |
| Fp | r2 |
| Ep | r2 |
| Ap | r0 |

(n) 输出 G

| BT | r |
| --- | --- |
|  |  |
|  |  |
|  |  |
| Ap | r0 |

(o) 输出 F

(p) 返回到其他函数

图 5-14 对图 5-13 所示的二叉树执行中序遍历算法时系统栈的变化状态

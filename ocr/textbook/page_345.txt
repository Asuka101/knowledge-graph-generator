q=p->next;                    //q指向d单链表的第二个结点
while(q!=NULL) {             //从第二个结点起查找被删除的元素
    if(q->data.key==item.key) {
        p->next=q->next;
        delete q; return true;
    }
    else {p=q; q=q->next;}
}
return false;                //返回假表示删除失败

在散列表的插入和查找算法中，平均查找长度与表的大小$m$无关，只与所选取的散列函数、$\alpha$的值和处理冲突的方法有关。若所选取的散列函数能够使任一关键字等概率地映射到散列空间的任一地址上，则理论上已经证明，当采用线性探查法处理冲突时，平均查找长度为$\frac{1}{2}\left(1+\frac{1}{1-\alpha}\right)$；当用链接法处理冲突时，平均查找长度为$1+\frac{\alpha}{2}$；当用开放定址法中的平方探查法、双散列函数探查法处理冲突时，平均查找长度为$-\frac{1}{\alpha}\ln(1-\alpha)$。

如表9-5所示，当$\alpha$取不同值时，各种处理冲突的方法理论上所对应的平均查找长度，实际应用中比理论值要大些。

表9-5 各种处理冲突的方法所对应的平均查找长度

|$\alpha$| 线性 | 链接 | 其他 |$\alpha$| 线性 | 链接 | 其他 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0.1 | 1.06 | 1.05 | 1.05 | 0.75 | 2.50 | 1.38 | 1.85 |
| 0.25 | 1.17 | 1.13 | 1.15 | 0.90 | 5.50 | 1.45 | 2.56 |
| 0.5 | 1.50 | 1.25 | 1.39 | 0.95 | 10.50 | 1.50 | 3.15 |

在散列存储中，插入和查找的速度是相当快的，它优于前面介绍过的任一种方法，特别是当数据量很大时更是如此。散列存储的缺点如下。
- 根据关键字计算散列地址需要花费一定的计算时间，若关键字不是整数，则首先要把它转换为整数，为此也要花费一定的转换时间。
- 占用的存储空间较多，因为采用开放定址法解决冲突的散列表总是取$\alpha$值小于1，采用链接法处理冲突的散列表同线性表的链接存储相比多占用一个具有$m$个位置的指针数组空间。
- 在散列表中只能按关键字查找元素，而无法按非关键字查找元素。
- 数据中元素之间的原有逻辑关系无法在散列表中体现出来。

9.5 B树查找

9.5.1 B_树定义

B树包括B_树和B*树两种，本节主要讨论B_树，对B*树只作简要介绍。B_树是

d[1]=top; top=1;

此时 top 指向 d[1]元素，表示顶点$v_1$的入度为 0，而 d[1]的值为 0，表明下一个入度为 0 的元素为 d[0]，即对应下一个入度为 0 的顶点为$v_0$，d[0]的值为 -1，所以此栈当前有两个元素 d[1]和 d[0]。

（4）因 d[2]~d[5]的值均不为 0，即对应的$v_2 \sim v_5$的入度均不为 0，所以它们均不进栈。至此，初始栈建立完毕，得到的数组 d 为:

\[
\begin{array}{|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
-1 & 0 & 2 & 2 & 1 & 3 \\
\hline
\end{array}
\]$\uparrow$top=1

由此可知，数组 d 具有两方面功能：存储所有顶点的入度；链接入度为 0 的顶点形成链栈。

将入度为 0 的顶点利用上述链栈链接起来后，拓扑算法中循环执行的“选择一个入度为 0 的顶点并输出之”，可通过输出栈顶指针 top 所代表的顶点序号来实现；“从 AOV 网中删除刚输出的顶点（假定为$v_j$，其中 j 等于 top 的值）及所有出边”，可通过首先做退栈处理，使 top 指向下—个入度为 0 的元素，然后遍历$v_j$的邻接表，分别把所有邻接点的入度减 1，若减 1 后的入度为 0 则令该元素进栈等操作来实现。此外，该循环的终止条件“直到不存在入度为 0 的顶点为止”，可通过判断栈空来实现。

对于图 8-12 (a)，当删除由 top 值所代表的顶点$v_1$及所有出边后，数组 d 变为:

\[
\begin{array}{|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
-1 & 0 & 1 & 1 & 0 & 3 \\
\hline
\end{array}
\]$\uparrow$top=4

当依次删除 top 所表示的每个顶点及所有出边后，数组 d 的变化分别如图 8-14 所示。

\[
\begin{array}{|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
-1 & 0 & 1 & 1 & 0 & 2 \\
\hline
\end{array}
\]$\uparrow$top=0

(a) 删除顶点$v_4$及所有出边

\[
\begin{array}{|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
-1 & 0 & -1 & -1 & 0 & 1 \\
\hline
\end{array}
\]$\uparrow$top=3

(c) 删除顶点$v_2$及所有出边

\[
\begin{array}{|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
-1 & 0 & -1 & 1 & 0 & 2 \\
\hline
\end{array}
\]$\uparrow$top=2

(b) 删除顶点$v_0$及所有出边

\[
\begin{array}{|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
-1 & 0 & -1 & -1 & 0 & -1 \\
\hline
\end{array}
\]$\uparrow$top=5

(d) 删除顶点$v_3$及所有出边

图 8-14 数组 d 变化示意图

当删除顶点$v_5$及所有出边后，top 的值为 -1，表示栈空，至此此算法执行结束，得到的拓扑序列为: 1,4,0,2,3,5。

根据以上分析，给出拓扑排序算法的具体描述如下。

void Toposort(adjlist GL, int n) //对用邻接表 GL 表示的有向图进行拓扑排序
{

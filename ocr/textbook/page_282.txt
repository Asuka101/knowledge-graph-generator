遍历, 当$v_1$的所有邻接点均被访问过时, 则退回到上一个顶点$v_k$, 从$v_k$的另一个未被访问过的邻接点出发进行深度优先搜索遍历, 直到退回到初始点并且没有未被访问过的邻接点为止。

结合如图 7-10所示的无向图 G7分析以$v_0$作为初始点的深度优先搜索遍历的过程。

(1) 访问顶点$v_0$, 并将 visited[0]置为真, 表明$v_0$已被访问过, 接着从$v_0$的一个未被访问过的邻接点$v_1$($v_0$的3个邻接点$v_1$,$v_2$和$v_3$都未被访问过, 先访问$v_1$) 出发进行深度优先搜索遍历。

(2) 访问顶点$v_1$, 并将 visited[1]置为真, 表明$v_1$已被访问过, 接着从$v_1$的一个未被访问过的邻接点$v_4$($v_1$的4个邻接点中只有$v_0$被访问过, 其余3个邻接点$v_4$,$v_5$,$v_6$均未被访问过, 先访问$v_4$) 出发进行深度优先搜索遍历。

(3) 访问顶点$v_4$, 并将 visited[4]置为真, 表明$v_4$已被访问过, 接着从$v_4$的一个未被访问过的邻接点$v_5$($v_4$的两个邻接点为$v_1$和$v_5$,$v_1$被访问过, 只剩$v_5$一个未被访问) 出发进行深度优先搜索遍历。

(4) 访问顶点$v_5$, 并将 visited[5]置为真, 表明$v_5$已被访问过, 接着因$v_5$的两个邻接点$v_1$和$v_4$都已被访问过, 所以退回到上一个顶点$v_4$, 又因$v_4$的两个邻接点$v_1$和$v_5$都已被访问过, 所以再退回到上一个顶点$v_1$,$v_1$的4个邻接点中有3个已被访问过, 此时只能从未被访问过的邻接点$v_6$出发进行深度优先搜索遍历。

(5) 访问顶点$v_6$, 并将 visited[6]置为真, 表明$v_6$已被访问过, 接着从$v_6$的一个未被访问过的邻接点$v_2$(只此一个) 出发进行深度优先搜索遍历。

(6) 访问顶点$v_2$, 并将 visited[2]置为真, 表明$v_2$已被访问过, 接着因$v_2$的所有邻接点 (即$v_0$和$v_6$) 都被访问过, 所以退回到上一个顶点$v_6$, 同理, 由$v_6$退回到$v_1$, 再从$v_1$的一个未被访问过的邻接点$v_3$(只此一个) 出发进行深度优先搜索遍历。

(7) 访问顶点$v_3$, 并将 visited[3]置为真, 表明$v_3$已被访问过, 接着因$v_3$的所有邻接点 (它仅有一个邻接点$v_0$) 都被访问过, 所以退回到上一个顶点$v_0$, 又因$v_0$的所有邻接点都已被访问过, 所以再退回, 实际上就结束了对 G7 的深度优先搜索遍历的过程, 返回到调用此算法的函数中去。

从对无向图 G7 进行深度优先搜索遍历的过程分析可知, 从初始点$v_0$出发, 访问 G7 中各顶点的次序为:$v_0$,$v_1$,$v_4$,$v_5$,$v_6$,$v_2$,$v_3$。

图的深度优先搜索遍历的过程是递归的, visited[n]为保存顶点访问标记的逻辑型数组, 每个元素的初值均为假。下面分别以邻接矩阵和邻接表作为图的存储结构, 给出相应的深度优先搜索遍历的算法描述。

void dfsMatrix(adjmatrix GA, int i, int n, bool*visited)

{
    //从初始点 v_i 出发深度优先搜索由邻接矩阵 GA 表示的图
    cout<<i<<' ';
    //假设访问顶点 v_i 以输出该顶点的序号代之
    visited[i]=true;
    //标记 v_i 已被访问过
    for(int j=0; j<n; j++)
        //依次搜索 v_i 的每个邻接点
        if(GA[i][j]!=0 && GA[i][j]!=MaxValue && !visited[j])

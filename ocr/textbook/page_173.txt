在一个迷宫中，中间的每个方格位置都有四个可选择的移动方向，而在四个顶点只有两个方向，并且每个顶点的两个方向均有差别，每条边线上除顶点之外的每个位置只有三个方向，并且也都有差别。为了在求解迷宫的算法中避免判断边界条件和进行不同处理的麻烦，使每一个方格都能够试着按四个方向移动，可在迷宫的周围镶上边框，在边框的每个方格里填上1，作为墙壁，如图4-7(b)所示。这样需要用一个$[m+2][n+2]$大小的二维整型数组（用maze表示数组名）来存储迷宫数据。

当从迷宫中的一个位置（称它为当前位置）前进到下一个位置时，下一个位置相对于当前位置的位移量（包括行位移量和列位移量）随着前进方向的不同而不同，东、南、西、北（即右、下、左、上）各方向的位移量依次为$(0,1),(1,0),(0,-1)$和$(-1,0)$。用一个$4\times2$的整型数组move来存储位移量数据，则move数组的内容如右上面表格所示。其中，move[0]~move[3]依次存储向东、南、西、北每个方向移动一步的位移量。如move[1][0]和move[1][1]分别为从当前位置向南移动一步的行位移量和列位移量，其值分别为1和0。

在求解迷宫问题时，还需要使用一个与存储迷宫数据的maze数组同样大小的辅助数组，用标识符mark表示，用它来标识迷宫中对应位置是否被访问过。该数组每个元素的初始值为0，表示迷宫中的所有位置均没有被访问过。每访问迷宫中一个可通行的位置时，都使mark数组中对应元素置1，表示该位置已经被访问过，以后不会再访问到，这样才能够探索新的路径，避免重走已经走不通的老路。

为了寻找从入口点到出口点的一条通路，首先从入口点出发，按照东、南、西、北各方向的次序试探前进，若向东可通行，同时没有被访问过，则向东前进一个方格；否则表明向东没有通向出口的路径，接着应向南方向试着前进，若向南可通行同时没有被访问过，应向南前进一步；否则依次向西和向北试探。若试探完当前位置上的所有方向都没有通路，则应退回一步，到达该当前位置的下一个方向试探着前进，如到达该当前位置的方向为东，则下一个方向为南。因此每前进一步都要记录其上一步的坐标位置以及前进到此步的方向，以便退回之用，这正好需要用栈来解决，每前进一步时，都把当前位置和前进方向进栈，接着使向前一步后的新位置成为当前位置，若从当前位置无法继续前进时，就做一次退栈操作，从上一次位置的下一个方向试探着前进。若当前位置是出口点时，则表明找到了一条从入口点到出口点的路径，应结束算法执行，此时路径上的每个方格坐标（除出口坐标外）均被记录在栈中。若做退栈操作时栈为空，则表明入口点也已经退栈，并且其所有方向都已访问过，没有通向出口点的路径，此时应结束算法，打印出无通路信息。

栈和递归是可以相互转换的，当编写递归算法时，虽然表面上没有使用栈，但系统执行时会自动建立和使用栈。求解迷宫问题也是一个递归问题，适合采用递归算法来解决。若迷宫中的当前位置（初始为入口点）就是出口位置，则表明找到了通向出口的一条路径，应返回true结束递归；若当前位置上的所有方向都试探完毕，表明从当前位置出发没有寻找到通向出口点的路径，应返回false结束递归；若从当前位置按东、南、西、北方向的次序前进到下一个位置时，若该位置可通行且没有被访问过，则应以该位置为参数进行递归调用，若返回true的话，表明从该位置到出口点有通路，输出该位置坐标后，继续向上一个位置返回true结束递归。

下面给出求解迷宫问题的递归算法，其中$m$和$n$为全局整型常量，分别表示迷宫的行

9.5.3 B_树插入

在 B_树上插入一个元素的关键字$K$也同在二叉排序树上类似, 都首先要经过一个从树根结点到叶子结点的查找过程, 查找出$K$的插入位置, 然后再进行插入。不过在 B_树中不是添加新的叶子结点, 而是直接把关键字$K$按序插入到对应的叶子结点 (假定用$a$表示) 中, 并需要进行插入后的处理。关键字$K$插入$a$结点后, 使得该结点的关键字个数$n$增加 1, 此时若$a$结点中的关键字个数$n \leq m-1$, 则插入完成, 否则因$a$结点中的关键字个数$n=m$, 超过了规定的范围, 所以要进行结点的 “分裂”, 具体分裂过程如下。

(1) 执行 new 运算, 产生一个新结点$a'$。

(2) 将$a$结点中的原有信息:$m, P_0, (K_1, P_1), (K_2, P_2), \cdots, (K_m, P_m)$除$K_{\lceil m/2 \rceil}$之外分为前后两个部分, 分别存于$a$和$a'$结点中,$a$结点中保留的信息为:$\left\lceil m/2 \right\rceil - 1, P_0, (K_1, P_1), \cdots, (K_{\lceil m/2 \rceil - 1}, P_{\lceil m/2 \rceil - 1})$$a'$结点中的信息为:$m - \left\lceil m/2 \right\rceil, P_{\lceil m/2 \rceil}, (K_{\lceil m/2 \rceil + 1}, P_{\lceil m/2 \rceil + 1}), \cdots, (K_m, P_m)$其中$a$结点中含有$\left\lceil m/2 \right\rceil - 1$个索引项,$a'$结点中含有$m - \left\lceil m/2 \right\rceil$个索引项, 每个索引项包含一个关键字$K_i$, 该关键字所对应记录的存储位置$R_i$和一个子树指针$P_i$。

(3) 将关键字$K_{\lceil m/2 \rceil}$和指向$a'$结点的指针（假定用$p$表示）作为新结点$a'$的索引项$(K_{\lceil m/2 \rceil}, p)$插入到$a$结点在前驱结点（即父辈结点）中的索引项的后面（特别地, 若$a$结点是由前驱结点中的$P_0$指针指向的，则插入到$K_1$和$P_1$的位置上）。

当$a$结点的前驱结点被插入一个索引项后, 其关键字个数又有可能超过$m-1$, 若超过又使得该结点分裂为两个结点, 其分裂过程同上。在最坏的情况下, 这种从叶子结点开始产生的分裂, 要一直传递到树根结点, 使根结点产生分裂, 从而导致一个新的根结点的诞生。该新的根结点应包含有一个关键字和左、右两棵子树, 其中关键字为原树根结点的中项关键字$K_{\lceil m/2 \rceil}$, 左子树是以原树根结点为根的子树, 右子树是由原树根结点分裂出的一个新结点为根的子树。在 B_树中通过插入关键字可能最终导致的树根结点的分裂从而产生新的树根结点是 B_树增长其高度的唯一途径。

若如图 9-7(a) 所示是一个 3 阶 B_树的简图, 若在此树上依次插入关键字 65,24,50 和 38, 则 B_树的变化过程如图 9-7(b) ~ 图 9-7(h) 所示。

在 3 阶 B_树中, 每个结点的关键字个数最少为 1, 最多为 2, 当插入后关键字的个数为 3 时, 就得分裂成两个结点, 让原有结点只保留第 1 个关键字和它前后的两个指针, 让新结点保存原有结点中的最后一个（即第 3 个）关键字和它前后的两个指针, 让原有结点的第 2 个关键字和指向新结点的指针作为新结点的索引项插入到原有结点的前驱结点中, 若没有前驱结点, 则就生成一个新的树根结点, 并将原树根结点和分裂出的结点作为它的两棵子树。请读者自行分析插入过程中的 B_树变化。

下面给出 B_树的插入算法, 请读者结合注释自行分析。

元素的位置, 使轻者 (即排序码较小的元素) 上浮, 重者 (即排序码较大的元素) 下沉, 接着比较$\mathrm{A}[n-2]$同$\mathrm{A}[n-3]$元素的排序码, 同样使轻者上浮, 重者下沉, 以此类推, 直到比较$\mathrm{A}[1]$同$\mathrm{A}[0]$元素的排序码, 并使轻者上浮重者下沉后, 第 1 趟排序结束, 此时$\mathrm{A}[0]$为具有最小排序码的元素; 然后在$\mathrm{A}[n-1] \sim \mathrm{A}[1]$排序区间内进行第 2 趟排序, 使次最小排序码的元素被上浮到第 1 单元中; 重复进行$n-1$趟后, 整个气泡排序结束。

例如, 有 8 个元素的排序码为$(36,25,48,12,65,43,20,58)$, 如图 10-5 所示为进行气泡排序的过程, 其中括号为下一趟排序的区间, 中括号前面的一个排序码为本趟排序上浮出来的最小排序码, 箭头表示在本趟排序中较小排序码最终上浮的位置。在此过程中, 从第 4 趟排序起, 没有出现排序码的交换, 表明元素已经有序, 以后各趟的排序无须进行。

下标 0 1 2 3 4 5 6 7

(0) [36 25 48 12 65 43 20 58]

(1) 12 [36 25 48 20 65 43 58]

(2) 12 20 [36 25 48 43 65 58]

(3) 12 20 25 [36 43 48 58 65]

(4) 12 20 25 36 [43 48 58 65]

(5) 12 20 25 36 43 [48 58 65]

(6) 12 20 25 36 43 48 [58 65]

(7) 12 20 25 36 43 48 58 [65]

图 10-5 气泡排序的过程示例

气泡排序的算法描述如下。

void BubbleSort(ElemType A[], int n)

//采用气泡排序的方法对数组 A 中的 n 的元素排序

ElemType x;

int i,j,flag;

for(i=1; i<=n-1;i++) { //i 表示趟数,最多进行 n-1 趟

flag=0; //flag 表示每一趟是否有交换

for(j=n-1; j>=i; j--) //进行第 i 趟排序

if(A[j].stn<A[j-1].stn) {

x=A[j-1]; A[j-1]=A[j]; A[j]=x;

flag=1; //置 1 表示有交换

}

if(flag==0) return; //进行一趟后若无交换则排序完成应返回

}

从气泡排序算法可以看出, 若待排序元素为有序 (即正序, 最好情况), 则只需进行一趟排序, 其记录 (元素) 的比较次数为$n-1$次, 且不移动记录; 反之, 若待排序元素为逆序 (最坏情况), 则需进行$n-1$趟排序, 其比较次数为$\sum_{i=1}^{n-1}(n-i)=\frac{1}{2}\left(n^{2}-n\right)$次, 移动次数为

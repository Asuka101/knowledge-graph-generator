结合图 7-11 (a) 和图 7-11 (b) 分析上面的两个算法，判断从顶点$v_1$出发得到的广度优先搜索遍历的顶点序列是否分别为以下序列。

序列 1:$1,0,4,5,6,2,3$序列 2:$1,6,5,4,0,2,3$与图的深度优先搜索遍历一样，对于图的广度优先搜索遍历，若采用邻接矩阵表示，其时间复杂度为$O(n^2)$；若采用邻接表表示，其时间复杂度为$O(e)$。两者的空间复杂度均为$O(n)$。

由图的某个顶点出发进行广度优先搜索遍历时，访问各顶点的次序，对于邻接矩阵来说是唯一的，对于邻接表来说，可能因邻接表的不同而不同，这一点也与图的深度优先搜索遍历时的情形一样。

\section*{7.3 .3 非连通图的遍历}

在图的深度优先搜索遍历算法和图的广度优先搜索遍历算法中，对于无向图来说，若无向图是连通图，则能够访问到图中的所有顶点；若无向图是非连通图，则只能访问到初始点所在连通分量中的所有顶点，其他连通分量中的顶点是不可能访问到的。为此需要从其他每个连通分量中选定初始点，分别进行搜索遍历，才能够访问到图中的所有顶点。对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能够访问到所有顶点。为此需要从未被访问的顶点中再选一些顶点作为初始点，进行搜索遍历，直到图中的所有顶点都被访问过为止。

为了能够访问到任何图中的所有顶点，要以图中未被访问到的每一个顶点作为初始点，去调用上面的任何一个算法。在某个函数中执行下面的for语句：

for(int i=0; i<n; i++)
    if(!visited[i])
        dfsMatrix(GA,i,n,visited); //也可以调用其他遍历算法

若一个无向图是连通的，或从一个有向图的顶点$v_0$到其余每个顶点都是有路径的，则此循环语句只执行一次调用（即dfsMatrix（GA,0,n,visited）调用）就结束遍历过程，否则要执行多次调用才能结束遍历过程。对无向图来说，每次调用将遍历一个连通分量，有多少次调用过程，就说明该图有多少个连通分量。

采用图的邻接矩阵进行图的遍历运算的程序举例如下。

#include<iostream.h>
#include<stdlib.h>
#include<strstrea.h>                      //使用字符串流所需的系统头文件

typedef int VertexType;                    //定义顶点值的类型
typedef int WeightType;                    //定义边上权值的类型

const int MaxVertexNum=10;                 //定义图的最多顶点数

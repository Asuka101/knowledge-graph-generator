指针域，然后把 D 的左子树链接到 L 的左指针域，删除 D 结点后得到的二叉搜索树如图 6-3 (c) 所示。这种方法往往容易增加树的深度，使树的结构变坏，所以通常采用下面介绍的第 2 种方法。

删除双支结点的第 2 方法是：首先把它的中序前驱结点的值赋给该结点的值域，然后再删除它的中序前驱结点，因为它的中序前驱结点的右指针为空，所以只要把中序前驱结点的左指针链接到中序前驱结点所在的链接位置即可。如删除图 6-3 (a) 树中双支结点 D 时，首先把它的中序前驱结点 A 的值赋给 D 结点的值域，然后把 A 结点的左指针（此时为空）链接到 D 结点的左指针域，删除 D 结点后得到的二叉搜索树，如图 6-3 (c) 所示。又如，若从图 6-3 (a) 树中删除根结点 L，因为 L 是双支结点，所以首先把它的中序前驱结点 G 的值赋给 L 结点的值域，然后把 G 结点的左指针（此时指向 F 结点）链接到 D 结点的右指针域，删除 L 结点后得到的二叉搜索树，如图 6-3 (d) 所示。

采用以上方法从二叉搜索树中删除结点后，得到的仍然是一棵二叉搜索树。

从二叉搜索树中删除结点的算法可以是递归的，也可以是非递归的，下面只给出递归算法，读者可以编写出相应的非递归算法。

```
bool Delete(BTreeNode*&BST, const ElemType&item)
    //从二叉搜索树 BST 中删除值为 item 的结点，树根指针必须为引用
{
    //树为空，未找到待删除元素，返回假表示删除成功
    if (BST==NULL) return false;
    //待删除元素小于树根结点值，继续在左子树中删除
    if (item<BST->data) return Delete(BST->left, item);
    //待删除元素大于树根结点值，继续在右子树中删除
    if (item>BST->data) return Delete(BST->right, item);
    BTreeNode*temp=BST;
    //待删除元素等于树根结点值且左子树为空，将右子树作为整棵树并返回真
    if (BST->left==NULL) {
        BST=BST->right; delete temp; return true;
    }
    //待删除元素等于树根结点值且右子树为空，将左子树作为整棵树并返回真
    else if (BST->right==NULL) {
        BST=BST->left; delete temp; return true;
    }
    //待删除元素等于树根结点值且左、右子树均不为空时的处理情况
    else {
        //中序前驱结点就是左孩子结点时，把左孩子结点值赋给树根结点，
        //然后从左子树中删除根结点
        if (BST->left->right==NULL) {
            BST->data=BST->left->data;
            return Delete(BST->left, BST->left->data);
        }
        //找出中序前驱结点，即左子树的右下角结点，把该结点值赋给树根结点，
        //然后从以中序前驱结点为根的树上删除根结点
        else {
```

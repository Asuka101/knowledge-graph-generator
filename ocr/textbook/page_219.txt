在树的生成算法中，需要设置两个栈，一个用来存储指向根结点的指针，以便孩子结点向双亲结点链接之用；另一个用来存储待链接的孩子结点的序号，以便能正确地链接到双亲结点的指针域。若这两个栈分别用$s$和$d$表示，$s$和$d$栈的深度不会大于整个树的深度。

树的生成算法与二叉树的生成算法类似，设结点值仍为字符类型 char，整个 k 叉树用一个广义表形式的字符串 a 来表示，则具体算法描述如下。

void CreateGTree(GTreeNode*& GT, char* a)
//根据广义表字符串 a 所给出的 k 叉树建立对应的存储结构
{
    const int MS=10; //定义符号常量指定栈空间的大小
    GTreeNode*s[MS]; //s 数组作为存储树中结点指针的栈使用
    int d[MS]; //d 数组作为存储孩子结点链接到双亲结点//指针域的序号的栈使用
    int top=-1; //top 作为两个栈的栈顶指针
    GT=NULL; //给树根指针置空
    GTreeNode*p; //定义 p 为指向树结点的指针
    int i=0; //用 i 指示扫描字符串数组 a 中的当前字符位置
    while (a[i])
    { //每循环一次处理一个字符，直到字符串结束符为止
        switch(a[i]) {
            case ' ': break; //对空格不做任何处理
            case '(':
                top++; s[top]=p; d[top]=0;
                //p 指针进 s 栈，0 进 d 栈，表明待扫描的孩子结点//将链接到 s 栈顶元素所指结点的第一个指针域
                break;
            case ')':
                top--;
                //s 和 d 退栈
                break;
            case ',':
                d[top]++;
                //待读入的孩子结点将链接到 s 栈顶元素//所指结点的下一个指针域
                break;
            default: //此处处理的必然是字符元素
                //根据 a[i]字符生成新结点
                p=new GTreeNode;
                p->data=a[i];
                for(int i=0; i<k; i++) p->t[i]=NULL;
                //使 p 结点成为树根结点或链接到双亲结点对应的指针域
                if(GT==NULL) GT=p;
                else s[top]->t[d[top]]=p;
        }
        i++;
    } //准备处理下一个字符
}

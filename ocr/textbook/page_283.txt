```cpp
        //若从初始点v_i的一个有效邻接点v_j未被访问过，则从v_j出发进行递归调用
        dfsMatrix(GA, j, n, visited);
    }

    void dfsAdjion(adjlist GL, int i, int n, bool* visited)
    {
        cout<<i<<' ';  //假设访问顶点v_i以输出该顶点的序号代之
        visited[i]=true;  //标记v_i已被访问过
        edgenode*p=GL[i];  //取v_i邻接表的表头指针
        while(p!=NULL) {  //依次搜索v_i的每个邻接点
            int j=p->adjvex;  //j为v_i的一个邻接点序号
            if(!visited[j])  //若v_j未被访问过，则从v_j出发进行递归调用
                dfsAdjion(GL, j, n, visited);
            p=p->next;  //使p指向v_i单链表的下一个边结点
        }
    }

图 7-10 中的 G7 所对应的邻接矩阵和邻接表如图 7-11 所示，请结合图分析以上的两个算法，判断从顶点v_1出发得到的深度优先搜索遍历的顶点序列是否分别为以下序列。

序列1：$1,0,2,6,3,4,5$序列2：$1,6,2,0,3,5,4$(a) 邻接矩阵

(b) 邻接表

图 7-11 G7 所对应的邻接矩阵和邻接表

当图中每个顶点的序号确定后，图的邻接矩阵表示是唯一的，所以从某一项点出发进行深度优先搜索遍历时访问各顶点的次序也是唯一的。但图的邻接表表示不是唯一的，它与边的输入次序和链接次序有关，所以对于同一个图的不同邻接表，从某一项点出发进行深度优先搜索遍历时访问各顶点的次序也可能不同。另外，对于同一个邻接矩阵或邻接表，如果指定的出发点不同，则将得到不同的遍历序列。

从以上两个算法可以看出，对邻接矩阵表示的图进行深度优先搜索遍历时，需要扫描邻接矩阵中的每一个元素，所以其时间复杂度为$O(n^2)$；对邻接表表示的图进行深度优先搜
```

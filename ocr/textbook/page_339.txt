都对应着一定的查找次序或称查找路径，都产生一个确定的探查序列（即待比较元素的地址序列）。在查找的多种方法中，主要有线性探查法、平方探查法和双散列函数探查法等。

(1) 线性探查法。

线性探查法是用开放定址法处理冲突的一种最简单的探查方法，它从发生冲突的$d$单元起，依次探查下一个单元（当达到下标为$m-1$的表尾单元时，下一个探查的单元是下标为 0 的表首单元，即把散列表看作首尾相接的循环表），直到碰到一个空闲单元或探查完所有单元为止。这种方法的探查序列为$d, d+1, d+2, \cdots$，或表示为$(d+i)\%m (0 \leq i \leq m-1)$。若使用递推公式表示，则为：$\left\{\begin{array}{l}
d_0=h(K) \\
d_i=(d_{i-1}+1)\%m \quad (1 \leq i \leq m-1)
\end{array}\right.$其中，$i$在最坏的情况下才能取值到$m-1$，一般只需取前几个值就可能找到一个空闲单元。找到一个空闲单元后，把发生冲突的待插入元素存入该单元即可。

【例 9-2】向例 9-1 中构造的$H$散列表中再插入关键字分别为 31 和 58 的两个元素，若发生冲突则使用线性探查法处理。

先看插入关键字为 31 的元素的情况。关键字为 31 的散列地址为$h(31)=31\%13=5$，因$H[5]$已被占用，接着探查下一个即下标为 6 的单元，因该单元空闲，所以关键字为 31 的元素被存储到下标为 6 的单元中，此时对应的散列表$H$为:

\n
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\
\hline H & & & 54 & & 43 & 18 & 31 & 46 & 60 & & 75 & & 90 \\
\hline
\end{tabular}

再看插入关键字为 58 的元素的情况。关键字为 58 的散列地址为$h(58)=58\%13=6$，因$H[6]$已被占用，接着探查下一个即下标为 7 的单元，因$H[7]$仍不为空，再接着探查下标为 8 的单元，这样当探查到下标为 9 的单元时，才找到一个空闲单元，所以把关键字为 58 的元素存入该单元中，此时对应的散列表$H$为:

\n
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\
\hline H & & & 54 & & 43 & 18 & 31 & 46 & 60 & 58 & 75 & & 90 \\
\hline
\end{tabular}

利用线性探查法处理冲突容易造成元素的“堆积”（或称“聚集”），这是因为当连续$n$个单元被占用后，再散列到这些单元上的元素和直接散列到后面一个空闲单元上的元素都要占用这个空闲单元，致使该空闲单元很容易被占用，造成更大的堆积，从而大大地增加查找下一个空闲单元的路径长度。如在例 9-2 最后得到的散列表中，下标为 11 的空闲单元均可被散列地址为 4~11 的元素所占用，从而造成 4~12 单元的堆积现象，若此时再插入散列地址为 4 的元素，则需要经过 10 次比较才能查找到空闲单元，此为下标 0 的单元，同样，当查找该元素时，也必须经过 10 次比较才能成功。

在线性探查中，造成堆积现象的根本原因是探查序列过分集中在发生冲突的单元的后面，没有在整个散列空间上分散开。下面介绍的双散列函数探查法和平方探查法可以在一定程度上克服堆积现象的发生。

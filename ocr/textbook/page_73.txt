return false;
}

该函数与 FindList 函数的定义类似, FindList 函数是在查找成功后由 item 带回元素的值, 而 UpdateList 函数是在查找成功后, 用 item 的值修改元素的值。

在线性表查找和更新算法中, 运行时间主要取决于比较元素的次数, 当第 1 个元素 list[0] 等于待查找或更新的元素时, 则只需要比较一次就结束操作, 对应的时间复杂度为$O(1)$, 这是最好的情况; 当前$n-1$元素比较均不成立, 只有比较到最后一个元素 list[$n-1$] ($n$为线性表的长度 L.size) 才等于待查找或更新的元素时, 则需要经过$n$次比较完成操作, 对应的时间复杂度为$O(n)$, 这是最差的情况: 当元素值互不相同, 并且都有相同的概率$\left(\text { 即平均概率 } \frac{1}{n}\right)$等于待查找或更新的元素时, 则需要比较元素的平均次数为$\frac{1}{n} \sum_{i=1}^{n} i=\frac{n+1}{2}$, 对应的时间复杂度为$O(n)$, 这是平均情况。当经过依次同线性表中所有$n$个元素比较后, 仍找不到与给定值相等的元素, 则表明查找失败, 算法执行 return false 语句后结束, 此种情况下的时间复杂度同样为$O(n)$。所以无论查找成功或失败, 顺序查找线性表的时间复杂度均为$O(n)$。

\section*{9. 向线性表中按给定条件插入一个元素}

当该函数的 pos 参数为 0 时, 则需要实现在有序表上的插入, 并且要保证插入新元素后仍为一个有序表。在有序表上查找插入位置最简单和常用的方法是顺序比较法, 它从第 1 个元素起, 依次取出每一个元素同待插入的元素 item 进行比较, 当 item 小于某一个元素的值时比较结束, 此元素位置就是 item 的插入位置。若比较到表尾后仍满足不了条件, 表明 item 大于所有元素, 则应把 item 插入到表尾, 成为新的表尾元素。另外, 当元素类型为记录时, 则必须对该类型进行小于号重载后才能实现 item<L.list[i] 的直接比较。

例如, 一个有序表为 A = (25,36,40,48,55,72,83), 当向其中插入 16 时, 其插入位置为表头, 即第 1 个元素 25 的位置; 当向其中插入 50 时, 其插入位置为 55 元素的位置; 当向其中插入 92 时, 其插入位置在表尾, 即最后一个元素 83 的后面位置。

当该函数的 pos 参数等于 -1 , 要求把 item 插入到线性表的表尾, 即第 L.size+1 个元素的位置上。

当该函数的 pos 参数为大于等于 1 , 同时小于等于线性表长度加 1 时, 则直接把 item 插入到线性表的第 pos 个元素的位置上。

在线性表的第 pos 个元素的位置插入一个新元素前, 还要检查存储线性表的动态数组空间是否具有空闲位置, 若没有, 则要扩大原有的空间。

为了实现在第 pos 个元素的位置插入新元素, 还要把从该位置开始的其后所有元素均后移一个位置, 以使空出第 pos 个元素的位置, 用于写入新元素。

完成插入后, 要使线性表的长度域增 1 , 然后返回真结束算法。

根据以上分析编写出此算法如下。

bool InsertList(List &L, ElemType item, int pos)
{

HG=(HG001,HG002,HG003)
若使用具有 mainlist 类型的一维数组 a 来顺序存储这四个子表（即整个主表，在每个子表的后面可以预留一些空闲位置，待插入新元素之用，假定在这里不留置空闲位置），同时使用具有 indexlist 类型的一维数组 b1 来顺序存储这种划分所得到的索引表，则 b1 中的内容，如表 9-2 所示。
表 9-2 索引表 b1
\begin{tabular}{c c c c} & index & start & length \ \hline 0 & JS & 0 & 4 \ 1 & DZ & 4 & 3 \ 2 & JJ & 7 & 2 \ 3 & HG & 9 & 3 \ \end{tabular}
对于上面的线性表 LA，若按照职称数据项的值进行划分，使得具有相同职称的记录在同一个子表中，则得到的 4 个子表分别为：
JSH=(JS001,HG001)
FJS=(JS004,DZ003,HG002)
JIA=(JS002,JS003,DZ002,JJ001,JJ002)
ZHU=(DZ001,HG003)
若在上一次划分使用的主表 a 的基础上来链接存储这一次划分所得到的子表，则首先需要在主表 a 的元素类型 ElemType 中增加一个指针域（next），然后利用这个指针域把这一次每个子表中的元素分别链接起来，链接后得到的每个链接子表，如图 9-3 所示，其中每个指针上的数值为该指针的具体值，即所指向结点（元素）的下标位置。
设用具有 indexlist 类型的一维数组 b2 来顺序存储这次划分所得到的索引表(每个子表已在主表 a 中链接存储)，则 b2 中的内容，如表 9-3 所示。
对于上面的线性表 LA，若按照记录的关键字进行划分，则每个子表中只有一个记录，也就是说，每个记录对应索引表中的一个索引项，此时每个索引项中的索引值就是对应记录的关键字，每个子表的开始位置就是对应记录的存储位置，因每个子表的长度均为 1，所以完全可以省略子表的长度域。按照此种方法划分得到的索引表，如表 9-4 所示。
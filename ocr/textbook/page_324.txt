仍找不到关键字为$K$的元素，则表明查找失败，返回特定的值，常用-1表示。

顺序查找的算法描述如下。

int Seqsch(ElemType A[], int n, KeyType K)
                    //从顺序表A[0]至A[n-1]的n个元素中顺序查找出关键字为K的元素
                    //若查找成功返回其下标,否则返回-1
{
                    //从表头元素A[0]开始顺序向后查找,查找成功则退出循环
    for(int i=0; i<n; i++)
        if(A[i].key==K) break;
                    //查找成功则返回该元素的下标i,否则返回-1
    if(i<n) return i;
    else return -1;
}

对该算法的一个改进，可在表的尾端设置一个“岗哨”，即在查找之前把给定值$K$赋给数组A中第$n$个位置的关键字域，这样每循环一次只需要进行元素比较，不需要比较下标是否越界，当比较到第$n$位置时，由于A[n].key==K必然成立，将自然退出循环。改进后的算法描述如下。

int Seqschl(ElemType A[], int n, KeyType K)
{
    A[n].key=K;                      //设置岗哨
    for(int i=0; i<n; i++) if(A[i].key==K) break;
    if(i<n) return i;
    else return -1;
}

由于改进后的算法省略了对下标越界的检查，所以必定能够提高算法的执行速度。
顺序查找的缺点是速度较慢，查找成功最多需比较$n$次，平均查找长度为$(n+1)/2$次，约为表长度的一半，查找失败也需比较$n+1$次，所以顺序查找的时间复杂性为$O(n)$。

顺序查找的优点是既适用于顺序表，也适用于单链表，同时对表中元素的排列次序无任何要求，这将给插入新元素带来方便，因为不需要为新元素寻找插入位置和移动原有元素，只要把它加入到表尾(对于顺序表)或表头(对于单链表)即可。

为了尽量提高顺序查找的速度，一种方法是，在已知各元素查找概率不等的情况下，可将各元素按查找概率从大到小排列，从而降低查找的平均比较次数(即平均查找长度)；另一种方法是，在事先未知各元素查找概率的情况下，在每次查找到一个元素时，将它与前驱元素对调位置，这样，过一段时间后，查找频度高(即概率大)的元素就会被逐渐前移，最后形成元素的前后位置按查找概率从大到小排列，从而达到减少平均查找长度的目的。

9.2.2 二分查找

二分查找 (binary search)又称折半查找、对分查找。作为二分查找对象的数据表必须

//若i等于m,则表明查找失败,返回-1
if(i==m) return -1;
//在已经查找到的第i个子表中顺序查找关键字为K2的记录
j=B[i].start;
while(j<B[i].start+B[i].length)
    if(K2==A[j].key) break;  //若KeyType被定义为字符串类型
                            //则条件应改为strcmp(K2,A[j].key)==0
    else j++;
//若查找成功则返回元素的下标位置,否则返回-1
if(j<B[i].start+B[i].length) return j;
else return -1;
}

若每个子表在主表A中采用的是链接存储，则只要把上面算法中的while循环和其后的if语句进行如下修改即可。

while(j!=-1)
    if(K2==A[j].key) break;
    else j=A[j].next;
return j;

若索引表B为稠密索引，则算法更为简单，只要在参数表中给出索引表参数B，索引表长度参数m和具有关键字类型的参数K即可，而在算法中只需要查找索引表B，并当查找成功时返回B[i].start的值，失败时返回-1即可。

索引查找的比较次数等于算法中查找索引表的比较次数和查找相应子表的比较次数之和。假定索引表的长度为$m$，相应子表的长度为$s$，则索引查找的平均查找长度为：$\text{ASL}=\frac{1+m}{2}+\frac{1+s}{2}=1+\frac{m+s}{2}$因为所有子表的长度之和等于主表的长度$n$，所以若每个子表具有相同的长度，即$s$等于$n/m$，则平均查找长度为$1+\frac{m+n/m}{2}$。由数学知识可知，当$m=n/m$（即$m=\sqrt{n}$，此时子表长度$s$也等于$\sqrt{n}$）时，平均查找长度最小，即为$1+\sqrt{n}$。可见，索引查找的速度快于顺序查找，但低于二分查找。在主表被等分为$\sqrt{n}$个子表的条件下，其时间复杂度为$O(\sqrt{n})$。

当$n=10000$时，若采用顺序查找则平均查找长度约为5000次，若采用二分查找约为13次，若采用索引查找，则约为100次。

虽然二分查找最快，但进行二分查找的表必须是顺序存储的有序表，为建立有序表需要花费时间，而对于顺序查找和索引查找则无此要求。

在索引存储中，不仅便于查找单个元素，而且更便于查找一个子表中的全部元素。当需要对一个子表中的全部元素依次处理时，只要从索引表中查找出该子表的开始位置，接着依次取出该子表中的每一个元素并处理即可。

若在主表中的每个子表后都预留有空闲位置，则索引存储也便于进行插入和删除运算，因为其运算过程只涉及到索引表和相应的子表，只需要对相应子表中的元素进行比较

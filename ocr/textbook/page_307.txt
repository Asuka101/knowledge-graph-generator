cout<<"输入图的有无向和有无权选择 (0 为无, 非 0 为有):";\ncin>>k1>>k2;\nadjmatrix ga;\nInitMatrix(ga,k2);\ncout<<"输入图的边集:"<<endl;\nchar* a=new char[100];\n//cin>>a; //输入一个图的边集\nstrcpy(a,"{<0,1>1,<0,3>4,<1,2>9,<1,3>2,<2,0>3,<2,1>5,");\nstrcat(a,"<2,3>8,<3,2>6}"); //字符数组 a 中保存图 8-8（a）的边集\nCreateMatrix(ga,n,a,k1,k2);\ncout<<"以二元组形式输出邻接矩阵 ga:"<<endl;\nPrintMatrix(ga,n,k1,k2);\nadjmatrix gb;\nInitMatrix(gb,k2);\nFloyed(ga,gb,n); //每对顶点的最短路径保存在 gb 中\ncout<<"以二元组形式输出邻接矩阵 gb:"<<endl;\nPrintMatrix(gb,n,k1,k2);\n}\n\n程序运行结果如下。\n\n输入待处理图的顶点数:4\n输入图的有无向和有无权选择 (0 为无, 非 0 为有):1 1\n输入图的边集:\n以二元组形式输出邻接矩阵 ga:\nV={0,1,2,3}\nE={<0,1>1,<0,3>4,<1,2>9,<1,3>2,<2,0>3,<2,1>5,<2,3>8,<3,2>6,}\n以二元组形式输出邻接矩阵 gb:\nV={0,1,2,3}\nE={<0,1>1,<0,2>9,<0,3>4,<1,0>11,<1,2>8,<1,3>2,<2,0>3,<2,1>4,\n<2,3>6,<3,0>9,<3,1>10,<3,2>6,}\n\n\section*{8.3 拓扑排序}\n\n\subsection*{8.3.1 拓扑排序的概念}\n\n一个较大的工程经常被分成许多子工程，把这些子工程称做活动（activity）。在整个工程中，有些子工程（活动）必须在其他有关子工程完成之后才能开始，也就是说，一个子工程的开始是以它的所有前序子工程的结束为先决条件的，但有些子工程没有先决条件，可以安排在任何时间开始。为了形象地反映出整个工程中各个子工程（活动）之间的先后关系，可用一个有向图来表示，图中的顶点代表活动（子工程），图中的有向边代表活动的

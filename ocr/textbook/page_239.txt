叉树, 所以适宜采用顺序存储, 这样能够充分利用其存储空间。

对堆进行顺序存储时, 首先要对堆中的所有结点进行编号, 然后再以编号为下标存储到指定数组的对应元素中。为了利用数组的 0 号元素, 堆中结点的编号从 0 而不是从 1 开始, 当然编号次序仍然按照从上到下、同一层从左到右进行, 若堆中含有$n$个结点, 则编号范围为$0 \sim n-1$。

堆中的结点从 0 开始编号后, 编号为 0 至$\lfloor n / 2\rfloor-1$的结点为分支结点, 编号为$\lfloor n / 2\rfloor \sim n-1$的结点为叶子结点; 当$n$为奇数则每个分支结点既有左孩子又有右孩子, 当$n$为偶数则编号最大的一个分支结点只有左孩子没有右孩子; 对于每个编号为$i$的分支结点, 其左孩子结点的编号为$2i+1$, 右孩子结点的编号为$2i+2$; 除编号为 0 的堆顶结点外, 对于其余编号为$i$的结点, 其双亲结点的编号为$\lfloor(i-1)/2\rfloor$。

对于图 6-4 所示的堆, 对应的顺序存储结构, 如图 6-5 所示。$\begin{array}{|c|c|c|c|c|c|c|c|c|c|}\hline 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\hline 18 & 26 & 35 & 73 & 48 & 60 & & & & \\\hline\end{array}$(a) 图 6-4 (a) 的存储结构$\begin{array}{|c|c|c|c|c|c|c|c|c|c|}\hline 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\hline 74 & 53 & 42 & 25 & 36 & 35 & 20 & 18 & 22 & \\\hline\end{array}$(b) 图 6-4 (b) 的存储结构

图 6-5 堆的顺序存储结构

根据此存储结构可以验证给出的双亲和左、右孩子结点之间的下标关系。

当一个堆采用顺序存储结构时, 需要定义一个元素类型为 ElemType、长度为 MaxSize 的一个数组来存储堆中的所有元素, 还需要定义一个整型变量, 用以存储堆的长度, 即堆中当前包含的结点数。设存储堆元素的数组名用 heap 表示, 存储堆长度的变量名用 len 表示, 并且把它们连同存储空间大小 MaxSize 一起定义在一个结构类型中, 结构类型名用 Heap 表示, 则该类型定义为:

struct Heap {
    ElemType* heap; // 定义指向动态数组空间的指针
    int len;        // 定义保存堆长度的变量
    int MaxSize;    // 用于保存初始化时所给的动态数组空间的大小
};

6.2.4 堆的运算

在堆的抽象数据类型中列出的每一种操作的具体算法描述如下。对于插入和删除算法将以小根堆为例给出, 当为大根堆时只是相应条件中的比较操作符不同, 其余都相同。

1. 初始化堆

void InitHeap(Heap& HBT) // 置 HBT 为一个空堆

所以被修改为 4 , 对应的路径为$\{2,0,1\}$; 同样,$v_{2}$到$v_{3}$的路径长度通过新中间点$v_{0}$后也由 8 变为 7 , 所以被修改为 7 , 对应的路径为$\{2,0,3\}$; 剩余的 4 对顶点的路径长度, 因加入$v_{0}$作为新中间点后仍不变短, 所以保持原值不变。

(2) 令$k=1$, 即以$v_{1}$作为新考虑的中间点, 对$A^{(0)}$中每对顶点之间的路径长度进行必要的修改后得到第 1 次运算结果$A^{(1)}$, 如图 8-8 (d) 所示。此时第 1 行和第 1 列同对角线的元素一样, 取上一次的值, 对于其他 6 个元素, 若$v_{i}$通过新中间点$v_{1}$然后到$v_{j}$的路径长度$A^{(0)}[i][1]+A^{(0)}[1][j]$小于原来的路径长度$A^{(0)}[i][j]$, 则用前者修改之, 否则仍保持原值。因$v_{0}$到$v_{2}$的路径长度$A^{(0)}[0][2]=\infty$, 通过新中间点$v_{1}$后变短, 即为$A^{(0)}[0][1]+A^{(0)}[1][2]=$1+9=10$, 所以被修改为 10 , 对应的路径为$\{0,1,2\}$;$v_{0}$到$v_{3}$的路径长度$A^{(0)}[0][3]=4$, 通过新中间点$v_{1}$后变短, 即为$A^{(0)}[0][1]+A^{(0)}[1][3]=1+2=3$, 所以也被修改为 3 , 对应的路径为$\{0,1,3\}$;$v_{2}$到$v_{3}$的路径长度$A^{(0)}[2][3]=7$, 通过新中间点$v_{1}$后也变短, 即为$A^{(0)}[2][1]+$A^{(0)}[1][3]=4+2=6$, 所以在第一次被修改的基础上又重新被修改为 6 , 对应的路径为$A^{(0)}[2][1]$的路径$\{2,0,1\}$并上$A^{(0)}[1][3]$的路径$\{1,3\}$, 即为$\{2,0,1,3\}$; 剩余 3 对顶点的路径长度, 因加入新中间点$v_{1}$后不变短, 所以仍保持原值不变。

(3) 令$k=2$, 即以$v_{2}$作为新考虑的中间点, 对$A^{(1)}$中每对顶点的路径长度进行必要地修改, 得到第 2 次运算的结果, 如图 8-8(e) 所示。同上两次的分析过程一样, 请读者分析这一次结果。

(4) 令$k=3$, 即以$v_{3}$作为新考虑的中间点, 这也是最后一个要考虑的中间点, 在$A^{(2)}$的基础上进行运算, 得到的运算结果$A^{(3)}$, 如图 8-8(f) 所示, 也请读者自行分析。$A^{(3)}$中的每个元素$A^{(3)}[i][j]$的值就是图 8-8(a) 中顶点$v_{i}$到$v_{j}$的最短路径长度。当然相应的最短路径也可以, 通过另设一个矩阵记录下来。

通过以上分析可知, 在每次运算中, 对$i=k, j=k$或$i=j$的那些元素无需进行计算,因为它们不会被修改, 对于其余元素, 只有满足$A^{(k-1)}[i][k]+A^{(k-1)}[k][j]<A^{(k-1)}[i][j]$的元素才会被修改, 即把小于号左边的两个元素之和赋给$A^{(k)}[i][j]$, 在这两个元素中, 前者是列号等于$k$, 后者是行号等于$k$, 所以它们在进行第$k$次运算的整个过程中, 其值都不会改变,即为上一次运算的结果, 故每一次运算都可以在原数组上 “就地” 进行, 即用新修改的值替换原值即可, 不需要使用两个数组交替进行。

假设有$n$个顶点的一个带权图$G$的邻接矩阵用 GA 表示, 与 GA 同类型的, 求每对顶点之间最短路径长度的二维数组用 A 表示, A 的初值等于 GA。弗洛伊德算法需要在 A 上进行$n$次运算, 每次以$v_{k}(0 \leq k \leq n-1)$作为一个新考虑的中间点, 求出每对顶点之间的当前最短路径长度, 最后一次运算后, A 中的每个元素 A[i][j] 就是图 G 中从顶点$v_{i}$到顶点$v_{j}$的最短路径长度。利用 C++语言编写弗洛伊德算法如下, 假定在该算法中不需要记录每对顶点之间的最短路径, 只需要记录每对顶点之间的最短长度。

void Floyd(adjmatrix GA, adjmatrix A, int n)

//利用弗洛伊德算法求 GA 表示的图中每对顶点之间的最短长度

//对应保存于二维数组 A 中

{
int i,j,k;

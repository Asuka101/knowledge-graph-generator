个结点中排序码最大的结点。所以利用堆排序的过程比较简单, 首先把 A[0] 与 A[n-1] 对换,使 A[n-1] 为排序码最大的结点, 接着对 A[0] (即对调前的 A[n-1]) 在前 n-1 个结点中进行篩运算, 又得到 A[0] 为当前区间 A[0]~A[n-2] 内具有最大排序码的结点, 再接着把 A[0] 同当前区间的最后一个结点 A[n-2] 对换, 使 A[n-2] 为次最大排序码结点, 这样经过 n-1 次对换和篩运算后, 所有结点成为有序, 排序结束。

若在图10-2(f) 已构成堆的基础上进行堆排序, 则前 3 次对换和篩运算的过程如图 10-3 所示, 剩余 6 次对换和篩运算的过程请读者自行完成。

堆排序的算法描述如下。

void HeapSort (ElemType A[], int n)
{
    //利用堆排序的方法对数组 A 中的 n 个元素进行排序
    ElemType x;
    int i;
    for(i=n/2-1; i>=0; i--) Sift(A,n,i);   //建立初始堆
    for(i=1; i<=n-1; i++) {
        //进行 n-1 次循环, 完成堆排序
        //将树根结点的值同当前区间内最后一个结点的值对换
    }
}

Operations
void InitGTree(GTREE& GT);
//初始化树,即把它置为一棵空树
void CreateGTree(GTREE& GT, char* a);
//根据广义表表示的树建立对应的存储结构
void TraverseGTree(GTREE GT);
//按照一定次序遍历树,使得每个结点的值均被访问一次
bool FindGTree(GTREE GT, ElemType& item);
//从树中查找值为item的结点,若存在该结点则由item带回
//它的完整值并返回true,否则返回false表示查找失败
void PrintGTree(GTREE GT);
//按照树的一种表示方法输出一棵树
bool EmptyGTree (GTREE GT);
//判断树是否为空,若是则返回true,否则返回false
void ClearGTree(GTREE& GT);
//清除树中的所有结点,使之变为一棵空树

end GeneralTree

\section*{5.5 .2 树的存储结构}

1. 树的顺序存储结构

树的顺序存储结构需要使用一个一维数组, 存储方法是: 首先对树中每个结点进行编号, 然后以各结点的编号为下标, 把结点值对应存储到相应元素中。

若待存储的树的度为$k$, 即它是一棵$k$叉树, 则结点编号的规则为: 树根结点的编号为 1 , 然后按照从上到下、每一层再从左到右的次序依次对每个结点编号。若一个结点的编号为$i$, 则$k$个孩子结点的编号依次为$k \times i - (k-2), k \times i - (k-3), \cdots, k \times i + 1$。如对于 3 叉树, 若双亲结点的编号为$i$, 则 3 个孩子结点的编号依次为$3 \times i - 1, 3 \times i, 3 \times i + 1$。又如对于 4 叉树, 若双亲结点的编号为$j$, 则 4 个孩子结点的编号依次为$4 \times j - 2, 4 \times j - 1, 4 \times j, 4 \times j + 1$。

若$k$叉树中一个结点的编号为$j$, 则它的父亲结点的编号为$(j-2)/k+1$, 即等于$j-2$除以$k$得到的整数商再加上 1 。如当$k=3$时, 父结点的编号为$(j-2)/3+1$, 若$j=10$, 则父结点的编号为 3 。

树的顺序存储适合满树和完全树的情况, 否则将非常浪费存储空间。故在实际应用中很少使用, 本节也不做深入讨论。

2. 树的链接存储结构

树的链接存储结构通常采用如下 3 种方式。

(1) 标准方式。

在这种方式中, 树中的每个结点除了包含有存储数据元素的值域外, 还包含有$k$个指针域, 用来分别指向$k$个孩子结点, 或者说, 用来分别链接$k$棵子树, 其中$k$为树的度。结点的类型可定义为:

}
}

2. 树的遍历

树的遍历包括先根遍历（或称深度优先遍历）、后根遍历和按层遍历（或称广度优先遍历）3种。

先根遍历定义为：先访问根结点，然后从左到右依次先根遍历每棵子树，此遍历过程是一个递归过程。先根遍历图 5-15 所示的树，得到的结点序列为：

A B D E H I F C G

后根遍历：从左到右依次后根遍历根结点的每棵子树，然后再访问根结点，此遍历过程也是一个递归过程。后根遍历图 5-15 所示的树，得到的结点序列为：

D H I E F B G C A

按层遍历：先访问第1层结点（即树根结点），再从左到右访问第2层结点，依次按层访问，直到全树中的所有结点都被访问为止，或者说直到访问完最深一层结点为止。按层遍历图 5-15 所示的树，得到的结点序列为：

A B C D E F G H I

同二叉树的先序遍历算法类似，树的先根遍历算法如下。

void PreRoot(GTreeNode* GT)          //先根遍历一棵k叉树
{
    if (GT != NULL) {
        cout << GT->data << ' ';      //访问根结点
        for (int i = 0; i < k; i++)
            PreRoot(GT->t[i]);        //递归遍历每一个子树
    }
}

树的后根遍历算法如下。

void PostRoot(GTreeNode* GT)         //后根遍历一棵k叉树
{
    if (GT != NULL) {
        for (int i = 0; i < k; i++)
            PostRoot(GT->t[i]);       //递归遍历每一个子树
        cout << GT->data << ' ';      //访问根结点
    }
}

在树的按层遍历算法中，需要设置一个队列，假定用 q 表示，元素类型应定义为结点指针类型 GTreeNode*，算法开始时将 q 初始化为空，接着若树根指针不为空则入队；然后每从队列中删除一个元素（即为指向结点的指针）时，都输出它的值并且依次使非空的孩子指针入队，这样反复进行下去，直到队列为空时止。此算法是一个非递归算法，若使用的队列采用现成的顺序队列的定义和运算，算法的具体描述如下。

}
if(p->right!=NULL) {
    //若存在右孩子,则右孩子结点指针进队
    rear=(rear+1)%MaxSize;
    q[rear]=p->right;
}
} //while end
}

在这个算法中，队列的最大长度不会超过二叉树中一层上的最多结点数，在定义队列数组时，要使数组的长度大于队列的最大长度，这样在结点进队时肯定不会发生溢出，因此也就不需要判断是否队满了。此算法的时间复杂度为$O(n)$，$n$表示二叉树中结点的个数。

\section*{5.4 二叉树其他运算}

\section*{1. 初始化二叉树}

void InitBTree(BTreeNode*& BT)   //初始化二叉树,即把树根指针置空
{
    BT=NULL;
}

\section*{2. 建立二叉树}

二叉树的输入格式不同，建立二叉树的算法也不同，采用广义表表示的输入法，二叉树广义表表示的规定如下。

(1) 每棵树的根结点作为由子树构成的表的名字而放在表的前面。

(2) 每个结点的左子树和右子树用逗号分开，若只有右子树而没有左子树，则逗号不能省略。

例如，对于图 5-11 (a) 所示的二叉树，其广义表表示为：$A(B(C),D(E(F,G),H(I)))$根据二叉树的广义表表示建立二叉树链接存储结构的基本思路是：从保存二叉树广义表的字符串 a 中输入每个字符，若遇到的是空格则不进行任何操作；若遇到的是字母（设以字母作为结点的值），则表明是结点的值，应为它建立一个新结点，并把该结点（若它不是整个树的根结点的话）作为左孩子（若$k=1$）或右孩子（若$k=2$）链接到其双亲结点上；若遇到的是左括号，则表明子表开始，应首先把指向它前面字母所在结点的指针（即根结点指针）进栈，以便括号内的子结点向双亲结点链接之用，然后把$k$置为 1，因为左括号后面紧跟着的字母（若有的话）必为根结点的左孩子；若遇到的是右括号，则表明子表结束，应退栈；若遇到的是逗号，则表明以左孩子为根的子树处理完毕，应接着处理以右孩子为根的子树，所以要把$k$置为 2。如此处理每一个字符，直到处理完所有字符为止。

建立二叉树的算法描述如下。

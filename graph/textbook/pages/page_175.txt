该算法的运行时间和使用系统栈所占有的存储空间与迷宫的大小成正比，在最好情况下的时间和空间复杂度均为$O(m+n)$，在最差情况下均为$O(m \times n)$，平均情况在它们之间。

下面给出求解迷宫算法的完整程序。

```cpp
#include<iostream.h>
const int m=6,n=8; //定义m和n常量,假定求解图4-7所示的迷宫问题
int maze[m+2][n+2]; //定义保存迷宫数据的数组
int mark[m+2][n+2]; //定义保存访问标记的数组
int move[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
//行下标0,1,2,3分别代表东,南,西,北方向
int SeekPath(int x,int y)
{ //函数体在此省略
}
void main(void)
{
    int i,j;
    //输入迷宫数据
    for(i=0; i<m+2; i++)
        for(j=0; j<n+2; j++)
            cin>>maze[i][j];
    //初始化mark数组
    for(i=0; i<m+2; i++)
        for(j=0; j<n+2; j++)
            mark[i][j]=0;
    //置入口点对应的访问标记为1
    mark[1][1]=1;
    //从入口点(1,1)开始调用求解迷宫的递归算法
    if(SeekPath(1,1))
        cout<<"("<<1<<","<<1<<")"<<endl; //从入口到出口的路径
    //按所经位置的相反次序输出,最后需要输出入口点的坐标
}
```

次序链接。通常, 当向表示集合的单链表中插入一个元素结点时, 为操作简便, 把它插入到表头, 即插入到第1个结点的前面, 使它成为新的表头结点, 而原来的表头结点成为第2个结点, 此时只修改新插入结点的指针域, 使其指向原来的表头结点, 再修改表头指针,使其指向新插入的结点, 从而完成结点的插入过程。当从单链表中删除一个结点时, 就是把该结点的指针域的值 (即后一结点的地址) 赋给其前一结点的指针域即可, 若它本身为表头结点, 则应把该结点的指针域的值赋给表头指针。

表示集合的单链表的结点结构定义如下。

struct SNode {
    ElemType data;
    SNode* next;
};

其中 SNode 为结点类型, data 为存储元素值的结点值域, next 为存储下一个结点地址的指针域。

由于单链表中的结点通常是靠动态分配产生的, 不需要事先分配存储空间, 所以存储一个单链表只需要存储它的表头指针即可。由表头指针就能够访问该单链表。假定表头指针用 HT 表示, 则 HT 应定义为:

SNode* Head;   //集合单链表的表头指针

集合单链表的示意图如图 3-2 所示。

HT$\rightarrow$\boxed{a_1}$\rightarrow$\boxed{a_2}$\rightarrow$...$\rightarrow$\boxed{a_i}$\rightarrow$\boxed{a_{i+1}}$\rightarrow$...$\rightarrow$\boxed{a_n}

图 3-2 集合单链表的示意图

按照集合的抽象数据类型的定义, 假定集合存储采用单链表结构, 由表头指针 HT 表示, 下面给出对集合的各种操作在单链表上的实现。熟悉了第 2 章对用单链表表示的进行线性表操作的各种算法, 以及上面面对顺序表 (数组) 表示的进行集合操作的各种算法后,同学们也不难写出下面面对用单链表表示的进行集合操作的各种算法。

\section*{1. 初始化集合为空}

void InitSet(SNode*& HT)
{
    HT=NULL;
}

\section*{2. 清除集合中的所有元素并释放占有的动态存储空间}

void ClearSet(SNode*& HT)
{
    SNode *p=HT, *q;           //p 指向 Head 单链表
    while(p!=NULL) {            //回收 Head 集合中的每个结点
        q=p->next;              //q 指向 p 的后继结点

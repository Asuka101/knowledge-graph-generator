第7章图
7.1图概念
7.1.1图定义
图(graph)图型结构简称，一种复杂非线性数据结构。图各个领域都有着广泛应用。图二元组定义：G=(V,E)。其中V顶点集合，V=v_i|0leqileqn-1,ngeq0,v_iintextVertexType，textVertexType顶点值类型，同以前使用textElemType一样可以代表任何类型，n顶点数，当n=0时则V空集；EV上二元关系集合，通常讨论仅含二元关系情况，且直接用E表示这个关系。这样，E就是V上顶点序偶或无序对（每个无序对(x,y)两个对称序偶langlex,yranglelangley,xrangle简写形式）集合。对于V上每个顶点，E都允许有任意多个前驱任意多个后继，即对每个顶点前驱后继个数均不加限制。
回顾一下线性表树二元组定义，都其二元关系上规定某种限制，线性表限制只允许每个结点有前驱后继；树限制只允许每个结点有前驱。因此，图比线性表树更具有广泛性，它包含线性表树在内，线性表树可看作图简单情况。
对于图G，若E序偶集合，则每个序偶对应图形一条有向边，若E无序对集合，则每个无序对对应图形一条无向边，所以可把E看作为边集合。这样图二元组定义可叙述：图由顶点集（vertexset）边集（edgeset）所组成。针对图G，顶点集和边集可分别记为V(G)E(G)。若顶点集为空，则边集必然为空；若顶点集非空，则边集可空可不空。当边集为空时，图G顶点均孤立顶点。
对于图G，若边集E(G)中为有向边，则称此图为有向图（directedgraph）；若边集E(G)中为无向边，则称此图为无向图（undirectedgraph）。如图7-1所示，G1G2分别无向图有向图，G1每个顶点里数字该顶点序号（序号0开始），顶点值没有图形给出，G2每个顶点里字母该顶点值或关键字，顶点外面数字该顶点序号。一般图型结构讨论，只关心顶点序号而不关心顶点值，所有顶点值通常另外保存数组或文件，待需要时取用。G1G2对应顶点集和边集分别如下所示，这里假定用每个顶点序号i代替顶点v_i值。
V(G1)=0,1,2,3,4,5,E(G1)=(0,1),(0,2),(0,3),(0,4),(1,4),(2,4),(2,5),(3,5),(4,5)V(G2)=0,1,2,3,4E(G2)=<0,1>,<0,2>,<1,2>,<1,4>,<2,1>,<2,3>,<4,3>若用G2顶点值表示其顶点集和边集，则如下所示。V(G2)=textA,B,C,D,EE(G2)=<textA,B>,<textA,C>,<textB,C>,<textB,E>,<textC,B>,<textC,D>,<textE,D>日常生活，图应用到处可见，各种交通图、线路图、结构图流程图。
subsection7.1.2图基本术语
section1.端点邻接点
无向图中，若存在一条边(v_i,v_j)，则称v_i、v_j为此边两个端点，并称它们互为邻接点(adjacent)，即v_iv_j邻接点，v_j也v_i邻接点。图7-1(a)，以顶点v_0端点4条边(0,1)、(0,2)、(0,3)(0,4)，v_04个邻接点分别v_1、v_2、v_3v_4；以顶点v_3端点两条边(3,0)(3,5)，v_3两个邻接点分别v_0v_5。
有向图，若存在一条边<v_i,v_j>，则称此边顶点v_i一条出边（outedge）。顶点v_j一条入边（inedge）；称v_i为此边起始点，简称起点或始点，v_j为此边终止端点，简称终点；称v_iv_j互为邻接点，并称v_jv_i出边邻接点，v_iv_j入边邻接点。图7-1(b)，顶点C有两条出边<textC,B><textC,D>，两条入边<textA,C><textB,C>，顶点C两个出边邻接点为BD，两个入边邻接点为AB。
section2.顶点度
无向图中顶点v度（degree）以该顶点端点边数目，简单地说，就是该顶点边数目，记为D(v)。图G1v_0顶点度4，v_1顶点度2。有向图顶点v度有入度出度之分，入度（indegree）该顶点入边数目，记为textID(v)；出度（outdegree）该顶点出边数目，记为textOD(v)；顶点v度等于它入度出度之，即D(v)=textID(v)+textOD(v)。图G2顶点A入度0，出度2，度为2；顶点C入度2，出度2，度为4。
若图中有n个顶点e条边，则该图所有顶点度数之同边数e满足下面关系：e=frac12sum_i=0^n-1D(v_i)因为每条边各为两个端点增加度数1，合起来图添加度数2，所以全部顶点度数之所有边数2倍，或者说，边数全部顶点度数之一半。
3.完全图、稠密图、稀疏图
若无向图中每两个顶点之间都存在着一条边，有向图每两个顶点之间都存在着方向相反两条边，则称此图为完全图。显然，若完全图是无向，则图包含有frac12n(n-1)条边，它等于n个元素每次取出2个元素所有组合数；若完全图是有向，则图包含有n(n-1)条边，即每个顶点到其余n-1个顶点之间都有一条出边。当图接近完全图时，则称它稠密图，相反，当图含有较少边数（即e<<n(n-1)，双小于号表示远远小于，此边数通常与顶点数n同数量级）时，则称它稀疏图。如图7-2所示，G3就是含有5个顶点无向完全图，G4就是含有6个顶点稀疏图。
(a)G3
(b)G4
图7-2完全图稀疏图
4.子图
设有两个图G=(V,E)G'=(V',E')，若V'V子集，即V'subseteqV，且E'E子集，即E'subseteqE，并且E'所涉及到顶点全部包含V'，则称G'G子图。，由G3全部顶点同一v_0相连所有边可构成G3子图，由G3顶点v_0、v_1、v_2它们之间所有边可构成G3另子图。
5.路径回路
图G，顶点v到顶点v'一条路径(path)顶点序列v_i1,v_i2,cdots,v_im，其中v=v_i1，v'=v_im，若此图无向图，则(v_j-1,v_j)inE(G)，(2leqjleqm)；若此图有向图，则<v_j-1,v_j>inE(G)，(2leqjleqm)。顶点v到顶点v'路径长度指该路径上经过边数目。若一条路径上所有顶点均不同，则称为简单路径。若一条路径上前后两端点相同，则称为回路或环(cycle)，若回路中除前后两端点相同外，基余顶点均不同则称为简
单回路或简单环。图G4,顶点c到顶点d一条简单路径c、e、a、b、d,其路径长度4;路径a、b、e、a一条简单回路,其路径长度3;路径a、b、e、f、b不是一条简单路径,因为存在着顶点b到b一条回路。
6.连通连通分量
无向图G,若顶点v_i到顶点v_j有路径,则称v_iv_j连通。若图G任意两个顶点都连通,则称G连通图,否则若存在顶点之间不连通情况则称为非连通图。无向图G极大连通子图称为G连通分量。显然,任何连通图都可以通过连通分量把所有顶点连通起来,而非连通图有多个连通分量。,上面给出图G1图G3都连通图。下面图7-3(a)所示非连通图,它包含有3个连通分量,如图7-3(b)、图7-3(c)、图7-3(d)所示。
(a)无向图
(b)第一个连通分量
(c)第二个连通分量
(d)第三个连通分量
图7-3非连通图连通分量
7.强连通图和强连通分量
有向图G,顶点v_i到顶点v_j有路径,则称v_i到v_j连通。若图G任意两个顶点v_iv_j都连通,即v_i到v_jv_j到v_i都存在路径,则称G强连通图。有向图G极大强连通子图称为G强连通分量。显然,强连通图可以通过强连通分量把所有顶点连通起来,非强连通图有多个强连通分量。如图7-4(a)所示有3个强连通分量,如图7-4(b)、图7-4(c)、图7-4(d)所示。
(a)有向量
(b)第一个强连通分量
(c)第二个强连通分量
(d)第三个强连通分量
图7-4有向图强连通分量
8.权和网
图中,每条边可以标上具有某种含义数值,通常非负实数,此数值称为该边权(weight)。,对于反映城市交通线路图,边上权可表示该条线路长度或等级;对于反映电子线路图,边上权可表示两端点间电阻、电流或电压;对于反映零件装配图,边上权可表示端点零件需要装配另端点零件数量。
量；对于反映工程进度图，边上权可表示从前一子工程到后一子工程所需要天数。边上带有权图称作带权图，也常称做网(network)。如图7-5所示G5G6就分别无向带权图有向带权图。
(a)G5
(b)G6
图7-5无向带权图有向带权图
对于带权图，若用图顶点集和边集表示，则边集中每条边后面应附加该边上权值。图G5G6边集分别：E(G5)=(0,1)5,(0,2)7,(1,2)12,(1,3)3,(1,4)8,(2,3)6,(2,4)20,(3,4)15E(G6)=<0,1>2,<0,2>3,<0,3>8,<1,3>12,<2,0>6,<2,3>6,<2,4>1,<3,4>4subsection7.1.3图抽象数据类型
图抽象数据类型数部分图G，它可以采用顺序、链接任一种存储结构，存储类型用GraphType标识符表示，操作部分包括初始化图、建立图、遍历图、查找图、输出图、清除图常用运算，以及求图最小生成树、最短路径、拓扑排序、关键路径特定运算。图抽象数据类型具体定义如下。
DATGRAPHis
Data:
图G，存储类型用标识符GraphType表示
Operations
voidInitGraph(GraphType&G);//初始化图存储空间
voidCreateGraph(GraphType&G,charE,intn);//根据图边集E建立图存储结构
voidTraverseGraph(GraphType&G,inti,intn);//按照一定次序顶点i开始遍历图
boolFindGraph(GraphType&G,VertexType&item,intn);//从图查找给定值顶点
voidPrintGraph(GraphType&G,intn);//按照图一种表示方法输出图
voidClearGraph(GraphType&GT);//清除图中动态分配存储空间
voidMinSpanGraph(GraphType&G,intn);//求图最小生成树
voidMinPathGraph(GraphType&G,intn);//求图顶点之间最短路径
voidTopolGraph(GraphType&G,intn);//求有向图顶点之间拓扑序列
voidKeyPathGraph(GraphType&G,intn);//求有向带权图关键路径
endGeneralTree
本章将结合图存储结构遍历讨论图常用运算算法，对于图特定运算方法算法，将留到第8章专门讨论。
section7.2图存储结构
图存储结构又称图存储表示或图表示。图有多种表示方法，这里介绍比较常用邻接矩阵、邻接表和边集数组3种。
subsection7.2.1邻接矩阵
邻接矩阵（adjacencymatrix）表示图形顶点之间相邻关系矩阵。设G=(V,E)具有n个顶点图，顶点序号依次0,1,2,cdots,n-1，则G邻接矩阵具有如下定义n阶方阵。A[i,j]=begincases1&text对于无向图，(v_i,v_j)text或(v_j,v_i)inE(G);1&text对于有向图，langlev_i,v_jrangleinE(G)0&E(G)text不存在v_isimv_jtext边endcases对于图7-1G_1G_2，它们邻接矩阵分别A_1A_2所示。由A_1可以看出，无向图邻接矩阵按主对角线轴对称。A_1=beginbmatrix0&1&1&1&1&01&0&0&0&1&01&0&0&0&1&01&0&0&0&0&11&1&1&0&0&10&0&1&1&1&0endbmatrix,A_2=beginbmatrix0&1&1&0&00&0&1&0&10&1&0&1&00&0&0&0&00&0&0&1&0endbmatrix若图G带权图，则用邻接矩阵表示也很方便，只要把1换为相应边上权值，把非对角线上0换为某很大特定实数，表示这个边不存在，这个特定实数通常用infty或MaxValue表示，它要大于图G所有边上权值之。
，对于图7-5带权图G_5G_6，它们邻接矩阵分别用A_3A_4所示。A_1=beginbmatrix0&5&7&infty&infty5&0&12&3&8infty&12&0&6&20infty&3&6&0&15infty&8&20&15&0endbmatrix,A_2=beginbmatrix0&2&3&8&inftyinfty&0&infty&12&infty6&infty&0&6&1infty&infty&infty&0&4infty&infty&infty&infty&0endbmatrix
采用邻接矩阵表示图，便于查找图中任一条边或边上权。要查找边(i,j)或<i,j>,则只要查找邻接矩阵第i行第j列元素A[i,j]是否有效值（即非零值非MaxValue值）。若该元素有效值，则表明此边存在，否则此边不存在。邻接矩阵元素可以随机存取，所以查找一条边时间复杂度O(1)。这种存储表示也便于查找图中任一点度，对于无向图，顶点v_i度就是对应第i行或第i列上有效元素个数；对于有向图，顶点v_i出度就是对应第i行上有效元素个数，顶点v_i入度就是对应第i列上有效元素个数。由于求任一点度需访问对应一行或一列所有元素，所以其时间复杂度O(n)，n表示图中顶点数，即邻接矩阵阶数。从图邻接矩阵中查任一项点邻接点或所有邻接点同样也很方便。查找v_i邻接点（对于无向图）或出边邻接点（对于有向图），则只要第i行上查找出有效元素，以该元素所在列号j序号顶点v_j就是所求邻接点或出边邻接点。一般算法要求依次查找出顶点v_i所有邻接点（对于有向图则出边邻接点或入边邻接点），此时需访问对应第i行或第i列上所有元素，所以其时间复杂度O(n)。
图邻接矩阵存储需要占用ntimesn个整数存储位置（因顶点序号整数），所以其空间复杂度O(n^2)。这种存储结构用于表示稠密图能够充分利用存储空间，但若用于表示稀疏图，则将使邻接矩阵变为稀疏矩阵，从而造成存储空间很大浪费。
图邻接矩阵表示，只是使用一个二维数组存储顶点之间相邻关系，为了存储图中n个顶点元素信息，通常还需要使用一维数组，用数组下标i元素存储顶点v_i信息。这两种数组类型可定义如下。
constintMaxVertexNum=图最大顶点数，它要大于等于具体图顶点数n;
constintMaxEdgeNum=图最大边数，它要大于等于具体图边数e;
typedefintWeightType;//定义边权值类型
constWeightTypeMaxValue=特定权值，它要大于图中所有有效权值之;
typedefVertexTypevexlist[MaxVertexNum];//定义vexlist存储顶点信息数组类型
typedefintadjmatrix[MaxVertexNum][MaxVertexNum];
//定义adjmatrix存储邻接矩阵数组类型
图顶点信息利用vexlist类型一维数组存储后，能够根据顶点序号直接访问到相应元素，图中顶点之间邻接关系利用邻接矩阵存储后，也能够根据任一条边两个端点直接访问到相应元素，所以，可把它们看作图一种顺序存储。
section1.图邻接矩阵存储初始化算法
voidInitMatrix(adjmatrixGA,intk)//假定k等于0无权图，k不等于0有权图
inti,j;
for(i=0;i<MaxVertexNum;i++)
for(j=0;j<MaxVertexNum;j++)
if(i==j)GA[i][j]=0;
elseif(k)GA[i][j]=MaxValue;
elseGA[i][j]=0;
2.根据图边集生成图邻接矩阵算法
voidCreateMatrix(adjmatrixGA,intn,chars,intk1,intk2)
//k10则无向图否则有向图，k20则无权图否则有权图
//s字符串用来保存图边集，n图顶点数
istringstreamsin(s);//定义sin字符串输入流，与s边集对应
charc1,c2,c3;//用来保存输入流中读入字符
inti,j;//用i,j保存一条边起点终点序号
WeightTypew;//用w保存一条边权值
sin>>c1;//sin输入流中读入第1个字符'('
if(k1==0&&k2==0)//建立无向无权图
do
sin>>c1>>i>>c2>>j>>c3;//依次读入一条边5个数据
GA[i][j]=GA[j][i]=1;//置相应对称元素1
sin>>c1;//读入逗号或右花括号
if(c1==')')break;//边集处理完毕，退出循环
while(1);
elseif(k1==0&&k2!=0)//建立无向有权图
do
sin>>c1>>i>>c2>>j>>c3>>w;
GA[i][j]=GA[j][i]=w;//置相应对称元素w
sin>>c1;
if(c1==')')break;
while(1);
elseif(k1!=0&&k2==0)//建立有向无权图
do
sin>>c1>>i>>c2>>j>>c3;
GA[i][j]=1;//置相应元素1
sin>>c1;
if(c1==')')break;
while(1);
elseif(k1!=0&&k2!=0)//建立有向有权图
do
sin>>c1>>i>>c2>>j>>c3>>w;
GA[i][j]=w;//置相应元素w
sin>>c1;
if(c1==')')break;
while(1);
算法每条sin语句之后可增加一条语句或函数调用检查ij是否0simn-1范围内，若不则退出运行。
3.根据图邻接矩阵输出图二元组表示（顶点集和边集）算法
voidPrintMatrix(adjmatrixGA,intn,intk1,intk2)
```cpp
//输出用邻接矩阵表示图顶点集和边集
inti,j;
cout<<"V=";//输出顶点集开始
for(i=0;i<n-1;i++)cout<<i<<',';
cout<<n-1<<''<<endl;//输出顶点集结束
cout<<"E=";//输出边集开始
if(k2==0)
//对无权图处理情况
for(i=0;i<n;i++)
for(j=0;j<n;j++)
if(GA[i][j]==1)
if(k1==0)
//对无向无权图处理
if(i<j)cout<<'('<<i<<','<<j<<')'<<',';
else
//对有向无权图处理
cout<<'<'<<i<<','<<j<<'>'<<',';
else
//对有权图处理情况
for(i=0;i<n;i++)
for(j=0;j<n;j++)
if(GA[i][j]!=0&&GA[i][j]!=MaxValue)
if(k1==0)
//对无向有权图处理
if(i<j)cout<<'('<<i<<','<<j<<')'<<GA[i][j]<<',';
else
//对有向有权图处理
cout<<'<'<<i<<','<<j<<'>'<<GA[i][j]<<',';
cout<<''<<endl;//注意:边集最后一条边后面多出逗号
上面各算法，邻接矩阵参数GA值参，由于它指针参数，只占用4个字节存储空间，与调用它实参指向同一个二维数组，共同访问该实参数组相应元素。所以，对于指针值参，也同样具有一般引用参数作用。
section7.2.2邻接表
邻接表(adjacencylist)对图每个顶点建立邻接关系单链表，并把它们表头指针用一维向量（数组）存储一种图表示方法。顶点v_i建立邻接关系单链表称作v_i邻接表。v_i邻接表中每个结点用来存储以该顶点端点或起点一条边信息，因而称为边结点。v_i邻接表中结点数，对于无向图来说，等于v_i度数、邻接点数或出度数；对于有向图来说，等于v_i出边数、出边邻接点数或出度数。边结点类型通常定义3个域：一是邻接点域(adjvex)，用以存储顶点v_i邻接顶点v_j序号j；二是权域(weight)，用以存储边(v_i,v_j)或<v_i,v_j>上权；三是链域(next)，用以链接v_i邻接表中下结点。这3个域，邻接点域链域必不可少，权域可根据情况取舍，
```
若表示无权图，则可省去此域。对于每个顶点v_i邻接表，需要设置表头指针，若图G中有n个顶点，则就有n个表头指针。为了便于随机访问任一顶点邻接表，需要把这n个表头指针用一维数组（数组）存储起来，其中第i个分量存储v_i邻接表表头指针。这样，图G就可以由这个表头向量来表示存取。
图7-1G1图7-5G6对应邻接表如图7-6所示。
(a)G1所示邻接表
(b)G6所示邻接表
图7-6G1G6邻接表
图邻接表不是唯一，因为每个顶点邻接表中，各边结点链接次序可以任意安排，其具体链接次序与边输入次序生成算法有关。
建立图邻接表中边结点类型定义表头向量类型定义如下。
structedgenode
intadjvex;//邻接点域
WeightTypeweight;//权值域，对无权图可省去
edgenodenext;//指向下—个边结点链域
;
typedefedgenodeadjlist[MaxVertexNum];//定义adjlist存储n个表头指针
//数组类型
1.初始化图邻接表算法
voidInitAdjoin(adjlistGL)
for(inti=0;i<MaxVertexNum;i++)GL[i]=NULL;
2.根据图边集生成其邻接表算法
voidCreateAdjoin(adjlistGL,intn,chars,intk1,intk2)
//k10则无向图；否则有向图，k20则无权图；否则有权图
istringstreamsin(s);
charc1,c2,c3;
inti,j;
WeightTypew;
edgenodep;
sin>>c1;
if(k2==0)
do
//输入流中读入一条边
sin>>c1>>i>>c2>>j>>c3;
p=newedgenode;
p->adjvex=j;p->weight=1;//假定无权图每条边权为1
p->next=GL[i];
GL[i]=p;
//对于无向图,还需向序号j单链表表头插入边结点
if(k1==0)
p=newedgenode;
p->adjvex=i;p->weight=1;
p->next=GL[j];
GL[j]=p;
while(c1==',');
else
do
//输入流中读入一条边
sin>>c1>>i>>c2>>j>>c3>>w;
p=newedgenode;
p->adjvex=j;p->weight=w;
p->next=GL[i];
GL[i]=p;
//对于无向图,还需向序号j单链表表头插入边结点
if(k1==0)
p=newedgenode;
p->adjvex=i;p->weight=w;
p->next=GL[j];
GL[j]=p;
while(c1==',');
3.把邻接表表示图用顶点集和边集形式输出算法
voidPrintAdjJoin(adjlistGL,intn,intk1,intk2)
//输出用邻接表表示图顶点集和边集
inti,j;
edgenodep;
cout<<"V=";
for(i=0;i<n-1;i++)cout<<i<<',';
cout<<n-1<<''<<endl;
cout<<"E=";
for(i=0;i<n;i++)
if(k2==0)
p=GL[i];
while(p)
j=p->adjvex;
if(k1==0)
//对无向无权图处理情况
if(i<j)cout<<'('<<i<<','<<j<<')'<<',';
//使用条件i<j，为了避免输出重复边
else
//对有向无权图处理
cout<<'<'<<i<<','<<j<<'>'<<',';
p=p->next;
else
//对有权图处理情况
p=GL[i];
while(p)
j=p->adjvex;
if(k1==0)if(i<j)
//对无向有权图处理
cout<<'('<<i<<','<<j<<')'<<p->weight<<',';
else
//对有向有权图处理
cout<<'<'<<i<<','<<j<<'>'<<p->weight<<',';
p=p->next;
cout<<''<<endl;
//注意：边集最后一条边后面多出逗号
图邻接表中查找顶点边（出边）或邻接点（出边邻接点），只要首先表头向量取出对应表头指针，然后表头指针出发进行查找即可。由于每个顶点单链表平均长度e/n（对于有向图）或2e/n（对于无向图），所以此查找运算时间复杂度O(e/n)。但有向图邻接表中查找顶点入边或入边邻接点，那就不方便，它需要扫描所有顶点邻接表中边结点，因此其时间复杂度O(n+e)。对于那些需要经常查找
顶点入边或入边邻接点运算,可以为此专门建立逆邻接表(ContraryAdjacencyList),该表中每个顶点单链表不是存储该顶点所有出边信息,而是存储所有入边信息,邻接域存储入边邻接点序号。如图7-5所示图7-5G_6建立逆邻接表,从此表中很容易求出每个顶点入边、入边上权、入边邻接点入度。
![0]->[26∧]
1->[02∧]
2->[03∧]
3->[08-]->[112-]->[26∧]
4->[21-]->[34∧]
图7-7G6逆邻接表
有向图邻接表中,求顶点出边信息较方便,逆邻接表中,则求顶点入边信息较方便,若把它们合起来构成十字邻接表(orthogonaladjacencylist),则求顶点出边信息入边信息都将很方便。如图7-8所示图7-5G_6建立十字邻接表。
![0]->[012∧]->[023∧]->[038∧]
1->[1312∧]
2->[206∧]->[236∧]->[241∧]
3->[344∧]
4->[]
图7-8G6十字邻接表
十字邻接表中,每个边结点对应图中一条有向边,它包含5个域:边起点域、终点域、边上权域、入边链域出边链域。其中,入边链域用于指向同一个顶点下一条入边结点,通过它把入边链接起来;出边链域用于指向同一个顶点下一条出边结点,通过它把出边链接起来。表头向量每个分量包括两个域:入边表表头指针域出边表表头指针域。
图邻接表、逆邻接表或十字邻接表示,表头向量需要占用n个或2n个指针存储空间,所有边结点需要占用2e(对于无向图)或e(对于有向图)个边结点空间,所以其空间复杂度O(n+e)。这种存储结构用于表示稀疏图比较节省存储空间,因为只需要很少边结点,若用于表示稠密图,则将占用较多存储空间,同时也将增加每个顶点邻接表中查找结点时间。
图邻接表表示图邻接矩阵表示,虽然方法不同,但也存在着对应关系。邻接
表中每个顶点v_i单链表对应邻接矩阵第i行，整个邻接表可看做邻接矩阵带行指针向量链接存储；整个逆邻接表可看成邻接矩阵带列指针向量链接存储；整个十字邻接表可看成邻接矩阵十字链接存储。对于稀疏矩阵，若采用链接存储比较节省存储空间，所以稀疏图邻接表示比邻接矩阵表示要节省存储空间。
section7.2.3边集数组
边集数组(edgesetarray)利用一维数组存储图中所有边一种图表示方法。该数组中所含元素个数要大于等于图中边条数，每个元素用来存储一条边起点、终点（对于无向图，可选定边任一端点为起点或终点）权（若有的话），各边数组次序可任意安排，也可根据具体要求而定。边集数组只是存储图中所有边信息，若需要存储顶点信息，同样需要具有n个元素一维数组。图7-1G2图7-5G5所对应边集数组如图7-9所示。
(a)G2边集数组
(b)G5边集数组
图7-9G2G5边集数组
section1.边集数组元素类型边集数组类型定义
structedge
intfromvex;//边起点域
intendvex;//边终点域
WeightTypeweight;//边权值域,对于无权图可省去此域
;
typedefedgeedgeset[MaxEdgeNum];//定义edgeset边集数组类型
section2.初始化图边集数组算法
voidInitArray(edgesetGE)
for(inti=0;i<MaxEdgeNum;i++)
GE[i].fromvex=GE[i].endvex=-1;
GE[i].weight=MaxValue;
section3.根据图边集生成图边集数组算法
voidCreateArray(edgesetGE,intn,chars,intk)
//k0则无权图否则有权图
```cpp
istringstreamsin(s);
charc1,c2,c3;
inti,j,c=0;
WeightTypew;
sin>>c1;
if(k==0)//建立无权图
do
//输入流中读入一条边
sin>>c1>>i>>c2>>j>>c3;
//置边集数组下标c元素值
GE[c].fromvex=i;
GE[c].endvex=j;
GE[c].weight=1;//假定无权图每条边权为1
c++;
//读入逗号或右花括号
sin>>c1;
while(c1==',');
else//建立有权图
do
//输入流中读入一条边
sin>>c1>>i>>c2>>j>>c3>>w;
//置边集数组下标c元素值
GE[c].fromvex=i;
GE[c].endvex=j;
GE[c].weight=w;
c++;
//读入逗号或右花括号
sin>>c1;
while(c1==',');
4.根据图边集数组表示输出图二元组表示算法
voidPrintArray(edgesetGE,intn,intk1,intk2)
//输出用边集数组表示图顶点集和边集
inti;
cout<<"V=";
for(i=0;i<n-1;i++)cout<<i<<",";
cout<<n-1<<""<<endl;
cout<<"E=";
i=-1;
while(GE[++i].fromvex!=-1)//访问边集数组每条边
if(k2==0)
if(k1==0)//对无向无权图处理
```
```cpp
cout<<'('<<GE[i].fromvex<<','<<GE[i].endvex<<')'<<',';
else
//对有向无权图处理
cout<<'<''<GE[i].fromvex<<','<<GE[i].endvex<<'>'<<',';
else
if(x1==0)//对无向有权图处理
cout<<'('<<GE[i].fromvex<<','<<GE[i].endvex;
cout<<')'<<GE[i].weight<<',';
else
//对有向有权图处理
cout<<'<''<GE[i].fromvex<<','<<GE[i].endvex;
cout<<'>'<<GE[i].weight<<',';
cout<<')'<<endl;//注意:边集最后一条边后面多出逗号
若图中有e条边，边集数组查找一条边或顶点度都需要扫描整个数组，所以其时间复杂度O(e)。边集数组适合那些对边依次进行处理运算，不适合对顶点运算对任一条边运算。边集数组表示空间复杂度O(e)。空间复杂度上讲，边集数组也适合表示稀疏图。
图邻接矩阵、邻接表和边集数组表示各有利弊，具体应用时，要根据图稠密稀疏程度以及算法要求进行选择。
section7.3图遍历
图遍历就是从指定某个顶点（称此初始点）出发，按照一定搜索方法对图所有顶点都做一次访问过程。图遍历比树遍历要复杂，因为树根到达树中每个结点只有一条路径，而图初始点到达图中每个顶点可能存在着多条路径。当顺着图中一条路径访问某顶点后，可能还会顺着另一条路径回到该顶点。为了避免重复访问图中同一个顶点，必须记住每个顶点是否访问，为此可设置辅助数组visited[n]，它每个元素初值均逻辑值假，即常量0，表明未访问，一旦访问顶点v_i，就把对应元素visited[i]置逻辑值真，即常量1，表明v_i已访问。
根据搜索方法不同，图遍历有两种：深度优先搜索遍历广度优先搜索遍历。
subsection7.3.1深度优先搜索遍历
深度优先搜索（depth-firstsearch）遍历类似于对树先根遍历，它递归过程，可叙述：首先访问顶点v_i（一开始初始点），并将其标记已访问，然后v_i任未访问邻接点（有向图入边邻接点除外，下同）出发进行深度优先搜索
```
遍历,当v_1所有邻接点均访问过时,则退回到上顶点v_k,v_k另未访问邻接点出发进行深度优先搜索遍历,直到退回到初始点并且没有未访问邻接点为止。
结合如图7-10所示无向图G7分析以v_0作为初始点深度优先搜索遍历过程。
(1)访问顶点v_0,并将visited[0]置真,表明v_0已访问,接着v_0未访问邻接点v_1(v_03个邻接点v_1,v_2v_3都未访问,先访问v_1)出发进行深度优先搜索遍历。
(2)访问顶点v_1,并将visited[1]置真,表明v_1已访问,接着v_1未访问邻接点v_4(v_14个邻接点中只有v_0访问,其余3个邻接点v_4,v_5,v_6均未访问,先访问v_4)出发进行深度优先搜索遍历。
(3)访问顶点v_4,并将visited[4]置真,表明v_4已访问,接着v_4未访问邻接点v_5(v_4两个邻接点为v_1v_5,v_1访问,只剩v_5未访问)出发进行深度优先搜索遍历。
(4)访问顶点v_5,并将visited[5]置真,表明v_5已访问,接着因v_5两个邻接点v_1v_4都已访问,所以退回到上顶点v_4,又因v_4两个邻接点v_1v_5都已访问,所以再退回到上顶点v_1,v_14个邻接点中有3个已访问,此时只能从未访问邻接点v_6出发进行深度优先搜索遍历。
(5)访问顶点v_6,并将visited[6]置真,表明v_6已访问,接着v_6未访问邻接点v_2(只此)出发进行深度优先搜索遍历。
(6)访问顶点v_2,并将visited[2]置真,表明v_2已访问,接着因v_2所有邻接点(即v_0v_6)都访问,所以退回到上顶点v_6,同理,由v_6退回到v_1,再v_1未访问邻接点v_3(只此)出发进行深度优先搜索遍历。
(7)访问顶点v_3,并将visited[3]置真,表明v_3已访问,接着因v_3所有邻接点(它仅有邻接点v_0)都访问,所以退回到上顶点v_0,又因v_0所有邻接点都已访问,所以再退回,实际上就结束对G7深度优先搜索遍历过程,返回到调用此算法函数去。
对无向图G7进行深度优先搜索遍历过程分析可知,初始点v_0出发,访问G7各顶点次序:v_0,v_1,v_4,v_5,v_6,v_2,v_3。
图深度优先搜索遍历过程递归,visited[n]保存顶点访问标记逻辑型数组,每个元素初值均假。下面分别以邻接矩阵邻接表作为图存储结构,给出相应深度优先搜索遍历算法描述。
voiddfsMatrix(adjmatrixGA,inti,intn,boolvisited)
//初始点v_i出发深度优先搜索由邻接矩阵GA表示图
cout<<i<<'';
//假设访问顶点v_i以输出该顶点序号代之
visited[i]=true;
//标记v_i已访问
for(intj=0;j<n;j++)
//依次搜索v_i每个邻接点
if(GA[i][j]!=0&&GA[i][j]!=MaxValue&&!visited[j])
```cpp
//若初始点v_i有效邻接点v_j未访问，则v_j出发进行递归调用
dfsMatrix(GA,j,n,visited);
voiddfsAdjion(adjlistGL,inti,intn,boolvisited)
cout<<i<<'';//假设访问顶点v_i以输出该顶点序号代之
visited[i]=true;//标记v_i已访问
edgenodep=GL[i];//取v_i邻接表表头指针
while(p!=NULL)//依次搜索v_i每个邻接点
intj=p->adjvex;//jv_i邻接点序号
if(!visited[j])//若v_j未访问，则v_j出发进行递归调用
dfsAdjion(GL,j,n,visited);
p=p->next;//使p指向v_i单链表下边结点
图7-10G7所对应邻接矩阵邻接表如图7-11所示，请结合图分析以上两个算法，判断顶点v_1出发得到深度优先搜索遍历顶点序列是否分别以下序列。
序列1：1,0,2,6,3,4,5序列2：1,6,2,0,3,5,4(a)邻接矩阵
(b)邻接表
图7-11G7所对应邻接矩阵邻接表
当图每个顶点序号确定后，图邻接矩阵表示唯一，所以某一项点出发进行深度优先搜索遍历时访问各顶点次序也唯一。但图邻接表表示不是唯一，它与边输入次序链接次序有关，所以对于同一个图不同邻接表，某一项点出发进行深度优先搜索遍历时访问各顶点次序也可能不同。另外，对于同一个邻接矩阵或邻接表，如果指定出发点不同，则将得到不同遍历序列。
以上两个算法可以看出，对邻接矩阵表示图进行深度优先搜索遍历时，需要扫描邻接矩阵每元素，所以其时间复杂度O(n^2)；对邻接表表示图进行深度优先搜
```
索遍历时,需要扫描邻接表中每个边结点,所以其时间复杂度O(e);两者空间复杂度均O(n)。
section7.3.2广度优先搜索遍历
广度优先搜索(breadth-firstsearch)遍历类似于对树按层遍历,其过程:首先访问初始点v_0,并将其标记已访问,接着访问v_0所有未访问邻接点,其访问次序可以任意,假定依次v_i1,v_i2,cdots,v_in,并均标记已访问,然后再按照v_i1,v_i2,cdots,v_in次序,访问每顶点所有未访问邻接点（次序任意）,并均标记已访问,以此类推,直到图中所有初始点v_0有路径相通顶点都访问为止。
结合如图7-12所示有向图G8分析v_0出发进行广度优先搜索遍历过程。
(1)访问初始点v_0,并将其标记已访问。
(2)访问v_0所有未访问邻接点v_1v_2,并将它们标记已访问。
(3)访问顶点v_1所有未访问邻接点v_3、v_4v_5,并将它们标记已访问。
(4)访问顶点v_2所有未访问邻接点v_6（它两个邻接点中顶点v_5已访问），并将其标记已访问。
(5)访问顶点v_3所有未访问邻接点v_7（只此邻接点且没有访问），并将其标记已访问。
(6)访问顶点v_4所有未访问邻接点，因v_4邻接点v_7（只此）已访问，所以此次不访问任何顶点。
(7)访问顶点v_5所有未访问邻接点v_8,并将其标记已访问。
(8)访问顶点v_6所有未访问邻接点，因v_6仅邻接点v_8已访问，所以此次不访问任何顶点。
(9)依次访问v_7v_8所有未访问邻接点，因它们均没有邻接点，所以整个遍历过程到此结束。
以上对有向图G8进行广度优先搜索遍历过程分析可知，初始点v_0出发，得到访问各顶点次序：v_0,v_1,v_2,v_3,v_4,v_5,v_6,v_7,v_8。
广度优先搜索遍历，先访问顶点，其邻接点亦先访问，所以算法实现需要使用队列，用来依次记住访问顶点。算法开始时，将初始点v_0访问后插入队列，以后每次队列删除元素，就依次访问它每未访问邻接点，并令其进队，这样，当队列为空时，表明所有与初始点有路径相通顶点都已访问完毕，算法到此结束。下面分别以邻接矩阵邻接表作为图存储结构给出相应广度优先搜索遍历算法，算法使用队列可以采用第4章已经给出顺序或链接队列类型，也可以直接定义队列进行运算操作。
n
[图片]
voidbfsMatrix(adjmatrixGA,inti,intn,boolvisited)
//初始点v_i出发广度优先搜索由邻接矩阵GA表示图
constintMaxSize=30;//定义队列最大长度
intq[MaxSize]=0;//定义队列q，其元素类型应为整型
intfront=0,rear=0;//定义队首队尾指针
cout<<i<<'';
visited[i]=true;//标记初始点v_i已访问
q[++rear]=i;//将已访问初始点序号i入队
while(front!=rear)
front=(front+1)%MaxSize;
intk=q[front];//删除队首元素，第1次执行时k值ifor(intj=0;j<n;j++)//依次搜索v_k每可能邻接点
if(GA[k][j]!=0&&GA[k][j]!=MaxValue&&!visited[j])
cout<<j<<'';//访问未访问邻接点v_jvisited[j]=true;//标记v_j已访问
rear=(rear+1)%MaxSize;
q[rear]=j;//顶点序号j入队
voidbfsAdjoin(adjlistGL,inti,intn,boolvisited)
//初始点v_i出发广度优先搜索由邻接表GL表示图
constintMaxSize=30;//给出顺序队列最大长度
intq[MaxSize]=0;//定义队列q，其元素类型应为整型
intfront=0,rear=0;//定义队首队尾指针
cout<<i<<'';
visited[i]=true;//标记初始点v_i已访问
q[++rear]=i;//将已访问初始点序号i入队
while(front!=rear)
front=(front+1)%MaxSize;
intk=q[front];//删除队首元素，第1次执行时k值iedgenodep=GL[k];//取v_k邻接表表头指针
while(p!=NULL)
intj=p->adjvex;//依次搜索v_k每邻接点
if(!visited[j])//若v_j没有访问过则进行处理
cout<<j<<'';
visited[j]=true;
rear=(rear+1)%MaxSize;
q[rear]=j;//顶点序号j入队
p=p->next;//使p指向v_k邻接表下边结点
结合图7-11(a)图7-11(b)分析上面两个算法，判断顶点v_1出发得到广度优先搜索遍历顶点序列是否分别以下序列。
序列1:1,0,4,5,6,2,3序列2:1,6,5,4,0,2,3与图深度优先搜索遍历一样，对于图广度优先搜索遍历，若采用邻接矩阵表示，其时间复杂度O(n^2)；若采用邻接表表示，其时间复杂度O(e)。两者空间复杂度均O(n)。
由图某个顶点出发进行广度优先搜索遍历时，访问各顶点次序，对于邻接矩阵来说唯一，对于邻接表来说，可能因邻接表不同而不同，这一点也与图深度优先搜索遍历时情形一样。
section7.3.3非连通图遍历
图深度优先搜索遍历算法图广度优先搜索遍历算法，对于无向图来说，若无向图连通图，则能够访问到图所有顶点；若无向图是非连通图，则只能访问到初始点所在连通分量所有顶点，其他连通分量顶点不可能访问到。为此需要其他每个连通分量选定初始点，分别进行搜索遍历，才能够访问到图所有顶点。对于有向图来说，若初始点到图中每个顶点都有路径，则能够访问到图所有顶点，否则不能够访问到所有顶点。为此需要从未访问顶点再选一些顶点作为初始点，进行搜索遍历，直到图中所有顶点都访问为止。
为了能够访问到任何图中所有顶点，要以图中未访问到每顶点作为初始点，去调用上面任何算法。某个函数执行下面for语句：
for(inti=0;i<n;i++)
if(!visited[i])
dfsMatrix(GA,i,n,visited);//也可以调用其他遍历算法
若无向图连通，或有向图顶点v_0到其余每个顶点都有路径，则此循环语句只执行一次调用（即dfsMatrix（GA,0,n,visited）调用）就结束遍历过程，否则要执行多次调用才能结束遍历过程。对无向图来说，每次调用将遍历连通分量，有多少次调用过程，就说明该图有多少个连通分量。
采用图邻接矩阵进行图遍历运算程序举例如下。
include<iostream.h>
include<stdlib.h>
include<strstrea.h>//使用字符串流所需系统头文件
typedefintVertexType;//定义顶点值类型
typedefintWeightType;//定义边上权值类型
constintMaxVertexNum=10;//定义图最多顶点数
constWeightTypeMaxValue=1000;//定义无边上特定权值
typedefVertexTypevexlist[MaxVertexNum];
//定义vexlist存储顶点信息数组类型
typedefintadjmatrix[MaxVertexNum][MaxVertexNum];
//定义adjmatrix存储邻接矩阵数组类型
include"采用邻接矩阵存储图常用运算.cpp"
voidmain()
inti,n,k1,k2;
cout<<"输入待处理图顶点数:";
cin>>n;
cout<<"输入图有无向有无权选择(0无,非0有):";
cin>>k1>>k2;
boolvisited=newbool[n];//定义并动态分配标志数组
adjmatrixga;
InitMatrix(ga,k2);
cout<<"输入图边集:";
chara=newchar[100];
cin>>a;//输入图边集
CreateMatrix(ga,n,a,k1,k2);
cout<<"按图邻接矩阵得到深度优先遍历序列:"<<endl;
for(i=0;i<n;i++)visited[i]=false;
dfsMatrix(ga,0,n,visited);
cout<<endl;
cout<<"按图邻接矩阵得到广度优先遍历序列:"<<endl;
for(i=0;i<n;i++)visited[i]=false;
bfsMatrix(ga,0,n,visited);
cout<<endl;
PrintMatrix(ga,n,k1,k2);
该程序一次运行结果如下:
输入待处理图顶点数:7
输入图有无向有无权选择(0无,非0有):00
输入图边集:(0,1),(0,2),(0,3),(1,4),(1,5),(1,6),(2,6),(4,5)
按图邻接矩阵得到深度优先遍历序列:
0145623
按图邻接矩阵得到广度优先遍历序列:
0123456
V=0,1,2,3,4,5,6
E=(0,1),(0,2),(0,3),(1,4),(1,5),(1,6),(2,6),(4,5),
第6章特殊二叉树
特殊二叉树包括二叉搜索树、堆、哈夫曼树、线索二叉树平衡二叉树，它们都有着不同应用。本章将讨论特殊二叉树定义、结构运算特点。
section6.1二叉搜索树
subsection6.1.1二叉搜索树定义
二叉搜索树（binarysearchingtree）又称二叉排序树（binarysortingtree），它或是一棵空树，或者一棵具有如下特性非空二叉树。
（1）若它左子树非空，则左子树上所有结点关键字均小于根结点关键字。
（2）若它右子树非空，则右子树上所有结点关键字均大于（若允许具有相同关键字结点存在，则大于等于）根结点关键字。
（3）左、右子树本身又各一棵二叉搜索树。
二叉搜索树中，当每个结点元素类型简单类型时，则结点关键字就是该结点值；当每个结点元素类型记录类型时，则结点关键字该结点某域值。如当元素类型整型时，则结点关键字就是该结点值即整数；当元素类型学生记录类型时，则每个学生学号（即记录域）就是相应结点关键字。算法描述，以结点值比较作为其关键字比较，实际情况可能进行关键字域比较，若C++语言环境下运行，可通过关系操作符重载，使其真正比较记录关键字。
由二叉搜索树定义可知，一棵非空二叉搜索树中，其结点关键字按照左子树、根和右子树有序，所以对它进行中序遍历得到结点序列必然有序序列。
如图6-1所示一棵二叉搜索树，树中每个结点关键字都大于它左子树中所有结点关键字，而小于它右子树中所有结点关键字。对此树进行中序遍历得到结点序列：12,15,18,23,26,30,52,63,74可见此序列有序序列。
begincenter
includegraphics[width=0.5textwidth]image.png
endcenter
图6-1二叉搜索树
subsection6.1.2二叉搜索树抽象数据类型
二叉搜索树抽象数据类型数据部分一棵二叉搜索树，它可以具有同一般二叉树一样任何存储结构，操作部分除了已经讨论对一般二叉树操作外，还具有对二叉搜索树一
些常用操作，即搜索（查找）、更新、插入删除元素操作。假定二叉搜索树中结点类型BTreeNode，指向二叉搜索树树根结点指针BST，则对二叉搜索树BST查找、更新、插入删除元素操作声明如下。
boolFind(BTreeNodeBST,ElemType&item);
boolUpdate(BTreeNodeBST,constElemType&item);
voidInsert(BTreeNode&BST,constElemType&item);
boolDelete(BTreeNode&BST,constElemType&item);
查找函数find二叉搜索树BST查找等于给定值item元素，若查找成功则返回true，并由item带回该元素值，否则返回false。更新函数Update二叉搜索树BST查找等于给定值item元素，若查找成功则用item值更新该元素并返回true，否则返回false。插入函数Insert向二叉搜索树BST插入元素item，使得插入后仍保持一棵二叉搜索树。删除函数Delete二叉搜索树中删除等于给定值item结点，若删除成功则返回true，否则返回false。
section6.1.3二叉搜索树运算
1.查找
根据二叉搜索树定义，查找等于给定值item元素时，若二叉搜索树为空，则表明查找失败，应返回假。否则，若item等于当前树根结点值，则表明查找成功，应由引用参数item带回根结点值并返回真；若item小于根结点值，则继续根左子树中查找；若item大于根结点值，则继续根右子树中查找。这是递归查找过程，其递归算法描述如下。
boolFind(BTreeNodeBST,ElemType&item)
//二叉搜索树中查找等于给定值item元素
if(BST==NULL)returnfalse;//查找失败返回假
else
if(item==BST->data)//若查找成功则带回元素值并返回真
item=BST->data;
returntrue;
elseif(item<BST->data)//向左子树继续查找
returnFind(BST->left,item);
else//向右子树继续查找
returnFind(BST->right,item);
由于此递归算法递归调用属于末尾递归调用，即递归调用语句函数体中最后一条可执行语句，每次递归调用返回后不执行任何语句又返回到上一层，因此原先保存数据堆栈信息都没有用处。所以为了避免无效花费进出数据栈操作上时间
使用数据栈空间，相应非递归算法如下。
boolFind1(BTreeNodeBST,ElemType&item)//二叉搜索树查找非递归算法
while(BST!=NULL)
if(item==BST->data)
item=BST->data;returntrue;
elseif(item<BST->data)BST=BST->left;
elseBST=BST->right;
returnfalse;
从图6-1所示二叉搜索树中查找关键字23元素时,首先用23同根结点30进行比较,因为23<30,所以向30左子树继续查找;再用23同当前根结点15进行比较,因为23>15,所以向15右子树继续查找;再用23同当前根结点23进行比较,因为相等,所以由item带回该结点值并返回真,整个查找过程就此结束。若图6-1查找关键字48元素时,其查找过程:首先用48同根结点30进行比较,因为48>30,所以向30右子树继续查找;再用48同当前根结点52进行比较,因为48<52,所以向52左子树继续查找,此时左子树为空,所以返回假,表明查找失败,整个查找过程就此结束。
二叉搜索树上进行查找过程,给定值item同树中结点比较次数最少一次(即树根结点就是待查结点),最多为树深度,所以平均查找次数要小于等于树深度。若二叉搜索树是一棵理想平衡树或接近理想平衡树,则进行查找时间复杂度O(logn);若退化一棵单支树（最极端最差情况），则其时间复杂度O(n)。对于一般情况,其时间复杂度可大致看作O(logn)。因此二叉搜索树上查找比集合或线性表上进行顺序查找时间复杂度O(n)要好得多,这正是构造二叉搜索树优势所在。二叉搜索树查找递归算法空间复杂度平均情况O(logn),最差情况O(n),非递归算法空间复杂度O(1)。
2.更新
二叉搜索树更新算法与查找算法基本相同,区别仅有两点:一是更新算法中当查找到待更新元素时,应将item值赋给该元素,而查找算法中是将该元素值赋给item带回;二是更新算法参数item可以变参(即引用参数),也可以值参,并且参数说明前面可以加或不加常量标识符const,而查找算法参数item只能变参,并且不能加常量标识符const。请同学们编写此更新算法。
3.插入
根据二叉搜索树定义,向二叉搜索树中插入元素item过程:若二叉树为空,则由item元素生成新结点将作为根结点插入;否则,若item小于根结点,则将新结点插入到根左子树上,若item大于等于(若不允许具有相同值结点存在,则对等于情况应
作单独处理）根结点，则将新结点插入到根右子树上。显然插入过程递归，对应递归算法描述如下。
voidInsert(BTreeNode&BST,constElemType&item)
if(BST==NULL)
//把按照item元素生成新结点链接到已找到插入位置
BTreeNodep=newBTreeNode;
p->data=item;
p->left=p->right=NULL;
BST=p;
elseif(item<BST->data)//向左子树中插入元素
Insert(BST->left,item);
else
Insert(BST->right,item);//向右子树中插入元素
此算法树根指针参数BST必须说明引用，因为当它空时需要由它带回树根指针，或者递归时由它提供新插入结点链接位置。
同一叉搜索树递归查找算法一样，此算法也属于末尾递归调用，所以为了消除末尾递归，减少算法运行时间空间，也可编写出对应非递归算法（注意：消除末尾递归不需要使用栈）。对于插入过程非递归算法，需要首先查找插入位置，然后再进行插入。查找插入位置树根结点开始，若树根指针为空，则新结点就是树根结点；否则，若item小于根结点，则沿着根左指针左子树上继续查找插入位置，若item大于等于根结点，则沿着根右指针右子树上继续查找插入位置，当查找到结点（设由parent指针所指向）左指针或右指针空时，则这个空指针位置就是新元素结点插入位置。
进行插入时，若原树为空，则将新结点指针赋给BST，该新结点就成为树根结点；否则，将新结点赋给parent结点左指针域或右指针域，作为该结点左孩子或右孩子。插入过程非递归算法具体描述如下。
voidInsert1(BTreeNode&BST,constElemType&item)
//插入新元素寻找插入位置，定义指针t指向当前待比较结点，初始
//指向树根结点，定义指针parent指向t结点双亲结点，初始NULL
BTreeNodet=BST,parent=NULL;
while(t!=NULL)
parent=t;
if(item<t->data)t=t->left;
elset=t->right;
//建立值为item,左、右指针域空新结点
BTreeNodep=newBTreeNode;
p->data=item;
p->left=p->right=NULL;
//将新结点插入到二叉搜索树BST
if(parent==NULL)BST=p;
elseif(item<parent->data)parent->left=p;
elseparent->right=p;
二叉搜索树插入算法时间空间复杂度,与其查找更新算法完全相同。
利用二叉搜索树插入算法,可以很容易地编写出生成一棵具有n个结点二叉搜索树算法,设生成二叉搜索树n个元素由数组提供,则算法描述如下。
voidCreateBSTree(BTreeNode&BST,ElemTypea[],intn)
//利用数组n个元素建立二叉搜索树算法
BST=NULL;
for(inti=0;i<n;i++)
Insert(BST,a[i]);
一般情况下,此算法时间复杂度O(ntimeslgn)。
若建立二叉搜索树一组元素关键字:(38,26,62,94,35,50,28,55)按照上述算法,每插入结点后得到二叉搜索树如图6-2所示。
(a)插入38(b)插入26(c)插入62(d)插入94(e)插入35
(f)插入50(g)插入28(h)插入55
图6-2二叉搜索树生成过程
4.删除
二叉搜索树删除比插入要复杂一些,因为插入结点都链接到树叶子结点上,因而不会破坏树原有结构,也就是说,不会破坏树中原有结点之间链接关系。
二叉搜索树上删除结点（元素）则不同，它可能删除叶子结点，也可能删除分支结点，当删除分支结点时，就破坏原有结点之间链接关系，需要重新修改指针，使得删除后仍一棵二叉搜索树。
结合如图6-3(a)所示二叉搜索树，分3种情况介绍删除结点操作。
(a)二叉搜索树
(b)删除GM后
(c)删除D结点后
(d)删除L结点后
图6-3二叉搜索树删除
(1)删除叶子结点。
此种删除操作很简单，只要将其双亲结点链接到它指针去掉（即置空）。删除图6-3(a)树中叶子结点A时，把D结点左指针域置空；删除叶子结点W时，把S结点右指针域置空。
(2)删除单支结点。
这种删除操作也比较简单，因为该结点只有左子树或右子树一支，也就是说，其后继只有：左孩子或右孩子。删除该结点时，只要将后继指针链接到它所在链接位置即可。删除图6-3(a)树中单支结点G时，将G左指针（即指向F结点指针）赋给D结点右指针域即可；删除单支结点M时，将M右指针（即指向S结点指针）赋给L结点右指针域即可；删除这两个结点后，得到二叉搜索树，如图6-3(b)所示。
(3)删除双支结点。
这种删除比较复杂，因为待删除结点有两个后继指针，需要妥善处理。删除这种结点第1种方法：首先把它右子树链接到它中序前驱结点（即中序序列处于它前面结点）右指针域，此中序前驱结点必是它左子树中“最右下”右指针为空（左指针可能为空，也可能不为空）结点，图6-3(a)树中双支结点D中序前驱A结点，双支结点L中序前驱G结点；然后把它左子树链接到它所在链接位置。图6-3(a)树中删除双支结点D时，则首先把D右子树链接到A结点右
指针域，然后把D左子树链接到L左指针域，删除D结点后得到二叉搜索树如图6-3(c)所示。这种方法往往容易增加树深度，使树结构变坏，所以通常采用下面介绍第2种方法。
删除双支结点第2方法：首先把它中序前驱结点值赋给该结点值域，然后再删除它中序前驱结点，因为它中序前驱结点右指针为空，所以只要把中序前驱结点左指针链接到中序前驱结点所在链接位置即可。删除图6-3(a)树中双支结点D时，首先把它中序前驱结点A值赋给D结点值域，然后把A结点左指针（此时为空）链接到D结点左指针域，删除D结点后得到二叉搜索树，如图6-3(c)所示。又，若图6-3(a)树中删除根结点L，因为L双支结点，所以首先把它中序前驱结点G值赋给L结点值域，然后把G结点左指针（此时指向F结点）链接到D结点右指针域，删除L结点后得到二叉搜索树，如图6-3(d)所示。
采用以上方法二叉搜索树中删除结点后，得到仍然一棵二叉搜索树。
二叉搜索树中删除结点算法可以递归，也可以是非递归，下面只给出递归算法，读者可以编写出相应非递归算法。
```
boolDelete(BTreeNode&BST,constElemType&item)
//二叉搜索树BST删除值为item结点，树根指针必须引用
//树为空，未找到待删除元素，返回假表示删除成功
if(BST==NULL)returnfalse;
//待删除元素小于树根结点值，继续左子树中删除
if(item<BST->data)returnDelete(BST->left,item);
//待删除元素大于树根结点值，继续右子树中删除
if(item>BST->data)returnDelete(BST->right,item);
BTreeNodetemp=BST;
//待删除元素等于树根结点值且左子树为空，将右子树作为整棵树并返回真
if(BST->left==NULL)
BST=BST->right;deletetemp;returntrue;
//待删除元素等于树根结点值且右子树为空，将左子树作为整棵树并返回真
elseif(BST->right==NULL)
BST=BST->left;deletetemp;returntrue;
//待删除元素等于树根结点值且左、右子树均不为空时处理情况
else
//中序前驱结点就是左孩子结点时，把左孩子结点值赋给树根结点，
//然后左子树中删除根结点
if(BST->left->right==NULL)
BST->data=BST->left->data;
returnDelete(BST->left,BST->left->data);
//找出中序前驱结点，即左子树右下角结点，把该结点值赋给树根结点，
//然后从以中序前驱结点为根树上删除根结点
else
```
BTreeNodep1=BST,p2=BST->left;
while(p2->right!=NULL)p1=p2;p2=p2->right;
BST->data=p2->data;
returnDelete(p1->right,p2->data);
二叉搜索树查找、插入、删除元素运算都具有相同时间复杂度，都与具体二叉搜索树深度成正比，时间复杂度平均情况O(logn)，最差情况O(n)；它们空间复杂度，对于递归算法来说，平均情况O(logn)，最差情况O(n)，对于非递归算法来说均O(1)。
可以采用下面程序调试对二叉搜索树各种运算算法。
include<iostream.h>
include<stdlib.h>
//定义二叉搜索树结点值类型整型
typedefintElemType;
//定义二叉搜索树结点类型
structBTreeNode
ElemTypedata;
BTreeNodeleft;
BTreeNoderight;
;
include"二叉树运算.cpp"
include"二叉搜索树运算.cpp"//保存对二叉搜索树运算算法
voidmain()
ElemTypex;
//定义指向二叉搜索树结点指针，并用它作为树根指针
BTreeNodebst;
//初始化二叉搜索树，即置树根指针bst为空
InitBTree(bst);
//定义数组a并初始化
ElemTypea[10]=30,50,20,40,25,70,54,23,80,92;
//利用数组a建立树根指针bst二叉搜索树
CreateBSTree(bst,a,10);
//以广义表形式输出二叉搜索树
PrintBTree(bst);cout<<endl;
//求出以bst树根指针二叉搜索树深度
cout<<"深度：";cout<<DepthBTree(bst)<<endl;
//中序遍历以bst树根指针二叉搜索树
cout<<"中序:";InOrder(bst);cout<<endl;
//二叉搜索树中查找结点
cout<<"输入待查找整数值:";
cin>>x;
if(Find1(bst,x))cout<<"查找元素"<<x<<"成功!"<<endl;
elsecout<<"查找元素"<<x<<"失败!"<<endl;
//向二叉搜索树中插入结点
cout<<"输入待插入结点整数值:";
cin>>x;
Insert1(bst,x);
//二叉搜索树中删除结点
cout<<"输入待删除结点值:";
cin>>x;
if(Delete(bst,x))cout<<"删除元素"<<x<<"成功!"<<endl;
elsecout<<"删除元素"<<x<<"失败!"<<endl;
//再以广义表形式输出二叉搜索树
PrintBTree(bst);cout<<endl;
//再次中序遍历以bst树根指针二叉搜索树
cout<<"中序:";InOrder(bst);cout<<endl;
//清除以bst树根指针二叉树
ClearBTree(bst);
程序一次运行结果如下。30(20(,25(23)),50(40,70(54,80(,92))))深度:5
中序:20232530405054708092
输入待查找整数值:70
查找元素70成功!
输入待插入结点整数值:15
输入待删除结点值:30
删除元素30成功!25(20(15,23),50(40,70(54,80(,92))))中序:15202325405054708092
6.2堆
6.2.1堆定义
堆(heap)分为小根堆大根堆两种,对于小根堆,它具有如下特性一棵完全二叉树。
（1）若树根结点存在左孩子，则根结点值(或某个域值)小于等于左孩子结点值(或某个域值)。
（2）若树根结点存在右孩子，则根结点值(或某个域值)小于等于右孩子结点值
(或某个域值)。
(3)以左、右孩子为根子树又各堆。
大根堆定义与上述类似,只要把小于等于改为大于等于就得到。
由堆定义可知,若一棵完全二叉树堆,则该树中以每个结点为根子树也都一
个堆。
如图6-4所示分别小根堆大根堆。根据堆定义可知,堆顶结点,即整个完全二叉树根结点,对于小根堆来说具有最小值,对于大根堆来说具有最大值。图6-4(a)小根堆,堆中最小值堆顶结点值18,图6-4(b)大根堆,堆中最大值堆顶结点值74。若用堆来表示优先级队列,则堆顶结点具有最高优先级,每次做删除操作要删除堆顶结点。beginaligned&text(a)小根堆&text(b)大根堆endaligned图6-4小根堆大根堆
section6.2.2堆抽象数据类型
堆抽象数据类型数据部分按任一种存储结构表示堆,用标识符HBT表示,其存储类型用标识符HeapType表示。堆抽象数据类型操作部分通常:向堆插入元素、从堆删除堆顶元素、初始化堆、清除堆判断堆是否为空。堆抽象数据类型具体定义如下。
ADTHEAPis
Data:
具有HeapType类型堆HBT
Operations:
voidInitHeap(HeapType&HBT);//初始化堆为空
voidClearHeap(HeapType&HBT);//清除堆,使之变为空
boolEmptyHeap(HeapType&HBT);//判断堆是否为空
voidInsertHeap(HeapType&HBT,ElemTypeitem);//向堆插入元素
ElemTypeDeleteHeap(HeapType&HBT);//从堆删除堆顶元素并返回
endHEAP
section6.2.3堆存储结构
堆同一般二叉树一样既可采用顺序存储,也可采用链接存储。但由于堆一棵完全二
叉树,所以适宜采用顺序存储,这样能够充分利用其存储空间。
对堆进行顺序存储时,首先要对堆所有结点进行编号,然后再以编号下标存储到指定数组对应元素。为了利用数组0号元素,堆中结点编号0而不是1开始,当然编号次序仍然按照从上到下、同一层从左到右进行,若堆含有n个结点,则编号范围0simn-1。
堆中结点0开始编号后,编号0至lfloorn/2rfloor-1结点分支结点,编号lfloorn/2rfloorsimn-1结点叶子结点;当n奇数则每个分支结点既有左孩子又有右孩子,当n偶数则编号最大分支结点只有左孩子没有右孩子;对于每个编号i分支结点,其左孩子结点编号2i+1,右孩子结点编号2i+2;除编号0堆顶结点外,对于其余编号i结点,其双亲结点编号lfloor(i-1)/2rfloor。
对于图6-4所示堆,对应顺序存储结构,如图6-5所示。beginarray|c|c|c|c|c|c|c|c|c|c|hline0&1&2&3&4&5&6&7&8&9hline18&26&35&73&48&60&&&&hlineendarray(a)图6-4(a)存储结构beginarray|c|c|c|c|c|c|c|c|c|c|hline0&1&2&3&4&5&6&7&8&9hline74&53&42&25&36&35&20&18&22&hlineendarray(b)图6-4(b)存储结构
图6-5堆顺序存储结构
根据此存储结构可以验证给出双亲左、右孩子结点之间下标关系。
当堆采用顺序存储结构时,需要定义元素类型ElemType、长度MaxSize数组来存储堆中所有元素,还需要定义整型变量,用以存储堆长度,即堆当前包含结点数。设存储堆元素数组名用heap表示,存储堆长度变量名用len表示,并且把它们连同存储空间大小MaxSize一起定义结构类型,结构类型名用Heap表示,则该类型定义:
structHeap
ElemTypeheap;//定义指向动态数组空间指针
intlen;//定义保存堆长度变量
intMaxSize;//用于保存初始化时所给动态数组空间大小
;
6.2.4堆运算
堆抽象数据类型列出每一种操作具体算法描述如下。对于插入删除算法将以小根堆为例给出,当为大根堆时只是相应条件比较操作符不同,其余都相同。
1.初始化堆
voidInitHeap(Heap&HBT)//置HBT空堆
HBT.MaxSize=10;//初始定义数组长度10,以后可增减
HBT.heap=newElemType[HBT.MaxSize];//动态分配存储堆数组空间
if(!HBT.heap)
cout<<"用于动态分配内存空间用完,退出运行!"<<endl;
exit(1);
HBT.len=0;//设置len域初值0
2.清除堆
voidClearHeap(Heap&HBT)//清除HBT,使之成为空堆
if(HBT.heap!=NULL)
delete[]HBT.heap;
HBT.heap=NULL;
HBT.len=0;
HBT.MaxSize=0;
3.检查堆是否为空
boolEmptyHeap(Heap&HBT)//判断HBT是否为空,返真,否返假
returnHBT.len==0;
4.向堆插入元素
向堆插入元素时,首先将该元素写入到堆尾,即堆最后元素后面,亦即下标len位置上,然后经调整新堆。由于原有堆上插入新元素后,可能使以该元素为根子树不堆,从而使整个树不为堆,所以必须进行调整使之仍堆。调整方法很简单,若新元素小于双亲结点值,就让它们互换位置;新元素换到双亲位置后,使得以该位置为根子树成为堆,但新元素可能还小于此位置双亲结点值,从而使以上一层双亲结点为根子树不堆,还需要按上述方法继续调整,这样持续传递上去,直到以新位置双亲结点为根子树仍堆或者调整到堆顶为止,此时得到整个树又成为堆。
对于图6-4(a)所示堆,若向它插入新元素50时,由于它不小于双亲结点值35,所以以35为根子树仍堆,从而使整个二叉树仍然堆,此次插入不需要作任何调整。插入新元素50后得到堆,如图6-6(a)所示。
(a)插入50
(b)插入30
(c)插入15
图6-6堆插入
对于图6-4(a)所示堆,若向它插入新元素30,由于它小于双亲结点值35,所以需要将30与35对调位置,对调后因新元素30不小于其双亲元素18,所以调整结束,得到整个二叉树堆,插入结果如图6-6(b)所示。
对于图6-4(a)所示堆,若向它插入新元素15,由于它小于双亲元素35,所以需要将15与35对调位置,对调后因新元素15小于其双亲元素18,所以又需要将15与18对调位置,此时新元素调整到堆顶位置,所以调整结束,得到插入后结果如图6-6(c)所示。
向堆插入元素算法描述如下。
voidInsertHeap(Heap&HBT,ElemTypeitem)//向小根堆HBT插入元素
//堆满时重分配大一倍存储空间并进行相应操作
if(HBT.len==HBT.MaxSize)
intk=sizeof(ElemType);
HBT.heap=(ElemType)realloc(HBT.heap,2HBT.MaxSizek);//计算每个元素存储空间长度
//堆动态存储空间扩展原来2倍,原内容自动保持不变
if(HBT.heap==NULL)
cout<<"动态可分配存储用完,退出运行!"<<endl;
exit(1);
HBT.MaxSize=2HBT.MaxSize;//把堆空间大小修改新长度
//用i指向待调整元素位置,初始指向新元素所在堆尾位置
inti=HBT.len;
//寻找新元素最终位置,每次使双亲元素下移一层
while(i!=0)
intj=(i-1)/2;//j指向下标i元素双亲元素
if(item>=HBT.heap[j])break;//比较调整结束退出循环
HBT.heap[i]=HBT.heap[j];//双亲元素下移
i=j;//改变调整元素位置其双亲位置
//把新元素调整到最终位置,并使堆长度增1
HBT.heap[i]=item;
HBT.len++;
此算法运行时间主要取决于while循环执行次数，它等于新元素向双亲位置逐层上移次数，此次数最多等于整个树深度减1，所以算法时间复杂度O(logn)，其中n表示堆大小。
5.从堆删除元素
从堆删除元素就是删除堆顶元素并使之返回。堆顶元素删除后，留下堆顶位置应由堆尾元素来填补，这样既保持顺序存储结构又不需要移动其他任何元素。把堆尾元素素移动到堆顶位置后，它可能不小于左、右孩子结点，使整个二叉树不为堆，所以需要调整过程，使之变为含有n-1个元素堆（删除前为n个元素）。调整过程首先树根结点开始，若树根结点值大于两个孩子结点最小值，就将它与具有最小值孩子结点互换位置，使得根结点值小于两个孩子结点值；原树根结点对调到孩子位置后，可能使以该位置为根子树又不堆，因而又需要使新元素向孩子一层调整，如此调整下去，直到以调整后位置为根子树成为堆或调整到叶子结点为止。
对于图6-4(a)所示堆，当从中删除顶点元素18时，需要把堆尾元素60写入到堆顶位置成为堆顶元素，由于60大于两个孩子最小值26，所以应互换6026位置，60移到新位置后，又大于两个孩子最小值48，所以接着同48互换位置，此时60已调整到叶子结点，所以调整完成后得到完全二叉树又成为堆，如图6-7所示。
![image](attachment://figure_6_7.png)
图6-7堆删除
若图6-4(a)所示堆顶元素不是60而是45，则进行删除操作时把45写入到堆顶位置后，因45大于两个孩子最小值26，所以需把它对调到左孩子26位置，此时它小于两个孩子最小值48，表明以45所在新位置为根子树已经成为堆，至此调整结束。
从堆删除元素算法描述如下。
```
ElemTypeDeleteHeap(Heap&HBT)//从小根堆HBT删除堆顶元素并返回
if(HBT.len==0)//若为空堆，则显示出错误信息并退出运行
cerr<<"堆为空，退出运行!"<<endl;
exit(1);
ElemTypetemp=HBT.heap[0];//将堆顶元素暂存temp以便返回
HBT.len--;//堆长度减1
if(HBT.len==0)returntemp;//若删除操作后变为空堆则返回
ElemTypex=HBT.heap[HBT.len];//将待调整堆尾元素暂存x
inti=0;//用i指向待调整元素位置，初始指向堆顶位置
intj=1;//用j指向i左孩子位置，初始指向下标1位置
while(j<=HBT.len-1)//寻找待调整元素最终位置
//若右孩子存在并且较小，应使j指向右孩子
if(j<HBT.len-1&&HBT.heap[j]>HBT.heap[j+1])j++;
```
//若条件成立则调整结束，退出循环
if(x<=HBT.heap[j])break;
//孩子元素上移到双亲位置
HBT.heap[i]=HBT.heap[j];
//使ij分别指向下一层结点
i=j;j=2i+1;
HBT.heap[i]=x;//把待调整元素放到最终位置
returntemp;//返回原堆顶元素
此算法运行时间主要取决于while循环执行次数，它等于堆顶新元素向孩子位置逐层下移次数，此次数最多等于整个树深度减1，所以堆删除算法时间复杂度同插入算法相同，均O(logn)。
解决实际问题时，若每次只需要取出（即删除）具有最小值元素，则适合采用堆这种数据结构，因为其插入删除元素时间复杂度均O(logn)。若采用线性表来实现这种功能，其插入删除元素时间复杂度将均O(n)。
计算机操作系统，管理共享资源就需要使用堆，把等待使用该资源所有用户按照优先级号组织起来，优先级最高用户一定处于堆首位置，系统每次这个堆中取出(删除)堆顶元素并之服务，需要使用该资源新用户加入到等待使用该资源堆。
使用堆完整程序如下，请读者阅读分析。
include<iostream.h>
include<stdlib.h>
typedefintElemType;//定义元素类型整型
structHeap
ElemTypeheap;//定义堆顺序存储类型
intlen;
intMaxSize;
;
include"堆运算.cpp"//假定heap.cpp保存着堆运算各种算法
voidmain()
inta[8]=23,56,40,62,38,55,10,16;
Heapb;//定义堆b
InitHeap(b);//初始化堆b
inti,x;
//向堆b依次插入数组a每元素
for(i=0;i<8;i++)InsertHeap(b,a[i]);
//按下标位置依次输出堆中每个元素
for(i=0;i<7;i++)cout<<b.heap[i]<<',';
cout<<b.heap[7]<<endl;
//依次删除堆顶元素并显示出来，直到堆空为止
while(!EmptyHeap(b))
x=DeleteHeap(b);
cout<<x;
if(!EmptyHeap(b))cout<<',';
cout<<endl;
ClearHeap(b);
请通过堆图示操作过程验证下面运行结果正确性。
10,16,23,38,56,55,40,62
10,16,23,38,40,55,56,62
section6.3哈夫曼树
subsection6.3.1基本术语
1.路径路径长度
一棵树存在着结点序列k_1,k_2,cdots,k_j，使得k_ik_i+1双亲(1leqi<j)，则称此结点序列是从k_1到k_j路径，因树中每个结点只有双亲结点，所以它也这两个结点之间唯一路径。k_1到k_j所经过分支数称为这两点之间路径长度，它等于路径上结点数减1。图6-3(a)所示二叉树，树根结点L到叶子结点P路径结点序列L,M,S,P，路径长度3。
2.结点权带权路径长度
许多应用，常常将树结点赋上有着某种意义实数，称此实数该结点权。结点带权路径长度规定树根结点到该结点之间路径长度与该结点上权乘积。
3.树带权路径长度
树带权路径长度定义为树中所有叶子结点带权路径长度之，通常记：textWPL=sum_i=1^nw_il_i
其中，n表示叶子结点数目，w_il_i分别表示叶子结点k_i权值树根结点到k_i之间路径长度。
4.哈夫曼树
哈夫曼树（Huffmantree）又称做最优二叉树。它n个带权叶子结点构成所有二叉树，带权路径长度WPL最小二叉树。因为构造这种树算法最早由哈夫曼于1952年提出，所以称为哈夫曼树。
，有4个叶子结点a,b,c,d，分别带权9,4,5,2，由它们构成三棵不同二叉树（当然还有其他许多种）分别如图6-8(a)~图6-8(c)所示。
(a)带权二叉树之一
(b)带权二叉树之二
(c)带权二叉树之三
图6-8由四个叶子结点构成三棵不同带权二叉树
每一棵二叉树带权路径长度WPL分别：
①WPL=9times2+4times2+5times2+2times2=40；
②WPL=4times1+2times2+5times3+9times3=50；
③WPL=9times1+5times2+4times3+2times3=37。
其中，③树WPL最小，稍后便知，此树就是哈夫曼树。
因此，n个带权叶子结点所构成二叉树，满二叉树或完全二叉树不一定最优二叉树。权值越大结点离树根越近二叉树才最优二叉树。
section6.3.2构造哈夫曼树
构造最优二叉树算法具体叙述如下。
(1)根据与n个权值w_1,w_2,cdots,w_n对应n个结点构成具有n棵二叉树森林F=T_1,T_2,cdots,T_n其中，每棵二叉树T_i(1leqileqn)都只有权值w_i根结点，其左、右子树均空。
(2)森林F选出两棵根结点权值最小树作为一棵新树左、右子树，且置新树根结点权值其左、右子树上根结点权值之。
(3)F删除构成新树那两棵树，同时把新树加入F。
(4)重复(2)(3)步，直到F只含有一棵树为止，此树便是哈夫曼树。
若仍采用图6-84个带权叶子结点来构造一棵哈夫曼树，按照上述算法，则构造过程如图6-9所示，其中图6-9(d)就是最后生成哈夫曼树，它带权路径长度37，由此可知，图6-8(c)一棵哈夫曼树。
(a)四棵树
(b)三棵树
(c)两棵树
(d)一棵树
图6-9构造哈夫曼过程
构造哈夫曼树过程,当每次由两棵权值最小树生成一棵新树时,新树左子树右子树可以任意安排,这样将会得到具有不同结构多个哈夫曼树,但它们都具有相同带权路径长度。为了使得到哈夫曼树结构尽量唯一,通常规定生成哈夫曼树中每个结点左子树根结点权小于等于右子树根结点权。上述哈夫曼树构造过程就是依照这一规定进行。
根据上述构造哈夫曼树方法可以写出相应用C++语言描述算法如下。
BTreeNodeCreateHuffman(ElemTypea[],intn)
//根据数组an个权值建立一棵哈夫曼树,返回树根指针
BTreeNodeb,q;
//动态分配由b指向指针数组
b=newBTreeNode[n];
inti,j;
//初始化b指针数组,使每个指针元素指向a数组对应元素结点
for(i=0;i<n;i++)
b[i]=newBTreeNode;
b[i]->data=a[i];b[i]->left=b[i]->right=NULL;
//进行n-1次循环建立哈夫曼树
for(i=1;i<n;i++)
//用k1表示森林具有最小权值树根结点下标
//用k2表示森林具有次最小权值树根结点下标
intk1=-1,k2;
//让k1初始指向森林第一棵树,k2初始指向森林第二棵树
for(j=0;j<n;j++)
if(b[j]!=NULL&k1==-1)k1=j;continue;
if(b[j]!=NULL)k2=j;break;
//当前森林中求出最小权值树和次最小权值树
for(j=k2;j<n;j++)
if(b[j]!=NULL)
if(b[j]->data<b[k1]->data)k2=k1;k1=j;
elseif(b[j]->data<b[k2]->data)k2=j;
//由最小权值树和次最小权值树建立一棵新树，q指向树根结点
q=newBTreeNode;
q->data=b[k1]->data+b[k2]->data;
q->left=b[k1];q->right=b[k2];
//将指向新树指针赋给b指针数组k1位置，k2位置为空
b[k1]=q;b[k2]=NULL;
//删除动态建立数组b
delete[]b;
//返回整个哈夫曼树树根指针
returnq;
一颗哈夫曼树生成过程，每次都由两棵子树构成一棵树，对于n个叶子结点共需要构成n-1棵子树。所以，一棵哈夫曼树中只存在双支结点叶子结点，若叶子结点n个，则双支结点必为n-1个。
根据哈夫曼树求出带权路径长度算法如下。
ElemTypeWeightPathLength(BTreeNodeFBT,intlen)
//根据FBT指针所指向哈夫曼树求出带权路径长度，len初值0
if(FBT==NULL)return0;//空树则返回0
else
//访问到叶子结点时返回该结点带权路径长度，其中值参len
//保存当前访问结点路径长度
if(FBT->left==NULL&&FBT->right==NULL)
returnFBT->datalen;
//访问到非叶子结点时进行递归调用，返回左、右子树带权
//路径长度之，向下深入一层时len值增1
else
returnWeightPathLength(FBT->left,len+1)+
WeightPathLength(FBT->right,len+1);
section6.3.3哈夫曼编码
哈夫曼树应用很广,哈夫曼编码就是其中一种,下面简要介绍。
电报通信,电文以二进制0、1序列传送。发送端需要将电文字符序列转换成二进制0、1序列（即编码），接收端又需要把接收到0、1序列转换成对应字符序列（即译码）。
最简单二进制编码方式长编码。若电文只使用A、B、C、D、E、F这6种字符，若进行长编码，则需要二进制三位，可依次编码000、001、010、011、100、101。若用这6个字符作为6个叶子结点，生成一棵二叉树，让该二叉树每个分支结点左、右分支分别用01编码，树根结点到每个叶子结点路径上所经分支0、1编码序列应等于该叶子结点二进制编码，则对应编码二叉树，如图6-10所示。
![A](A)[B](B)[C](C)[D](D)[E](E)[F](F)
图6-10编码二叉树
通常，电文每个字符出现频率（即次数）一般不同。一份电文，这6个字符出现频率依次：4、2、6、8、3、2，则电文编码后总长度L可由下式计算：L=sum_i=1^nc_il_i其中，n表示电文使用字符数，c_il_i分别表示对应字符k_i电文出现频率编码长度。因此，可求出L：L=sum_i=1^6left(c_itimes3right)=3times(4+2+6+8+3+2)=75可知，采用长编码时，传送电文总长度75。
那么，如何能缩短传送电文总长度，从而节省传送时间呢？若采用不等长编码，让出现频率高字符具有较短编码，让出现频率低字符具有较长编码，这样有可能缩短传送电文总长度。采用不等长编码要避免译码二义性或多义性。假设用0表示字符D，用01表示字符C，则当接收到编码串…01…，并译到字符0时，立即译出对应字符D，还是接着与下字符1一起译对应字符C，这就产生二义性。因此，若对某一字符集进行不等长编码，则要求字符集任一字符编码都不能其他字符编码前缀。符合此要求编码叫做无前缀编码。显然长编码无前缀编码，这长编码所对应编码二叉树也可直观地看出，任一叶子结点都不可能其他叶子结点双亲，也就是说，只有当结点另结点双亲时，该结点字符编码才会另结点字符编码前缀。
为了使不长编码成为无前缀编码，可用该字符集每个字符作为叶子结点生成一棵编码二叉树。为了获得传送电文最短长度，可将每个字符出现频率作为字符结点权值赋予该结点上，求出此树最小带权路径长度就等于求出传送电文最短长度。因
此，求传送电文最短长度问题就转化为求由字符集所有字符作为叶子结点，由字符出现频率作为其权值所产生哈夫曼树问题。
由上例生成编码哈夫曼树如图6-11所示。由编码哈夫曼树得到字符编码称作哈夫曼编码。其中，A、B、C、D、E、F这6个字符哈夫曼编码依次：00,1010,01,11,100,1011。电文最短传送长度：L=WPL=sum_i=1^6w_il_i
=4times2+2times4+6times2+8times2+3times3+2times4
=61显然，计算结果比等长编码所得到传送电文总长度75要小得多。
对求哈夫曼树带权路径长度算法略加修改，就可以得到求哈夫曼编码算法。具体如下。
voidHuffManCoding(BTreeNodeFBT,intlen)
//根据FBT指针所指向哈夫曼树输出每个叶子编码，len初值0
staticinta[10];//数组长度要至少等于哈夫曼树深度减1
if(FBT!=NULL)
//访问到叶子结点时输出其保存数组a01序列编码
if(FBT->left==NULL&&FBT->right==NULL)
cout<<"结点权值"<<FBT->data<<"编码:";
for(inti=0;i<len;i++)cout<<a[i]<<'';
cout<<endl;
//访问到非叶子结点时分别向左、右子树递归调用，并分别把分支上0、1编码保存到数组a对应元素，向下深入一层时len值增1
else
a[len]=0;HuffManCoding(FBT->left,len+1);
a[len]=1;HuffManCoding(FBT->right,len+1);
采用如下程序调试对哈夫曼树算法。
include<iostream.h>
include<stdlib.h>
typedefintElemType;
structBTreeNode
ElemTypedata;
```cpp
BTreeNodeleft;
BTreeNoderight;
;
include"二叉树运算.cpp"
//根据数组an个权值建立一棵哈夫曼树，返回树根指针
BTreeNodeCreateHuffman(ElemTypea[],intn);//补充函数定义
//根据FBT指针所指向哈夫曼树求出带权路径长度，len初值0
ElemTypeWeightPathLength(BTreeNodeFBT,intlen);//补充函数定义
//根据FBT指针所指向哈夫曼树输出每个叶子编码，len初值0
voidHuffManCoding(BTreeNodeFBT,intlen);//补充函数定义
voidmain()
intn,i;
BTreeNodefbt=NULL;
//输入哈夫曼树中叶子结点数
cout<<"输入待构造哈夫曼树中带权叶子结点数n:";
cin>>n;
//用数组a保存键盘输入n个叶子结点权值
ElemTypea=newElemType[n];
cout<<"输入"<<n<<"个整数作为权值:";
for(i=0;i<n;i++)cin>>a[i];
//根据数组a建立哈夫曼树
fbt=CreateHuffman(a,n);
//以广义表形式输出哈夫曼树
cout<<"广义表形式哈夫曼树:";
PrintBTree(fbt);
cout<<endl;
//输出哈夫曼树权值，即带权路径长度
cout<<"哈夫曼树权:";
cout<<WeightPathLength(fbt,0)<<endl;
//输出哈夫曼编码，即每个叶子结点所对应0,1序列
cout<<"树中每个叶子哈夫曼编码:"<<endl;
HuffManCoding(fbt,0);
ClearBTree(fbt);
程序一次运行结果如下。
输入待构造哈夫曼树中带权叶子结点数n:6
输入6个整数作为权值:39512615
广义表形式哈夫曼树:50(21(9,12),29(14(6,8(3,5)),15))
哈夫曼树权:122
```
树中每个叶子哈夫曼编码:
结点权值9编码:00结点权值12编码:01结点权值6编码:100结点权值3编码:1010结点权值5编码:1011结点权值15编码:116.4线索二叉树
subsection6.4.1二叉树线索化
对二叉树进行某种遍历得到结点序列,可以看作线性表。该线性表,除第一个结点外,每个结点有且仅有前驱,除最后结点外,每个结点有且仅有后继。为了同二叉树所具有结点前驱(即双亲)后继(即孩子)区别开来,容易混淆地方,通常把遍历序列结点前驱或后继冠以某种遍历名称,把中序序列结点前驱称作中序前驱,结点后继称作中序后继。对于如图6-12所示二叉树,中序遍历结点序列B、G、D、A、E、H、C、F,其中B结点中序遍历得到线性序列表头结点,它没有前驱,其中序后继G结点,A结点中序前驱D结点,中序后继E结点。
对于一棵具有n个结点二叉树,对应二叉链表中共有2n个指针域,其中n-1个用于指向除树根结点以外其余n-1个结点,另有n+1个指针域空闲着。若把每个结点中空着左指针域右指针域用于分别指向某种遍历次序前驱结点后继结点,则遍历这种二叉树时,可由此信息直接找到该遍历次序下前驱结点或后继结点,从而比递归遍历提高遍历速度、节省建立系统栈所使用存储空间。这种结点空指针域存放该结点某次遍历次序下前驱结点或后继结点指针叫做线索(thread),其中空左指针域存放指向其前驱结点指针叫做左线索或前驱线索,空右指针域存放指向其后继结点指针叫做右线索或后继线索。对一棵二叉树所有结点空指针域按照某种遍历次序加线索过程叫做线索化,线索化二叉树称做线索二叉树。如图6-12(b)所示对图6-12(a)二叉树加中序线索而得到中序线索二叉树。
n
(a)二叉树
(b)加中序线索后二叉树
图6-12中序线索二叉树
线索二叉树，为了区别各个结点左、右指针域所存放孩子指针，或是线索，必须结点结构增加两个线索标志域，左线索标志域，用ltag表示，另右线索标志域，用rtag表示。ltagrtag只需取两种值，以区别其对应指针域保存孩子指针，或是线索，取真时指向线索，取假时指向孩子。
增加线索标志域后二叉树结点结构如下。
|Left|ltag|data|rtag|right|
该结点结构类型定义:
structTTreeNode
ElemTypedata;//值域
boolltag,rtag;//线索标志域
TTreeNodeleft;//左指针域
TTreeNoderight;//右指针域
;
如图6-13所示图6-12中序线索二叉树链接存储结构。
![图6-13索引二叉树链接存储结构]
对一棵结点类型TTreeNode二叉树进行线索化时，该二叉树初始状态应为：每个结点线索标志域均假（0），若结点有左孩子或右孩子，则相应指针域指向孩子，否则为空，以便线索化过程加入线索。
对一棵二叉树进行某种遍历次序线索化，显然就是对该二叉树进行这种遍历过程，只不过访问根结点时，不是简单地打印根结点值，而是对指针域空结点加线索，具体做法如下。
(1)若前驱结点不为空，或者说当前结点不是序列第1个结点，同时前驱结点右线索标志域真（表示此结点右指针域空）时，则将当前结点指针赋给前驱结点右指针域，即给前驱结点加右线索。
(2)若当前结点左指针域空，则将左线索标志域置真，同时把前驱结点指针赋给当前结点左指针域，即给当前结点加左线索。
(3)若当前结点右指针域空，则将右线索标志域置真，以便当访问到下（即后继）结点时，给它加右线索。
(4)将当前结点指针赋给保存前驱结点指针变量，以便当访问下结点时，此当前结点成为前驱结点。
设pre用来保存前驱结点指针引用参数，初始为空；设HBT用来保存当前结点指针值参，初始指向待线索化一棵二叉树根结点，下面给出对二叉树进行中序线索化即建立中序线索算法，它中序遍历算法基础上改造而成。
voidInThread(TTreeNodeHBT,TTreeNode&pre)
//对二叉树HBT加中序线索
if(HBT!=NULL)
if(HBT->ltag==false)
InThread(HBT->left,pre);//左子树非空时给左子树加中序线索
if(pre!=NULL&&pre->rtag==true)
pre->right=HBT;//给前驱结点加后继线索
if(HBT->left==NULL)
HBT->ltag=true;
HBT->left=pre;//给当前结点加前驱线索
if(HBT->right==NULL)
HBT->rtag=true;//给右指针域空结点加右线索标记
pre=HBT;//把刚访问当前结点置前驱结点
if(HBT->rtag==false)
InThread(HBT->right,pre);//右子树非空时给右子树加中序线索
对二叉树进行中序线索化算法，若把对左子树加线索条件语句放到对右子树加线索条件语句之上，则得到前序线索化算法，所建立线索前序线索；若把对右子树加线索条件语句放到对左子树加线索条件语句之下，则得到后序线索化算法，所建立线索后序线索。
若该函数不使用pre参数，也可以函数体开始位置加上如下语句替代。
staticTTreeNodepre=NULL;
利用下面算法向带线索标志域二叉搜索树插入元素，但不进行中序线索链接。
voidInsertThreed(TTreeNode&HBT,constElemType&item)
//向带线索二叉搜索树插入元素，但不链接线索
if(HBT==NULL)
TTreeNodep=newTTreeNode;
p->data=item;
p->left=p->right=NULL;
p->ltag=p->rtag=0;
HBT=p;
elseif(item<HBT->data)//向左子树中插入元素
InsertThreed(HBT->left,item);
else
InsertThreed(HBT->right,item);
利用下面算法建立带线索标志域二叉搜索树，但不进行中序线索链接。
voidCreateThreed(TTreeNode&HBT,ElemTypea[],intn)
HBT=NULL;
for(inti=0;i<n;i++)
InsertThreed(HBT,a[i]);
带线索标志域二叉搜索树建立后，随时可以调用InThread算法，建立其中序线索。若要向带线索二叉搜索树中插入结点，并且要进行实际线索链接，则应采用下面插入算法。
voidInsertThreed1(TTreeNode&HBT,constElemType&item)
//向带线索二叉搜索树插入元素，并进行线索链接
//新结点寻找插入位置
TTreeNodet=HBT,parent=NULL;
while(t!=NULL)
parent=t;
if(item<t->data)
if(t->ltag==false)t=t->left;elset=NULL;
else
if(t->rtag==false)t=t->right;elset=NULL;
//建立值为item新结点
TTreeNodep=newTTreeNode;
p->data=item;
p->ltag=p->rtag=true;//叶子结点左、右孩子指针均线索
//将新结点插入到线索二叉搜索树HBT
if(parent==NULL)
p->left=p->right=NULL;//作为树根结点插入
HBT=p;
elseif(item<parent->data)
p->left=parent->left;//作为左孩子结点插入
parent->ltag=false;//置双亲左线索标志域假
parent->left=p;//新结点链接双亲左孩子
p->right=parent;//双亲结点成为新结点后继
else
p->right=parent->right;//作为右孩子结点插入
parent->rtag=false;//置双亲右线索标志域假
parent->right=p;//新结点链接双亲右孩子
p->left=parent;//双亲结点成为新结点前驱
parent->rtag=false;//置双亲右线索标志域假
parent->right=p;//新结点链接双亲右孩子
p->left=parent;//双亲结点成为新结点前驱
利用InsertThread1算法建立一棵带线索二叉搜索树算法如下。
voidCreateThread1(TTreeNode&HBT,ElemTypea[],intn)
//利用数组n个元素建立带线索二叉搜索树算法
HBT=NULL;
for(inti=0;i<n;i++)
InsertThread1(HBT,a[i]);
section6.4.2利用线索进行遍历
以中序线索例来讨论这个问题。首先讨论一下如何中序线索二叉树上寻找结点p（即指针p所指向结点）中序后继结点，它分为如下两种情况。
(1)若p结点右线索标志域真，则表明p->right右线索，它直接指向p中序后继结点。
(2)若p右线索标志域假，则表明p->right指向右孩子结点，p中序后继结点必是其右子树中第一个中序遍历到结点，因此p右孩子开始，沿左指针链往下查找，直到找到没有左孩子（即左线索标志域1）结点为止，该结点p右子树中“最左下”结点，它就是p中序后继结点。如图6-14所示，p中序后继结点R_k(kgeq1)，R_k可能叶子结点，也可能只含有右子树单支结点；另外，若k=1，则表示p右孩子R_1p中序后继结点。
(a)二叉树表示
(b)二叉链表表示
图6-14求中继后继结点示意图
根据以上分析，给出中序线索二叉树上求结点p中序后继算法如下。
TTreeNodeInorderNext(TTreeNodep)//返回p结点中继后继结点
if(p->rtag==true)
returnp->right;
else
p=p->right;
while(p->ltag==false)p=p->left;
returnp;
有求中序后继结点算法，就不难写出中序线索二叉树上进行中序遍历算法。此算法可叙述：首先从根结点起沿左指针链往下查找，直到找到左线索标志域真的结点为止，该结点左指针域必为空，它就是整个中序序列第一个结点；然后打印该结点，接着利用上述求中序后继结点算法得到下结点，以此类推，直到中序后继结点为空时止。
设HBT具有TTreeNode指针类型值参，初始指向一棵中序线索二叉树根结点，则对此树进行中序遍历算法可描述如下。
voidThInorder(TTreeNodeHBT)//按中序线索遍历二叉树HBT
if(HBT!=NULL)
while(HBT->ltag==false)
HBT=HBT->left;//查找出中序遍历第一个结点
do
cout<<HBT->data<<'';//输出结点值
HBT=InorderNext(HBT);//查找出HBT结点中序后继结点
while(HBT!=NULL);//当HT空时算法结束
利用线索进行二叉树遍历时间复杂度O(n)，空间复杂度O(1)。实际运行时间要少于不加线索情况。
以广义表形式输出一棵线索二叉树算法如下。
voidPrintTTreel(TTreeNodeHBT)
if(HBT!=NULL)
cout<<HBT->data;//输出根结点值
if(HBT->ltag==false||HBT->rtag==false)
cout<<'(';//输出左括号
if(HBT->ltag==false)
PrintTTreel(HBT->left);//输出左子树
if(HBT->rtag==false)
cout<<',';//若右子树不为空则首先输出逗号分隔符
PrintTTreel(HBT->right);//输出右子树
cout<<(')');//输出右括号
利用下面程序调试上述每个算法。
include<iostream.h>
include<stdlib.h>
typedefintElemType;//定义二叉树结点值类型整型
structTTreeNode
ElemTypedata;//值域
boolltag,rtag;//线索标志域
TTreeNodeleft;//左指针域
TTreeNoderight;//右指针域
;
include"线索二叉树运算.cpp"
voidmain()
TTreeNodehbt=NULL,pre=NULL,hbt1=NULL;
ElemTypea[10]=30,50,20,40,25,70,54,23,80,92;
CreateThreed(hbt,a,10);
InThread(hbt,pre);
PrintTTree1(hbt);cout<<endl;
cout<<"中序:";ThInorder(hbt);cout<<endl;
CreateThreed1(hbt1,a+3,7);
PrintTTree1(hbt1);cout<<endl;
cout<<"中序:";ThInorder(hbt1);cout<<endl;
该程序运行结果如下:
30(20(,25(23)),50(40,70(54,80(,92))))中序:2023253040505470809240(25(23),70(54,80(,92)))中序:232540547080926.5平衡二叉树
平衡二叉树（balancedbinarytree）对二叉搜索树一种改进。二叉搜索树有缺陷，那就是树结构事先无法预料，随机性很大，它只与结点值插入次序有关，往往得到一棵很不“平衡”二叉树，即树高度与相同结点数理想平衡树相差甚远，最坏情况下，有可能变为一棵单支二叉树，其高度与结点数相同，相当于单链表，对其运算时间复杂度由正常O(logn)变为O(n)，从而部分或全部地丧失利用二叉搜索树组织数据优点。为了克服二叉搜索树这个缺陷，需要插入删除结点时对树结构进行必要调整，使二叉搜索树结构始终处于一种较平衡状态，当然它没有理想平衡树那样绝对平衡。若要使二叉搜索树调整成理想平衡树那样结构，将会使调整运算变得很复杂，使调整带来好处得不偿失。
subsection6.5.1平衡二叉树定义
平衡二叉树简称平衡树，由阿德尔森-维尔斯基兰迪斯（Adelson-VelskiiandLandis）于1962年首先提出，所以又称为AVL树。若一棵二叉树每个结点左、右子树高度至多相差1，则称此树为平衡。把二叉树每个结点左子树高度减去右子树高度定义该结点平衡因子（balancefactor）。因此，平衡树中每个结点平衡因子只能1、0或-1。如图6-15(a)所示一棵平衡二叉树，如图6-15(b)图6-15(c)所示分别一棵非平衡树，每个结点上方所标数字该结点平衡因子。
n
(a)平衡二叉树
(b)非平衡二叉树例1
(c)非平衡二叉树例2
图6-15带平衡因子二叉树
虽然平衡树平衡性比理想平衡树要差一些，但理论上已经证明：具有n个结点平衡树高度任何情况下决不会比具有相同结点数理想平衡树高出45%以上。因此，平衡树上进行查找运算虽比理想平衡树要慢一些，但通常比任意生成二叉排序树快得多，当然，其时间复杂度数量级表示仍为O(logn)。
当向一棵平衡树插入新结点时，插入后，某些结点左、右子树高度不变，就不会影响这些结点平衡因子，因而也不会因为这些结点造成不平衡；若插入后某些结点左子树高度增加1（右子树高度增加1情况与之类似），则就影响这些结点平衡因子，具体分为如下3种情况。
(1)若插入前一部分结点左子树高度h_L与右子树高度h_R相等，即平衡因子0，则插入后将使平衡因子变为1，但仍符合平衡条件，不必对它们加以调整。
(2)若插入前一部分结点h_L小于h_R，即平衡因子-1，则插入后将使平衡因子变为0，平衡更加改善，不必对它们进行调整。
(3)若插入前一部分结点h_L大于h_R，即平衡因子1，则插入后将使平衡因子变为2，破坏平衡树限制条件，需对它们加以调整，使整个二叉排序树恢复平衡树。
若插入后，某些结点右子树高度增加1，则也分为相应3种情况，对于第1种情况，平衡因子将由0变为-1，不必进行调整；对于第2种情况平衡因子由-1变为-2，则必须对它们进行调整；对于第3种情况平衡因子由1变为0，平衡更加改善，也不必进行调整。
向平衡树中插入结点后破坏其平衡性，首先要找出最小不平衡子树，然后再调整这个子树中有关结点之间链接关系，使之成为新平衡子树。当然，调整前后该子树二叉搜索树性质不变，即调整前后得到中序序列要完全相同。稍后便知，最小不平衡子树调整平衡子树后，原有其他所有不平衡子树无需调整，整个二叉搜索树就又成为一棵平衡树。
所谓最小不平衡子树指以离插入结点最近、且平衡因子绝对值大于1结点做根子树。图6-15(b)，以值30结点做根子树该树最小不平衡子树，分别以2036做根不平衡子树不是最小不平衡子树；图6-15(c)，以值32结点做根子树该树最小不平衡子树，当然它也唯一不平衡子树。
section6.5.2平衡二叉树调整
为了便于讨论，不妨设最小不平衡子树根结点用A表示，则调整该子树操作可归纳下列4种。
section1.LL型调整操作
A结点左孩子（用B表示）左子树上插入结点，使得A结点平衡因子由1变为2而引起不平衡所进行调整操作。调整过程如图6-16所示，图中用长方框表示子树，用长方框高度表示子树高度，用带阴影小方框表示插入结点。图6-16(a)插入前平衡子树，alpha、betagamma子树高度均h（hgeq0，若h=0，则它们均空树），A结点B结点平衡因子分别10。图6-16(b)B左子树alpha上插入新结点，
使以A为根子树成为最小不平衡子树情况。图6-16(c)调整后成为新平衡子树情况。调整规则：将A左孩子B向右上旋转代替A成为原不平衡子树根结点，将A结点向下旋转成为B右子树根结点，而B原右子树β则作为A结点左子树。此调整过程需要修改3个指针，如图6-16(c)箭头所示，一是将原指向结点A指针修改指向结点B；二是将B右指针修改指向结点A；三是将A左指针修改指向B原右子树根结点。另外，还需要修改AB结点平衡因子，应均置0。
(a)插入前
(b)插入后
(c)调整后
图6-16LL型调整操作示意图
从图6-16可以看出，调整前后对应中序序列相同，即αβBAγ，所以经调整后仍保持二叉搜索树特性不变。
如图6-17所示LL型搜索调整两个实例，其中，图6-17(a)、图6-17(b)、图6-17(c)一例，此处A结点9，B结点6，α、β、γ均空树；图6-17(d)、图6-17(e)、图6-17(f)另一例，此处A结点50，B结点45，α、β、γ分别只含有结点30、48、60子树。
(a)插入前
(b)插入3后
(c)LL调整后
(d)插入前
(e)插入20后
(f)LL调整后
图6-17LL调整实例
2.RR型调整操作
A结点右孩子（用B表示）右子树上插入结点，使得A结点平衡因子由-1变为-2而引起不平衡所进行调整操作，调整过程如图6-18所示。图6-18(a)插入前平衡子树，alpha、beta、gamma子树高度相同，均h(hgeq0)，A结点B结点平衡因子分别-10；图6-18(b)B结点右子树gamma上插入新结点，使以A为根子树成为最小不平衡子树情况；图6-18(c)调整后重新恢复平衡情况。调整规则：将A右孩子B向左上旋转代替A成为原最小不平衡子树根结点，将A结点向左下旋转成为B左子树根结点，而B原左子树beta则作为A结点右子树。此调整过程同LL型调整过程对称，要修改3个指针如图6-18(c)箭头所示。同样，进行RR型调整前后，仍保持着二叉搜索树特性不变。另外，插入前调整后，其子树高度均h+2，由插入所引起上层其他结点不平衡将自动消失。
(a)插入前
(b)插入后
(c)调整后
图6-18RR型调整操作示意图
3.LR型调整操作
A结点左孩子（用B表示）右子树上插入结点，使得A结点平衡因子由1变为2而引起不平衡所进行调整操作，调整过程如图6-19所示。图6-19(a)插入前平衡子树，betagamma子树高度均h(hgeq0)，alphadelta子树高度均h+1，特别地若alphadelta子树为空树时，则B结点右子树也同时为空，此时C结点将插入新结点。插入前A结点B结点平衡因子分别10，若C结点存在，则C结点平衡因子0。图6-19(b)B结点右子树上插入新结点（当B右子树为空时，则C结点，否则C左子树或右子树上带阴影结点，图中给出左子树beta上插入情况，若右子树gamma上插入，情况类似），使得以A为根子树成为最小不平衡子树情况，此处A结点B结点平衡因子按相反方向变化，而不像前两种调整操作那样，都按同一方向变化。图6-19(c)调整后情况。调整规则：将A左孩子右子树根结点C提升到A结点位置；将B结点作为C左子树根结点，而C结点原左子树beta则作为B结点右子树；将A结点作为C右子树根结点，而C结点原右子树则作为A结点左子树。此调整过程比前两种要复杂，需修改5个指针，如图6-19(c)箭头所示。
(a)插入前
(b)插入后
(c)调整后
图6-19LR型调整操作示意图
可以看出,调整前后对应中序序列相同,即为alphamathrmBbetamathrmCgammamathrmAdelta,只是链接次序不同罢了,但没有影响其二叉搜索树特性。另外，插入前调整后子树高度不改变。
如图6-20所示LR型调整操作两个实例，其中图6-20(a)、图6-20(b)、图6-20(c)一例,此处A结点9,B结点3,C结点6,它新插入结点,alpha、beta、gamma、delta均空树;图6-20(d)、图6-20(e)、图6-20(f)另一例,此处A结点85,B结点74,C结点80,alphadelta子树分别只含有结点6592,betagamma均空。
(a)插入前
(b)插入6后
(c)LR调整后
(d)插入前
(e)插入78后
(f)LR调整后
图6-20LR型调整实例
4.RL型调整操作
A结点右孩子左子树上插入结点,使A结点平衡因子由-1变为-2而引起
不平衡所进行调整操作，调整过程如图6-21所示。它同mathrmLR型调整过程对称，请读者分析调整过程。
(a)插入前
(b)插入后
(c)调整后
图6-21RL型调整操作示意图
上述每一种调整操作，以A为根最小不平衡子树高度插入结点前调整后相同，因此对其所有祖先结点平衡性不会产生任何影响，即原有平衡因子不变。故按照上述方法将最小不平衡子树调整平衡子树后，整个二叉搜索树就成为一棵新平衡树。
下面用一组关键字(46,15,20,35,28,58,18,50,54)生成一棵平衡二叉搜索树，生成过程如图6-22所示。
(a)插46(b)插15(c)插入20后LR
(d)插35(e)插入28后LL(f)插入58后RR
(g)插18(h)插入50后RL型调整(i)插54
图6-22建立平衡二叉树实例
二叉搜索树插入删除运算，采用平衡树优点：使树结构较好，从而提高查找运算速度。缺点：使插入删除运算变得复杂化，从而降低它们运算速度。每次插入或删除运算，不仅要进行插入删除结点操作，而且要检查是否存在有最小不平衡子树，若存在，则需要对最小不平衡子树中有关指针进行修改。因此，采用平衡树，适合于那种对二叉搜索树一经建立就很少进行插入删除运算，而主要进行查找运算应用场合。
对二叉搜索树删除结点而引起不平衡而进行调整操作比插入结点情况还要复杂，当调整完最小不平衡子树后，还可能引起祖先结点不平衡，还需要继续向上调整。平衡二叉树插入删除算法二叉搜索树算法基础上修改而成，比较复杂，有关这方面内容超出教学要求，故本节不做介绍。
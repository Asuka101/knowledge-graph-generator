第6章特殊二叉树
特殊二叉树包括二叉搜索树、堆、哈夫曼树、线索二叉树和平衡二叉树等，它们都有着不同的应用。本章将讨论特殊二叉树的定义、结构和运算特点。
section6.1二叉搜索树
subsection6.1.1二叉搜索树的定义
二叉搜索树（binarysearchingtree）又称二叉排序树（binarysortingtree），它或是一棵空树，或者是一棵具有如下特性的非空二叉树。
（1）若它的左子树非空，则左子树上所有结点的关键字均小于根结点的关键字。
（2）若它的右子树非空，则右子树上所有结点的关键字均大于（若允许具有相同的关键字的结点存在，则大于等于）根结点的关键字。
（3）左、右子树本身又各是一棵二叉搜索树。
在二叉搜索树中，当每个结点的元素类型为简单类型时，则结点的关键字就是该结点的值；当每个结点的元素类型为记录类型时，则结点的关键字为该结点的某一个域的值。如当元素的类型为整型时，则结点的关键字就是该结点的值即整数；当元素的类型为学生记录类型时，则每个学生的学号（即记录中的一个域）就是相应结点的关键字。在算法描述中，以结点的值的比较作为其关键字的比较，实际情况可能进行的是关键字域的比较，若在C++语言环境下运行，可通过关系操作符的重载，使其真正比较的是记录的关键字。
由二叉搜索树的定义可知，在一棵非空的二叉搜索树中，其结点的关键字是按照左子树、根和右子树有序的，所以对它进行中序遍历得到的结点序列必然是一个有序序列。
如图6-1所示是一棵二叉搜索树，树中每个结点的关键字都大于它的左子树中所有结点的关键字，而小于它的右子树中所有结点的关键字。对此树进行中序遍历得到的结点序列为：12,15,18,23,26,30,52,63,74可见此序列是一个有序序列。
begincenter
includegraphics[width=0.5textwidth]image.png
endcenter
图6-1二叉搜索树
subsection6.1.2二叉搜索树的抽象数据类型
二叉搜索树的抽象数据类型中的数据部分是一棵二叉搜索树，它可以具有同一般二叉树一样的任何存储结构，操作部分除了已经讨论过的对一般二叉树的操作外，还具有对二叉搜索树的一
些常用操作，即搜索（查找）、更新、插入和删除元素的操作。假定二叉搜索树中的结点类型为BTreeNode，指向二叉搜索树的树根结点的指针为BST，则对二叉搜索树BST的查找、更新、插入和删除元素的操作声明如下。
boolFind(BTreeNodeBST,ElemType&item);
boolUpdate(BTreeNodeBST,constElemType&item);
voidInsert(BTreeNode&BST,constElemType&item);
boolDelete(BTreeNode&BST,constElemType&item);
查找函数find从二叉搜索树BST中查找等于给定值item的元素，若查找成功则返回true，并由item带回该元素的值，否则返回false。更新函数Update从二叉搜索树BST中查找等于给定值item的元素，若查找成功则用item的值更新该元素并返回true，否则返回false。插入函数Insert向二叉搜索树BST中插入一个元素item，使得插入后仍保持为一棵二叉搜索树。删除函数Delete从二叉搜索树中删除等于给定值item的结点，若删除成功则返回true，否则返回false。
section6.1.3二叉搜索树的运算
1.查找
根据二叉搜索树的定义，查找等于给定值item的元素时，若二叉搜索树为空，则表明查找失败，应返回假。否则，若item等于当前树根结点的值，则表明查找成功，应由引用参数item带回根结点的值并返回真；若item小于根结点的值，则继续在根的左子树中查找；若item大于根结点的值，则继续在根的右子树中查找。这是一个递归查找过程，其递归算法描述如下。
boolFind(BTreeNodeBST,ElemType&item)
//从二叉搜索树中查找等于给定值item的元素
if(BST==NULL)returnfalse;//查找失败返回假
else
if(item==BST->data)//若查找成功则带回元素值并返回真
item=BST->data;
returntrue;
elseif(item<BST->data)//向左子树继续查找
returnFind(BST->left,item);
else//向右子树继续查找
returnFind(BST->right,item);
由于此递归算法中的递归调用属于末尾递归的调用，即递归调用语句是函数体中最后一条可执行语句，每次递归调用返回后不执行任何语句又返回到上一层，因此原先保存在数据堆栈中的信息都是没有用处的。所以为了避免无效花费在进出数据栈操作上的时间和
使用数据栈的空间，相应的非递归算法如下。
boolFind1(BTreeNodeBST,ElemType&item)//二叉搜索树查找的非递归算法
while(BST!=NULL)
if(item==BST->data)
item=BST->data;returntrue;
elseif(item<BST->data)BST=BST->left;
elseBST=BST->right;
returnfalse;
从图6-1所示的二叉搜索树中查找关键字为23的元素时,首先用23同根结点30进行比较,因为23<30,所以向30的左子树继续查找;再用23同当前根结点15进行比较,因为23>15,所以向15的右子树继续查找;再用23同当前根结点23进行比较,因为相等,所以由item带回该结点的值并返回真,整个查找过程就此结束。若从图6-1中查找关键字为48的元素时,其查找过程为:首先用48同根结点30进行比较,因为48>30,所以向30的右子树继续查找;再用48同当前根结点52进行比较,因为48<52,所以向52的左子树继续查找,此时左子树为空,所以返回假,表明查找失败,整个查找过程就此结束。
在二叉搜索树上进行查找的过程中,给定值item同树中结点比较的次数最少为一次(即树根结点就是待查的结点),最多为树的深度,所以平均查找次数要小于等于树的深度。若二叉搜索树是一棵理想平衡树或接近理想平衡树,则进行查找的时间复杂度为O(logn);若退化为一棵单支树（最极端和最差的情况），则其时间复杂度为O(n)。对于一般情况,其时间复杂度可大致看作O(logn)。因此在二叉搜索树上查找比在集合或线性表上进行顺序查找的时间复杂度O(n)要好得多,这正是构造二叉搜索树的优势所在。二叉搜索树查找的递归算法的空间复杂度平均情况为O(logn),最差情况为O(n),非递归算法的空间复杂度为O(1)。
2.更新
二叉搜索树的更新算法与查找算法基本相同,区别仅有两点:一是在更新算法中当查找到待更新的元素时,应将item的值赋给该元素,而在查找算法中是将该元素的值赋给item带回;二是在更新算法中参数item可以为变参(即引用参数),也可以为值参,并且在参数说明的前面可以加或不加常量标识符const,而在查找算法中参数item只能为变参,并且不能加常量标识符const。请同学们编写此更新算法。
3.插入
根据二叉搜索树的定义,向二叉搜索树中插入元素item的过程为:若二叉树为空,则由item元素生成的新结点将作为根结点插入;否则,若item小于根结点,则将新结点插入到根的左子树上,若item大于等于(若不允许具有相同值的结点存在,则对等于情况应
作单独处理）根结点，则将新结点插入到根的右子树上。显然插入过程是递归的，对应的递归算法描述如下。
voidInsert(BTreeNode&BST,constElemType&item)
if(BST==NULL)
//把按照item元素生成的新结点链接到已找到的插入位置
BTreeNodep=newBTreeNode;
p->data=item;
p->left=p->right=NULL;
BST=p;
elseif(item<BST->data)//向左子树中插入元素
Insert(BST->left,item);
else
Insert(BST->right,item);//向右子树中插入元素
此算法中的树根指针参数BST必须说明为引用，因为当它为空时需要由它带回树根指针，或者在递归时由它提供新插入结点的链接位置。
同一叉搜索树的递归查找算法一样，此算法也属于末尾递归的调用，所以为了消除末尾递归，减少算法运行的时间和空间，也可编写出对应的非递归算法（注意：消除末尾递归不需要使用栈）。对于插入过程的非递归算法，需要首先查找插入位置，然后再进行插入。查找插入位置从树根结点开始，若树根指针为空，则新结点就是树根结点；否则，若item小于根结点，则沿着根的左指针在左子树上继续查找插入位置，若item大于等于根结点，则沿着根的右指针在右子树上继续查找插入位置，当查找到一个结点（设由parent指针所指向）的左指针或右指针为空时，则这个空的指针位置就是新元素结点的插入位置。
在进行插入时，若原树为空，则将新结点指针赋给BST，该新结点就成为树根结点；否则，将新结点赋给parent结点的左指针域或右指针域，作为该结点的左孩子或右孩子。插入过程的非递归算法具体描述如下。
voidInsert1(BTreeNode&BST,constElemType&item)
//为插入新元素寻找插入位置，定义指针t指向当前待比较的结点，初始
//指向树根结点，定义指针parent指向t结点的双亲结点，初始为NULL
BTreeNodet=BST,parent=NULL;
while(t!=NULL)
parent=t;
if(item<t->data)t=t->left;
elset=t->right;
//建立值为item,左、右指针域为空的新结点
BTreeNodep=newBTreeNode;
p->data=item;
p->left=p->right=NULL;
//将新结点插入到二叉搜索树BST中
if(parent==NULL)BST=p;
elseif(item<parent->data)parent->left=p;
elseparent->right=p;
二叉搜索树插入算法的时间和空间复杂度,与其查找和更新算法完全相同。
利用二叉搜索树的插入算法,可以很容易地编写出生成一棵具有n个结点的二叉搜索树的算法,设生成二叉搜索树的n个元素由数组提供,则算法描述如下。
voidCreateBSTree(BTreeNode&BST,ElemTypea[],intn)
//利用数组中的n个元素建立二叉搜索树的算法
BST=NULL;
for(inti=0;i<n;i++)
Insert(BST,a[i]);
在一般情况下,此算法的时间复杂度为O(ntimeslgn)。
若建立二叉搜索树的一组元素的关键字为:(38,26,62,94,35,50,28,55)按照上述算法,每插入一个结点后得到的二叉搜索树如图6-2所示。
(a)插入38(b)插入26(c)插入62(d)插入94(e)插入35
(f)插入50(g)插入28(h)插入55
图6-2二叉搜索树的生成过程
4.删除
二叉搜索树的删除比插入要复杂一些,因为被插入的结点都是被链接到树中的叶子结点上,因而不会破坏树的原有结构,也就是说,不会破坏树中原有结点之间的链接关系。
从二叉搜索树上删除结点（元素）则不同，它可能删除的是叶子结点，也可能删除的是分支结点，当删除分支结点时，就破坏了原有结点之间的链接关系，需要重新修改指针，使得删除后仍为一棵二叉搜索树。
结合如图6-3(a)所示的二叉搜索树，分3种情况介绍删除结点的操作。
(a)二叉搜索树
(b)删除G和M后
(c)删除D结点后
(d)删除L结点后
图6-3二叉搜索树的删除
(1)删除叶子结点。
此种删除操作很简单，只要将其双亲结点链接到它的指针去掉（即置为空）。如删除图6-3(a)树中叶子结点A时，把D结点的左指针域置空；删除叶子结点W时，把S结点的右指针域置空。
(2)删除单支结点。
这种删除操作也比较简单，因为该结点只有左子树或右子树一支，也就是说，其后继只有一个：左孩子或右孩子。删除该结点时，只要将后继指针链接到它所在的链接位置即可。如删除图6-3(a)树中单支结点G时，将G的左指针（即指向F结点的指针）赋给D结点的右指针域即可；删除单支结点M时，将M的右指针（即指向S结点的指针）赋给L结点的右指针域即可；删除这两个结点后，得到的二叉搜索树，如图6-3(b)所示。
(3)删除双支结点。
这种删除比较复杂，因为待删除的结点有两个后继指针，需要妥善处理。删除这种结点的第1种方法是：首先把它的右子树链接到它的中序前驱结点（即中序序列中处于它前面的一个结点）的右指针域，此中序前驱结点必是它的左子树中“最右下”的一个右指针为空（左指针可能为空，也可能不为空）的结点，在图6-3(a)树中双支结点D的中序前驱为A结点，双支结点L的中序前驱为G结点；然后把它的左子树链接到它所在的链接位置。如在图6-3(a)树中删除双支结点D时，则首先把D的右子树链接到A结点的右
指针域，然后把D的左子树链接到L的左指针域，删除D结点后得到的二叉搜索树如图6-3(c)所示。这种方法往往容易增加树的深度，使树的结构变坏，所以通常采用下面介绍的第2种方法。
删除双支结点的第2方法是：首先把它的中序前驱结点的值赋给该结点的值域，然后再删除它的中序前驱结点，因为它的中序前驱结点的右指针为空，所以只要把中序前驱结点的左指针链接到中序前驱结点所在的链接位置即可。如删除图6-3(a)树中双支结点D时，首先把它的中序前驱结点A的值赋给D结点的值域，然后把A结点的左指针（此时为空）链接到D结点的左指针域，删除D结点后得到的二叉搜索树，如图6-3(c)所示。又如，若从图6-3(a)树中删除根结点L，因为L是双支结点，所以首先把它的中序前驱结点G的值赋给L结点的值域，然后把G结点的左指针（此时指向F结点）链接到D结点的右指针域，删除L结点后得到的二叉搜索树，如图6-3(d)所示。
采用以上方法从二叉搜索树中删除结点后，得到的仍然是一棵二叉搜索树。
从二叉搜索树中删除结点的算法可以是递归的，也可以是非递归的，下面只给出递归算法，读者可以编写出相应的非递归算法。
```
boolDelete(BTreeNode&BST,constElemType&item)
//从二叉搜索树BST中删除值为item的结点，树根指针必须为引用
//树为空，未找到待删除元素，返回假表示删除成功
if(BST==NULL)returnfalse;
//待删除元素小于树根结点值，继续在左子树中删除
if(item<BST->data)returnDelete(BST->left,item);
//待删除元素大于树根结点值，继续在右子树中删除
if(item>BST->data)returnDelete(BST->right,item);
BTreeNodetemp=BST;
//待删除元素等于树根结点值且左子树为空，将右子树作为整棵树并返回真
if(BST->left==NULL)
BST=BST->right;deletetemp;returntrue;
//待删除元素等于树根结点值且右子树为空，将左子树作为整棵树并返回真
elseif(BST->right==NULL)
BST=BST->left;deletetemp;returntrue;
//待删除元素等于树根结点值且左、右子树均不为空时的处理情况
else
//中序前驱结点就是左孩子结点时，把左孩子结点值赋给树根结点，
//然后从左子树中删除根结点
if(BST->left->right==NULL)
BST->data=BST->left->data;
returnDelete(BST->left,BST->left->data);
//找出中序前驱结点，即左子树的右下角结点，把该结点值赋给树根结点，
//然后从以中序前驱结点为根的树上删除根结点
else
```
BTreeNodep1=BST,p2=BST->left;
while(p2->right!=NULL)p1=p2;p2=p2->right;
BST->data=p2->data;
returnDelete(p1->right,p2->data);
二叉搜索树的查找、插入、删除元素的运算都具有相同的时间复杂度，都与具体二叉搜索树的深度成正比，时间复杂度的平均情况为O(logn)，最差情况为O(n)；它们的空间复杂度，对于递归算法来说，平均情况为O(logn)，最差情况为O(n)，对于非递归算法来说均为O(1)。
可以采用下面程序调试对二叉搜索树各种运算的算法。
include<iostream.h>
include<stdlib.h>
//定义二叉搜索树结点值的类型为整型
typedefintElemType;
//定义二叉搜索树结点类型
structBTreeNode
ElemTypedata;
BTreeNodeleft;
BTreeNoderight;
;
include"二叉树运算.cpp"
include"二叉搜索树运算.cpp"//保存对二叉搜索树运算的算法
voidmain()
ElemTypex;
//定义指向二叉搜索树结点的指针，并用它作为树根指针
BTreeNodebst;
//初始化二叉搜索树，即置树根指针bst为空
InitBTree(bst);
//定义数组a并初始化
ElemTypea[10]=30,50,20,40,25,70,54,23,80,92;
//利用数组a建立树根指针为bst的二叉搜索树
CreateBSTree(bst,a,10);
//以广义表形式输出二叉搜索树
PrintBTree(bst);cout<<endl;
//求出以bst为树根指针的二叉搜索树的深度
cout<<"深度：";cout<<DepthBTree(bst)<<endl;
//中序遍历以bst为树根指针的二叉搜索树
cout<<"中序:";InOrder(bst);cout<<endl;
//从二叉搜索树中查找一个结点
cout<<"输入一个待查找的整数值:";
cin>>x;
if(Find1(bst,x))cout<<"查找元素"<<x<<"成功!"<<endl;
elsecout<<"查找元素"<<x<<"失败!"<<endl;
//向二叉搜索树中插入一个结点
cout<<"输入一个待插入结点的整数值:";
cin>>x;
Insert1(bst,x);
//从二叉搜索树中删除一个结点
cout<<"输入一个待删除结点的值:";
cin>>x;
if(Delete(bst,x))cout<<"删除元素"<<x<<"成功!"<<endl;
elsecout<<"删除元素"<<x<<"失败!"<<endl;
//再以广义表形式输出二叉搜索树
PrintBTree(bst);cout<<endl;
//再次中序遍历以bst为树根指针的二叉搜索树
cout<<"中序:";InOrder(bst);cout<<endl;
//清除以bst为树根指针的二叉树
ClearBTree(bst);
程序的一次运行结果如下。30(20(,25(23)),50(40,70(54,80(,92))))深度:5
中序:20232530405054708092
输入一个待查找的整数值:70
查找元素70成功!
输入一个待插入结点的整数值:15
输入一个待删除结点的值:30
删除元素30成功!25(20(15,23),50(40,70(54,80(,92))))中序:15202325405054708092
6.2堆
6.2.1堆的定义
堆(heap)分为小根堆和大根堆两种,对于一个小根堆,它是具有如下特性的一棵完全二叉树。
（1）若树根结点存在左孩子，则根结点的值(或某个域的值)小于等于左孩子结点的值(或某个域的值)。
（2）若树根结点存在右孩子，则根结点的值(或某个域的值)小于等于右孩子结点的值
(或某个域的值)。
(3)以左、右孩子为根的子树又各是一个堆。
大根堆的定义与上述类似,只要把小于等于改为大于等于就得到了。
由堆的定义可知,若一棵完全二叉树是堆,则该树中以每个结点为根的子树也都是一
个堆。
如图6-4所示分别为一个小根堆和一个大根堆。根据堆的定义可知,堆顶结点,即整个完全二叉树的根结点,对于小根堆来说具有最小值,对于大根堆来说具有最大值。图6-4(a)是一个小根堆,堆中的最小值为堆顶结点的值18,图6-4(b)是一个大根堆,堆中的最大值为堆顶结点的值74。若用堆来表示优先级队列,则堆顶结点具有最高的优先级,每次做删除操作要删除堆顶结点。beginaligned&text(a)小根堆&text(b)大根堆endaligned图6-4小根堆和大根堆
section6.2.2堆的抽象数据类型
堆的抽象数据类型中的数据部分是按任一种存储结构表示的堆,用标识符HBT表示,其存储类型用标识符HeapType表示。堆的抽象数据类型中的操作部分通常为:向堆中插入一个元素、从堆中删除堆顶元素、初始化一个堆、清除一个堆和判断一个堆是否为空等。堆的抽象数据类型的具体定义如下。
ADTHEAPis
Data:
具有HeapType类型的一个堆HBT
Operations:
voidInitHeap(HeapType&HBT);//初始化一个堆为空
voidClearHeap(HeapType&HBT);//清除一个堆,使之变为空
boolEmptyHeap(HeapType&HBT);//判断一个堆是否为空
voidInsertHeap(HeapType&HBT,ElemTypeitem);//向堆中插入元素
ElemTypeDeleteHeap(HeapType&HBT);//从堆中删除堆顶元素并返回
endHEAP
section6.2.3堆的存储结构
堆同一般二叉树一样既可采用顺序存储,也可采用链接存储。但由于堆是一棵完全二
叉树,所以适宜采用顺序存储,这样能够充分利用其存储空间。
对堆进行顺序存储时,首先要对堆中的所有结点进行编号,然后再以编号为下标存储到指定数组的对应元素中。为了利用数组的0号元素,堆中结点的编号从0而不是从1开始,当然编号次序仍然按照从上到下、同一层从左到右进行,若堆中含有n个结点,则编号范围为0simn-1。
堆中的结点从0开始编号后,编号为0至lfloorn/2rfloor-1的结点为分支结点,编号为lfloorn/2rfloorsimn-1的结点为叶子结点;当n为奇数则每个分支结点既有左孩子又有右孩子,当n为偶数则编号最大的一个分支结点只有左孩子没有右孩子;对于每个编号为i的分支结点,其左孩子结点的编号为2i+1,右孩子结点的编号为2i+2;除编号为0的堆顶结点外,对于其余编号为i的结点,其双亲结点的编号为lfloor(i-1)/2rfloor。
对于图6-4所示的堆,对应的顺序存储结构,如图6-5所示。beginarray|c|c|c|c|c|c|c|c|c|c|hline0&1&2&3&4&5&6&7&8&9hline18&26&35&73&48&60&&&&hlineendarray(a)图6-4(a)的存储结构beginarray|c|c|c|c|c|c|c|c|c|c|hline0&1&2&3&4&5&6&7&8&9hline74&53&42&25&36&35&20&18&22&hlineendarray(b)图6-4(b)的存储结构
图6-5堆的顺序存储结构
根据此存储结构可以验证给出的双亲和左、右孩子结点之间的下标关系。
当一个堆采用顺序存储结构时,需要定义一个元素类型为ElemType、长度为MaxSize的一个数组来存储堆中的所有元素,还需要定义一个整型变量,用以存储堆的长度,即堆中当前包含的结点数。设存储堆元素的数组名用heap表示,存储堆长度的变量名用len表示,并且把它们连同存储空间大小MaxSize一起定义在一个结构类型中,结构类型名用Heap表示,则该类型定义为:
structHeap
ElemTypeheap;//定义指向动态数组空间的指针
intlen;//定义保存堆长度的变量
intMaxSize;//用于保存初始化时所给的动态数组空间的大小
;
6.2.4堆的运算
在堆的抽象数据类型中列出的每一种操作的具体算法描述如下。对于插入和删除算法将以小根堆为例给出,当为大根堆时只是相应条件中的比较操作符不同,其余都相同。
1.初始化堆
voidInitHeap(Heap&HBT)//置HBT为一个空堆
HBT.MaxSize=10;//初始定义数组长度为10,以后可增减
HBT.heap=newElemType[HBT.MaxSize];//动态分配存储堆的数组空间
if(!HBT.heap)
cout<<"用于动态分配的内存空间用完,退出运行!"<<endl;
exit(1);
HBT.len=0;//设置len域的初值为0
2.清除堆
voidClearHeap(Heap&HBT)//清除HBT,使之成为一个空堆
if(HBT.heap!=NULL)
delete[]HBT.heap;
HBT.heap=NULL;
HBT.len=0;
HBT.MaxSize=0;
3.检查一个堆是否为空
boolEmptyHeap(Heap&HBT)//判断HBT是否为空,是返真,否返假
returnHBT.len==0;
4.向堆中插入一个元素
向堆中插入一个元素时,首先将该元素写入到堆尾,即堆中最后一个元素的后面,亦即下标为len的位置上,然后经调整为一个新堆。由于在原有堆上插入一个新元素后,可能使以该元素为根的子树不为堆,从而使整个树不为堆,所以必须进行调整使之仍为一个堆。调整的方法很简单,若新元素小于双亲结点的值,就让它们互换位置;新元素换到双亲位置后,使得以该位置为根的子树成为堆,但新元素可能还小于此位置的双亲结点的值,从而使以上一层的双亲结点为根的子树不为堆,还需要按上述方法继续调整,这样持续传递上去,直到以新位置的双亲结点为根的子树仍为一个堆或者调整到堆顶为止,此时得到的整个树又成为一个堆。
对于图6-4(a)所示的堆,若向它插入一个新元素50时,由于它不小于双亲结点的值35,所以以35为根的子树仍为一个堆,从而使整个二叉树仍然是一个堆,此次插入不需要作任何调整。插入新元素50后得到的堆,如图6-6(a)所示。
(a)插入50
(b)插入30
(c)插入15
图6-6堆的插入
对于图6-4(a)所示的堆,若向它插入一个新元素30,由于它小于双亲结点的值35,所以需要将30与35对调位置,对调后因新元素30不小于其双亲元素18,所以调整结束,得到的整个二叉树为一个堆,插入结果如图6-6(b)所示。
对于图6-4(a)所示的堆,若向它插入的一个新元素为15,由于它小于双亲元素35,所以需要将15与35对调位置,对调后因新元素15小于其双亲元素18,所以又需要将15与18对调位置,此时新元素被调整到了堆顶位置,所以调整结束,得到的插入后结果如图6-6(c)所示。
向堆中插入一个元素的算法描述如下。
voidInsertHeap(Heap&HBT,ElemTypeitem)//向小根堆HBT中插入元素
//堆满时重分配大一倍的存储空间并进行相应操作
if(HBT.len==HBT.MaxSize)
intk=sizeof(ElemType);
HBT.heap=(ElemType)realloc(HBT.heap,2HBT.MaxSizek);//计算每个元素存储空间的长度
//堆动态存储空间扩展为原来的2倍,原内容自动保持不变
if(HBT.heap==NULL)
cout<<"动态可分配的存储用完,退出运行!"<<endl;
exit(1);
HBT.MaxSize=2HBT.MaxSize;//把堆空间大小修改为新的长度
//用i指向待调整元素的位置,初始指向新元素所在的堆尾位置
inti=HBT.len;
//寻找新元素的最终位置,每次使双亲元素下移一层
while(i!=0)
intj=(i-1)/2;//j指向下标为i的元素的双亲元素
if(item>=HBT.heap[j])break;//比较调整结束退出循环
HBT.heap[i]=HBT.heap[j];//双亲元素下移
i=j;//改变调整元素的位置为其双亲位置
//把新元素调整到最终位置,并使堆的长度增1
HBT.heap[i]=item;
HBT.len++;
此算法的运行时间主要取决于while循环的执行次数，它等于新元素向双亲位置逐层上移的次数，此次数最多等于整个树的深度减1，所以算法的时间复杂度为O(logn)，其中n表示堆的大小。
5.从堆中删除元素
从堆中删除元素就是删除堆顶元素并使之返回。堆顶元素被删除后，留下的堆顶位置应由堆尾元素来填补，这样既保持了顺序存储结构又不需要移动其他任何元素。把堆尾元素素移动到堆顶位置后，它可能不小于左、右孩子结点，使整个二叉树不为堆，所以需要一个调整过程，使之变为含有n-1个元素的堆（删除前为n个元素）。调整过程首先从树根结点开始，若树根结点的值大于两个孩子结点中的最小值，就将它与具有最小值的孩子结点互换位置，使得根结点的值小于两个孩子结点的值；原树根结点被对调到一个孩子位置后，可能使以该位置为根的子树又不为堆，因而又需要使新元素向孩子一层调整，如此调整下去，直到以调整后的位置为根的子树成为一个堆或调整到叶子结点为止。
对于图6-4(a)所示的堆，当从中删除顶点元素18时，需要把堆尾元素60写入到堆顶位置成为堆顶元素，由于60大于两个孩子中的最小值26，所以应互换60和26的位置，60被移到新位置后，又大于两个孩子中的最小值48，所以接着同48互换位置，此时60已被调整到叶子结点，所以调整完成后得到的完全二叉树又成为一个堆，如图6-7所示。
![image](attachment://figure_6_7.png)
图6-7堆的删除
若图6-4(a)所示堆的顶元素不是60而是45，则进行删除操作时把45写入到堆顶位置后，因45大于两个孩子中的最小值26，所以需把它对调到左孩子26的位置，此时它小于两个孩子中的最小值48，表明以45所在的新位置为根的子树已经成为一个堆，至此调整结束。
从堆中删除元素的算法描述如下。
```
ElemTypeDeleteHeap(Heap&HBT)//从小根堆HBT中删除堆顶元素并返回
if(HBT.len==0)//若为空堆，则显示出错误信息并退出运行
cerr<<"堆为空，退出运行!"<<endl;
exit(1);
ElemTypetemp=HBT.heap[0];//将堆顶元素暂存temp以便返回
HBT.len--;//堆的长度减1
if(HBT.len==0)returntemp;//若删除操作后变为空堆则返回
ElemTypex=HBT.heap[HBT.len];//将待调整的堆尾元素暂存x中
inti=0;//用i指向待调整元素的位置，初始指向堆顶位置
intj=1;//用j指向i的左孩子位置，初始指向下标1的位置
while(j<=HBT.len-1)//寻找待调整元素的最终位置
//若右孩子存在并且较小，应使j指向右孩子
if(j<HBT.len-1&&HBT.heap[j]>HBT.heap[j+1])j++;
```
//若条件成立则调整结束，退出循环
if(x<=HBT.heap[j])break;
//孩子元素上移到双亲位置
HBT.heap[i]=HBT.heap[j];
//使i和j分别指向下一层结点
i=j;j=2i+1;
HBT.heap[i]=x;//把待调整元素放到最终位置
returntemp;//返回原堆顶元素
此算法的运行时间主要取决于while循环的执行次数，它等于堆顶新元素向孩子位置逐层下移的次数，此次数最多等于整个树的深度减1，所以堆删除算法的时间复杂度同插入算法相同，均为O(logn)。
在解决实际问题时，若每次只需要取出（即删除）具有最小值的元素，则适合采用堆这种数据结构，因为其插入和删除元素的时间复杂度均为O(logn)。若采用线性表来实现这种功能，其插入和删除元素的时间复杂度将均为O(n)。
在计算机操作系统中，管理一个共享资源就需要使用一个堆，把等待使用该资源的所有用户按照优先级号组织起来，优先级最高的用户一定处于堆首位置，系统每次从这个堆中取出(删除)堆顶元素并为之服务，需要使用该资源的新用户被加入到等待使用该资源的堆中。
使用堆的一个完整程序如下，请读者阅读和分析。
include<iostream.h>
include<stdlib.h>
typedefintElemType;//定义元素类型为整型
structHeap
ElemTypeheap;//定义堆的顺序存储类型
intlen;
intMaxSize;
;
include"堆运算.cpp"//假定在heap.cpp中保存着堆运算的各种算法
voidmain()
inta[8]=23,56,40,62,38,55,10,16;
Heapb;//定义一个堆b
InitHeap(b);//初始化堆b
inti,x;
//向堆b中依次插入数组a中的每一个元素
for(i=0;i<8;i++)InsertHeap(b,a[i]);
//按下标位置依次输出堆中的每个元素
for(i=0;i<7;i++)cout<<b.heap[i]<<',';
cout<<b.heap[7]<<endl;
//依次删除堆顶元素并显示出来，直到堆空为止
while(!EmptyHeap(b))
x=DeleteHeap(b);
cout<<x;
if(!EmptyHeap(b))cout<<',';
cout<<endl;
ClearHeap(b);
请通过堆的图示操作过程验证下面运行结果的正确性。
10,16,23,38,56,55,40,62
10,16,23,38,40,55,56,62
section6.3哈夫曼树
subsection6.3.1基本术语
1.路径和路径长度
在一棵树中存在着一个结点序列k_1,k_2,cdots,k_j，使得k_i是k_i+1的双亲(1leqi<j)，则称此结点序列是从k_1到k_j的路径，因树中每个结点只有一个双亲结点，所以它也是这两个结点之间的唯一路径。从k_1到k_j所经过的分支数称为这两点之间的路径长度，它等于路径上的结点数减1。在图6-3(a)所示的二叉树中，从树根结点L到叶子结点P的路径为结点序列L,M,S,P，路径长度为3。
2.结点的权和带权路径长度
在许多应用中，常常将树中的结点赋上一个有着某种意义的实数，称此实数为该结点的权。结点的带权路径长度规定为从树根结点到该结点之间的路径长度与该结点上权的乘积。
3.树的带权路径长度
树的带权路径长度定义为树中所有叶子结点的带权路径长度之和，通常记为：textWPL=sum_i=1^nw_il_i
其中，n表示叶子结点的数目，w_i和l_i分别表示叶子结点k_i的权值和树根结点到k_i之间的路径长度。
4.哈夫曼树
哈夫曼树（Huffmantree）又称做最优二叉树。它是n个带权叶子结点构成的所有二叉树中，带权路径长度WPL最小的二叉树。因为构造这种树的算法是最早由哈夫曼于1952年提出的，所以被称为哈夫曼树。
例如，有4个叶子结点a,b,c,d，分别带权为9,4,5,2，由它们构成的三棵不同的二叉树（当然还有其他许多种）分别如图6-8(a)~图6-8(c)所示。
(a)带权二叉树之一
(b)带权二叉树之二
(c)带权二叉树之三
图6-8由四个叶子结点构成的三棵不同的带权二叉树
每一棵二叉树的带权路径长度WPL分别为：
①WPL=9times2+4times2+5times2+2times2=40；
②WPL=4times1+2times2+5times3+9times3=50；
③WPL=9times1+5times2+4times3+2times3=37。
其中，③树的WPL最小，稍后便知，此树就是哈夫曼树。
因此，在n个带权叶子结点所构成的二叉树中，满二叉树或完全二叉树不一定是最优二叉树。权值越大的结点离树根越近的二叉树才是最优二叉树。
section6.3.2构造哈夫曼树
构造最优二叉树的算法具体叙述如下。
(1)根据与n个权值w_1,w_2,cdots,w_n对应的n个结点构成具有n棵二叉树的森林F=T_1,T_2,cdots,T_n其中，每棵二叉树T_i(1leqileqn)都只有一个权值为w_i的根结点，其左、右子树均为空。
(2)在森林F中选出两棵根结点的权值最小的树作为一棵新树的左、右子树，且置新树的根结点的权值为其左、右子树上根结点的权值之和。
(3)从F中删除构成新树的那两棵树，同时把新树加入F中。
(4)重复(2)和(3)步，直到F中只含有一棵树为止，此树便是哈夫曼树。
若仍采用图6-8中的4个带权叶子结点来构造一棵哈夫曼树，按照上述算法，则构造过程如图6-9所示，其中图6-9(d)就是最后生成的哈夫曼树，它的带权路径长度为37，由此可知，图6-8(c)是一棵哈夫曼树。
(a)四棵树
(b)三棵树
(c)两棵树
(d)一棵树
图6-9构造哈夫曼的过程
在构造哈夫曼树的过程中,当每次由两棵权值最小的树生成一棵新树时,新树的左子树和右子树可以任意安排,这样将会得到具有不同结构的多个哈夫曼树,但它们都具有相同的带权路径长度。为了使得到的哈夫曼树的结构尽量唯一,通常规定生成的哈夫曼树中每个结点的左子树根结点的权小于等于右子树根结点的权。上述哈夫曼树的构造过程就是依照这一规定进行的。
根据上述构造哈夫曼树的方法可以写出相应的用C++语言描述的算法如下。
BTreeNodeCreateHuffman(ElemTypea[],intn)
//根据数组a中n个权值建立一棵哈夫曼树,返回树根指针
BTreeNodeb,q;
//动态分配一个由b指向的指针数组
b=newBTreeNode[n];
inti,j;
//初始化b指针数组,使每个指针元素指向a数组中对应元素的结点
for(i=0;i<n;i++)
b[i]=newBTreeNode;
b[i]->data=a[i];b[i]->left=b[i]->right=NULL;
//进行n-1次循环建立哈夫曼树
for(i=1;i<n;i++)
//用k1表示森林中具有最小权值的树根结点的下标
//用k2表示森林中具有次最小权值的树根结点的下标
intk1=-1,k2;
//让k1初始指向森林中第一棵树,k2初始指向森林中第二棵树
for(j=0;j<n;j++)
if(b[j]!=NULL&k1==-1)k1=j;continue;
if(b[j]!=NULL)k2=j;break;
//从当前森林中求出最小权值树和次最小权值树
for(j=k2;j<n;j++)
if(b[j]!=NULL)
if(b[j]->data<b[k1]->data)k2=k1;k1=j;
elseif(b[j]->data<b[k2]->data)k2=j;
//由最小权值树和次最小权值树建立一棵新树，q指向树根结点
q=newBTreeNode;
q->data=b[k1]->data+b[k2]->data;
q->left=b[k1];q->right=b[k2];
//将指向新树的指针赋给b指针数组中k1位置，k2位置为空
b[k1]=q;b[k2]=NULL;
//删除动态建立的数组b
delete[]b;
//返回整个哈夫曼树的树根指针
returnq;
在一颗哈夫曼树的生成过程中，每次都由两棵子树构成一棵树，对于n个叶子结点共需要构成n-1棵子树。所以，在一棵哈夫曼树中只存在双支结点和叶子结点，若叶子结点为n个，则双支结点必为n-1个。
根据哈夫曼树求出带权路径长度的算法如下。
ElemTypeWeightPathLength(BTreeNodeFBT,intlen)
//根据FBT指针所指向的哈夫曼树求出带权路径长度，len初值为0
if(FBT==NULL)return0;//空树则返回0
else
//访问到叶子结点时返回该结点的带权路径长度，其中值参len
//保存当前被访问结点的路径长度
if(FBT->left==NULL&&FBT->right==NULL)
returnFBT->datalen;
//访问到非叶子结点时进行递归调用，返回左、右子树的带权
//路径长度之和，向下深入一层时len值增1
else
returnWeightPathLength(FBT->left,len+1)+
WeightPathLength(FBT->right,len+1);
section6.3.3哈夫曼编码
哈夫曼树的应用很广,哈夫曼编码就是其中的一种,下面简要介绍。
在电报通信中,电文是以二进制的0、1序列传送的。在发送端需要将电文中的字符序列转换成二进制的0、1序列（即编码），在接收端又需要把接收到的0、1序列转换成对应的字符序列（即译码）。
最简单的二进制编码方式是等长编码。若电文中只使用A、B、C、D、E、F这6种字符，若进行等长编码，则需要二进制的三位，可依次编码为000、001、010、011、100、101。若用这6个字符作为6个叶子结点，生成一棵二叉树，让该二叉树中每个分支结点的左、右分支分别用0和1编码，从树根结点到每个叶子结点的路径上所经分支的0、1编码序列应等于该叶子结点的二进制编码，则对应的编码二叉树，如图6-10所示。
![A](A)[B](B)[C](C)[D](D)[E](E)[F](F)
图6-10编码二叉树
通常，电文中每个字符的出现频率（即次数）一般是不同的。在一份电文中，这6个字符的出现频率依次为：4、2、6、8、3、2，则电文被编码后的总长度L可由下式计算：L=sum_i=1^nc_il_i其中，n表示电文中使用的字符数，c_i和l_i分别表示对应字符k_i在电文中的出现频率和编码长度。因此，可求出L为：L=sum_i=1^6left(c_itimes3right)=3times(4+2+6+8+3+2)=75可知，采用等长编码时，传送电文的总长度为75。
那么，如何能缩短传送电文的总长度，从而节省传送时间呢？若采用不等长编码，让出现频率高的字符具有较短的编码，让出现频率低的字符具有较长的编码，这样有可能缩短传送电文的总长度。采用不等长编码要避免译码的二义性或多义性。假设用0表示字符D，用01表示字符C，则当接收到编码串…01…，并译到字符0时，是立即译出对应的字符D，还是接着与下一个字符1一起译为对应的字符C，这就产生了二义性。因此，若对某一字符集进行不等长编码，则要求字符集中任一字符的编码都不能是其他字符编码的前缀。符合此要求的编码叫做无前缀编码。显然等长编码是无前缀编码，这从等长编码所对应的编码二叉树也可直观地看出，任一叶子结点都不可能是其他叶子结点的双亲，也就是说，只有当一个结点是另一个结点的双亲时，该结点的字符编码才会是另一个结点的字符编码的前缀。
为了使不等长编码成为无前缀编码，可用该字符集中的每个字符作为叶子结点生成一棵编码二叉树。为了获得传送电文的最短长度，可将每个字符的出现频率作为字符结点的权值赋予该结点上，求出此树的最小带权路径长度就等于求出了传送电文的最短长度。因
此，求传送电文的最短长度问题就转化为求由字符集中的所有字符作为叶子结点，由字符的出现频率作为其权值所产生的哈夫曼树的问题。
由上例生成的编码哈夫曼树如图6-11所示。由编码哈夫曼树得到的字符编码称作哈夫曼编码。其中，A、B、C、D、E、F这6个字符的哈夫曼编码依次为：00,1010,01,11,100,1011。电文的最短传送长度为：L=WPL=sum_i=1^6w_il_i
=4times2+2times4+6times2+8times2+3times3+2times4
=61显然，计算结果比等长编码所得到的传送电文总长度75要小得多。
对求哈夫曼树带权路径长度的算法略加修改，就可以得到求哈夫曼编码的算法。具体如下。
voidHuffManCoding(BTreeNodeFBT,intlen)
//根据FBT指针所指向的哈夫曼树输出每个叶子的编码，len初值为0
staticinta[10];//数组的长度要至少等于哈夫曼树的深度减1
if(FBT!=NULL)
//访问到叶子结点时输出其保存在数组a中的0和1序列编码
if(FBT->left==NULL&&FBT->right==NULL)
cout<<"结点权值为"<<FBT->data<<"的编码:";
for(inti=0;i<len;i++)cout<<a[i]<<'';
cout<<endl;
//访问到非叶子结点时分别向左、右子树递归调用，并分别把分支上的0、1编码保存到数组a的对应元素中，向下深入一层时len值增1
else
a[len]=0;HuffManCoding(FBT->left,len+1);
a[len]=1;HuffManCoding(FBT->right,len+1);
采用如下程序调试对哈夫曼树的算法。
include<iostream.h>
include<stdlib.h>
typedefintElemType;
structBTreeNode
ElemTypedata;
```cpp
BTreeNodeleft;
BTreeNoderight;
;
include"二叉树运算.cpp"
//根据数组a中n个权值建立一棵哈夫曼树，返回树根指针
BTreeNodeCreateHuffman(ElemTypea[],intn);//补充函数定义
//根据FBT指针所指向的哈夫曼树求出带权路径长度，len初值为0
ElemTypeWeightPathLength(BTreeNodeFBT,intlen);//补充函数定义
//根据FBT指针所指向的哈夫曼树输出每个叶子的编码，len初值为0
voidHuffManCoding(BTreeNodeFBT,intlen);//补充函数定义
voidmain()
intn,i;
BTreeNodefbt=NULL;
//输入哈夫曼树中叶子结点数
cout<<"输入待构造的哈夫曼树中带权叶子结点数n:";
cin>>n;
//用数组a保存从键盘输入的n个叶子结点的权值
ElemTypea=newElemType[n];
cout<<"输入"<<n<<"个整数作为权值:";
for(i=0;i<n;i++)cin>>a[i];
//根据数组a建立哈夫曼树
fbt=CreateHuffman(a,n);
//以广义表形式输出哈夫曼树
cout<<"广义表形式的哈夫曼树:";
PrintBTree(fbt);
cout<<endl;
//输出哈夫曼树的权值，即带权路径长度
cout<<"哈夫曼树的权:";
cout<<WeightPathLength(fbt,0)<<endl;
//输出哈夫曼编码，即每个叶子结点所对应的0,1序列
cout<<"树中每个叶子的哈夫曼编码:"<<endl;
HuffManCoding(fbt,0);
ClearBTree(fbt);
程序的一次运行结果如下。
输入待构造的哈夫曼树中带权叶子结点数n:6
输入6个整数作为权值:39512615
广义表形式的哈夫曼树:50(21(9,12),29(14(6,8(3,5)),15))
哈夫曼树的权:122
```
树中每个叶子的哈夫曼编码:
结点权值为9的编码:00结点权值为12的编码:01结点权值为6的编码:100结点权值为3的编码:1010结点权值为5的编码:1011结点权值为15的编码:116.4线索二叉树
subsection6.4.1二叉树的线索化
对二叉树进行某种遍历得到的结点序列,可以看作一个线性表。在该线性表中,除第一个结点外,每个结点有且仅有一个前驱,除最后一个结点外,每个结点有且仅有一个后继。为了同在二叉树中所具有的结点前驱(即双亲)和后继(即孩子)区别开来,在容易混淆的地方,通常把遍历序列中结点的前驱或后继冠以某种遍历的名称,如把中序序列中结点的前驱称作中序前驱,结点的后继称作中序后继。对于如图6-12所示的二叉树,中序遍历的结点序列为B、G、D、A、E、H、C、F,其中B结点为中序遍历得到的线性序列的表头结点,它没有前驱,其中序后继为G结点,A结点的中序前驱为D结点,中序后继为E结点等。
对于一棵具有n个结点的二叉树,对应的二叉链表中共有2n个指针域,其中n-1个用于指向除树根结点以外的其余n-1个结点,另有n+1个指针域空闲着。若把每个结点中空着的左指针域和右指针域用于分别指向某种遍历次序的前驱结点和后继结点,则在遍历这种二叉树时,可由此信息直接找到在该遍历次序下的前驱结点或后继结点,从而比递归遍历提高了遍历速度、节省了建立系统栈所使用的存储空间。这种在结点的空指针域中存放的该结点在某次遍历次序下的前驱结点或后继结点的指针叫做线索(thread),其中在空的左指针域中存放的指向其前驱结点的指针叫做左线索或前驱线索,在空的右指针域中存放的指向其后继结点的指针叫做右线索或后继线索。对一棵二叉树中的所有结点的空指针域按照某种遍历次序加线索的过程叫做线索化,被线索化了的二叉树称做线索二叉树。如图6-12(b)所示是对图6-12(a)的二叉树加中序线索而得到的中序线索二叉树。
n
(a)二叉树
(b)加中序线索后的二叉树
图6-12中序线索二叉树
在一个线索二叉树中，为了区别各个结点的左、右指针域所存放的是孩子指针，或是线索，必须在结点结构中增加两个线索标志域，一个是左线索标志域，用ltag表示，另一个是右线索标志域，用rtag表示。ltag和rtag只需取两种值，以区别其对应的指针域保存的是孩子指针，或是线索，取真时指向线索，取假时指向孩子。
增加线索标志域后的二叉树结点结构如下。
|Left|ltag|data|rtag|right|
该结点结构的类型定义为:
structTTreeNode
ElemTypedata;//值域
boolltag,rtag;//线索标志域
TTreeNodeleft;//左指针域
TTreeNoderight;//右指针域
;
如图6-13所示是图6-12的中序线索二叉树的链接存储结构。
![图6-13索引二叉树的链接存储结构]
对一棵结点类型为TTreeNode的二叉树进行线索化时，该二叉树的初始状态应为：每个结点的线索标志域均为假（0），若一个结点有左孩子或右孩子，则相应的指针域指向孩子，否则为空，以便在线索化的过程中加入线索。
对一棵二叉树进行某种遍历次序的线索化，显然就是对该二叉树进行这种遍历的过程，只不过在访问根结点时，不是简单地打印根结点的值，而是对指针域为空的结点加线索，具体做法如下。
(1)若前驱结点不为空，或者说当前结点不是序列中的第1个结点，同时前驱结点的右线索标志域为真（表示此结点的右指针域为空）时，则将当前结点的指针赋给前驱结点的右指针域，即给前驱结点加右线索。
(2)若当前结点的左指针域为空，则将左线索标志域置真，同时把前驱结点的指针赋给当前结点的左指针域，即给当前结点加左线索。
(3)若当前结点的右指针域为空，则将右线索标志域置为真，以便当访问到下一个（即后继）结点时，给它加右线索。
(4)将当前结点指针赋给保存前驱结点指针的变量，以便当访问下一个结点时，此当前结点成为前驱结点。
设pre是用来保存前驱结点指针的引用参数，初始为空；设HBT是用来保存当前结点指针的值参，初始指向待线索化的一棵二叉树的根结点，下面给出对二叉树进行中序线索化即建立中序线索的算法，它是在中序遍历算法的基础上改造而成的。
voidInThread(TTreeNodeHBT,TTreeNode&pre)
//对二叉树HBT加中序线索
if(HBT!=NULL)
if(HBT->ltag==false)
InThread(HBT->left,pre);//左子树非空时给左子树加中序线索
if(pre!=NULL&&pre->rtag==true)
pre->right=HBT;//给前驱结点加后继线索
if(HBT->left==NULL)
HBT->ltag=true;
HBT->left=pre;//给当前结点加前驱线索
if(HBT->right==NULL)
HBT->rtag=true;//给右指针域为空的结点加右线索标记
pre=HBT;//把刚访问过的当前结点置为前驱结点
if(HBT->rtag==false)
InThread(HBT->right,pre);//右子树非空时给右子树加中序线索
在对二叉树进行中序线索化的算法中，若把对左子树加线索的条件语句放到对右子树加线索的条件语句之上，则得到前序线索化的算法，所建立的线索为前序线索；若把对右子树加线索的条件语句放到对左子树加线索的条件语句之下，则得到后序线索化的算法，所建立的线索为后序线索。
若在该函数中不使用pre参数，也可以在函数体的开始位置加上如下语句替代。
staticTTreeNodepre=NULL;
利用下面算法向带线索标志域的二叉搜索树插入元素，但不进行中序线索的链接。
voidInsertThreed(TTreeNode&HBT,constElemType&item)
//向带线索的二叉搜索树插入元素，但不链接线索
if(HBT==NULL)
TTreeNodep=newTTreeNode;
p->data=item;
p->left=p->right=NULL;
p->ltag=p->rtag=0;
HBT=p;
elseif(item<HBT->data)//向左子树中插入元素
InsertThreed(HBT->left,item);
else
InsertThreed(HBT->right,item);
利用下面算法建立带线索标志域的二叉搜索树，但不进行中序线索链接。
voidCreateThreed(TTreeNode&HBT,ElemTypea[],intn)
HBT=NULL;
for(inti=0;i<n;i++)
InsertThreed(HBT,a[i]);
带线索标志域的二叉搜索树建立后，随时可以调用InThread算法，建立其中序线索。若要向带线索的二叉搜索树中插入结点，并且要进行实际的线索链接，则应采用下面插入算法。
voidInsertThreed1(TTreeNode&HBT,constElemType&item)
//向带线索的二叉搜索树插入元素，并进行线索链接
//为新结点寻找插入位置
TTreeNodet=HBT,parent=NULL;
while(t!=NULL)
parent=t;
if(item<t->data)
if(t->ltag==false)t=t->left;elset=NULL;
else
if(t->rtag==false)t=t->right;elset=NULL;
//建立值为item的新结点
TTreeNodep=newTTreeNode;
p->data=item;
p->ltag=p->rtag=true;//叶子结点的左、右孩子指针均为线索
//将新结点插入到线索二叉搜索树HBT中
if(parent==NULL)
p->left=p->right=NULL;//作为树根结点插入
HBT=p;
elseif(item<parent->data)
p->left=parent->left;//作为左孩子结点插入
parent->ltag=false;//置双亲的左线索标志域为假
parent->left=p;//新结点链接为双亲的左孩子
p->right=parent;//双亲结点成为新结点的后继
else
p->right=parent->right;//作为右孩子结点插入
parent->rtag=false;//置双亲的右线索标志域为假
parent->right=p;//新结点链接为双亲的右孩子
p->left=parent;//双亲结点成为新结点的前驱
parent->rtag=false;//置双亲的右线索标志域为假
parent->right=p;//新结点链接为双亲的右孩子
p->left=parent;//双亲结点成为新结点的前驱
利用InsertThread1算法建立一棵带线索的二叉搜索树的算法如下。
voidCreateThread1(TTreeNode&HBT,ElemTypea[],intn)
//利用数组中的n个元素建立带线索的二叉搜索树的算法
HBT=NULL;
for(inti=0;i<n;i++)
InsertThread1(HBT,a[i]);
section6.4.2利用线索进行遍历
以中序线索为例来讨论这个问题。首先讨论一下如何在中序线索二叉树上寻找一个结点p（即指针p所指向的结点）的中序后继结点，它分为如下两种情况。
(1)若p结点的右线索标志域为真，则表明p->right为右线索，它直接指向p的中序后继结点。
(2)若p的右线索标志域为假，则表明p->right指向右孩子结点，p的中序后继结点必是其右子树中第一个中序遍历到的结点，因此从p的右孩子开始，沿左指针链往下查找，直到找到一个没有左孩子（即左线索标志域为1）的结点为止，该结点是p的右子树中“最左下”的结点，它就是p的中序后继结点。如图6-14所示，p的中序后继结点是R_k(kgeq1)，R_k可能是叶子结点，也可能是只含有右子树的单支结点；另外，若k=1，则表示p的右孩子R_1是p的中序后继结点。
(a)二叉树表示
(b)二叉链表表示
图6-14求中继后继结点示意图
根据以上分析，给出在中序线索二叉树上求结点p的中序后继的算法如下。
TTreeNodeInorderNext(TTreeNodep)//返回p结点的中继后继结点
if(p->rtag==true)
returnp->right;
else
p=p->right;
while(p->ltag==false)p=p->left;
returnp;
有了求中序后继结点的算法，就不难写出在中序线索二叉树上进行中序遍历的算法。此算法可叙述为：首先从根结点起沿左指针链往下查找，直到找到一个左线索标志域为真的结点为止，该结点的左指针域必为空，它就是整个中序序列的第一个结点；然后打印该结点，接着利用上述求中序后继结点的算法得到下一个结点，以此类推，直到中序后继结点为空时止。
设HBT为具有TTreeNode指针类型的一个值参，初始指向一棵中序线索二叉树的根结点，则对此树进行中序遍历的算法可描述如下。
voidThInorder(TTreeNodeHBT)//按中序线索遍历二叉树HBT
if(HBT!=NULL)
while(HBT->ltag==false)
HBT=HBT->left;//查找出中序遍历中的第一个结点
do
cout<<HBT->data<<'';//输出结点的值
HBT=InorderNext(HBT);//查找出HBT结点的中序后继结点
while(HBT!=NULL);//当HT为空时算法结束
利用线索进行二叉树遍历的时间复杂度为O(n)，空间复杂度为O(1)。实际运行时间要少于不加线索的情况。
以广义表形式输出一棵线索二叉树的算法如下。
voidPrintTTreel(TTreeNodeHBT)
if(HBT!=NULL)
cout<<HBT->data;//输出根结点的值
if(HBT->ltag==false||HBT->rtag==false)
cout<<'(';//输出左括号
if(HBT->ltag==false)
PrintTTreel(HBT->left);//输出左子树
if(HBT->rtag==false)
cout<<',';//若右子树不为空则首先输出逗号分隔符
PrintTTreel(HBT->right);//输出右子树
cout<<(')');//输出右括号
利用下面程序调试上述每个算法。
include<iostream.h>
include<stdlib.h>
typedefintElemType;//定义二叉树结点值的类型为整型
structTTreeNode
ElemTypedata;//值域
boolltag,rtag;//线索标志域
TTreeNodeleft;//左指针域
TTreeNoderight;//右指针域
;
include"线索二叉树运算.cpp"
voidmain()
TTreeNodehbt=NULL,pre=NULL,hbt1=NULL;
ElemTypea[10]=30,50,20,40,25,70,54,23,80,92;
CreateThreed(hbt,a,10);
InThread(hbt,pre);
PrintTTree1(hbt);cout<<endl;
cout<<"中序:";ThInorder(hbt);cout<<endl;
CreateThreed1(hbt1,a+3,7);
PrintTTree1(hbt1);cout<<endl;
cout<<"中序:";ThInorder(hbt1);cout<<endl;
该程序的运行结果如下:
30(20(,25(23)),50(40,70(54,80(,92))))中序:2023253040505470809240(25(23),70(54,80(,92)))中序:232540547080926.5平衡二叉树
平衡二叉树（balancedbinarytree）是对二叉搜索树的一种改进。二叉搜索树有一个缺陷，那就是树的结构事先无法预料，随机性很大，它只与结点的值和插入次序有关，往往得到的是一棵很不“平衡”的二叉树，即树的高度与相同结点数的理想平衡树相差甚远，在最坏的情况下，有可能变为一棵单支二叉树，其高度与结点数相同，相当于一个单链表，对其运算的时间复杂度由正常的O(logn)变为O(n)，从而部分或全部地丧失了利用二叉搜索树组织数据的优点。为了克服二叉搜索树的这个缺陷，需要在插入和删除结点时对树的结构进行必要的调整，使二叉搜索树的结构始终处于一种较平衡的状态，当然它没有理想平衡树那样绝对的平衡。若要使二叉搜索树调整成理想平衡树那样的结构，将会使调整运算变得很复杂，使调整带来的好处得不偿失。
subsection6.5.1平衡二叉树的定义
平衡二叉树简称平衡树，是由阿德尔森-维尔斯基和兰迪斯（Adelson-VelskiiandLandis）于1962年首先提出的，所以又称为AVL树。若一棵二叉树中每个结点的左、右子树的高度至多相差1，则称此树为平衡的。把二叉树中每个结点的左子树高度减去右子树高度定义为该结点的平衡因子（balancefactor）。因此，平衡树中每个结点的平衡因子只能是1、0或-1。如图6-15(a)所示是一棵平衡二叉树，如图6-15(b)和图6-15(c)所示分别是一棵非平衡树，每个结点上方所标数字为该结点的平衡因子。
n
(a)平衡二叉树
(b)非平衡二叉树例1
(c)非平衡二叉树例2
图6-15带平衡因子的二叉树
虽然平衡树的平衡性比理想平衡树要差一些，但理论上已经证明：具有n个结点的平衡树的高度在任何情况下决不会比具有相同结点数的理想平衡树高出45%以上。因此，在平衡树上进行查找运算虽比理想平衡树要慢一些，但通常比任意生成的二叉排序树快得多，当然，其时间复杂度的数量级表示仍为O(logn)。
当向一棵平衡树插入一个新结点时，插入后，某些结点的左、右子树的高度不变，就不会影响这些结点的平衡因子，因而也不会因为这些结点造成不平衡；若插入后某些结点的左子树高度增加1（右子树高度增加1的情况与之类似），则就影响了这些结点的平衡因子，具体分为如下3种情况。
(1)若插入前一部分结点的左子树高度h_L与右子树高度h_R相等，即平衡因子为0，则插入后将使平衡因子变为1，但仍符合平衡的条件，不必对它们加以调整。
(2)若插入前一部分结点的h_L小于h_R，即平衡因子为-1，则插入后将使平衡因子变为0，平衡更加改善，不必对它们进行调整。
(3)若插入前一部分结点的h_L大于h_R，即平衡因子为1，则插入后将使平衡因子变为2，破坏了平衡树的限制条件，需对它们加以调整，使整个二叉排序树恢复为平衡树。
若插入后，某些结点的右子树高度增加1，则也分为相应的3种情况，对于第1种情况，平衡因子将由0变为-1，不必进行调整；对于第2种情况是平衡因子由-1变为-2，则必须对它们进行调整；对于第3种情况是平衡因子由1变为0，平衡更加改善，也不必进行调整。
向平衡树中插入一个结点后破坏了其平衡性，首先要找出最小不平衡子树，然后再调整这个子树中有关结点之间的链接关系，使之成为新的平衡子树。当然，调整前后该子树的二叉搜索树性质不变，即调整前后得到的中序序列要完全相同。稍后便知，最小不平衡子树被调整为平衡子树后，原有其他所有不平衡子树无需调整，整个二叉搜索树就又成为一棵平衡树。
所谓最小不平衡子树是指以离插入结点最近、且平衡因子绝对值大于1的结点做根的子树。在图6-15(b)中，以值为30的结点做根的子树是该树的最小不平衡子树，分别以20和36做根的不平衡子树不是最小不平衡子树；在图6-15(c)中，以值为32的结点做根的子树是该树的最小不平衡子树，当然它也是唯一一个不平衡子树。
section6.5.2平衡二叉树的调整
为了便于讨论，不妨设最小不平衡子树的根结点用A表示，则调整该子树的操作可归纳为下列4种。
section1.LL型调整操作
在A结点的左孩子（用B表示）的左子树上插入结点，使得A结点的平衡因子由1变为2而引起的不平衡所进行的调整操作。调整过程如图6-16所示，图中用长方框表示子树，用长方框的高度表示子树的高度，用带阴影的小方框表示被插入的结点。图6-16(a)为插入前的平衡子树，alpha、beta和gamma的子树高度均为h（hgeq0，若h=0，则它们均为空树），A结点和B结点的平衡因子分别为1和0。图6-16(b)为在B的左子树alpha上插入一个新结点，
使以A为根的子树成为最小不平衡子树的情况。图6-16(c)为调整后成为新的平衡子树的情况。调整规则是：将A的左孩子B向右上旋转代替A成为原不平衡子树的根结点，将A结点向下旋转成为B的右子树的根结点，而B的原右子树β则作为A结点的左子树。此调整过程需要修改3个指针，如图6-16(c)中的箭头所示，一是将原指向结点A的指针修改为指向结点B；二是将B的右指针修改为指向结点A；三是将A的左指针修改为指向B的原右子树的根结点。另外，还需要修改A和B结点的平衡因子，应均被置为0。
(a)插入前
(b)插入后
(c)调整后
图6-16LL型调整操作示意图
从图6-16可以看出，调整前后对应的中序序列相同，即为αβBAγ，所以经调整后仍保持了二叉搜索树的特性不变。
如图6-17所示是LL型搜索调整的两个实例，其中，图6-17(a)、图6-17(b)、图6-17(c)为一例，此处A结点为9，B结点为6，α、β、γ均为空树；图6-17(d)、图6-17(e)、图6-17(f)为另一例，此处A结点为50，B结点为45，α、β、γ分别为只含有一个结点30、48、60的子树。
(a)插入前
(b)插入3后
(c)LL调整后
(d)插入前
(e)插入20后
(f)LL调整后
图6-17LL调整实例
2.RR型调整操作
在A结点的右孩子（用B表示）的右子树上插入结点，使得A结点的平衡因子由-1变为-2而引起的不平衡所进行的调整操作，调整过程如图6-18所示。图6-18(a)为插入前的平衡子树，alpha、beta、gamma子树的高度相同，均为h(hgeq0)，A结点和B结点的平衡因子分别为-1和0；图6-18(b)为在B结点的右子树gamma上插入一个新结点，使以A为根的子树成为最小不平衡子树的情况；图6-18(c)为调整后重新恢复平衡的情况。调整规则是：将A的右孩子B向左上旋转代替A成为原最小不平衡子树的根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树beta则作为A结点的右子树。此调整过程同LL型调整过程对称，要修改的3个指针如图6-18(c)中的箭头所示。同样，进行RR型调整前后，仍保持着二叉搜索树的特性不变。另外，在插入前和调整后，其子树高度均为h+2，由插入所引起的上层其他结点的不平衡将自动消失。
(a)插入前
(b)插入后
(c)调整后
图6-18RR型调整操作示意图
3.LR型调整操作
在A结点的左孩子（用B表示）的右子树上插入结点，使得A结点的平衡因子由1变为2而引起的不平衡所进行的调整操作，调整过程如图6-19所示。图6-19(a)为插入前的平衡子树，beta和gamma子树的高度均为h(hgeq0)，alpha和delta子树的高度均为h+1，特别地若alpha和delta子树为空树时，则B结点的右子树也同时为空，此时C结点将是被插入的新结点。插入前A结点和B结点的平衡因子分别为1和0，若C结点存在，则C结点的平衡因子为0。图6-19(b)为在B结点的右子树上插入一个新结点（当B的右子树为空时，则为C结点，否则为C的左子树或右子树上带阴影的结点，图中给出在左子树beta上插入的情况，若在右子树gamma上插入，情况类似），使得以A为根的子树成为最小不平衡子树的情况，此处A结点和B结点的平衡因子是按相反方向变化的，而不像前两种调整操作那样，都是按同一方向变化的。图6-19(c)为调整后的情况。调整规则是：将A的左孩子的右子树的根结点C提升到A结点的位置；将B结点作为C的左子树的根结点，而C结点的原左子树beta则作为B结点的右子树；将A结点作为C的右子树的根结点，而C结点的原右子树则作为A结点的左子树。此调整过程比前两种要复杂，需修改5个指针，如图6-19(c)中的箭头所示。
(a)插入前
(b)插入后
(c)调整后
图6-19LR型调整操作示意图
可以看出,调整前后对应的中序序列相同,即为alphamathrmBbetamathrmCgammamathrmAdelta,只是链接次序不同罢了,但没有影响其二叉搜索树的特性。另外，在插入前和调整后的子树高度不改变。
如图6-20所示是LR型调整操作的两个实例，其中图6-20(a)、图6-20(b)、图6-20(c)为一例,此处A结点为9,B结点为3,C结点为6,它是新插入的结点,alpha、beta、gamma、delta均为空树;图6-20(d)、图6-20(e)、图6-20(f)为另一例,此处A结点为85,B结点为74,C结点为80,alpha和delta子树分别只含有一个结点65和92,beta和gamma均为空。
(a)插入前
(b)插入6后
(c)LR调整后
(d)插入前
(e)插入78后
(f)LR调整后
图6-20LR型调整实例
4.RL型调整操作
在A结点的右孩子的左子树上插入结点,使A结点的平衡因子由-1变为-2而引起的
不平衡所进行的调整操作，调整过程如图6-21所示。它同mathrmLR型调整过程对称，请读者分析调整过程。
(a)插入前
(b)插入后
(c)调整后
图6-21RL型调整操作示意图
在上述每一种调整操作中，以A为根的最小不平衡子树的高度在插入结点前和调整后相同，因此对其所有祖先结点的平衡性不会产生任何影响，即原有的平衡因子不变。故按照上述方法将最小不平衡子树调整为平衡子树后，整个二叉搜索树就成为了一棵新的平衡树。
下面用一组关键字为(46,15,20,35,28,58,18,50,54)生成一棵平衡的二叉搜索树，生成过程如图6-22所示。
(a)插46(b)插15(c)插入20后LR
(d)插35(e)插入28后LL(f)插入58后RR
(g)插18(h)插入50后RL型调整(i)插54
图6-22建立平衡二叉树实例
在二叉搜索树的插入和删除运算中，采用平衡树的优点是：使树的结构较好，从而提高查找运算的速度。缺点是：使插入和删除运算变得复杂化，从而降低它们的运算速度。在每次插入或删除运算中，不仅要进行插入和删除结点的操作，而且要检查是否存在有最小不平衡子树，若存在，则需要对最小不平衡子树中有关指针进行修改。因此，采用平衡树，适合于那种对二叉搜索树一经建立就很少进行插入和删除运算，而主要是进行查找运算的应用场合。
对二叉搜索树删除结点而引起的不平衡而进行的调整操作比插入结点的情况还要复杂，当调整完最小不平衡子树后，还可能引起祖先结点中的不平衡，还需要继续向上调整。平衡二叉树的插入和删除算法是在二叉搜索树算法的基础上修改而成的，是比较复杂的，有关这方面的内容超出了教学要求，故本节不做介绍。
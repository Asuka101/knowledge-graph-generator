第5章树
section5.1树概念
subsection5.1.1树定义
树（tree）树形结构简称。它一种重要非线性数据结构。树或者一棵空树，即不含有任何结点（元素），或者一棵非空树，即至少含有结点。一棵非空树，它有且仅有称作根（root）结点，其余所有结点分为m棵(mgeq0)互不相交子树（即称做根的子树），每棵子树（subtree）又同样一棵树，并且每棵子树根结点整个树根结点后继，而整个树根结点又所有子树根结点前驱。显然，树定义递归，树是一种递归数据结构。树递归定义，将以后实现树各种运算提供方便。
一棵树T如图5-1(a)所示，它由根结点A两棵子树T1T2所组成，T1T2如图5-1(b)图5-1(c)所示；T1又由它根结点B三棵子树T11、T12T13所组成，这3棵子树分别对应如图5-1(d)、图5-1(e)图5-1(f)所示；T11T13只含有根结点，不含于子树（或者说子树为空树），不可再分；T12又由它根结点E两棵只含有根结点子树所组成，每棵子树根结点分别HI；T2由它根结点C一棵子树所组成，该子树也只含有根结点G，不可再分。
n
begincenter
includegraphics[width=0.8textwidth]image.png
endcenter
n
一颗树中，每个结点定义它每个子树根结点前驱，而它每个子树根结点就成为它后继。由此可用二元组给出树定义：texttree=(K,R)K=leftk_imid1leqileqn,ngeq0,k_iintextElemTyperight
其中,n为树中结点数,n=0则空树,n>0则非空树。对于一棵非空树,关系R应满足下列条件。
(1)有且仅有结点没有前驱,该结点称为树根。
(2)除树根结点外,其余每个结点有且仅有前驱结点。
(3)包括树根结点在内每个结点,可以有任意多个(含0个)后继。
上面树mathrmT若采用二元组表示,则结点集合KK上二元关系R分别:K=textA,B,C,D,E,F,G,H,Ir=<textA,B>,<textA,C>,<textB,D>,<textB,E>,<textB,F>,<textC,G>,<textE,H>,<textE,I>其中mathrmA结点无前驱结点,称为树根结点;其余每个结点有且仅有前驱结点;所有结点,mathrmB结点有三个后继结点,mathrmA结点mathrmE结点分别有两个后继结点,mathrmC结点有后继结点,其余结点均没有后继结点。
日常生活计算机领域,树结构广泛存在。
【例5-1】可把家族看作一棵树,树中结点家族成员姓名及相关信息,树中关系父子关系,即父亲儿子前驱,儿子父亲后继。一棵家族树,如图5.2(a)所示,王庭贵有两个儿子王万胜王万利,王万胜又有3个儿子王家新、王家王家国。
【例5-2】可把地区或单位组织结构看作一棵树,树中结点机构名称及相关信息,树中关系上下级关系。城市分为若干个区,每个区又分为若干个街道,每个街道又分为若干个居委会。
【例5-3】可把一本书结构看作一棵树,树中结点为书、章、节名称及相关信息,树中关系包含关系。一本书结构,如图5.2(b)所示,根结点书名称数学,它包含3章,每章名称分别加法、减法乘法,加法一章又包含两节,分别一位加两位,减法乘法也分别包含若干节。
【例5-4】可把算术表达式表示成一棵树,运算符作为根结点,它前后两个运算对象分别作为根左、右两棵子树。把算术表达式ab+(c-d/e)f表示成树,如图5-2(c)所示。
![图像内容]
(a)家族树
(b)书结构树
(c)算术表达式树
图5-2树应用例子
【例5-5】计算机领域,每个逻辑盘上信息组织目录结构就是一棵树,树中结点包含有目录名或文件名每个目录项或文件项,树中根目录用反斜线表示,根目录下包含有若干个子目录项文件项,每个子目录下又包含有若干个子目录项文件项,以
此类推，目录结构树如图5-3所示。
![目录结构树](attachment://image.png)
图5-3目录结构树
subsection5.1.2树表示
树表示方法有多种。图5-1、图5-2图5-3树形表示法其中一种，也最常用一种，图5-1图5-2结点从上向下展开，而图5-3结点是从左向右展开。树形表示法，结点之间关系通过连线表示，虽然每条连线上都不带有箭头（即方向），但它并不是无向，而是有向，其方向隐含从上向下或左向右，即连线上方或左边结点下方或右边结点前驱，下方或左边结点上方或右边结点后继。树另一种表示法二元组表示法。除这两种之外，通常还有3种：一是集合图表示，每棵树对应圆形，圆内包含根结点和子树，图5-1所示树T对应集合图表示如图5-4(a)所示；二是凹入表示，每棵树根对应着条形，子树根对应着较短条形，且树根上，子树根下，树T凹入表示，如图5-4(b)所示；三是广义表表示，每棵树根作为由子树构成表名字而放在表前面，图5-1树T广义表示如图5-4(c)所示。
![树其他几种表示](attachment://image2.png)
(a)集合图
(b)凹入表
A(B(D,E,(H,I),F),C(G))
(c)广义表
图5-4树其他几种表示
5.1.3树基本术语
1.结点度树度
每个结点具有子树数或者说后继结点数定义该结点度（degree）。树中所有结点度最大值定义该树度。图5-1树T，B结点度3，A、E结点度均2，C结点度1，其余结点度均0。因所有结点最大度为3，所以树T度3。
2.分支结点叶子结点
一棵树，度等于0结点称作叶子结点或终端结点，度大于0结点称作分支结点或非终端结点。分支结点，每个结点分支数就是该结点度数，对于度为1结点，其分支数为1，所以称之为单分支结点；对于度为2结点，其分支数为2，所以称之为双分支结点，其余类推。树T，D、H、I、F、G都叶子结点；A、B、C、E分支结点，其中C为单分支结点，AE双分支结点，B三分支结点。
3.孩子结点、双亲结点兄弟结点
一棵树，每个结点子树根，或者说每个结点后继，习惯地称为该结点孩子、儿子或子女（child），相应地，该结点称为孩子结点双亲、父亲或父母（parent）。具有同一双亲孩子互称兄弟（brothers）。结点所有子树结点称为该结点子孙。结点祖先则定义树根结点到达该结点路径上经过所有结点。树T，B结点孩子D、E、F结点，双亲A结点，D、E、F互为兄弟，B结点子孙D、E、H、I、F结点，I结点祖先A、B、E结点，对于树T其他结点亦可进行类似分析。
由孩子结点双亲结点定义可知，一棵树，根结点没有双亲结点，叶子结点没有孩子结点，其余结点既有双亲结点也有孩子结点。树T，根结点A没有双亲，叶子结点D、H、I、F、G没有孩子。
4.结点层数树深度
树既一种递归结构，也一种层次结构，树中每个结点都处在一定层数上。结点层数（level）树根开始定义，根结点第1层，它孩子结点第2层，以此类推。树中所有结点最大层数称为树深度（depth）或高度（height）。树T，A结点处于第1层，B、C结点处于第2层，D、E、F、G结点处于第3层，H、I结点所处第4层为树T所有结点最大层数，所以树T深度4。
5.有序树无序树
若树各结点子树按照一定次序左向右安排，则称之为有序树，否则称之为无序树。如图5-5两棵树，若看作无序树，则相同；n
若看作有序树，则不同，因为根结点A两棵子树次序不同。又，对于一棵反映父子关系家族树，兄弟结点之间按照排行大小有序，所以它一棵有序树。再，对于机关或单位机构设置树，若各层机构按照一定次序排列，则一棵有序树，否则一棵无序树。因为任何无序树都可以当作任一次序有序树来处理，所以以后若不特别指明，均认为树是有序。
6.森林
森林m(mgeqslant0)棵互不相交树集合。，对于树中每个分支结点来说，其子树集合就是森林。树T，由A结点子树所构成森林T1,T2，由B结点子树所构成森林T11,T12,T13。
section5.1.4树性质
【性质1】树中结点数等于所有结点度数加1。
证明：根据树定义，一棵树，除树根结点外，每个结点有且仅有前驱结点，也就是说，每个结点与指向它分支一一对应，所以除树根结点之外结点数等于所有结点分支数（即度数），从而可得树中结点数等于所有结点度数加1。
【性质2】度为k树第i层上至多有k^i-1个结点(igeqslant1)。
下面用数学归纳法证明：
对于第1层显然成立，因为树中第1层上只有结点，即整个树根结点，而由i=1代入k^i-1计算，也同样得到只有结点，即k^i-1=k^1-1=k^0=1；假设对于第i-1层(i>1)命题成立，即度k树第i-1层上至多有k^(i-1)-1=k^i-2个结点，则根据树度定义，度为k树每个结点至多有k个孩子，所以第i层上结点数至多第i-1层上结点数k倍，即至多k^i-2timesk=k^i-1个，这与命题相同，故命题成立。
【性质3】深度hk叉树至多有frack^h-1k-1个结点。
证明：显然当深度hk叉树（即度k树）上每一层都达到最多结点数时，所有结点总和才能最大，即整个k叉树具有最多结点数。sum_i=1^hk^i-1=k^0+k^1+k^2+cdots+k^h-1=frack^h-1k-1当一棵k叉树上结点数等于frack^h-1k-1时，则称该树为满k叉树。，对于一棵深度4满二叉树，其结点数为2^4-1，即15；对于一棵深度4满三叉树，其结点数为frac3^4-12，即40。
【性质4】具有n个结点k叉树最小深度leftlceillog_k(n(k-1)+1)rightrceil。
其中，公式两边符号表示对内部数值进行向上取整，即lceilxrceil取大于等于x最小整数，lceil4rceil、lceil4.3rceillceil5.6rceil值分别4、56。同样一对lfloorrfloor符号表示对内部数值进行向下取整，lfloorxrfloor取小于等于x最大整数，lfloor4rfloor、lfloor4.2rfloorlfloor5.8rfloor值分别4、45。
证明：设具有n个结点k叉树深度h，若该树中前h-1层都满，即每1层结点数都等于k^i-1个(1leqileqh-1)，第h层（即最后一层）结点数可能满，也可能不满，则该树具有最小深度。根据性质3，其深度h计算公式：frack^h-1-1k-1<nleqfrack^h-1k-1可变换k^h-1<n(k-1)+1leqk^h以k底取对数后得h-1<log_k(n(k-1)+1)leqh即log_k(n(k-1)+1)leqh<log_k(n(k-1)+1)+1因h只能整数，所以h=leftlceillog_k(n(k-1)+1)rightrceil因此得到具有n个结点一般k叉树最小深度leftlceillog_k(n(k-1)+1)rightrceil。
，对于二叉树，求最小深度计算公式leftlceillog_2(n+1)rightrceil，若n=20，则最小深度5；对于三叉树，求最小深度计算公式leftlceillog_3(2n+1)rightrceil，若n=20，则最小深度4。
section5.2二叉树
subsection5.2.1二叉树定义
二叉树（binarytree）指树度2有序树。它一种最简单、而且最重要树，计算机领域有着广泛应用。二叉树递归定义：二叉树或者一棵空树，或者一棵由根结点两棵互不相交分别称做根左子树右子树所组成非空树，左子树右子树又同样都一棵二叉树。
一棵二叉树BT如图5-6(a)所示，它由根结点A左子树BT₁、右子树BT₂所组成，BT₁BT₂分别如图5-6(b)图5-6(c)所示；BT₁又由根结点B左子树BT₁₁（只含有根结点D）、右子树BT₁₂（此为空树）所组成；对于BT₂树也可进行类似分析。
(a)
(b)
(c)
图5-6二叉树
二叉树，每个结点左子树根结点称之为左孩子（leftchild），右子树根结点称之为右孩子（rightchild）。二叉树BT，A结点左孩子B结点，右孩子C
结点：B结点左孩子D结点，右孩子为空，或者说没有右孩子；C结点左孩子En结点，右孩子F结点；F结点没有左孩子，右孩子G结点，D、E、G结点叶子结点，n其左、右孩子均空。
section5.2.2二叉树性质
二叉树具有下列一些重要性质。
【性质1】二叉树上终端结点数等于双分支结点数加1。
证明：设二叉树上终端结点数用n_0表示，单分支结点数用n_1表示，双分支结点数用nn_2表示，则总结点数n_0+n_1+n_2；另一方面，一棵二叉树，所有结点分支数（即度数）应等于单分支结点数加上双分支结点数2倍，即等于n_1+2n_2。由树性质1可得：n_0+n_1+n_2=n_1+2n_2+1quadtext即quadn_0=n_2+1，二叉树BT，度为2结点数为2个，度为0结点数为3个，它比度n2结点数正好多1个。
【性质2】二叉树上第i层上至多有2^i-1个结点（igeq1）。
证明：由树性质2可知，度为k树第i层上至多有k^i-1个结点。对于二叉树，树n度2，将k=2代入k^i-1即可得到此性质。
【性质3】深度h二叉树至多有2^h-1个结点。
证明：由树性质3可知，深度hk叉树至多有(k^h-1)/(k-1)个结点。对于二叉树，n树度2，将k=2代入(k^h-1)/(k-1)即可得到此性质。
一棵二叉树，当第i层结点数为2^i-1个时，则称此层结点数是满，当树n每一层都满时，则称此树为满二叉树。由性质3可知，深度h满二叉树结点数n2^h-1个。一棵深度4满二叉树，如图5-7（a）所示，其结点数为15。图中每个结点值用该结点编号来表示，编号树根1开始，按照层数从小到大、同一层n左到右次序进行。
一棵二叉树，除最后一层外，若其余层都满，并且最后一层或者满，或n者右边缺少连续若干个结点，则称此树为完全二叉树。由此可知，满二叉树完全二n叉树特例。一棵完全二叉树如图5-7（b）所示。它与高度满二叉树相比，最后一n层右边缺少5个结点。该树中每个结点上面数字对该结点编号，编号方法同n满二叉树。
(a)满二叉树
(b)完全二叉树
图5-7满二叉树完全二叉树
【性质4】对完全二叉树编号i结点（1leqileqn,ngeq1,n结点数）有如下性质。
(1)若编号i结点有左孩子，则左孩子结点编号2i；若编号i结点有右孩子，则右孩子结点编号2i+1。
(2)除树根结点外，若结点编号i，则它双亲结点编号i/2，也就是说，当i偶数时，其双亲结点编号i/2，它双亲结点左孩子；当i奇数时，其双亲结点编号(i-1)/2，它双亲结点右孩子。
(3)若ileqlfloorn/2rfloor，即2ileqn，则编号i结点分支结点，否则叶子结点。
(4)若n奇数，则每个分支结点都既有左孩子，又有右孩子；若n偶数，则编号最大分支结点（编号n/2）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。，图5-7(b)所示完全二叉树，因树中结点数n=10，所以编号小于等于5结点分支结点，大于5结点叶子结点。因n=10偶数，所以编号5结点E只有左孩子K，没有右孩子，其余分支结点（即编号1sim4结点）左、右孩子都有。对于编号2结点B来说，它左孩子编号4结点D，右孩子编号5结点E，它双亲编号1结点。对于树中其他结点也可进行类似分析。
有教科书，把完全二叉树结点编号0开始定义，这样对于具有n个结点完全二叉树来说，分支结点编号0simlfloorn/2rfloor-1，叶子结点编号lfloorn/2rfloorsimn-1；编号i左、右孩子结点编号分别2i+12i+2，双亲结点编号lfloor(i-1)/2rfloor。根据孩子结点编号i可推出双亲结点编号j，因为若i编号左孩子，则2j+1=i，j就等于(i-1)/2，其值整数，也可表示lfloor(i-1)/2rfloor；若i编号右孩子，则2j+2=i，j就等于i/2-1，因j只能整数，所以i必然偶数，则i/2-1值与lfloor(i-1)/2rfloor值相等。故对于除根结点之外任何编号i结点，其双亲结点编号必然lfloor(i-1)/2rfloor。
那么，又如何得到编号i左、右孩子结点编号2i+12i+2呢？这可用数学归纳法证明。当i等于0时，结论成立，根结点左、右孩子编号分别12，这与公式所求相同；对于编号i结点，其左、右孩子结点编号2i+12i+2成立，则对于编号i+1结点，其左、右孩子结点编号应为2(i+1)+12(i+1)+2，也可写成2(i+1)+12(i+1)+2，所以命题成立。
【性质5】具有n个(n>0)结点完全二叉树深度lceillog_2(n+1)rceil或lfloorlog_2nrfloor+1。
证明：设所求完全二叉树深度h，由完全二叉树定义可知，它前h-1层都满，最后一层可以满，也可以不满，由此得到如下不等式。2^h-1-1<nleq2^h-1可变换2^h-1<n+1leq2^h取对数后得h-1<log_2(n+1)leqh即log_2(n+1)leqh<log_2(n+1)+1因h只能取整数，所以h=lceillog_2(n+1)rceil完全二叉树深度h结点数n关系，还可表示2^h-1leqn<2^h取对数后得
h-1leqslantoperatornamelbn<h即operatornamelbn<hleqslantoperatornamelbn+1因h只能取整数,所以h=lflooroperatornamelbnrfloor+1一棵二叉树,若除最后一层外,其余层都满,而最后一层上结点可以任意分布,则称此树为理想平衡二叉树,简称理想平衡树或理想二叉树。显然,理想平衡树包含满二叉树完全二叉树。完全二叉树深度h结点数n之间关系,理想平衡树中同样成立,因为性质5证明结果实际上根据理想平衡树定义推导出来。如图5-8(a)所示一棵理想平衡树,但它不是完全二叉树;如图5-8(b)所示不是一棵理想平衡树,因它最后两层都未满。
![image](attachment://ideal_balanced_tree.png)
(a)理想平衡树
![image](attachment://ordinary_binary_tree.png)
(b)普通二叉树
图5-8理想平衡树普通二叉树
section5.2.3二叉树抽象数据类型
二叉树抽象数据类型数据部分一棵二叉树,操作部分包括初始化二叉树、建立二叉树、遍历二叉树、查找二叉树、输出二叉树清除二叉树一些常用操作。下面给出二叉树抽象数据类型具体定义。
DATABinaryTreeis
Data:
采用任一种方式存储二叉树,假定其存储类型用BTreeType标识符表示,
该类型对象(即二叉树)用BT标识符表示
Operations
voidInitBTree(BTreeType&BT);
//初始化二叉树,即把它置一棵空树
voidCreateBTree(BTreeType&BT,chara);
//根据广义表表示二叉树建立对应存储结构
boolEmptyBTree(BTreeType&BT);
//判断一棵二叉树是否为空,若则返回true,否则返回false
voidTraverseBTree(BTreeType&BT);
//按照一定次序遍历一棵二叉树,使得每个结点值均访问一次
boolFindBTree(BTreeType&BT,ElemType&item);
//二叉树查找值为item结点,若存在该结点则由item带回它完整值
//并返回true,否则返回false表示查找失败
```plaintext
intBTreeDepth(BTreeType&BT);
//求出一棵二叉树深度
voidPrintBTree(BTreeType&BT);
//按照树一种表示方法输出一棵二叉树
voidClearBTree(BTreeType&BT);
//清除二叉树所有结点,使之变为一棵空树
endBinaryTree
section5.2.4二叉树存储结构
同线性表一样,二叉树也有顺序链接两种存储结构。
section1.顺序存储结构
顺序存储一棵二叉树时,首先对该树每个结点进行编号,然后以各结点编号下标,把各结点值对应存储到一维数组。每个结点编号与深度满二叉树对应结点编号相同,即树根结点编号1,接着按照从上到下从左到右次序,若结点编号i,则左、右孩子编号分别2i2i+1。如图5-9所示二叉树,各结点上方数字就是该结点编号。
(a)完全二叉树
(b)一般二叉树
图5-9带结点编号二叉树
假定分别采用一维数组data1data2来顺序存储图5-9(a)图5-9(b)二叉树,则两数组各元素值如图5-10所示。
data1
|0|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|---|
||25|15|36|10|20|32|48|4|11|18|
data2
|0|1|2|3|4|5|6|7|8|9|10|11|12|13|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
||1|D|P|C|F|M|||E|H||N|
图5-10二叉树顺序存储结构
二叉树顺序存储结构,各结点之间关系通过下标计算出来,因此访问每结点双亲左、右孩子（若有的话）都非常方便。编号i结点（即下标i元素），其双亲结点下标lfloori/2rfloor；若存在左孩子，则左孩子结点下标2i；若存在右孩子，则右孩子结点下标2i+1。
```
二叉树顺序存储结构对于存储完全二叉树合适，它能够充分利用存储空间，但对于一般二叉树，特别对于那些单支结点较多二叉树来说很不合适，因为可能只有少数存储位置利用，而多数或绝大多数存储位置空闲着。因此，对于一般二叉树通常采用下面介绍链接存储结构。
section2.链接存储结构
二叉树链接存储，通常采用方法，每个结点设置3个域：值域、左指针域右指针域。其结点结构：beginarray|c|c|c|hlinetextleft&textdata&textrighthlineendarray其中，data表示值域，用来存储对应数据元素，leftright分别表示左指针域右指针域，用来分别存储左孩子右孩子结点存储位置（即指针）。
链接存储另一种方法：上面结点结构再增加parent指针域，用来指向其双亲结点。这种存储结构既便于查找孩子结点，也便于查找双亲结点，当然也带来存储空间相应增加。
对于如图5-11(a)所示二叉树，不带双亲指针链接存储结构（称作二叉链表）如图5-11(b)所示，其中f1指向树根结点指针，简称树根指针或根指针；带双亲指针链接存储结构（称作带双亲指针二叉链表）如图5-11(c)所示，其中f2树根指针。
(a)二叉树
(b)不带双亲指针链接存储结构
(c)带双亲指针链接存储结构
图5-11二叉树链接存储结构
同单链表相同，二叉链表既可由独立分配结点链接而成，也可由数组元素结点链接而成。若采用独立结点，则结点类型可定义：
structBTreeNode
ElemTypedata;
BTreeNodeleft;
BTreeNoderight;
;
若采用元素结点，则结点类型可定义：
structABTreeNode
ElemTypedata;
intleft,right;
;
元素结点，leftright域分别存储左、右孩子结点所在单元下标，所以定义整型。建立二叉链表而提供元素结点数组类型可定义：
typedefABTreeNodeABTList[BTreeMaxSize];
其中，BTreeMaxSize全局整型常量，其值由用户事先定义，由它决定建立二叉链表最大结点数。
设用ABTList类型一维数组存储图5-11（b）所示二叉链表，由于链接存储，结点之间逻辑关系通过指针实现，所以各结点数组占用下标位置可以按照任何一种次序安排，假定按照层数从小到大、同一层从左到右次序各结点分配存储位置，则得到该二叉链表存储映像，如图5-12所示。
data|0|1|2|3|4|5|6|7|8|9|10|BTreeMaxSize-1
:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
A|B|D|C|E|H|F|G|I|||
left|1|2|4|5|0|7|0|0|0|||
right|10|3|0|6|0|8|9|0|0|11|0|
图5-12利用数组建立二叉树链接存储结构
注意：元素结点下标1位置起使用，下标0位置左指针域通常用来存储树根指针，右指针域通常用来存储空链表表头指针，空闲链表由空闲结点right域链接而成。
数组建立二叉树好处：建立好后可以把整个数组写入到文件保存起来，当需要时再从文件整体读入到数组进行处理。
section5.3二叉树遍历
设二叉树由具有BTreeNode类型、通过动态分配产生独立结点链接而成，并设BT指向树根结点指针，树根指针出发可以访问到树每结点，所以可以用树根指针来指定一棵二叉树。
二叉树遍历二叉树最重要运算。二叉树遍历指按照一定次序访问树中所有结点，并且每个结点值仅访问一次过程。根据二叉树递归定义，一棵非空二叉
树由根结点、左子树右子树所组成，因此，遍历一棵非空二叉树问题可分解3个子问题：访问根结点、遍历左子树遍历右子树。若分别用D、LR表示上述3个子问题，则有DLR、LDR、LRD、DRL、RDL、RLD6种次序遍历方案。其中前3种方案都先遍历左子树，后遍历右子树，而后3种则相反，都先遍历右子树，后遍历左子树，由于二者对称，故我们只讨论前3种次序遍历方案。熟悉前3种，后3种也就迎刃而解。
遍历方案DLR，因为访问根结点操作遍历左、右子树之前，故称之为前序（preorder）遍历或先根遍历。类似地，LDR方案，访问根结点操作遍历左子树之后遍历右子树之前，故称之为中序（inorder）遍历或中根遍历；LRD方案，访问根结点操作遍历左、右子树之后，故称之为后序（postorder）遍历或后根遍历。显然，遍历左、右子树问题仍然遍历二叉树问题，当二叉树空时递归结束，所以很容易给出这3种遍历递归算法。
1.前序遍历算法
voidPreOrder(BTreeNodeBT)
if(BT!=NULL)
cout<<BT->data<<'';//访问根结点
PreOrder(BT->left);//前序遍历左子树
PreOrder(BT->right);//前序遍历右子树
2.中序遍历算法
voidInOrder(BTreeNodeBT)
if(BT!=NULL)
InOrder(BT->left);//中序遍历左子树
cout<<BT->data<<'';//访问根结点
InOrder(BT->right);//中序遍历右子树
3.后序遍历算法
voidPostOrder(BTreeNodeBT)
if(BT!=NULL)
PostOrder(BT->left);//后序遍历左子树
PostOrder(BT->right);//后序遍历右子树
cout<<BT->data<<'';//访问根结点
3种遍历算法，访问根结点操作可视具体应用情况而定，这里暂以打印根结点值代之。当然若结点值用户定义记录类型，则还必须依次输出结点值对象每个域值。
以中序遍历算法为例，结合如图5-13所示二叉树，分析其执行过程。
(a)二叉树
(b)链接存储结构
图5-13二叉树遍历
当其他函数调用（此次称为第0次递归调用）中序遍历算法时，需要以指向树根A结点指针mathrmAp作为实参，把它传递给算法值参mathrmBT，系统栈中应包括mathrmBT域返回地址r域，设进行第0次递归调用后返回地址r0，中序遍历左子树后返回地址（即执行cout语句地址）r1，中序遍历右子树后返回地址（即算法结束地址）r2，并设指向每个结点指针用该结点值后缀小写字母p表示，指向B结点指针就用mathrmBp表示，则每次进行递归调用时系统栈变化状态，如图5-14所示。
|BT|r|
|---|---|
|||
|||
|||
|Ap|r0|
(a)A进栈
|BT|r|
|---|---|
|||
|||
|||
|Bp|r1|
|Ap|r0|
(b)B进栈
|BT|r|
|---|---|
|||
|||
|Cp|r1|
|Bp|r1|
|Ap|r0|
(c)C进栈
|BT|r|
|---|---|
||r1|
|Cp|r1|
|Bp|r1|
|Ap|r0|
(d)空指针进栈
|BT|r|
|---|---|
||r2|
|Cp|r1|
|Bp|r1|
|Ap|r0|
(e)输出C
|BT|r|
|---|---|
|||
|Dp|r2|
|Bp|r1|
|Ap|r0|
(f)输出B
|BT|r|
|---|---|
||r1|
|Dp|r2|
|Bp|r1|
|Ap|r0|
(g)空指针进栈
|BT|r|
|---|---|
||r2|
|Dp|r2|
|Bp|r1|
|Ap|r0|
(h)输入D
|BT|r|
|---|---|
|||
|||
|Ep|r2|
|Ap|r0|
(i)输出A
|BT|r|
|---|---|
||r1|
|Fp|r2|
|Ep|r2|
|Ap|r0|
(j)空指针进栈
|BT|r|
|---|---|
||r2|
|Fp|r2|
|Ep|r2|
|Ap|r0|
(k)输入E
|BT|r|
|---|---|
|||
|Gp|r1|
|Fp|r2|
|Ep|r2|
|Ap|r0|
(l)G进栈
|BT|r|
|---|---|
||r1|
|Gp|r1|
|Fp|r2|
|Ep|r2|
|Ap|r0|
(m)空指针进栈
|BT|r|
|---|---|
||r2|
|Gp|r1|
|Fp|r2|
|Ep|r2|
|Ap|r0|
(n)输出G
|BT|r|
|---|---|
|||
|||
|||
|Ap|r0|
(o)输出F
(p)返回到其他函数
图5-14对图5-13所示二叉树执行中序遍历算法时系统栈变化状态
由上述分析中序遍历算法执行过程可知，打印出结点序列:
C,B,D,A,E,G,F
类似地，若按照前序遍历算法后序遍历算法遍历图5-13所示二叉树，则打印出结点序列分别:
A,B,C,D,E,F,GC,D,B,G,F,E,A
二叉树三种递归遍历算法，对于每个算法都访问到每个结点每域，并且每个结点每域仅访问一次。所以其时间复杂度均O(n)，n表示二叉树结点个数。另外执行每个递归遍历算法时，系统都要使用栈，栈最大深度等于二叉树深度加1，而二叉树深度视其具体形态决定，若二叉树理想平衡树或接近理想平衡树，则二叉树深度大致lceillog_2nrceil，所以其空间复杂度O(log_2n)；若二叉树退化一棵单支树（即最差情况），则空间复杂度O(n)，n同样二叉树结点数。
上面所述二叉树遍历按二叉树递归结构进行，另外，还可以按照二叉树层次结构进行遍历，即按照从上到下、同一层从左到右次序访问各结点。如图5-13所示二叉树，按层遍历各结点次序:
A,B,E,C,D,F,G
按层遍历算法需要使用队列，开始时把整个树根结点入队，然后每队列删除结点并输出该结点值时，都把它非空左、右孩子结点入队，这样当队列空时算法结束。
4.按层遍历算法
此算法非递归算法，具体描述如下。
voidLevelOrder(BTreeNodeBT)
//按层遍历由BT指针所指向二叉树
constintMaxSize=30;//定义用于存储队列数组长度
BTreeNodeq[MaxSize];//定义队列所使用数组空间
intfront=0,rear=0;//定义队首指针队尾指针，初始空队
BTreeNodep;
if(BT!=NULL)
rear=(rear+1)%MaxSize;
q[rear]=BT;//将树根指针进队
while(front!=rear)
front=(front+1)%MaxSize;//使队首指针指向队首元素
p=q[front];
cout<<p->data<<'';//输出队首元素所指结点值
if(p->left!=NULL)
rear=(rear+1)%MaxSize;
q[rear]=p->left;//若存在左孩子，则左孩子结点指针进队
if(p->right!=NULL)
//若存在右孩子,则右孩子结点指针进队
rear=(rear+1)%MaxSize;
q[rear]=p->right;
//whileend
这个算法，队列最大长度不会超过二叉树一层上最多结点数，定义队列数组时，要使数组长度大于队列最大长度，这样结点进队时肯定不会发生溢出，因此也就不需要判断是否队满。此算法时间复杂度O(n)，n表示二叉树结点个数。
section5.4二叉树其他运算
section1.初始化二叉树
voidInitBTree(BTreeNode&BT)//初始化二叉树,即把树根指针置空
BT=NULL;
section2.建立二叉树
二叉树输入格式不同，建立二叉树算法也不同，采用广义表表示输入法，二叉树广义表表示规定如下。
(1)每棵树根结点作为由子树构成表名字而放在表前面。
(2)每个结点左子树右子树用逗号分开，若只有右子树而没有左子树，则逗号不能省略。
，对于图5-11(a)所示二叉树，其广义表表示：A(B(C),D(E(F,G),H(I)))根据二叉树广义表表示建立二叉树链接存储结构基本思路：保存二叉树广义表字符串a输入每个字符，若遇到空格则不进行任何操作；若遇到字母（设以字母作为结点值），则表明结点值，应为它建立新结点，并把该结点（若它不是整个树根结点的话）作为左孩子（若k=1）或右孩子（若k=2）链接到其双亲结点上；若遇到左括号，则表明子表开始，应首先把指向它前面字母所在结点指针（即根结点指针）进栈，以便括号内子结点向双亲结点链接之用，然后把k置1，因为左括号后面紧跟着字母（若有的话）必为根结点左孩子；若遇到右括号，则表明子表结束，应退栈；若遇到逗号，则表明以左孩子为根子树处理完毕，应接着处理以右孩子为根子树，所以要把k置2。如此处理每字符，直到处理完所有字符为止。
建立二叉树算法描述如下。
voidCreateBTree(BTreeNode&BT,chara)
//根据字符串a所给出用广义表表示二叉树建立对应存储结构
constintMaxSize=10;//栈数组长度要大于等于二叉树深度减1BTreeNodes[MaxSize];//s数组作为存储根结点指针栈使用
inttop=-1;//top作为栈顶指针,初值-1,表示空栈
BT=NULL;//把树根指针置空,即空树开始
BTreeNodep;//定义p指向二叉树结点指针
intk;//用k作为处理结点左子树右子树标记
//k=1处理左子树,k=2处理右子树
inti=0;//用i扫描数组a存储二叉树广义表字符串
while(a[i])//每循环一次处理字符,直到扫描到字符串结束符'0'为止
switch(a[i])
case''://对空格不作任何处理
break;
case'(':
if(top==MaxSize-1)
cout<<"栈空间太小,请增加MaxSize值!"<<endl;
exit(1);
top++;s[top]=p;k=1;
break;
case')':
if(top==-1)
cout<<"二叉树广义表字符串错!"<<endl;exit(1);
top--;break;
case',':
k=2;break;
default:
p=newBTreeNode;
p->data=a[i];p->left=p->right=NULL;
if(BT==NULL)BT=p;//作为根结点插入
else
if(k==1)s[top]->left=p;//作为左孩子插入
elses[top]->right=p;//作为右孩子插入
//switchend
i++;//扫描下字符修改i值
这个算法，s栈最大深度等于二叉树深度减1，而二叉树深度则等于广义表表示圆括号嵌套最大层数加1。所以当定义s栈数组空间时，其长度（即下标上限
值）要大于等于二叉树深度减1。该算法时间复杂度O(n),n表示二叉树广义表中字符个数，由于平均每2sim3个字符具有元素字符，所以n也可以看作二叉树元素结点个数。
3.检查二叉树是否为空
boolEmptyBTree(BTreeNodeBT)
//判断一棵二叉树是否为空,若为空则返回true,否则返回false
returnBT==NULL;
4.求二叉树深度
若一棵二叉树为空，则它深度0，否则它深度等于左子树右子树中最大深度加1。设dep1左子树深度，dep2右子树深度，则二叉树深度:max(textdep1,textdep2)+1其中，max函数表示取参数大者。
求二叉树深度递归算法如下。
intDepthBTree(BTreeNodeBT)
if(BT==NULL)
return0;//对于空树,返回0并结束递归
else
intdep1=DepthBTree(BT->left);//计算左子树深度
intdep2=DepthBTree(BT->right);//计算右子树深度
if(dep1>dep2)
returndep1+1;//返回树深度
else
returndep2+1;
利用此算法求图5-13所示二叉树深度，则得到返回结果4。
5.二叉树查找值为x结点，若存在由x带回完整值并返回真，否则返回假
该算法类似于前序遍历算法。若树为空则返回false结束递归。若树根结点值就等于x值，则把结点值赋给x后返回true结束递归，否则先向左子树查找；若找到则返回true结束递归，否则再向右子树查找；若找到则返回true结束递归；若左、右子树均未找到则返回false结束递归。具体算法描述:
boolFindBTree(BTreeNodeBT,ElemType&x)
if(BT==NULL)returnfalse;//树为空返回假
else
```c
if(BT->data==x)/树根结点值等于x则由x带回结点值并返回真/
x=BT->data;returntrue;
else
/向左子树查找若成功则继续返回真/
if(FindBTree(BT->left,x))returntrue;
/向右子树查找若成功则继续返回真/
if(FindBTree(BT->right,x))returntrue;
/左、右子树查找均失败则返回假/
returnfalse;
6.输出二叉树
输出二叉树就是根据二叉树链接存储结构以某种树表示形式打印出来，通常采用广义表形式打印。用广义表表示一棵二叉树规则：根结点放在由左、右子树组成表前面，而表是用一对圆括号括起来。对于图5-13所示二叉树，其对应广义表表示：A(B(C,D),E(F(G)))因此，用广义表形式输出一棵二叉树时，应首先输出根结点，然后再依次输出它左子树右子树，不过输出左子树之前要打印出左括号，输出右子树之后要打印出右括号；另外，依次输出左、右子树要至少有不为空，若均空就没有输出必要。
由以上分析可知，输出二叉树算法可前序遍历算法基础上作适当修改后得到，具体给出如下。
voidPrintBTree(BTreeNodeBT)
//输出二叉树广义表表示
if(BT!=NULL)
cout<<'<'<<BT->data;//输出根结点值
if(BT->left!=NULL||BT->right!=NULL)
cout<<'(';//输出左括号
PrintBTree(BT->left);//输出左子树
if(BT->right!=NULL)
cout<<',';//若右子树不为空则首先输出逗号分隔符
PrintBTree(BT->right);//输出右子树
cout<<')';//输出右括号
7.清除二叉树，使之变为一棵空树
要清除一棵二叉树必须先清除左子树，再清除右子树，最后删除（即回收）根结点并
```
把指向根结点指针置空。由此可知它递归过程，类似于后序递归遍历。
voidClearBTree(BTreeNode&BT)
if(BT!=NULL)
ClearBTree(BT->left);//删除左子树
ClearBTree(BT->right);//删除右子树
deleteBT;//释放根结点
BT=NULL;//置根指针为空
采用下面程序上机调试对二叉树运算算法。
include<iostream.h>
include<stdlib.h>
typedefcharElemType;//定义二叉树结点值类型字符型
structBTreeNode
ElemTypedata;
BTreeNodeleft;
BTreeNoderight;
;
include"二叉树运算.cpp"//保存对二叉树各种运算算法
voidmain()
BTreeNodebt;//定义指向二叉树结点指针,并用它作为树根指针
InitBTree(bt);//初始化二叉树,即置树根指针bt为空
charb[50];//定义用于存放二叉树广义表字符数组
cout<<"输入二叉树用广义表表示字符串:"<<endl;
cin.getline(b,sizeof(b));//输入字符串放入b数组
CreateBTree(bt,b);//建立以bt作为树根指针二叉树链接存储结构
PrintBTree(bt);cout<<endl;//以广义表形式输出二叉树
cout<<"前序:";PreOrder(bt);cout<<endl;
cout<<"中序:";InOrder(bt);cout<<endl;
```cpp
//后序遍历以bt树根指针二叉树
cout<<"后序:";PostOrder(bt);cout<<endl;
//按层遍历以bt树根指针二叉树
cout<<"按层:";LevelOrder(bt);cout<<endl;
//查找以bt树根指针二叉树结点
ElemTypex;
cout<<"输入待查字符:";
cin>>x;
if(FindBTree(bt,x))cout<<"查找字符"<x<>"成功!"<<endl;
elsecout<<"查找字符"<x<>"失败!"<<endl;
//求出以bt树根指针二叉树深度
cout<<"深度:";cout<<DepthBTree(bt)<<endl;
//清除以bt树根指针二叉树
ClearBTree(bt);
屏幕显示结果如下。
输入二叉树用广义表表示字符串:
a(b(c),d(e(f,g),h(,i)))
前序:abcdefghi
中序:cbafegdhi
后序:cbfgeihda
按层:abdcehfgi
输入待查字符:f
查找字符f成功!
深度:4
section5.5树存储结构运算
subsection5.5.1树抽象数据类型
这里所说树指度大于等于3树，通常称为多元树或多叉树。
树抽象数据类型数据部分一棵普通k叉树GT，它可以采用顺序、链接任一种存储结构，设存储类型用GTREE标识符表示，操作部分包括初始化树、建立树、遍历树、查找树、输出树、清除树、判空树一些常用运算。下面给出普通树抽象数据类型具体定义。
DATGeneralTreeis
Data:
一棵普通树GT,存储类型用标识符GTREE表示
```
Operations
voidInitGTree(GTREE&GT);
//初始化树,即把它置一棵空树
voidCreateGTree(GTREE&GT,chara);
//根据广义表表示树建立对应存储结构
voidTraverseGTree(GTREEGT);
//按照一定次序遍历树,使得每个结点值均访问一次
boolFindGTree(GTREEGT,ElemType&item);
//从树中查找值为item结点,若存在该结点则由item带回
//它完整值并返回true,否则返回false表示查找失败
voidPrintGTree(GTREEGT);
//按照树一种表示方法输出一棵树
boolEmptyGTree(GTREEGT);
//判断树是否为空,若则返回true,否则返回false
voidClearGTree(GTREE&GT);
//清除树中所有结点,使之变为一棵空树
endGeneralTree
section5.5.2树存储结构
1.树顺序存储结构
树顺序存储结构需要使用一维数组,存储方法:首先对树中每个结点进行编号,然后以各结点编号下标,把结点值对应存储到相应元素。
若待存储树度k,即它一棵k叉树,则结点编号规则:树根结点编号1,然后按照从上到下、每一层再从左到右次序依次对每个结点编号。若结点编号i,则k个孩子结点编号依次ktimesi-(k-2),ktimesi-(k-3),cdots,ktimesi+1。对于3叉树,若双亲结点编号i,则3个孩子结点编号依次3timesi-1,3timesi,3timesi+1。又对于4叉树,若双亲结点编号j,则4个孩子结点编号依次4timesj-2,4timesj-1,4timesj,4timesj+1。
若k叉树结点编号j,则它父亲结点编号(j-2)/k+1,即等于j-2除以k得到整数商再加上1。如当k=3时,父结点编号(j-2)/3+1,若j=10,则父结点编号3。
树顺序存储适合满树完全树情况,否则将非常浪费存储空间。故实际应用很少使用,本节也不做深入讨论。
2.树链接存储结构
树链接存储结构通常采用如下3种方式。
(1)标准方式。
这种方式,树中每个结点除了包含有存储数据元素值域外,还包含有k个指针域,用来分别指向k个孩子结点,或者说,用来分别链接k棵子树,其中k树度。结点类型可定义:
structGTreeNode
ElemTypedata;//结点值域
GTreeNodet[k];//结点指针域t[0]~t[k-1],k事先定义常量
;
(2)广义标准方式。
广义标准方式标准方式每个结点增加指向其双亲结点指针域。结点类型可定义:
structPGTreeNode
ElemTypedata;//结点值域
PGTreeNodet[k];//结点指针域t[0]~t[k-1],k事先定义常量
PGTreeNodeparent//双亲指针
;
如图5-15(a)所示一棵三叉树,其存储结构标准形式如图5-15(b)所示;广义标准形式如图5-15(c)所示。
n
(a)三叉树
n
(b)标准形式
n
(c)广义标准形式
图5-15树标准形式广义标准形式存储结构
(3)二叉树方式。
二叉树方式指首先将树转换对应二叉树形式,然后再采用二叉链表存储这棵二叉树。
将树转换二叉树规则：将树每个结点第1个孩子结点转换二叉树对应结点左孩子，将第2个孩子结点转换左孩子右孩子，将第3个孩子结点转换这个右孩子右孩子。也就是说，转换后得到二叉树每个结点及右孩子，转换前树互为兄弟。对于图5-15(a)所示树，对应二叉树形式，如图5-16(a)所示；它二叉链表，如图5-16(b)所示。
![image](attachment://tree_conversion.png)
(a)二叉树形式
(b)二叉链表
图5-16树二叉树形式存储结构
树以上3种链接存储表示方式，标准方式广义表示方式能够表示任何树，但二叉树方式一般只适合表示无序树，不能表示任一结点缺少前面孩子，又存在后面孩子那样有序树。
当然，树还有其他一些表示方法，但都较少使用，故不作介绍。
subsection5.5.3树运算
树运算包括建立树存储结构、进行树遍历、从树中查找结点值、求树深度输出树。假定要讨论树k叉树，k事先定义整型符号常量，树存储结构采用标准链接方式。
section1.建立树存储结构
建立树存储结构就是内存生成一棵树标准方式存储映象，即k叉链表。同二叉链表生成过程一样，首先要确定输入树方法，然后再写出相应算法。仍采用广义表形式输入，对于图5-15所示三叉树，得到广义表表示：textA(B(D,E(H,J),F),C(G))其中，假定每个结点非空子树都靠前面、按序排列子树，把所有空子树都留在后面。实际情况可能会出现缺少前面子树而存在后面子树情况，此时用广义表示时空子树后面逗号不能省略。
树生成算法，需要设置两个栈，用来存储指向根结点指针，以便孩子结点向双亲结点链接之用；另用来存储待链接孩子结点序号，以便能正确地链接到双亲结点指针域。若这两个栈分别用sd表示，sd栈深度不会大于整个树深度。
树生成算法与二叉树生成算法类似，设结点值仍字符类型char，整个k叉树用广义表形式字符串a来表示，则具体算法描述如下。
voidCreateGTree(GTreeNode&GT,chara)
//根据广义表字符串a所给出k叉树建立对应存储结构
constintMS=10;//定义符号常量指定栈空间大小
GTreeNodes[MS];//s数组作为存储树中结点指针栈使用
intd[MS];//d数组作为存储孩子结点链接到双亲结点//指针域序号栈使用
inttop=-1;//top作为两个栈栈顶指针
GT=NULL;//给树根指针置空
GTreeNodep;//定义p指向树结点指针
inti=0;//用i指示扫描字符串数组a当前字符位置
while(a[i])
//每循环一次处理字符，直到字符串结束符为止
switch(a[i])
case'':break;//对空格不做任何处理
case'(':
top++;s[top]=p;d[top]=0;
//p指针进s栈，0进d栈，表明待扫描孩子结点//将链接到s栈顶元素所指结点第一个指针域
break;
case')':
top--;
//sd退栈
break;
case',':
d[top]++;
//待读入孩子结点将链接到s栈顶元素//所指结点下指针域
break;
default://此处处理必然字符元素
//根据a[i]字符生成新结点
p=newGTreeNode;
p->data=a[i];
for(inti=0;i<k;i++)p->t[i]=NULL;
//使p结点成为树根结点或链接到双亲结点对应指针域
if(GT==NULL)GT=p;
elses[top]->t[d[top]]=p;
i++;
//准备处理下字符
2.树遍历
树遍历包括先根遍历（或称深度优先遍历）、后根遍历按层遍历（或称广度优先遍历）3种。
先根遍历定义：先访问根结点，然后从左到右依次先根遍历每棵子树，此遍历过程递归过程。先根遍历图5-15所示树，得到结点序列：
ABDEHIFCG
后根遍历：从左到右依次后根遍历根结点每棵子树，然后再访问根结点，此遍历过程也递归过程。后根遍历图5-15所示树，得到结点序列：
DHIEFBGCA
按层遍历：先访问第1层结点（即树根结点），再从左到右访问第2层结点，依次按层访问，直到全树所有结点都访问为止，或者说直到访问完最深一层结点为止。按层遍历图5-15所示树，得到结点序列：
ABCDEFGHI
同二叉树先序遍历算法类似，树先根遍历算法如下。
voidPreRoot(GTreeNodeGT)//先根遍历一棵k叉树
if(GT!=NULL)
cout<<GT->data<<'';//访问根结点
for(inti=0;i<k;i++)
PreRoot(GT->t[i]);//递归遍历每子树
树后根遍历算法如下。
voidPostRoot(GTreeNodeGT)//后根遍历一棵k叉树
if(GT!=NULL)
for(inti=0;i<k;i++)
PostRoot(GT->t[i]);//递归遍历每子树
cout<<GT->data<<'';//访问根结点
树按层遍历算法，需要设置队列，假定用q表示，元素类型应定义结点指针类型GTreeNode，算法开始时将q初始化为空，接着若树根指针不为空则入队；然后每队列删除元素（即指向结点指针）时，都输出它值并且依次使非空孩子指针入队，这样反复进行下去，直到队列为空时止。此算法非递归算法，若使用队列采用现成顺序队列定义运算，算法具体描述如下。
voidLayerOrder(GTreeNodeGT)
//按层遍历由GT指针所指向k叉树
Queueq;//定义队列q,其元素类型应为GTreeNode
InitQueue(q);//初始化队列q
GTreeNodep;
if(GT!=NULL)EnQueue(q,GT);//非空树根指针进队
while(!EmptyQueue(q))//当队列非空时执行循环
p=OutQueue(q);//队列删除结点指针
cout<<p->data<<'';
for(inti=0;i<k;i++)
if(p->t[i]!=NULL)
EnQueue(q,p->t[i]);
3.从树中查找结点值
此算法要求:当树查找值为item结点时,若存在该结点则由item带回它完整值并返回true,否则返回false表示查找失败。此算法类似树先根遍历算法,它首先访问根结点,若相等则带回结点值并返回真,否则依次查找每个子树。具体算法描述如下。
boolFindGTree(GTreeNodeGT,ElemType&item)
if(GT==NULL)returnfalse;//树空返回假
else
if(GT->data==item)
item=GT->data;returntrue;
for(inti=0;i<k;i++)
if(FindGTree(GT->t[i],item))returntrue;
returnfalse;//查找不成功返回假
4.树输出
要求输出树广义表形式。此算法同样类似于树先根遍历算法,它首先输出树根结点值,然后若存在非空子树则接着输出表左括号及输出第一棵子树,再依次输出每个逗号每棵子树,最后输出表右括号。该算法描述如下。
voidPrintGTree(GTreeNodeGT)
//以广义表形式输出按标准方式存储k叉树
if(GT!=NULL)
cout<<GT->data<<'';//输出根结点值
```c
inti;
for(i=0;i<k;i++)
if(GT->t[i]!=NULL)break;
if(i<k)
cout<<'(';
PrintGTree(GT->t[0]);
for(i=1;i<k;i++)
cout<<',';
PrintGTree(GT->t[i]);
cout<<')';
5.求树深度
树为空则深度0，否则它等于所有子树最大深度加1。为此设置整型变量，用来保存已求子树最大深度，当所有子树都求过后，返回该变量值加1。具体算法描述如下。
intGTreeDepth(GTreeNodeGT)
if(GT==NULL)return0;
else
intmax=0;
for(inti=0;i<k;i++)
intd=GTreeDepth(GT->t[i]);
if(d>max)max=d;
returnmax+1;
6.清除树中所有结点，使之变为一棵空树
此算法类似于树后根遍历，首先依次删除树根结点所有子树，然后删除根结点并把指向根结点指针置空。该算法指向树根结点参数GT必须引用，这样才能作用于具体实参。具体算法描述如下。
voidClearGTree(GTreeNode&GT)
if(GT!=NULL)
for(inti=0;i<k;i++)ClearGTree(GT->t[i]);
deleteGT;
GT=NULL;
```
上面讨论树一些运算都需要访问树中所有结点，并且每个结点值仅访问一次，访问时也只是做些简单操作，所以每个算法时间复杂度均O(n)，其中n表示树中结点数。各算法空间复杂度最好情况O(logn)，最差情况O(n)。
用下面程序调试对一般树运算算法。
include<iostream.h>
include<stdlib.h>
constintk=3;//假定k定义常数3
typedefcharDataType;//为了与队列使用元素类型ElemType相区别,树中元素类型用标识符DataType表示
structGTreeNode//一般树中结点类型
DataTypedata;//结点值域
GTreeNodet[k];//结点指针域t[0]~t[k-1]
;
typedefstructGTreeNodeElemType;//定义队列元素类型
structQueue//队列顺序存储类型
ElemTypequeue;//指向存储队列数组空间
intfront,rear;//队首指针、队尾指针变量
intMaxSize;//queue数组长度
;
include"顺序队列运算.cpp"
include"一般树运算.cpp"//注意把查找算法ElemType修改DataType
voidmain()
GTreeNodegt;
InitGTree(gt);
charb[50];
cout<<"输入一棵"<k<广义表字符串;"<<endl;
cin.getline(b,sizeof(b));//键盘输入树广义表字符串
CreateGTree(gt,b);//建立k叉树链接存储结构
cout<<"先根遍历结果:";PreRoot(gt);cout<<endl;
cout<<"后根遍历结果:";PostRoot(gt);cout<<endl;
cout<<"按层遍历结果:";LayerOrder(gt);cout<<endl;
cout<<"按广义表形式输出k叉树为:";
PrintGTree(gt);
cout<<endl;
cout<<"树深度:";cout<<GTreeDepth(gt)<<endl;
cout<<"输入待查找字符:";
charch;cin>>ch;
if(FindGTree(gt,ch))cout<<"查找成功!"<<endl;
elsecout<<"查找失败!"<<endl;
ClearGTree(gt);
得到运行结果如下:
输入一棵3叉树广义表字符串：
a(b(e,f(j)),c,d(g(k,l),h,i))
先根遍历结果：abefjcdgklhi
后根遍历结果：ejfbcklghida
按层遍历结果：abcdefghijkl
按广义表形式输出k叉树为：aleft(bleft(_,e,fleft(_,j,_right)right),c,dleft(gleft(k,_,lright),h,iright)right)树深度：4
输入待查找字符：h
查找成功!
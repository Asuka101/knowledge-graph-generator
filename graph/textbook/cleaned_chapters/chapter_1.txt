第1章绪论
数据结构计算机科学与技术、软件开发与应用、网络安全、信息管理、电子商务相关专业一门专业基础课程，它专门研究解决现实问题抽象出来数据如何计算机系统很好地表示、存取处理方法。这里所说数居广义，它不仅包括数值数据、字符数据、逻辑数据简单数据，而且还包括带有一定结构各种复杂数据，字符串、记录、向量、矩阵、表格、图形、音频、视频数据。
用计算机存储数据不仅要存储数据值，而且要存储数据之间相互联系。如何存储它们之间联系将出现各种不同存储方法，总体上有顺序、链接、索引、散列4种。
对数据进行处理方法根据数据处理要求目标而决定，现在人们已经总结出比较常用有效、解决相应问题各种数据处理方法。掌握这些方法进行各种软件开发设计基础。有正确有效数据处理方法，还需要转换计算机上能够依次执行一系列步骤，才能够得到运行结果，达到目标。为此，必须事先掌握一种计算机语言，C或C++语言，用它来对数据处理方法过程加以描述，即编写出程序代码，从而计算机上调试运行，实现设计要求。
section1.1常用术语
这一节，将对本教材使用一些常用术语给予大致定义说明。
数据(data)人们利用便于书写、记忆交流符号对现实世界事物及其活动所做记录。数值、单词、一句话、一篇文章、一幅图画都称为数据。当然，若要利用计算机存储、处理加工数据，则必须按照一定规则对其进行二进制信息编码，变为二进制形式数据。
数据元素(dataelement)简称元素，它数据整体相对独立单位。对于一个二维表格数据来说，每行信息就是它数据元素；对于字符串数据来说，每个字符就是它数据元素；对于一维数组数据来说，每个下标位置所存储值就是它数据元素。数据数据元素相对而言。对于一条记录信息来说，它所属文件数据元素，而它相对于所含数据项而言又可看成数据。因此，本书，对数据数据元素这两个术语使用并不加以严格区别。
数据记录(datarecord)简称记录，它数据处理领域组织数据基本单位，数据每个数据元素许多应用场合都组织成记录结构。数据记录由或多个数据项(item)所组成，每个数据项可以简单数据项，即不可再分，数值、字符；也可以组合数据项，字符串、数组、记录、对象。如表1-1所示人事管理数据文件，每个记录表示职工有关信息，它由职工号、姓名、性别、出生年月、本单位工
龄、学历、职级7个数据项所组成。表中第1行为表头行或目录行，它给出该表中每条记录结构。表头行向下每一行为一条记录，它给出每个职工具体信息。
表1-1人事管理数据文件
|职工号|姓名|性别|出生年月|本单位工龄|学历|职级|
|--------|------|------|----------|------------|------|------|
|11001|张金雨|男|1965/05|20|大专|正科|
|11002|刘洪水|男|1952/07|15|本科|正处|
|11003|赵书琴|女|1973/12|12|研究生|副处|
|12001|尚明|男|1958/03|25|本科|副处|
|12002|沈芬|女|1964/06|20|中专|科员|
|13001|刘江河|男|1982/07|3|本科|科员|
|14001|胡丽|女|1977/10|4|研究生|副科|
表或文件，若所有记录某个数据项对应值均不同，则每个值就能够唯一地标识记录，把这个数据项称为表或文件关键数据项，简称关键项（keyitem），把关键项中每个值称为所在记录关键字（keyword或key）。表1-1，职工号数据项值均不同，所以可把职工号作为关键项，该项每个值就是所在记录关键字，11001就是第1条职工记录关键字，12002就是第5条记录关键字。
表或文件，能作为关键项数据项可能没有，可能只有，也可能多于。当没有时，可把多个有关数据项联合起来，构成组合关键项，用组合关键项中每组合值来唯一地标识记录，该组合值就是所在记录关键字。
引入关键项关键字后，以后讨论，经常利用关键项中所有值来代替所有记录，利用每个关键字来代表所在记录，而忽略其他非关键数据项。如表1-1数据可以简记(11001,11002,11003,12001,12002,13001,14001)，第2条记录可以简记11002。
数据处理(dataprocessing)指利用计算机对数据进行存储、检索、插入、删除、合并、拆分、排序、统计、计算、转换、输入、输出处理过程。学习程序设计语言数据结构知识进行计算机数据处理及各种应用开发软件基础。
数据结构(datastructure)指数据以及相互之间联系。它根据人们解决实际问题需要问题本身所含数据之间内在联系而抽象出来。这种数据结构与如何利用计算机存储处理无关，所以称为数据逻辑结构。数据逻辑结构包括集合、线、树、图基本结构，由它们组合嵌套可以形成较复杂结构。一种数据结构必须存储到计算机存储器中才能够利用计算机处理。存储数据结构有各种不同方法，大体上有顺序、链接、索引、散列基本方法，由它们不同组合嵌套可以形成各种更为复杂方法。每种存储方法都使数据存储器表现出相应结构，称此数据存储结构或物理结构。数据存储结构与其存储方法相对应，同样分为顺序、链接、索引、散列基本形式。一种数据逻辑结构可以根据处理问题需要选用任一种甚至几种存储结构进行存储。数据逻辑结构存储结构分别现实世界层面计算机世界层面上反映数据结构，有时统称它们数据结构，但一般所说数据结构指数据逻辑结构，不包含存储结构含义。
为了更确切地描述一种数据结构，通常采用二元组表示：
B=(K,R)B代表一种数据结构，它由数据元素集合KK上二元关系集合R所组成。其中K=leftk_imid1leqslantileqslantn,n>0rightR=leftr_jmid1leqslantjleqslantm,m>0right其中，k_i表示集合K第i个数据元素，nK数据元素个数，特殊情况下，若n=0，则K空集，此时B无结构，也可以说它具有任何结构；r_j表示集合R第j个二元关系（以后均简称关系），mR关系个数，特殊情况下，若m=0，则R空集，表明不考虑集合K元素之间存在着任何关系，彼此独立，就像数学集合里元素一样。本书所讨论数据结构，一般只讨论m=1情况，即R只包含关系(R=leftr_1right)情况。对于包含有多个关系数据结构，可分别对每关系进行讨论。K上关系r（以后直接用大写R表示）序偶集合。对于R任一序偶langlex,yrangle(x,yinK)，把x叫做序偶第一元素，把y叫做序偶第二元素，又称序偶第一元素第二元素直接前驱（简称前驱），称第二元素第一元素直接后继（简称后继）。langlex,yrangle序偶中，xy前驱，而yx后继。
一种数据结构还能够利用图形形象地表示出来，图形每个结点（又叫顶点）对应着数据元素，两结点之间带箭头连线（又称为有向边或弧）对应着关系序偶，其中序偶第一元素有向边起始结点，第二元素有向边终止结点，即箭头所指向结点。
根据某公司人事简表，构造出一些典型数据结构，如表1-2所示。
表1-2某公司人事简表
|职工号|姓名|性别|出生日期|职务|部门|
|---|---|---|---|---|---|
|01|万明华|男|1962-03-20|经理||
|02|赵宁|男|1968-06-14|主管|销售部|
|03|张利|女|1964-12-07|主管|财务部|
|04|赵书芳|女|1972-08-05|主任|办公室|
|05|刘永年|男|1959-08-15|科员|销售部|
|06|王明理|女|1975-04-01|科员|销售部|
|07|王敏|女|1972-06-28|科员|财务部|
|08|张才|男|1967-03-17|科员|财务部|
|09|马立仁|男|1975-10-12|科员|财务部|
|10|邢怀常|男|1976-07-05|科员|办公室|
表1-2中共有10条记录，每条记录都由6个数据项所组成，由于每条记录职工号各不相同，所以可把每条记录职工号作为该记录关键字，并下面例子，用记录关键字来代表整个记录。
【例1-1】一种数据结构set=(K,R)，其中K=01,02,03,04,05,06,07,08,09,10R=数据结构set，只存在元素集合，不存在关系集合，或者说关系为空，这表
明只考虑表1-2每条记录，而不考虑它们之间任何联系。具有这种特点数据结构称为集合结构，简称集合。对于集合结构，也可以看作按元素任意一种次序（先后位置有序）排列线性结构，存储空间可以根据需要按任一种存储方法进行存储。
【例1-2】一种数据结构linearity=(K,R)，其中K=01,02,03,04,05,06,07,08,09,10；R=langle05,01rangle,langle01,03rangle,langle03,08rangle,langle08,02rangle,langle02,07rangle,langle07,04rangle,langle04,06rangle,langle06,09rangle,langle09,10rangle对应图形如图1-1所示。
![图1-1数据线性结构示意图]
结合表1-2，可以看出：R按职工年龄从大到小排列关系。
linearity，每个数据元素有且仅有直接前驱元素（除结构第1个元素05外），有且仅有直接后继元素（除结构最后元素10外）。这种数据结构特点数据元素之间1对1（1:1）联系，即线性关系。将具有这种特点数据结构叫做线性结构，简称线。
【例1-3】一种数据结构tree=(K,R)，其中K=01,02,03,04,05,06,07,08,09,10；R=langle01,02rangle,langle01,03rangle,langle01,04rangle,langle02,05rangle,langle02,06rangle,langle03,07rangle,langle03,08rangle,langle03,09rangle,langle04,10rangle对应图形如图1-2所示。
![图1-2数据树形结构示意图]
结合表1-2可以看出：R人员之间领导与领导关系。
图1-2像倒着画一棵树，最上面没有前驱只有后继结点叫做树根结点，最下面一层只有前驱没有后继结点叫做树叶结点，除树根树叶之外结点叫做树枝结点（实际上，树根结点一种特殊树枝结点）。一棵树，每个结点有且只有前驱结点（除树根结点外），但可以有任意多个后继结点（树叶结点可看做具有0个后继结点）。这种数据结构特点数据元素之间1对N（1:N）联系（Ngeq0），即层次关系。将具有这种特点数据结构叫做树形结构，简称树。
【例1-4】一种数据结构graph=(K,R)，其中K=01,02,03,04,05,06,07；R=langle01,02rangle,langle02,01rangle,langle01,04rangle,langle04,01rangle,langle02,03rangle,langle03,02rangle,langle02,06rangle,langle06,02rangle,
<02,07>,<07,02>,<03,07>,<07,03>,<04,06>,<06,04>,<05,07>,<07,05>对应图形如图1-3所示。
从图1-3可以看出，RK上对称关系，即若存在langlex,yrangle，则必存在langley,xrangle与之对应。为了简化起见，把langlex,yranglelangley,xrangle这两个对称序偶用无序对(x,y)或(y,x)来代替；图形表示，把x结点y结点之间两条相反有向边用一条无向边来代替。这样R关系可改写：R=(01,02),(01,04),(02,03),(02,06),(02,07),(03,07),(04,06),(05,07)对应图形如图1-4所示。
如果说R每个序偶里两个元素所代表人员好友的话，那么r关系就是人员之间友好关系。
从图1-3或图1-4可以看出，结点之间联系M对N（Mgeqslant0,Ngeqslant0）联系，即网状关系。也就是说，每个结点可以有任意多个前驱结点任意多个后继结点。将具有这种特点数据结构叫做图形结构，简称图。
图形结构、树形结构线性结构定义可知，树形结构图形结构特殊情况（即M=1情况），线性结构树形结构特殊情况（即N=1情况）。为了区别于线性结构，将树形结构图形结构统称非线性结构。
【例1-5】一种数据结构B=(K,R)，其中K=k_1,k_2,k_3,k_4,k_5,k_6R=r_1,r_2r_1=langlek_3,k_2rangle,langlek_3,k_5rangle,langlek_2,k_1rangle,langlek_5,k_4rangle,langlek_5,k_6rangler_2=langlek_1,k_2rangle,langlek_2,k_3rangle,langlek_3,k_4rangle,langlek_4,k_5rangle,langlek_5,k_6rangle若用实线表示关系r_1，虚线表示关系r_2，则对应图形如图1-5所示。
从图1-5可以看出：数据结构B一种非线性图形结构。但是，若只考虑关系r_1则树形结构，若只考虑关系r_2则线性结构。
数据类型(datatype)对数据取值范围、数据元素之间结构以及允许施加操作一种总体描述。每一种计算机设计语言都定义有自己数据类型，一般有整数、实数（浮点数）、枚举、字符、字符串、指针、数组、记录、类、文件数据类型。整数类型计算机系统通常用两个字节或4个字节表示，若采用两个字节，则整数表示范围-2^15sim2^15-1，即-32768~32767之间；若采用4个字节，则整数表示范围-2^31sim2^31-1，即-2147483648~2147483647之间。对整数类型数据允许施加操作（运算）通常有：单目取正或取负运算，双目加、减、乘、除、取模运算双目等于、不等于、大于、大于等于、小于、小于等于关系（比较）运算以及赋值运算。字符类型计算机通常用字节或两个字节表示，无符号表示范围分别0~255或0~32767之间，能够分别至多对256或32768种字符进行编码。对字符类型数据允许进行操作主要赋值各种关系运算。字符串类型字符顺序排列线性结构，每具体字符串（其最大长度由具体语言规定）都字符串类型值，对字符串操作主要有求串长度、串复制、两串连接两串比较。
数据类型可分为简单类型结构类型两大类。任一种简单类型每个数据都无法再分割整体，整数、实数、字符、指针、枚举值、逻辑值都无法再分割整体。任一种结构类型都由简单类型数据按照一定规则构造而成，并且结构类型仍可以包含结构类型，所以一种结构类型数据（即结构数据）可以分解若干个简单数据或结构数据，每个结构数据仍可再分。数组就是一种结构类型，它由固定个数同一元素类型数据按线性结构排列而成，数组类型每数组值包含有固定个数同一类型数据，每个数据（元素）都可以通过下标运算符直接访问。记录也一种结构类型，它由固定个数不同（也可以相同）类型数组据线性结构排列而成，记录型每记录值包含有固定个数不同类型数据，每个数据（域）都可以通过成员运算符直接访问。
无论是简单类型还是结构类型都有“型”“值”概念，一种数据类型任一数据称为该类型值（又称为实例），该值（实例）与所属数据类型具有完全相同结构，数据类型所规定操作就是值上进行。所以一般叙述，并不明确指出“型”还是“值”，应根据实际情况加以理解，提到记录时，当讨论记录结构则认为记录型，当讨论具体一条记录则认为记录值。
抽象数据类型（AbstractDataType,ADT）由一种数据结构其上所有操作（运算）所组成。抽象数据类型包含有一般数据类型含义，但含义比一般数据类型更广、更抽象。一般数据类型通常由具体语言系统内部定义，直接提供给编程者定义数据并进行相应运算，因此称它们系统预定义数据类型。抽象数据类型通常由编程者根据已有数据类型定义，包括定义其所含数据（数据结构）这些数据上所进行操作。定义抽象数据类型时，就是定义其数据逻辑结构操作说明，不考虑数据存储结构操作具体实现（即具体操作代码），使得抽象数据类型具有很好通用性可移植性，便于用任何一种语言，特别面向对象语言实现。
抽象数据类型C++语言中是通过“类”类型来实现，其数据部分通常定义为类私有（private）或保护（protected）数据成员，它只允许给该类或派生类直接使用，操作
部分通常定义为类公共(public)成员函数,它既可以提供给该类或派生类使用也可以提供给其他类或函数使用,操作部分只给出操作说明(即函数声明),操作具体实现通常单独文件给出,使它与类定义(即声明)相分离,当然编译时将连接一起,类声明通常存放专门头文件(其扩展名为.h),这样能够较好地实现信息隐藏封装,符合面向对象程序设计(Object-OrientedProgramming,OOP)思想。
本书,为了更好地理解数据结构相应运算实现(即函数编程代码),采用传统记录结构类型来定义抽象数据类型数据(或称数据结构)部分,采用普通函数格式来定义抽象数据类型每个操作实现。虽然本书通常没有直接采用“类”类型来实现抽象数据类型,但读者通过学习后很容易做到,并且相配套实验教材《数据结构课程实验》,给出用类类型实现程序,有兴趣读者可以参考。
本书,描述每一种抽象数据类型将采用如下格式。
ADT<抽象数据类型名>is
Data:<数据描述>Operations:<操作声明>end<抽象数据类型名>【例1-6】把矩形定义及其运算设计成一种抽象数据类型,其数据部分包括矩形长度宽度,操作部分包括初始化矩形尺寸、求矩形周长面积。
假定该抽象数据类型名用RECTangle(矩形)表示,定义矩形长度宽度数据用lengthwidth表示,并假定其类型单精度浮点型(float),初始化矩形数据函数名用InitRectangle表示,求矩形周长函数名用Circumference(周长)表示,求矩形面积函数名用Area(面积)表示,则矩形ADT描述如下。
ADTRECTangleis
Data:
floatlength,width;
Operations:
voidInitRectangle(structRectangle&r,floatlen,floatwid);
floatCircumference(structRectangle&r);
floatArea(structRectangle&r);
endRECTangle
其中参数mathrmr类型名structRectangle表示用户定义记录(结构)类型,其保留字structC语言必须使用,而C++语言中则可省略不写。该类型包括矩形长度宽度两个域,用来统一描述此抽象数据类型所含数据部分,用C/C++语言定义如下。
structRectangle
floatlength,width;
;
初始化矩形数据函数定义如下。
voidInitRectangle(structRectangle&r,floatlen,floatwid)
r.length=len;/把len值赋给rlength域/
r.width=wid;/把wid值赋给rwidth域/
该函数把两个值参数lenwid值分别赋给引用参数rlength域width域，实现对矩形r初始化。求矩形周长求矩形面积函数分别定义如下。
floatCircumference(structRectangle&r)
return2(r.length+r.width);
floatArea(structRectangle&r)
returnr.lengthr.width;
这两个函数分别具有矩形引用参数（也可采用值参），调用执行后分别计算并返回引用矩形周长面积。
函数参数，有引用参数值参数之分，若参数类型参数名之间使用&符号，则就定义该参数引用参数，否则为值参数。对于引用参数，函数调用时，它看成对应调用参数（即实参）别名，函数访问它就是访问对应实参；对于值参数，当函数调用时，将它分配存储空间，并用对应实参值初始化，函数体中对值参数访问与对应实参无关，当函数调用结束后将自动释放掉为值参数所分配存储空间。C语言不能使用引用参数，它C++语言增加。通过C语言使用指针参数可以实现引用功能。可将上面求矩形面积函数修改如下。
floatArea(structRectangler)
returnr->lengthr->width;
若采用C++类来描述抽象数据类型RECTangle，则如下所示。
classRECTangle
private:
floatlength,width;
public:
RECTangle(floatlen,floatwid)
length=len;width=wid;
floatCircumference(void)
return2(length+width);
floatArea(void)
returnlengthwidth;
;
用C++语言编写出完整程序如下。
/程序1-1.cpp/
include<iostream.h>/C语言中用include<stdio.h>代替/
structRectangle
floatlength,width;
;
voidInitRectangle(Rectangle&r,floatlen,floatwid);/函数声明/
floatCircumference(Rectangle&r);/函数声明/
floatArea(Rectangle&r);/函数声明/
voidmain(void)
floatx,y;//用于键盘上输入矩形长宽
floatp,s;//用于保存矩形周长面积
Rectanglea;//定义矩形变量
cout<<"请输入矩形长宽!"<<endl;//输出提示信息
cin>>x>>y;//输入矩形长宽
InitRectangle(a,x,y);//对矩形a进行初始化
p=Circumference(a);//计算矩形a周长
s=Area(a);//计算矩形a面积
cout<<endl;
cout<<"矩形周长:"<p<<endl;//输出矩形周长
cout<<"矩形面积:"<s<<endl;//输出矩形面积
voidInitRectangle(Rectangle&r,floatlen,floatwid)
r.length=len;
r.width=wid;
floatCircumference(Rectangle&r)
return2(r.length+r.width);
floatArea(Rectangle&r)
returnr.lengthr.width;
C语言只能使用一种注释形式“/……/”，而C++语言中若注释行尾或者单独占据一行，则还可用双斜线“//”引出注释。
C++语言能够兼容C语言，也就是说，用C语言书写程序可以原封不动地C++语
言环境下运行，而C++语言对C语言做许多改进增强，输入、输出、参数定义、函数重载、运算符重载、模板、类方面，所以用C++语言编写程序不能C语言环境下运行。
对于上面程序，若要C语言环境下运行，除了修改输入、输出语句外，还要把引用参数修改指针参数，把对应实参修改为取地址表达式，以及把结构类型加上struct保留字。改写后得到C语言程序如下。
include<stdio.h>
structRectangle
floatlength,width;
;
voidInitRectangle(structRectangler,floatlen,floatwid);
floatCircumference(structRectangler);
floatArea(structRectangler);
voidmain()
floatx,y;
floatp,s;
structRectanglea;
printf("请输入矩形长宽!");
scanf("%f%f",&x,&y);
InitRectangle(&a,x,y);
p=Circumference(&a);
s=Area(&a);
printf("n");
printf("矩形周长:%fn",p);
printf("矩形面积:%fn",s);
voidInitRectangle(structRectangler,floatlen,floatwid)
r->length=len;
r->width=wid;
floatCircumference(structRectangler)
return2(r->length+r->width);
floatArea(structRectangler)
returnr->lengthr->width;
以后简便起见，一般使用C++语言进行算法描述，若读者只会使用C语言，则掌握上面所述差别后，不难把每个算法转换相应C语言算法。
数据对象(dataobject)简称对象，它属于一种数据类型特定实例，该数据类型既可以一般数据类型，也可以抽象数据类型。25整型数据对象，'A'字符数数据对象，语句charp定义p字符指针对象，可以用来指向字符串，inta[10]定义a含有10个整型数数组对象，structRectangler1定义r1Rectangle结构类型对象，RECTanglerec定义rec具有RECTangle抽象数据类型对象。
算法(algorithm)就是解决特定问题方法。描述算法可以采用文字叙述，也可以采用传统流程图、N-S图或PAD图，但要计算机上实现，则最终必须采用一种程序设计语言编写程序。作为算法应具备如下5个特性。
(1)有穷性。算法必须执行有穷步之后结束。
(2)确定性。算法每一步都必须具有确切含义，无二义性。
(3)可行性。算法每一步都必须可行，也就是说，每一步都能够通过手工或机器可以接受有限次操作有限时间内实现。
(4)输入。算法可以有0个、1个或多个输入量，算法执行之前提供给算法。
(5)输出。算法执行结束后至少要有输出量，它利用算法对输入量进行运算处理结果。
需要人们解决特定问题可分为数值非数值两类。解决数值问题算法叫做数值算法，科学工程计算方面算法大都属于数值算法，求解数值积分、求解线性方程组、求解代数方程求解微分方程。解决非数值问题算法叫做非数值算法，数据处理方面算法大都属于非数值算法，各种数据结构上进行排序算法、查找算法、插入算法、删除算法遍历算法。数值算法非数值算法并没有严格区别，一般说来，数值算法主要进行算术运算，而非数值算法，则主要进行比较逻辑运算。另一方面，特定问题可能递归，也可能是非递归，因而解决它们算法就有递归算法非递归算法之分。当然，理论上讲，任何递归算法都可以通过使用循环、堆栈技术转化非递归算法。
计算机领域，算法实质上针对所处理问题需要，数据逻辑结构存储结构基础上施加一种运算。由于数据逻辑结构存储结构不是唯一，很大程度上可以由用户自行选择设计，所以处理同一个问题算法也不是唯一。另外，即使对于具有相同逻辑结构存储结构而言，其算法设计思想技巧不同，编写出算法也大不相同。学习数据结构课程目的，就是学会根据数据处理问题需要，待处理数据选择合适逻辑结构存储结构，进而按照结构化、模块化以及面向对象程序设计方法设计出比较满意算法（程序）。
section1.2算法描述
算法就是解决特定问题方法，该方法可以借助各种工具描述出来。n个整数元素查找出最大值，用流程图描述则如图1-6所示。
图1-6求n个元素最大值
若采用文字描述，则下列步骤所示。
(1)给n个元素a_1sima_n输入数值。
(2)把第1个元素a_1赋给用于保存最大值元素变量x。
(3)把表示下标的变量i赋初值2。
(4)如果i<=n，则需要向下执行来处理当前数据元素a_i，否则输出最大值x后结束算法。
(5)如果a_i>x，则将a_i赋给x，否则不改变x值，这使得x始终保存着当前比较所有元素最大值。
(6)使下标i增1，以指示下元素。
(7)转向第(4)步继续执行下一次循环处理过程。
若要计算机上实现算法，则最终必须采用一种程序设计语言进行描述。对于上述算法，采用C++语言描述如下。
```cpp
//程序1-2.cpp
include<iostream.h>
constintn=10;//假定n等于10
voidmain(void)
inti,x,a[n];//用a[0]~a[n-1]保存a1~an元素
cout<<"请输入10个整数：";
for(i=0;i<n;i++)
cin>>a[i];
```
x=a[0];i=1;
while(i<n)
if(a[i]>x)x=a[i];
i++;
cout<<"10个整数最大值:"<<x<<endl;
本书对所有算法一般采用文字C++语言两种描述,文字描述给出算法思路执行步骤,C++语言描述给出机器上实现代码。
section1.3算法评价
对于解决同一个问题,往往能够编写出许多不同算法。,对于数组排序问题,就能够根据不同排序方法对应编写出各不相同多种算法。进行算法评价目的,既在于解决同一问题不同算法选择出较为合适一种,也在于知道如何对现有算法进行改进或者独立创新,从而设计出更好算法。一般如下5个方面对算法进行评价。
section1.正确性
正确性(correctness)设计评价算法首要条件,如果算法不正确,即不能完成或不能较好地完成所要求任务,其他方面也就无从谈起。正确算法指合理数据输入下,能够有限运行时间内得出正确结果。通过采用各种典型输入数据上机反复调试算法,使得算法每段代码都测试,若发现错误及时修正,最终可以验证出算法正确性。当然,要理论上证明算法正确性,并不是一件容易事,也不属于本课程所研究范围,故不进行讨论。
section2.稳健性
稳健性(robustness)指算法对不合理（又称不正确、非法、错误）数据输入反应处理能力。好算法应该能够识别错误数据并进行相应处理。对错误数据处理一般包括打印错误信息、调用错误处理程序、返回标识错误特定信息、中止程序运行。
section3.可读性
可读性(readability)指算法供人们阅读容易程度。可读性好算法,应该使用便于识别记忆、与描述事物或实现功能相一致标识符,应该符合结构化模块化程序设计思想,应该对其中每个功能模块、重要数据类型或语句加以注释,应该建立有相应文档,对整个算法功能、结构、使用及有关事项进行说明。
section4.时间复杂度
时间复杂度(timecomplexity)或称时间复杂性,又称计算复杂度(computational
complexity),它算法有效性量度之一,量度有效性另指标空间复杂度。时间复杂度算法运行时间相对度量。算法运行时间指计算机上开始到结束运行所花费时间长短,它大致等于计算机执行一种简单操作(赋值、比较、计算、转向、返回、输入输出)所需时间与算法进行简单操作次数乘积。因为执行一种简单操作所需时间随机器而异,它由机器本身硬件环境决定,与算法无关,所以只讨论影响运行时间另因素——算法进行简单操作次数多少。
不管算法简单还是复杂,最终都编译后分解成简单操作再通过CPU来具体执行。因此,每个算法都对应着一定简单操作次数。显然,算法,进行简单操作次数越少,其运行时间也就相对越短;次数越多,其运行时间也就相对越长。所以,通常把算法包含简单操作次数多少叫做该算法时间复杂度,用它来衡量算法运行时间性能(或称计算性能)。
若解决问题规模n,即所处理数据包含有n个元素,则算法时间复杂度通常n函数,假定记为f(n)。下面通过例子来分析算法时间复杂度。
【算法1-1】累加求和。
intSum(intb[],intn)
inti,s=0;
for(i=0;i<n;i++)
s+=b[i];
returns;
计算机执行这个算法时,函数体中第1条定义并赋初值语句第3条返回语句都各执行一次简单操作,第2条for循环语句所包含简单操作次数可进行如下分解计算。
i=0;//1次
mark1:if(i>=n)gotomark2;//n+1次
s+=b[i];//n次
i++;//n次
gotomark1;//n次
mark2:returns;
把第2条语句分解后每一条简单语句执行次数加起来,就得到它包含简单操作次数,即为4n+2。因此,算法1-1时间复杂度:f(n)=4n+4【算法1-2】矩阵相加。
voidMatrixAdd(inta[MS][MS],intb[MS][MS],intc[MS][MS],intn)
//实现矩阵a[n,n]b[n,n]加法,其存入c[n,n]
//MS大于等于n常量
inti,j;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
c[i][j]=a[i][j]+b[i][j];
运行此算法需要执行简单操作次数就等于双重for循环语句所包含简单操作次数，对该语句可进行如下分解计算。
i=0;//1次
mark1:if(i>=n)gotomark4;//n+1次
j=0;//n次
mark2:if(j>=n)gotomark3;//(n(n+1))次
c[i][j]=a[i][j]+b[i][j];//nn次
j++;//nn次
gotomark2;//nn次
mark3:i++;//n次
gotomark1;//n次
mark4:;
把分解后每一条简单语句执行次数加起来，就得到它所包含简单操作次数。因此，算法1-2时间复杂度:f(n)=4n^2+5n+2【算法1-3】简单选择排序。
voidSelectSort(intb[],intn)
inti,j,k,x;
for(i=0;i<n-1;i++)
k=i;
for(j=i+1;j<n;j++)
if(b[j]<b[k])k=j;
x=b[i];
b[i]=b[k];
b[k]=x;
此算法包含有双重for循环，外层for循环循环变量i，它0取值到n-2，对于i每一取值，首先通过k=i赋初值语句内层for循环语句，b[i]~b[n-1]之间顺序查找出具有最小值元素b[k]，然后通过3条赋值语句交换b[i]b[k]值，使得b[i]b[i]~b[n-1]之间最小值。这样，当算法执行结束后，数组bn个元素就按照其值从小到大次序排列好。
要计算出该算法包含简单操作次数，可将双重for循环语句分解如下:
i=0;//1次
mark1:if(i>=n-1)gotomark4;//n次
k=i;//n-1次
j=i+1;//n-1次
mark2:if(j>=n)gotomark3;/sum_i=0^n-2(n-i)=(n+2)(n-1)/2次
if(b[j]<b[k])k=j;/sum_i=0^n-2(n-i-1)=n(n-1)/2次
j++;/n(n-1)/2次
gotomark2;/n(n-1)/2次
mark3:x=b[i];/n-1次
b[i]=b[k];/n-1次
b[k]=x;/n-1次
i++;/n-1次
gotomark1;/n-1次
mark4:;
把分解后每一条简单语句执行次数加起来，就得到它所包含简单操作次数。算法1-3时间复杂度：f(n)=2n^2+7n-7以上分析可以看出，算法时间复杂度计算相当繁琐，特别对于较复杂算法更是如此。实际上，一般也没有必要精确地计算出算法时间复杂度，只要大致计算出相应数量级(order)即可。下面接着讨论时间复杂度f(n)数量级表示。
设f(n)辅助函数g(n)，定义当n大于等于某一足够大正整数n_0时，存在着两个正常数AB（其中A≤B），使得A≤fracf(n)g(n)≤B均成立，则称g(n)f(n)同数量级函数。把f(n)表示成数量级形式：f(n)=O(g(n))其中，大写字母O英文order（即数量级）一词第1个字母。这种表示意思指g(n)同f(n)只相差常数倍。
，算法1-1，当n≥1（即取n_01）时，4≤frac4n+4n≤8均成立，则g(n)=n；算法1-2，当n≥2（即取n_02）时，4≤frac4n^2+5n+2n^2≤7均成立，则g(n)=n^2；对于算法1-3，当n≥3（即取n_03）时，2≤frac2n^2+7n-7n^2≤4均成立，则g(n)也等于n^2。由此不难发现，当f(n)n多项式时，g(n)则f(n)最高次幂，它与f(n)其余项最高次幂系数都无关。若把算法1-1、算法1-2算法1-3时间复杂度分别用数量级形式表示，则分别O(n)、O(n^2)O(n^2)。
算法时间复杂度采用数量级形式表示后，将给求算法f(n)带来很大方便，这时只需要分析影响算法时间复杂度主要部分即可，不必对每一步都进行详细分析；同时，对主要部分分析也可简化，一般只要分析清楚循环体内简单操作执行次数或递归函数调用次数即可。，对于算法1-1，只要根据for循环循环体执行次数n，就可求出其时间复杂度O(n)；对于算法1-2，只要弄清楚双重循环内赋值操作执行次数n^2，就可求出其时间复杂度O(n^2)；对于算法1-3，只要能够求出内层for循
环体执行次数sum_i=0^n-2(n-i-1)=frac12n(n-1)=frac12n^2-frac12n，就可得到其时间复杂度O(n^2)。
算法时间复杂度通常具有O(1)、O(sqrtn)、O(n)、O(lgn)、O(ntimeslgn)、O(n^2)、O(n^3)、O(2^n)O(n!)形式。O(1)表示算法时间复杂度常量，它不随数据量n改变而改变，访问数据表第1个元素时，无论该表大小如何，其时间复杂度均O(1)。O(sqrtn)表示算法时间复杂度与数据量大小n平方根成正比，计算满足不等式sum_k=1^ikleqn最大i值时，其算法时间复杂度就是O(sqrtn)。这是因为计算i时间复杂度f(n)left[sqrt2n+frac14-frac12right]，对应g(n)sqrtn。具有O(n)数量级算法称为线性算法，其运行时间与n成正比，如对表进行顺序查找时，其时间复杂度就是O(n)。有一些算法时间复杂度O(lgn)，即与n对数成正比，有序表上进行二分查找算法就是如此。对数组进行排序各种简单算法O(n^2)数量级，当n加倍时，其运行时间将增长4倍；对数组进行排序各种改进算法O(ntimeslgn)数量级，当n加倍时，其运行时间只是原来2left(1+frac1lgnright)倍。做两个n阶矩阵乘法运算时，其时间复杂度O(n^3)。求具有n个元素集合所有子集算法，其时间复杂度应为O(2^n)，因为对于含有n个元素集合来说，共有2^n个不同子集。求具有n个元素全排列算法时间复杂度O(n!)，因为它共含有n!种不同排列。
对于不同n值，各种典型数量级所对应值如表1-3所示。可以看出，当n较大时，若时间复杂度指数或阶乘数量级，则相应算法无效，即不能实际运行。假定一台计算机每秒能做1亿次简单操作，则对于n值为32具有阶乘数量级算法，则至少要运行8.34times10^17个世纪才能完成，这显然不可能实现，无效算法。从表中还可以看出，当n大于一定值后，随着n值增大，各种数量级对应值增长速度大不相同，对数值增长速度最慢，平方根稍快，线性值较快，其余依次线性与对数乘积、平方、立方、指数阶乘，即阶乘增长速度最快。，当n增长到两倍时，lgn增长到1.25倍，sqrtn增长到约1.4倍，ntimeslgn增长到2.5倍，n^2增长到4倍，n^3增长到8倍，2^n增长到2^2n倍，n!增长到(2n)!倍。因此，当n大于一定值后，各种不同数量级对应值存在着如下关系：O(lgn)<O(sqrtn)<O(n)<O(ntimeslgn)<O(n^2)<O(n^3)<O(2^n)<O(n!)表1-3算法复杂度不同数量级变化对照表
|n|lgn|sqrtn|ntimeslgn|n^2|n^3|2^n|n!|
|-----|---------|-----------|---------------|-------|-------|-------|------|
|4|2|2|8|16|64|16|24|
|8|3|2.83|24|64|512|256|80320|
|10|3.32|3.16|33.2|100|1000|1024|3628800|
|16|4|4|64|256|4096|65536|2.1×10^13|
|32|5|5.66|160|1024|32768|4.3×10^9|2.6×10^35|
|128|7|11.31|896|16384|2097152|3.4×10^38|∞|
|1024|10|32|10240|1048576|1.07×10^9|∞|∞|
|10000|13.29|100|132877|10^8|10^12|∞|∞|
算法时间复杂度还可以具体分为最好、最差（又称最坏）平均3种情况讨论。下面结合一维数组a[n]顺序查找其值等于给定值item元素算法进行说明。
intSequenceSearch(inta[],intn,intitem)
//若查找成功则返回元素下标，否则返回-1
for(inti=0;i<n;i++)
if(a[i]==key)returni;
return-1;
此算法时间复杂度主要取决于for循环体反复执行次数。最好情况第1个元素a[0]值就等于item，此时只需要进行元素一次比较就查找成功，相应时间复杂度O(1)；最差情况最后元素a[n-1]值等于item，此时需要进行同全部n个元素比较才能查找成功，相应时间复杂度O(n)；平均情况：每元素都有相同概率left(text即均frac1nright)等于给定值item，则查找成功需要同元素进行比较平均次数frac1nsum_i=1^ni=frac12(n+1)，相应时间复杂度O(n)，它同最坏情况具有相同数量级，因为它们之间比较次数只系数项常数项上有差别，而n指数上没有差别。
当数组a上顺序比较n个全部元素后仍找不到等于给定值item元素，则表明查找失败，这种情况所对应时间复杂度也O(n)。
算法，最好情况时间复杂度最容易求出，但它通常没有多大实际意义，因为数据一般都随意分布，出现最好情况分布概率极小；最差情况时间复杂度也容易求出，它比最好情况有实际意义，通过它可以估计到算法运行时所需要相对最长时间，并且能够使用户知道如何设法改变数据排列次序，尽量避免或减少最差情况发生；平均情况下时间复杂度计算要困难一些，因为它往往需要概率统计方面数学知识，有时还需要经过严格理论推导才能求出，但平均情况时间复杂度最有实际意义，它确切地反映运行算法平均快慢程度，通常就用它来表示算法时间复杂度。对于大多数算法来说，平均最差这两种情况下时间复杂度数量级形式往往相同，它们主要差别最高次幂系数上。另外有一些算法，其最好、最差平均情况下时间复杂度或相应数量级都相同，对于介绍算法1-1、算法1-2算法1-3就是如此。
5.空间复杂度
空间复杂度(spacecomplexity)或称空间复杂性对算法运行过程临时占用存储空间大小量度，它也衡量算法有效性指标。算法计算机存储器上所占用存储空间，包括存储算法本身所占用存储空间、算法输入/输出数据所占用存储空间算法运行过程临时占用存储空间3个方面。
算法输入/输出数据所占用存储空间由要解决问题所决定，通过参数表由
调用函数传递来,对于引用参数将不占有这方面空间,而对于值参数将占有这方面空间。所以允许情况下，尽量采用引用参数或指针参数，减少使用值参数，对于数据类型长度较大参数更应如此。
存储算法本身所占用存储空间与算法书写长短成正比,要压缩这方面存储空间,就必须编写出较短算法,编写成递归算法通常就比相应非递归算法要短。
算法运行过程临时占用存储空间随算法不同而异,有算法只需要占用少量临时工作单元,而且不随问题规模大小而改变,称这种算法“就地”进行,节省存储算法,如本节介绍几个算法都如此。有算法需要占用临时工作单元数与解决问题规模n有关,它随着n增大而增大,当n较大时,将占用较多存储单元,将第10章中介绍快速排序归并排序算法就属于这种情况。
分析算法所占用存储空间要各方面综合考虑。对于递归算法来说,一般都比较简短,算法本身所占用存储空间较少,但运行时需要附加工作栈,从而占用较多临时工作单元;若写成非递归算法,一般可能比较长,算法本身占用存储空间较多,但运行时将可能需要较少存储单元。
算法空间复杂度通常考虑运行过程中为局部变量分配存储空间大小,它包括参数表值参变量分配存储空间函数体中定义局部变量分配存储空间两个部分。若算法递归算法,其空间复杂度递归所使用工作栈空间大小,它等于一次调用所分配临时存储空间大小乘以调用次数(即递归调用次数加1,这个1表示开始进行一次非递归调用)。算法空间复杂度一般也以数量级形式给出。如当算法空间复杂度常量,即不随处理数据量n大小而改变时,则表示O(1),当算法空间复杂度以2为底n对数成正比时,则表示O(logn),当算法空间复杂度与n成线性比例关系时,则表示O(n)。
注意:若形参为数组,则其实质上指针值参数,只需要它分配存储由实参传送来地址指针空间,即机器字长空间,通常2或4个字节。
对于算法,其时间复杂度空间复杂度往往相互影响,当追求较好时间复杂度时,可能会使空间复杂度性能变差,即可能导致占用较多存储空间;反之,当追求较好空间复杂度时,可能会使时间复杂度性能变差,即可能导致占用较长运行时间。另外,算法所有性能之间都存在着或多或少相互影响。因此,当设计算法(特别大型算法)时,要综合考虑算法各项性能、算法使用频率、算法处理数据量大小、算法描述语言特性、算法运行机器系统环境诸多因素,通过权衡利弊才能够设计出比较满意算法。
1.4与算法描述有关C++知识
下面对C++语言有关内容做简要说明,以后各章分析编写算法做准备,此部分可不作为教学讲授内容,而留给学生自学。
1.4.1包含文件语句
包含文件语句以关键字include开头，后跟用尖括号或双引号括起来头文件名，行末尾不需要使用分号。下面介绍几个常用系统头文件作用。
1.include<iostream.h>
程序开始使用该语句后，其后每函数，都可以使用标准输入设备（键盘）流对象cin、标准输出设备（屏幕）流对象cout标准错误输出设备（屏幕）流对象cerr，以及使用用于输入提取操作符“>”用于输出插入操作符“<”进行数据输入/输出操作。对于基本类型char、short、int、long、char（字符串型）、float、double、longdouble数据能够直接进行输入输出；对于非字符指针类型指针型数据能够直接输出指针（即操作数地址）；对于其他类型数据，只有通过对“>”“<”操作符重载后才能直接输入输出，当然若数据元素基本数据类型，则可对其元素直接输入输出。，一种记录结构类型如下。
structworker
intid;
charname[20];
floatwage;
若要对该记录类型对象（用wk表示）输入或输出数据，可使用如下输入或输出语句。
cin>>wk.id>>wk.name>>wk.wage;
cout<wk.id<<"""<wk.name<<"""<wk.wage<<endl;
若要对记录整体进行输入或输出，则必须对该类型进行提取或插入操作符重载，它们重载函数定义如下。
istream&operator>>(istream&istr,worker&x)
istr>>x.id>>x.name>>x.wage;
returnistr;
ostream&operator<<(ostream&ostr,constworker&x)
ostr<x.id<<"""<x.name<<"""<x.wage<<endl;
returnostr;
按照上述定义后，可使用如下语句对worker类型对象wk进行输入或输出。
cin>>wk;
cout<<wk;
执行第1条语句时将把实际参数cinwk引用（即按址）传送给调用函数istrx形参，使得istrx分别取代（或称易名）cinwk，函数对istrx操作实际上就是对cinwk操作。该函数返回istr（即cin），以便能够同一条输入语句连续使用“>>”操作符对多个对象进行输入。
注意：当同一行上输入多个数据时，键盘上输入数据之间必须用空格相隔开。
执行第2条语句时将把实际参数coutwk引用（即按址）传送给调用函数ostrx形参，使得ostrx分别取代coutwk，函数对ostrx操作实际上就是对coutwk操作。该函数返回ostr（即cout），以便能够同一条输出语句连续使用“<<”操作符对多个数据进行输出。
另外，使用include<iostream.h>语句之后函数，允许使用换行符常量endl空指针常量NULL，它们分别表示换行符“n”数值0（即空指针值“0”）。
2.include<stdlib.h>
stdlib.h头文件含有voidexit(int)、intrand(void)、voidsrand(unsigned)函数原型。exit(int)函数作用结束程序执行，一般用整数值0调用该函数表示正常结束，用整数值1调用该函数表示非正常结束。利用new操作符没有分配到所需要存储块时，应输出“存储分配失败！”错误信息并调用exit(1)函数终止程序运行。rand()函数作用返回0~32767之间随机整数。利用rand()%n可以产生0~n-1范围内随机整数。srand(unsigned)函数作用初始化随机数发生器，当参数不同时，接着由rand()函数所产生随机数序列也不同。若rand()函数前没有执行srand函数，则产生参数值1随机数序列，即相当于调用一次srand(1)函数。下面产生随机数程序。
```cpp
//程序1-3.cpp
include<iostream.h>
include<stdlib.h>
voidmain(void)
inti;
for(i=0;i<10;i++)
cout<<(rand()%100)<"";
cout<<endl;
srand(2);
for(i=0;i<10;i++)
cout<<(rand()%100)<"";
cout<<endl;
srand(1);
for(i=0;i<10;i++)
cout<<(rand()%100)<"";
```
cout<<endl;
该程序运行后显示结果如下。
4167340692478586264
4516989584509031516
4167340692478586264
下面程序每次运行时,将会得到完全不同运行结果。因为srand函数参数使用time(0)函数,此函数原型定义time.h头文件,它返回1970年1月1日零时算起至当前时间为止秒数。由于当前时间时刻变化,所以可以使每次运行程序时调用srand函数实参值均不同,从而使系统生成每次均不同随机数序列。
//程序1-4.cpp
include<iostream.h>//支持输入/输出函数
include<stdlib.h>//支持随机数函数
include<time.h>//支持时间函数
voidmain()
inti,x;
srand(time(0));
for(i=0;i<10;i++)
x=rand()%100;
cout<<x<<"";
cout<<endl;
stdlib.h头文件还包含有voidcalloc(unsignedintn,unsignedintsize)、voidmalloc(unsignedintsize)、voidrealloc(voidp,unsignedintsize)、voidfree(voidp)函数原型。calloc函数用来动态分配n个连续存储位置,每个位置含有存储数据元素size个字节,整个动态存储空间大小ntimestextsize个字节,用来最多存储n个数据元素。malloc函数用来动态分配大小size个字节新存储空间。realloc函数用来动态分配大小size个字节新存储空间,并把p所指向原动态存储空间内容复制到新分配得到动态存储空间,同时自动释放掉p所指向原动态存储空间。上述3个函数都返回新分配动态存储空间首地址,通常需要将它转换每个存储位置所存数据指针类型,若动态存储分配失败,则都将返回NULL表示失败。free函数释放由参数p所指向动态存储空间。以上4个函数C语言或C++语言环境都可以使用。另外,C++语言还能够使用newdelete运算符来非常方便地进行动态存储空间分配释放。
下面程序给出上述函数应用例子,其中定义指针p下3行语句具有相同功能。
//程序1-5.cpp
include<iostream.h>
include<stdlib.h>
voidmain(void)
intp;
//p=(int)malloc(8sizeof(int));
//p=(int)calloc(8,sizeof(int));
p=newint[8];
for(inti=0;i<8;i++)
p[i]=ii;
p=(int)realloc(p,12sizeof(int));
for(i=8;i<12;i++)
p[i]=2i;
for(i=0;i<12;i++)
cout<<p[i]<<"";
cout<<endl;
free(p);
该程序运行结果:
01491625364916182022
3.include<fstream.h>
fstream.h使用文件流类头文件，其中定义有输入文件流类ifstream、输出文件流类ofstream输入/输出文件流类fstream，利用它们可以编程者定义相应文件流对象，从而对外存上文件进行输入/输出操作。:
ifstreaminput("xxk1.dat",ios::in|ios::nocreate);
ofstreamoutput1("d:xxkxxk21.dat",ios::out),
ofstreamoutput2("xxk22.dat",ios::app);
fstreaminout("a:xxk3.dat",ios::in|ios::out);
以上每一条语句都定义相应文件流对象，其中第1个参数给出要打开实际文件，它字符指针类型，第2个参数给出文件打开方式。执行上述任一条语句后，若相应文件打开，则由文件流对象返回非0值，否则返回0值。当打开文件后，将内存开辟出相应文件缓冲区，通过文件流对象访问缓冲区，实现对文件读写操作。
上述第1条语句定义输入文件流对象input，要打开文件当前目录下xxk1.dat，并由ios::in参数规定按输入（即由文件到内存）方式打开，此参数可以省，由ios::nocreate参数规定若指定文件不存在则不应去建立它，否则将建立它。打开用于输入文件后，文件指针自动指向文件内容开始位置。
第2条语句定义输出文件流对象output1，要打开文件d盘xxk子目录下xxk21.dat，并由ios::out参数规定按输出（即由内存到文件）方式打开，此参数可以缺省，若指定文件不存在，则自动指定目录下建立文件名xxk21.dat空文件。打开用于输出文件后，文件原有内容自动清除掉。
第3条语句定义输出文件流对象output2,要打开文件当前目录下xxk22.dat,n并由ios::app参数规定按追加输出方式打开，同样若文件不存在则自动建立它。打开用于追加输出文件后，文件原有内容保持不变，文件指针自动移到文件末尾。n第4条语句定义输入/输出文件流对象inout,对应文件A盘根目录下xxk3.dat,并规定既可对该文件进行输入操作，也可对该文件进行输出操作。打开同时用于输入输出文件后，文件原有内容不变，文件指针自动移到文件内容开始位置。nn当文件打开后，可以按字符方式（又称ASCII码方式）或字节方式（又称二进制方式）进行访问。若向文件写入数据时采用字符方式，则该文件读出数据时也应该采用字符方式；同样，若写入数据按字节方式进行，则读出数据时也应按字节方式进行。数据按字符方式读出或写入，通过使用文件流对象提取操作符“>>”或插入操作符“<<”来实现，就如同对标准输入/输出设备进行读写操作一样。值得注意：当以字符方式向文件写入数据时，数据之间必须以空格或回车换行符隔开，因为读取每数据时都以这些符号作为结束标志。nn数据按字节方式写入文件时，把内存由指定字符指针所指向若干个字节内容直接写入到文件；数据按字节方式从文件读出时，把从文件读出若干个字节内容，直接存入到内存由指定字符指针所指开始位置存储区里。按字节方式读写文件比按字符方式读写文件要快，因为它不需要读写过程进行数据格式转换。按字节方式读写文件若通过事先移动文件指针，还能够随机读写文件任何位置开始内容，而对于按字符方式读写文件，则一般只能进行顺序访问。利用文件流对象调用文件流类成员函数read(char,int)或write(char,int)，能够对文件按字节方式进行读出或写入操作，当不能够从文件读出所规定字节数时，read函数返回0值，否则返回非0值，若返回0值，则利用文件流对象调用文件流类成员函数gcount()可得到实际读取字节数。nn下面列举一些简单文件操作例子。nn//程序1-6.cppninclude<iostream.h>ninclude<stdlib.h>ninclude<fstream.h>nvoidmain(void)nnofstreamf1("wr1.dat");nif(!f1)ncerr<<"wr1.datnotopen!";nexit(1);nnfor(inti=0;i<20;i++)nf1<<i<<"";nf1.close();n
该程序主函数第1条语句建立输出文件流f1，并使之与当前目录下wr1.dat文件相联系，若该文件存在则打开并清空，否则当前目录下建立它；若第1条语句执行时没有打开或建立wr1.dat文件，则第2条语句条件真，显示出错误信息后终止程序执行；第3条语句把0sim19之间整数按字符方式顺序写入到文件流f1所对应文件，写入每个整数之后同时写入空格作为分隔符；第4条语句关闭与f1相联系文件wr1.dat，即把相应文件缓冲区归还给系统。
```cpp
//程序1-7.cpp
include<iostream.h>
include<stdlib.h>
include<fstream.h>
voidmain(void)
ifstreamf1("wr1.dat",ios::in|ios::nocreate);
if(!f1)
cerr<<"Files'wr1.dat'notfound!";
exit(1);
inti;
while(!f1.eof())
if(f1>>i)cout<<i<<"";//或改为：f1>>i;cout<<i<<"";
cout<<endl;
f1.close();
```
该程序主函数第1条语句建立输入文件流f1，并使之与当前目录下文件wr1.dat相联系；若该文件没有打开，则执行第2条语句时将显示出错误信息并退出程序执行；第4条语句while循环，当文件指针没有指向文件末尾时，则f1.eof()值假（即0值），否则真（即非0值），若每次利用f1>>i表达式从文件读出整数到变量i，则该表达式值真，否则假，该循环作用是从f1流所对应文件开头，顺序读出每整数到变量i，并把它输出到屏幕上，直到文件指针移到文件结尾为止（每读出数据后，文件指针就向后移动数据位置）；第6条语句关闭f1对应wr1.dat文件。
```cpp
//程序1-8.cpp
include<iostream.h>
include<stdlib.h>
include<fstream.h>
structworker
intid;
charname[20];
floatwage;
;
voidmain(void)
```
fstreamfl("wr2.dat",ios::in|ios::out);
workera[5]=111,"xuxiaokai",567.00,123,"weirong",524.00,
240,"hexiaoxin",620,360,"yuanwei",445.00,
378,"ningchen",486.00
;
for(inti=0;i<5;i++)
fl.write((char)&a[i],sizeof(worker));
fl.seekg(0);//把文件指针移到文件开始位置
workerx;
while(!fl.eof())
if(fl.read((char)&x,sizeof(worker)))
cout<<x.id<<""<<x.name<<""<<x.wage<<endl;
cout<<"读出显示文件第4条记录:"<<endl;
fl.clear();//清除fl流中所有状态位,即恢复0
fl.seekg(3sizeof(worker));//使文件指针指向
//第3个位置上记录,文件开始第0位置
fl.read((char)&x,sizeof(worker));
cout<<x.id<<""<<x.name<<""<<x.wage<<endl;
fl.close();
该程序首先把数组a5个记录按字节方式依次写入到输入/输出流对象fl所对应文件wr2.dat，接着从文件开始位置（即第0字节）起顺序读出每条记录并按行显示出来，最后重新读出显示文件第4条记录。该程序运行后显示结果如下。
111xuxiaokai567
123weirong524
240hexiaoxin620
360yuanwei445
378ningchen486
读出显示文件第4条记录:
360yuanwei445
4.include<string.h>
string.h进行字符串操作头函数，其中定义有一些字符串函数原型。用户可以程序直接调用这些函数处理字符串。常用字符串函数如下。
(1)求串长度。
intstrlen(constchars);
返回s指针所指字符串长度，字符串空结束符("'0'")不计算在内。
(2)串复制。
charstrcpy(chardest,constcharsrc);
把src所指字符串复制到dest指针所指存储空间，该函数返回dest指针。
(3)串连接。
charstrcat(chardest,constcharsrc);
把src所指字符串复制到dest所指字符串后面存储空间，连接后dest所指串长度等于dest串原有长度与src串长度之，该函数返回dest指针。注意，dest所指字符串后面要有足够存储空间用于存储待连接字符串。
(4)串比较。
intstrcmp(constchars1,constchars2);
把s1所指字符串同s2所指字符串比较，若s1串大于s2串则返回值大于0(通常1)，若s1串小于s2串则返回值小于0(通常-1)；若s1串等于s2串则返回值等于0。
(5)串定位。
charstrchr(constchars,intc);
s所指字符串开始顺序查找ASCII码为c值字符（也可以把字符传递给参数c，实际上传递该字符ASCII码），若查找成功则返回指向该字符指针，否则返回NULL。
(6)串右定位。
charstrrchr(constchars,intc);
它与串定位函数功能相似，唯一区别它s串最后顺序向前查找。
(7)查找子串。
charstrstr(constchars1,constchars2);
s1串中开始位置起顺序查找s2串第1次出现，若查找成功则返回s1串中指向该子串开始位置指针，否则返回NULL。
下面使用字符串函数实例。
//程序1-9.cpp
include<iostream.h>
include<string.h>
voidmain()
chara[20],str1="hello",str2="wang",str3;
strcpy(a,str1);
strcat(a,"");//a串最后添加空格字符
strcat(a,str2);
cout<<(strlen(str1)<""<strlen(a)<endl;
cout<<(strcmp(a,str1)<""<strcmp(a+6,str2)
<""<strcmp(str1,str2)<endl;
str3=strchr(str1,'l');
cout<<str3-str1<<"";//输出str3指针所对应下标位置
str3=strchr(str1,'1');
cout<<str3-str1<<endl;
str3=strstr(str2,"an");
cout<<str2<<""<<str3<<endl;
该程序运行后显示结果如下，请读者结合程序分析其正确性。
510
10-1
23
wangang
section1.4.2数据类型
section1.简单类型
C++语言，简单类型包括整数类型、字符类型、布尔类型、浮点类型、指针类型、枚举类型void类型。整数类型又分为短整型(shortint或short)、整型(int)长整型(longint或long)3种，它们分别表示不同范围内整数。字符类型表示范围ASCII字符集汉字区位码字符集（每汉字两个ASCII字符，现在国际上统一使用一种编码，叫做unicode编码，它对所有国家字符统一采用双字节编码）。字符类型每一种整数类型都可以使用前缀关键字signed或unsigned，使之成为相应有符号或无符号数据类型，默认signed类型。布尔类型也称为逻辑类型，它只有两个值01，分别用符号常量falsetrue表示，即逻辑值“假”“真”。浮点类型包括float类型、double类型longdouble类型，用它们表示带小数点数。指针类型用来表示内存存储单元（字节）位置（地址），它基类型可以任何类型，指针类型用类型标识符后缀星号()表示。枚举类型用户自定义类型。void一种特殊类型，它不取任何值，通常用它定义不返回值函数类型，若带上“”后缀则定义指向任何类型指针。
字符类型也可以看作一种整数类型，每个字符ASCII码看作其中一个整数值。每一种类型数据可以根据需要强制转换另一种类型数据，其转换格式:
(<类型标识符>)<表达式>
或
(<类型标识符>)(<表达式>)
，假定xy分别intfloat型，则int(y)值int型，其值y值整数部分，(char)&x值字符指针类型，其值整型对象x地址。
section2.结构类型
C++语言，结构类型包括数组、字符串、记录文件。
(1)数组。
数组数目固定具有同一类型数据元素顺序组合，按照数组每个元素下标位置可认为数组具有线性结构，用二元组描述如下：
array=(A,R)，其中A=lefta[i]mid0leqslantileqslantn-1,ngeqslant1rightR=leftlanglea[i],a[i+1]ranglemid0leqslantileqslantn-2righta[i]数组下标i元素，n大于等于1整数，用来表明数组元素个数，数组元素下标0到n-1，数组前后相邻位置上两个元素序偶，其前一元素a[i]后一元素a[i+1]前驱，而a[i+1]a[i]后继，第1个元素a[0]无前驱元素，最后元素a[n-1]无后继元素。
按数组下标的个数，可把数组分为一维、二维、三维。
一维数组每个元素只包含有下标，二维数组每个元素包含有两个下标，第1个称为行下标，第2个称为列下标。
二维数组可看作一维数组或嵌套，即首先把它看作按行下标顺序排列一维数组，该数组每个元素又都按列下标顺序排列一维数组。对于一个二维数组b[m][n]，可视为一维数组b[m]，所含元素依次b[0],b[1],…,b[m-1]，其中每元素b[i]（0leqslantileqslantm-1）又都含有n个元素一维数组，所含元素依次b[i][0],b[i][1],…,b[i][n-1]。
同样，三维数组包含有3个下标，每个元素位置由一组3个下标值唯一确定。三维数组一维数组3层嵌套结构。对于一个三维数组c[p][m][n]，首先可视为一维数组c[p]，所含元素依次c[0],c[1],…,c[p-1]，其中每元素c[k]（0leqslantkleqslantp-1）又都含有m个元素一维数组，所含元素依次c[k][0],c[k][1],…,c[k][m-1]，这里每元素c[k][i]（0leqslantileqslantm-1）也都含有n个元素一维数组，所含元素依次c[k][i][0],c[k][i][1],…,c[k][i][n-1]。
数组存储结构顺序结构，即数组第i+1个元素紧接着存储第i个元素存储位置后面。对于一维数组a[n]，则每个元素a[i]存储位置首字节地址：textAddress(a[i])=Loc(a)+iLquad(0leqslantileqslantn-1)其中Loc(a)表示数组a存储空间首地址，L表示数组a元素类型大小，即每个元素所占用字节数，可用sizeof(a[i])计算。由上述公式可知：元素a[0]存储地址Loc(a)，它就是整个数组开始地址，a[1]存储地址Loc(a)+1L，a[2]存储地址Loc(a)+2L；…；a[n-1]存储地址Loc(a)+(n-1)L。
对于一个二维数组b[m][n]，每一行元素b[i]存储位置（即存储该行n个元素首字节地址）：textAddress(b[i])=Loc(b)+iRSquad(0leqslantileqslantm-1)其中Loc(b)表示二维数组b存储空间首地址，RS表示顺序存储一行n个元素所占用存储空间大小，它等于每个元素所占用字节数L与一行上元素个数n乘积。因此上述计算公式可改写：textAddress(b[i])=Loc(b)+inLquad(0leqslantileqslantm-1)对于二维数组b第i行（即下标i行），其中下标j元素b[i][j]存储位置：textAddress(b[i][j])=Loc(b)+inL+jLquad(0leqslantileqslantm-1,0leqslantjleqslantn-1)
对于三维或更高维数组，其每个元素存储位置（即首字节地址）也容易计算出来。对于三维数组c[p][m][n]，其相应一维数组元素、二维数组元素三维数组元素存储位置计算公式分别如下：textAddress(c[k])=textLoc(c)+kmnLquad(0leqkleqp-1)textAddress(c[k][i])=textLoc(c)+kmnL+inLquad(0leqkleqp-1,0leqileqm-1)textAddress(c[k][i][j])=textLoc(c)+kmnL+inL+jLquad(0leqkleqp-1,0leqileqm-1,0leqjleqn-1)上面对于多维数组存储空间分配按照行序为主进行，即第i行元素所占用存储空间后面紧接着保存第i+1行元素。C、C++、BASIC、PASCAL、Java大多数计算机语言对数组存储空间分配都按此方法进行。但也有计算机语言，FORTRAN语言采用列序为主进行，即第i列元素所占用存储空间后面紧接着保存第i+1列元素。对于一个二维数组a[m][n]，若采用列序为主分配存储空间，则元素a[i][j]存储位置：textAddress(a[i][j])=textLoc(a)+jmL+iLquad(0leqileqm-1,0leqjleqn-1)对于以列序为主进行存储空间分配三维数组，有兴趣读者可进行类似分析。
(2)字符串。
字符串类型一种特殊一维字符数组类型，该类型每值，下标0位置保存字符起到下标i位置(0leqi<n-1,n一维下标上界）保存ASCII码为0空字符'0'止，连续i个字符（不含'0'字符在内）称为字符串。
字符串常量用双引号括起来一串字符，当把它作为初值赋给字符数组时，把该常量每个字符依次写入到字符数组下标0开始对应位置上，并最后写入'0'字符作为字符串结束标志。若字符串长度len，则它占据字符数组0simtextlen位置，其中每个位置字节，用来保存字符，0simtextlen-1位置保存字符串本身字符，textlen位置保存空字符'0'。
字符数组定义时，允许把字符串常量作为初值赋给字符数组，而其他地方，要把字符串常量或字符数组保存字符串赋给字符数组时，则必须使用串复制函数strcpy。保存字符串字符数组数组名字符指针常量，它不能作为左值使用，但其他地方可以像字符指针变量一样使用。如当出现输出语句时，不是输出数组名指针值，而是输出以数组名指针开始地址、字符数组保存字符串；当使用输入语句时，不是把输入字符串常量存储地址赋给数组名指针，而是把该字符串保存到字符数组，并其后保存'0'字符。
注意：键盘上输入字符串常量，两边不要使用双引号作为起止符，它自动以非空格非回车符作为字符串第一个字符，以空格或回车符作为结束符，即其前字符字符串最后字符。
对字符串运算操作主要有求串长度、把串复制到另字符指针所指字符数组空间、比较两个串大小、串输入输出。
注意：当把字符串赋值或复制到另字符串时，目的字符串存储空间要大于等于源字符串长度加1。
利用一维数组能够保存字符串，若要依次保存多个字符串，则需要定义一个二维数组，其中每一行对应一维字符数组空间用来保存字符串。程序清单如下。
//程序1-10.cpp
include<iostream.h>
include<string.h>
voidmain()
chara[4][20]="Beijing","Shanghai","Tianjin","Guangzhou";
charp[20];
for(inti=0;i<4;i++)
cout<<a[i][0]<<endl;
strcpy(p,&a[0][0]);
for(i=1;i<4;i++)
if(strcmp(p,&a[i][0])<0)
strcpy(p,&a[i][0]);
cout<<endl<<p<<endl;
该程序主函数，第1条语句定义一个二维数组a[4][20]，该数组行下标范围0sim3，列下标范围0sim19，每一行元素a[i]（0leqileq3）能够存储字符串，其字符串最大长度应小于等于19，该语句同时对数组a进行初始化。第2条语句定义一维字符数组p[20]。第3条语句显示出数组a保存每个字符串，其中&a[i][0]可以改写a[i]。第4第5条语句通过顺序比较查找出数组a中值最大字符串，字符数组p用做比较过程保存当前最大值字符串，其初值数组a第1个字符串a[0]（即&a[0][0]）。最后一条语句显示出已经p保存最大值。该程序运行结果如下。
Beijing
Shanghai
Tianjin
Guangzhou
Tianjin
(3)记录。
记录类型多个不同数据类型（当然也可以相同）组合体。记录类型每值（即具体记录）记录类型实例，它由多个不同类型具休数据所组成。记录所有数据成员逻辑上集合结构，即成员之间没有任何次序，但物理存储上顺序结构，它按照记录类型定义各成员定义顺序存储。记录所占用存储空间大小等于各成员所占用存储空间大小之，此值可以通过sizeof运算符计算。
C/C++语言，记录称为结构，通过使用struct关键字定义用户需要记录（结构）类型。struct关键字后要给出标识符作为记录类型名，其后大括号中要给出所含每数据类型及其数据域名。访问记录某个数据域通过成员选择操作符（.）或（->）来实现，前者称为直接成员选择符，后者称为间接成员选择符。直接成员
选择符左面操作数应为记录类型对象（记录变量），而间接成员选择符左面操作数应为指向记录类型对象指针，它们右面操作数均应为记录要访问域名。通过“.”或“->”操作符能够读取记录任域值，或者向记录任域写入数据。
定义记录类型对象时，可以同时对它进行初始化，用于初始化记录值要用大括号括起来，各个域值按记录对应类型定义顺序给出，其前后域值之间要用逗号分开，若域值字符串，则必须用双引号括起来，若字符则必须用单引号括起来，若数组或另记录则必须用大括号括起来。记录类型对象还可以同简单类型对象那样，允许使用赋值号把对象赋给另同一类型对象。
下面定义学生记录类型（student），它包含有4个域，分别为学号（num）、姓名（name）、性别（sex）用于保存学生5门课程成绩及平均成绩数组（result）。
```
structstudent
charnum[8];//每个学号不能超过7个字符
charname[10];//姓名不能超过9个字符
charsex;//假定用字符mf分别表示男性女性
doubleresult[6];//前5个元素保存5门课成绩,最后保存平均成绩
;
```
为了使用上述类型，下面给出3条语句：第1条语句定义student对象s1并赋予初值，第2条语句计算出s1记录5门课程平均成绩，第3条语句显示出s1学号、姓名、性别平均成绩。其显示结果：980413左明华m77.6。
```
students1="980413","左明华",'m',76,83,64,90,75,0;
for(inti=0;i<5;i++)
s1.result[5]+=s1.result[i]/5;
cout<<s1.num<<""<<s1.name<<""<<s1.sex<<""<<s1.result[5]<<endl;
```
下面程序定义记录类型person，其大小24个字节，它带有指向自身类型指针next；另外两个域字符串域name整数域age。通过next域可以把该类型结点（对象）链接起来，形成单链表。该程序把r1、r2r3这3个结点依次链接起来，并使p指向这个单链表头结点r1。程序最后通过while循环依次按左对齐显示出每个结点name域age域值，其显示宽度分别155。
```
//程序1-11.cpp
include<iostream.h>
include<iomanip.h>//该头文件包含iostream.h全部内容,并包含
//更多输入/输出格式控制功能,使用此条命令时可省略其上一条命令
structperson
charname[15];
intage;
personnext;
;
voidmain()
```
personr1=("shiliang",38),r2=("zhangtongwen",34),
r3=("panweidong",42);
personp;
r1.next=&r2;r2.next=&r3;r3.next=NULL;
p=&r1;
cout.setf(ios::left);//使显示数据规定范围内左对齐,
//若把left改为right则右对齐，默认设置右对齐
while(p!=NULL)
cout<<setw(15)<<p->name<<setw(5)<<p->age<<endl;
p=p->next;
;
该程序运行后显示结果如下:
shiliang38
zhangtongwen34
panweidong42
（4）文件。
文件按位置有序数据集合。一篇文章，可看做按位置有序字符集合；统计表，可看做按行位置有序记录集合；一个二维数值矩阵，可看做先按行位置有序、对于同一行再按列位置有序数值集合；具有树结构图表，可看做先从上到下层次有序、同一层次上再按从左到右位置有序数据（结点）集合。它们均可看做相应文件。单从文件数据先后排列位置考虑，可以认为它具有线性结构。
计算机文件存储外存上，其存储结构由操作系统自动实现。C++语言，用户使用文件通过定义与之相对应文件流对象来实现。通过输入文件流对象使文件数据按照其位置从前到后次序依次流入到内存文件缓冲区，从而读取到指定内存变量；通过输出文件流对象，使输出到文件数据首先写入到文件缓冲区，然后操作系统再把文件缓冲区内容写入到外存上相应文件末尾。当然，对于字节文件，可以任何指定位臵写入信息，也可以把信息写入到任何指定位臵开始存储空间。
对于字符文件，通过输入文件流类或输入/输出文件流类对象打开后，主要采用以下4种操作方法从文件读取数据。
①流类对象>>变量。
②流类对象.get（字符变量）。
③流类对象.get()。
④流类对象.getline（字符指针变量，整数量）。
第1种操作方法流类对象所对应文件顺序读出数据（数据以空格或换行符隔开）到指定内存变量。第2种操作方法流类对象所对应文件顺序读出字符到内存字符变量。第3种操作方法同第2种类似，区别仅在于把读到字符作为函数值返回。第4种操作方法流类对象所对应文件顺序读出一行字符（以换行符或文件结束符作为行结束符，或者读到给定第2个参数“整数量”值减1个字符也作为
一行结束），并把它保存到以第1个参数给定字符指针变量所指定内存空间，该内存空间最多只允许存储长度等于给定整数量值减1字符串，并且其后自动存储字符串结束符'0'，通常所给整数量大小字符指针变量所指定存储空间大小。当然这里各种指定变量可以单独定义变量或数组，也可以数组元素或记录域。
上述第1、2、4种操作方法（或称函数调用、操作表达式）都返回相应流类对象值，当读取成功时，其返回值非0，读取失败（即遇到文件结束符，系统用符号常量EOF表示，其值-1）时，其返回值0。另外，其流类对象可以文件流对象，也可以标准输入流对象cin。若cin，则表示键盘输入数据，而不是外存文件输入数据。
对于字符文件，通过输出文件流类或输入/输出文件流类对象打开后，主要采用以下两种操作方法向文件写入数据。
(1)流类对象<<数据。
(2)流类对象.put（字符量）。
第1种操作方法向流类对象所对应文件顺序写入数据（常量、变量或表达式），每写入数据后，都要写入空格或换行符作为数据之间分隔符。第2种操作方法向流类对象所对应文件顺序写入字符量。同样，其流类对象可以文件流对象，也可以标准输出流对象cout。若cout，则将把数据输出到显示器屏幕上。
对于字节文件，通过输入文件流类、输出文件流类或输入/输出文件流类对象打开后，主要采用以下两种操作方法当前文件指针所指位置起读出或写入一定字节数信息。
(1)流类对象.read（字符指针，读出字节数）。
(2)流类对象.write（字符指针，写入字节数）。
第1种操作方法是从流类对象所对应文件当前文件指针所指字节位置起顺序读出一定字节数内容送入由字符指针所指定内存空间，若读取成功则返回非0值，否则返回0值。第2种操作方法向流类对象所对应文件当前文件指针所指字节位置起顺序写入由内存字符指针所指向一定字节数内容。
从文件读出或向文件写入数据、字符或一定字节数内容后，文件指针将自动后移数据、字符或一定字节数位置。若需要随机地读写文件任何字节位置（文件字节0开始编号）开始信息，则首先必须使文件指针移动到那里。用于移动文件指针函数如下。
(1)流类对象.seekg（pos,origin）。
(2)流类对象.seekp（pos,origin）。
第1种函数用于移动输入流或输入/输出文件文件指针，第2种函数用于移动输出文件文件指针。参数origin给出移动文件指针参考位置，它下列3种情况之一：ios::beg、ios::curios::end，它们表示参考位置分别文件开始（即第0字节位置）、文件指针当前位置文件结尾（即最后字节后位罝）。参数origin可以省略，默认文件开始位置。参数pos整数，当为正时表示参考位置起向右（即向后）移动字节数，当为负时表示参考位置起向左（即向前）移动字节数。使用下面两个函数可以输入或输出文件返回文件指针当前位置。
(1)流类对象.tellg()。
(2)流类对象.tellp()。
程序1-12把键盘上输入文本原封不动地写入到A盘上wr1.dat文件。当按Ctrl+Z键时表示输入文件结束符EOF,文本输入到此结束。
//程序1-12.cpp
include<iostream.h>
include<stdlib.h>
include<fstream.h>
voidmain()
charch;
ofstreamof1("a:wr1.dat");
ch=cin.get();
while(ch!=EOF)
of1.put(ch);
ch=cin.get();
of1.close();
将上面程序第9条赋值语句第10条while循环语句改写下面一条语句也正确。
while(cin.get(ch))of1.put(ch);
程序1-13以输入方式打开刚A盘上建立wr1.dat文件，把文件全部内容输出到屏幕，统计出文件中所含文本行数，最后显示出文件长度（即所含字符数，向文件写入换行符时，实际上同时写入回车换行两个控制字符）行数。
//程序1-13.cpp
include<iostream.h>
include<stdlib.h>
include<fstream.h>
voidmain()
ifstreamif1("a:wr1.dat",ios::nocreate);
if(!if1)
cout<<"filenotopen!";
exit(1);
charch;
inti=0;
if1.get(ch);
while(ch!=EOF)
cout<<ch;
```cpp
if(ch=='n')i=i+1;
if1.get(ch);
cout<<endl<<if1.tellg()<<endl;
if1.close();
cout<<i+1<<endl;//加1表示文件结束符所在行
程序,表达式if1.get(ch)可替换ch=if1.get(),表达式ch!=EOF可替换!if1.eof()。
section1.4.3函数
C/C++语言，程序由若干个功能相对独立函数模块所组成，其中必有定名main主函数模块。程序执行时将自动从主函数模块开始，其余一般函数模块。主函数模块可以调用其他函数模块，其他函数模块之间也可以相互调用。允许函数（除主函数外）直接或间接地调用自身，这种情况称为直接或间接递归调用。
函数可以不返回任何值，此时函数类型定义void。对这种函数调用只能作为函数语句使用。函数也可以返回简单或记录类型值，此时函数类型定义一种简单类型（int、int、char、char）或记录类型（student、person），对这种函数调用不能作为左值使用，只能作为右值使用。函数还可以返回简单类型或记录类型引用，此时函数类型定义一种类型后缀引用说明符&（int&、student&），对这种函数调用既可以作为左值使用，也可以作为右值使用。
程序1-14包含有主函数3个重载find函数，为了使它们具有相同参数个数类型情况下重载，改变参数之间次序，使其各不相同。这3个find重载函数都是从数组b[n]顺序查找找出pnum域值k（即k所指向字符串）元素，但返回值各不相同。int类型find函数返回其元素下标，若查找失败则返回n值；pupil型find函数返回其元素指针（即存储地址），若查找失败则返回空值NULL；pupil&型find函数返回其元素引用，这样可对返回变量赋值，若查找失败则显示错误信息后结束运行。
主函数，首先定义数组a[PN]，并其赋初值，每个元素值为pupil类型学生记录，包括学号分数，第1个学生学号010203，分数78；接着按行显示出数组a每个元素值；再接着定义待修改学生记录x，其学号020101，其分数修改值为98；然后根据键盘上输入数字1、23决定调用哪find函数查找与x记录学号相同元素，从而对该元素进行修改；主函数最后又显示出数组a每个元素值，显示结果可以看到，a[2]元素修改。
//程序1-14.cpp
include<iostream.h>
include<string.h>
include<stdlib.h>
constintPN=5;
structpupilcharpnum[8];intgrade;;
intfind(pupilb[],intn,chark);
```
pupilfind(intn,pupilb[],chark);
pupil&find(chark,pupilb[],intn);
voidmain()
pupila[PN]=(“010203”,78),(“010204”,92),(“020101”,85),
(“020301”,63),“040502”,87);
inti;
for(i=0;i<PN;i++)
cout<<a[i].pnum<<”“<<a[i].grade<<endl;
pupilx=(“020101”,98);
cout<<”请输入你选择(1,2,3)?”;
cin>>i;
switch(i)
case1:
i=find(a,PN,x.pnum);
if(i<PN)a[i]=x;
elsecout<<x.pnum<<”notfound!”<<endl;
break;
case2:
pupilp;
p=find(PN,a,x.pnum);
if(p!=NULL)p=x;
elsecout<<x.pnum<<”notfound!”<<endl;
break;
case3:
find(x.pnum,a,PN)=x;
for(i=0;i<PN;i++)
cout<<a[i].pnum<<”“<<a[i].grade<<endl;
intfind(pupilb[],intn,chark)
for(inti=0;i<n;i++)
if(strcmp(b[i].pnum,k)==0)returni;
returni;
pupilfind(intn,pupilb[],chark)
for(inti=0;i<n;i++)
if(strcmp(b[i].pnum,k)==0)return&b[i];
returnNULL;
```cpp
pupil&find(chark,pupilb[],intn)
for(inti=0;i<n;i++)
if(strcmp(b[i].pnum,k)==0)returnb[i];
cerr<<k<<"notfound!"<<endl;
exit(1);
该程序运行结果如下。
01020378
01020492
02010185
02030163
04050287
请输入你选择(1,2,3)?1
01020378
01020492
02010198
02030163
04050287
C++语言函数可以不带任何参数，此时函数名后圆括号内为空，或使用void关键字表示；也可以带有或多个参数，它们依次列到函数名后圆括号内。函数中所带每参数可分为值参数引用参数两种方式，当说明形参类型说明符后带有引用说明符“&”时，则该形参说明引用参数，不带有引用说明符“&”时则说明为值参数。对于函数值参数，它可以说明任何一种类型，包括任一种简单类型、任一种结构类型，还可以一种函数类型，而对于引用参数，则可以说明除了数组类型函数类型之外任何类型。
函数值参数调用该函数实际参数得到相应值，值参数具有自己存储空间，其内容改变不会影响到对应实际参数；引用参数调用该函数实际变量参数得到其存储位置，这样引用参数实际变量参数具有同一存储位置用于存储其内容，函数执行过程对引用参数读写操作实际上就是对相应实参变量读写操作，所以说对引用参数改变将反映给对应实参变量。
注意：当值参数指针变量时，虽然对指针变量值改变不会影响对应实参变量，但对指针变量所指存储位置内容修改将影响到实参变量所指存储位置内容，因为形参指针变量实参指针变量所指向存储位置相同。，对于数组就是采用按值传送，即传送实参数组名值（它数组存储空间首地址）给形参数组名，这样对形参数组中元素访问就是对实参数组对应元素访问。
程序1-15主函数依次调用3个函数，其中fun1函数参数均int型值参数，fun2函数参数均int型引用参数，fun3函数参数均int指针型值参数。根据程序运行结果进行分析，从中体会参数不同传送方式作用。
```
```cpp
//程序1-15
include<iostream.h>
include<iomanip.h>
voidfun1(inta,intb);
voidfun2(int&a,int&b);
voidfun3(intp1,intp2);
voidmain()
intx=5,y=10;
cout<<"按值传送情况:"<<endl;
cout<<"main:"<<setw(10)<<"x="<<setw(3)<<x
<<setw(10)<<"y="<<setw(3)<<y<<endl;
fun1(x,y);
cout<<"main:"<<setw(10)<<"x="<<setw(3)<<x
<<setw(10)<<"y="<<setw(3)<<y<<endl;
cout<<endl;
cout<<"引用传送情况:"<<endl;
cout<<"main:"<<setw(10)<<"x="<<setw(3)<<x
<<setw(10)<<"y="<<setw(3)<<y<<endl;
fun2(x,y);
cout<<"main:"<<setw(10)<<"x="<<setw(3)<<x
<<setw(10)<<"y="<<setw(3)<<y<<endl;
cout<<endl;
cout<<"按值传送指针情况:"<<endl;
cout<<"main:"<<setw(10)<<"x="<<setw(3)<<x
<<setw(10)<<"y="<<setw(3)<<y<<endl;
fun3(&x,&y);
cout<<"main:"<<setw(10)<<"x="<<setw(3)<<x
<<setw(10)<<"y="<<setw(3)<<y<<endl;
voidfun1(inta,intb)
a=a+b;
b=2a+3b;
cout<<"fun1:"<<setw(10)<<"a="<<setw(3)<<a
<<setw(10)<<"b="<<setw(3)<<b<<endl;
voidfun2(int&a,int&b)
a=a+b;
b=2a+3b;
cout<<"fun2:"<<setw(10)<<"a="<<setw(3)<<a
<<setw(10)<<"b="<<setw(3)<<b<<endl;
```
voidfun3(intp1,intp2)
p1+=p2;
p2-=1;
cout<<"fun3:"<<setw(10)<<"p1="<<setw(3)<<p1
<<setw(10)<<"p2="<<setw(3)<<p2<<endl;
该程序运行结果如下。
按值传送情况:
main:x=5y=10
fun1:a=15b=60
main:x=5y=10
引用传送情况:
main:x=5y=10
fun2:a=15b=60
main:x=15y=60
按值传送指针情况:
main:x=15y=60
fun3:p1=75p2=59
main:x=75y=59
程序1-16swap函数，使用函数参数，该函数函数名为p，不返回值，并带有两个整型值参。当调用swap函数时，其实参表中与函数形参对应应实际函数名，并且该函数原型应当与形参函数说明完全相同。该程序主函数调用swap函数，其实参数名print值（即该函数代码区首址）将传送给对应形参数名p，这样swap函数执行对p函数调用实际上就是对print函数调用，因为执行print函数代码。
//程序1-16
include<iostream.h>
voidswap(int&x,int&y,voidp(int,int));
voidprint(inta,intb);
voidmain()
intx=5,y=10;
swap(x,y,print);
print(x,y);
voidswap(int&x,int&y,voidp(int,int))
inttemp;
p(x,y);
temp=x;x=y;y=temp;
p(x,y);
voidprint(inta,intb)
cout<<a<<""<b<<endl;
该程序运行结果如下。
510
105
105
section1.4.4运算符重载
C++语言,满足应用需要,允许对大多数运算符进行重载。经常需要使用自定义记录类型上对关系运算符进行重载,使得记录同记录之间、记录同其中域类型数据之间也能够进行比较。假定一种记录类型:
structpupilcharpnum[8];intgrade;;
下面对具有pupil类型两个记录进行相等运算符(==)重载函数,通过比较两个记录pnum域值是否相等来判断这两个记录是否相等,若相等则返回true,否则返回false。
booloperator==(pupilr1,pupilr2)
if(strcmp(r1.pnum,r2.pnum)==0)returntrue;
elsereturnfalse;
下面对具有pupil类型记录字符串进行相等运算符(==)重载函数,若记录pnum域值等于给定字符串,则认为它们相等,应返回true,否则认为它们不,应返回false。
booloperator==(pupilr,charkey)
if(strcmp(r.pnum,key)==0)returntrue;
elsereturnfalse;
对于pupil类型两个记录,若要由grade域大小来决定这两个记录大小,则进行大于运算符(>)重载函数如下。
intoperator>(pupilr1,pupilr2)
returnr1.grade>r2.grade;
当r1记录grade域值大于r2记录grade域值时则返回1,表示r1>r2,否则返回0,表示r1<=r2。
上面进行大于运算符重载，若参数记录，另参数整型数时，则重载函数如下:
intoperator>(pupilr,intkey)
returnr.grade>key;
程序使用以上运算符重载函数后，下面各表达式都合法，其中假定rarbpupil类型对象，keychar或int类型对象。
ra==rb;//若rarbpnum域相等则返回真(1)，否则返回假（0）
ra==key;//若rapnum域等于key则返回真，否则返回假
ra>rb;//若ragrade域值大于rbgrade域值则返1，否返0
ra>key;//若ragrade域值大于key值则返回1，否则返回0
程序1-17是从pupil类型数组a[5]分别查找出学号020301记录分数最大记录。
//程序1-17.cpp
include<iostream.h>
include<string.h>
structpupilcharpnum[8];intgrade;;
booloperator==(pupilr1,pupilr2)
if(strcmp(r1.pnum,r2.pnum)==0)returntrue;
elsereturnfalse;
booloperator==(pupilr,charkey)
if(strcmp(r.pnum,key)==0)returntrue;
elsereturnfalse;
intoperator>(pupilr1,pupilr2)
returnr1.grade>r2.grade;
intoperator>(pupilr,intkey)
returnr.grade>key;
voidmain()
pupila[5]="010203",78,"010204",92,"020101",85,
"020301",63,"040502",87;
```cpp
inti;
cout<<"查找出学号020301学生记录:"<endl;
charp="020301";
for(i=0;i<5;i++)
if(a[i].pnum==p)break;
if(i<5)cout<<a[i].pnum<<""<a[i].grade<<endl;
elsecout<<p<<"对应记录没找到!"<endl;
cout<<"求出分数最高学生记录:"<endl;
pupilb=a[0];
for(i=1;i<5;i++)
if(a[i]>b)b=a[i];
cout<b.pnum<<""<b.grade<<endl;
该程序运行后打印结果:
查找出学号020301学生记录:
02030163
求出分数最高学生记录:
01020492
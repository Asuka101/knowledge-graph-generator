第8章图应用
图工程技术日常生活有着广泛地应用，常常都涉及到求图最小生成树、最短路径、拓扑序列、关键路径对图特定运算问题。本章就这些运算方法算法进行深入讨论。
section8.1图生成树最小生成树
subsection8.1.1生成树最小生成树概念
连通图G，如果取它全部顶点一部分边构成子图G'，即：V(G')=V(G)textE(G')subseteqE(G)若边集E(G')边将图所有顶点连通又不形成回路，则称子图G'原图G一棵生成树。
既连通图G全部n个顶点又没有回路子图G'（即生成树）必含有n-1条边。要构造子图G'，首先从图G中任取顶点加入G'，此时G'只有顶点，假定具有顶点图连通，以后每向G'加入顶点，都要加入以该顶点端点，以已连通顶点之中顶点另端点一条边，这样既连通该顶点又不会产生回路，进行n-1次后，就向G'加入n-1个顶点n-1条边，使得G'n个顶点既连通又不产生回路。
图G一棵生成树G'，若再增加一条边，就会出现一条回路。这是因为此边两个端点已连通，再加入此边后，这两个端点间有两条路径，因此就形成一条回路，子图G'也就不再生成树。同样，若生成树G'删去一条边，就使得G'变为非连通图。因为此边两个端点靠此边唯一连通，删除此边后，必定使这两个端点分属于两个连通分量，使G'变成具有两个连通分量非连通图。
同一个图可以有不同生成树。如图8-1(b)、图8-1(c)、图8-1(d)所示都图8-1(a)生成树。每棵生成树中都包含有8个顶点7条边，它们差别只是边选取不同。
这3棵生成树中，图8-1(b)所示生成树是从图中顶点v_0出发利用深度优先搜索遍历得到，称为深度优先生成树；生成树图8-1(c)所示是从顶点v_0出发利用广度优先搜索遍历得到，称为广度优先生成树；生成树图8-1(d)所示任意一棵生成树。当然图8-1(a)生成树远不止这几种，只要能连通所有顶点而又不产生回路子图都它生成树。由于连通图生成树使用最少边连通图所有顶点，所以它又能够连通图中所有顶点极小连通子图。
对于连通网（即无向连通带权图，假定每条边上权均大于零实数）来说，生成树不同，每棵树权（即树中所有边上权值总和）也可能不同。如图8-2(a)所示连通网，如图8-2(b)、图8-2(c)、图8-2(d)所示它三棵生成树，每棵树权都不同，它们分别57、5338。具有权最小生成树称为图最小生成树（minimumspanningtree）。通过后面将要介绍构造最小生成树算法可知，图8-2(d)所示就是图8-2(a)所示最小生成树。
n
求图最小生成树具有实际意义。，若连通网表示城市之间通信系统，网顶点代表城市，网边代表城市之间架设通信线路造价，各城市之间距离不同，地理条件不同，其造价也不同，即边上权不同，现在要求既连通所有城市又使总造价最低，这就是求图最小生成树问题。
求图最小生成树算法主要有两个：普里姆（Prim）算法克鲁斯卡尔（Kruskal）n算法。下面分别进行讨论。
section8.1.2普里姆算法
假设G=(V,E)具有n个顶点连通网，T=(U,TE)G最小生成树，其中，nUT顶点集，TET边集，UTE初值均空集。算法开始时，首先V中任n取顶点（取v_0），将它并入U，此时U=v_0，然后只要UV真子集（即UsubsetV），n就那些其端点已T，另端点仍T外所有边中，找一条最短（即权值最n小）边，假定(i,j)，其中v_iinU，v_jin(V-U)，并把该边(i,j)顶点j分别并入T边集nTE顶点集U，如此进行下去，每次往生成树里并入顶点一条边，直到n-1次后就n把所有n个顶点都并入到生成树T顶点集中，此时U=V，TE含有n-1条边，T就是最后n得到最小生成树。
普里姆算法关键之处：每次如何生成树T中到T外所有边中，找出一条最短n边。，第k次(1leqkleqn-1)前，生成树T已有k个顶点k-1条边，此时T中到Tn外所有边数k(n-k)，当然它包括两顶点间没有直接边相连，其权值看做常量nMaxValue边在内，如此多边查找最短边，其时间复杂度O(k(n-k))，显然很费n时。是否有一种好方法能够降低查找最短边时间复杂度呢？回答肯定，它能n够使查找最短边时间复杂度降低到O(n-k)。方法：设在进行第k次前已经保留着Tn中到T外每一顶点（共n-k个顶点）一条最短边，进行第k次时，首先这n-k条最n短边，找出一条最短边，它就是从T中到T外所有边中最短边，设(i,j)，此n步需进行n-k次比较；然后把边(i,j)顶点j分别并入T边集TE顶点集U，此时nT外只有n-(k+1)个顶点，对于其中每个顶点t，若(j,t)边上权值小于已保留原Tn中到顶点t最短边权值，则用(j,t)修改之，使T中到T外顶点t最短边(j,t)，n否则原有最短边保持不变，这样，就把第k次后T中到T外每一顶点t各一条最短边n都保留下来，进行第k+1次运算做好准备，此步需进行n-k-1次比较。所以，利用n此方法求第k次最短边共需比较2(n-k)-1次，即时n间复杂度O(n-k)。
对于图8-2(a)所示生成树，它邻接矩阵如图8-3n所示，若v_0出发利用普里姆算法构造最小生成树T，n其过程，每次（第0次为初始状态）向T并入一n个顶点一条边后，顶点集U、边集TE（每条边后n面为该边权）以及T中到T外每个顶点各一条最n短边所构成集合（设用LW表示）状态如下。n
第0次U=0nTE=nLW=(0,1)8,(0,2)infty,(0,3)5,(0,4)infty,(0,5)infty,(0,6)inftyn
第1次U=0,3nTE=(0,3)5nLW=(3,1)3,(0,2)infty,(0,4)infty,(3,5)7,(3,6)15n
第2次U=0,3,1TE=(0,3)5,(3,1)3LW=(1,2)12,(1,4)10,(3,5)7,(3,6)15第3次U=0,3,1,5TE=(0,3)5,(3,1)3,(3,5)7LW=(5,2)2,(5,4)9,(3,6)15第4次U=0,3,1,5,2TE=(0,3)5,(3,1)3,(3,5)7,(5,2)2LW=(2,4)6,(3,6)15第5次U=0,3,1,5,2,4TE=(0,3)5,(3,1)3,(3,5)7,(5,2)2,(2,4)6LW=(3,6)15第6次U=0,3,1,5,2,4,6TE=(0,3)5,(3,1)3,(3,5)7,(5,2)2,(2,4)6,(3,6)15LW=每次对应图形如图8-4(b)～图8-4(h)所示，其中粗实线表示新加入到TE集合边，细实线表示已加入到TE集合边，虚线表示LW集合边，但权值MaxValue边实际上不存在，所以没画出。
(a)连通网
(b)第0次
(c)第1次
(d)第2次
(e)第3次
(f)第4次
(g)第5次
(h)第6次
图8-4利用普里姆算法求图最小生成树示意图
如图8-4(h)所示就是最后得到最小生成树,它同图8-2(d)完全一样,所以图8-2(d)图8-2(a)最小生成树。
通过以上分析可知，构造最小生成树过程，进行第k次(1leqkleqn-1)前，边集TE边数k-1条，T中到T外每一顶点最短边集LW边数n-k条，TELW边数总和n-1条。为了保存这n-1条边，设用至少具有n-1个元素边集数组类型（即edgeset类型）对象CT来存储，其中CT前k-1个元素（即CT[0]~CT[k-2]）保存TE边，后n-k个元素（即CT[k-1]~CT[n-2]）保存LW边。进行第k次时，首先下标k-1~n-2元素（即LW边）查找出权值最小边，设CT[m]；接着把边CT[k-1]与CT[m]对调，确保第k次后CT前k个元素保存着TE边，后n-k-1个元素保存着LW边；然后再修改LW有关边，使得T中到T外每一顶点各一条最短边保存下来。这样经过n-1次运算后，CT就按序保存着最小生成树中全部n-1条边。
根据分析，编写利用普里姆算法产生图最小生成树算法描述如下。
voidPrim(adjmatrixGA,edgesetCT,intn)
//利用普里姆算法顶点v_0出发求出用邻接矩阵GA表示图
//最小生成树，最小生成树边集存于数组CT
inti,j,k,min,t,m,w;
//给CT赋初值，对应第0次LW值
for(i=0;i<n-1;i++)
CT[i].fromvex=0;
CT[i].endvex=i+1;
CT[i].weight=GA[0][i+1];
//进行n-1次循环，每次求出最小生成树中第k条边
for(k=1;k<n;k++)
//CT[k-1]~CT[n-2]（即LW）查找最短边CT[m]
min=MaxValue;
m=k-1;
for(j=k-1;j<n-1;j++)
if(CT[j].weight<min)
min=CT[j].weight;
m=j;
//把最短边对调到第k-1下标位置
edgetemp=CT[k-1];
CT[k-1]=CT[m];
CT[m]=temp;
//把新加入最小生成树T顶点序号赋给j
j=CT[k-1].endvex;
//修改LW有关边，使T中到T外每顶点各保持
//一条到目前为止最短边
for(i=k;i<n-1;i++)
t=CT[i].endvex;
w=GA[j][t];
if(w<CT[i].weight)
CT[i].weight=w;
CT[i].fromvex=j;
//内forend
//外forend
若利用图8-3所示邻接矩阵调用此算法，则得到边集数组CT内容如表8-1所示。
表8-1边集数组
begintabularc|c|c|c|c|c|c
hlineCT&0&1&2&3&4&5
hlinefromvex&0&3&3&5&2&3
hlineendvex&3&1&5&2&4&6
hlineweight&5&3&7&2&6&15
hline
endtabular
8.1.3克鲁斯卡尔算法
假设G=(V,E)具有n个顶点连通网，T=(U,TE)G最小生成树，U初值等于V，即包含有G全部顶点，TE初值为空。此算法基本思想：将图G边按权值从小到大顺序依次选取，若选取边使生成树T不形成回路，则把它并入TE，保留作为T一条边；若选取边使生成树T形成回路，则将其舍弃，如此进行下去，直到TE包含有n-1条边为止，此时T即为最小生成树。
以如图8-5(a)所示例来说明此算法。设此图用边集数组表示，且数组各边按权值从小到大顺序排列，若没有按序排列，则可通过调用排序算法，使之成为有序，如图8-5(b)所示，这样按权值从小到大选取各边就转换成按边集数组下标次序选取各边。当选取前3条边时，均不产生回路，应保留作为生成树T边，如图8-5(b)所示；选第4条边(2,3)时，将与已保留边形成回路，应舍去；接着保留(1,5)边，舍去(3,5)边；取到(0,1)边并保留后，保留边数已够5条（即n-1条），此时必定将全部6个顶点连通起来，如图8-5(c)所示，它就是图8-5(a)最小生成树。
实现克鲁斯卡尔算法关键之处：如何判断欲加入T一条边是否与生成树中已保留边形成回路。这可将各项点划分不同集合方法来解决，每个集合顶点表示无回路连通分量。算法开始时，由于生成树顶点集等于图G顶点集，边集空，所以n个顶点分属于n个集合，每个集合只有顶点，表明顶点之间互不连通。对于图8-5(a)，其六个集合：0,1,2,3,4,5
(a)连通网
(b)取到三条边
(c)最小生成树
(d)边集数组
图8-5克鲁斯卡尔算法求最小生成树示意图
当边集数组按次序选取一条边时,若它两个端点分属于不同集合,则表明此边连通两个不同连通分量,因每个连通分量无回路,所以连通后得到连通分量仍不会产生回路,此边应保留作为生成树一条边,同时把端点所在两个集合合并成,即成为连通分量;当选取一条边两个端点同属于集合时,此边应放弃,因同一个集合顶点连通无回路,若再加入一条边则必产生回路。上述例子,当选取(0,4)、(1,2)、(1,3)这三条边后,顶点集合则变成如下3个:0,4,1,2,3,5下一条边(2,3)两端点同属于集合,故舍去,再下一条边(1,5)两端点属于不同集合,应保留,同时把两个集合1,2,35合并成1,2,3,5,以此类推,直到所有顶点同属于集合,即进行n-1次合并,保留n-1条生成树边为止。
为了用C++语言编写出利用克鲁斯卡尔算法求图最小生成树具体实现,设GE具有edgeset类型边集数组,并假定每条边按照权值从小到大顺序存放;再设CT也具有edgeset类型边集数组,用该数组存储依次所求得生成树中每一条边;另外,还要设具有bool类型一个二维数组,用s[n][n]表示,它每一行元素用来保存相应连通子图所在顶点集合,若该行下标t元素真,则表明顶点v_t属于这个集合。
根据以上分析,给出克鲁斯卡尔算法具体描述如下。
voidKruskal(edgesetGE,edgesetCT,intn)
//求边集数组GE所示图最小生成树,树中每条边依次存于数组CT
inti,j;
//定义具有nn个元素动态分配二维数组s
bools=newbool[n];
for(i=0;i<n;i++)s[i]=newbool[n];
//初始化s集合,使每顶点分属于对应集合
for(i=0;i<n;i++)
```cpp
for(j=0;j<n;j++)
if(i==j)s[i][j]=true;
elses[i][j]=false;
//定义相应变量
intk=1;//k表示待获取最小生成树中边数,初值1
intd=0;//d表示GE中待扫描边元素下标位置,初值0
intm1,m2;//m1m2分别保存一条边两个顶点所在集合序号
//进行n-1次循环,得到最小生成树中n-1条边
while(k<n)
for(i=0;i<n;i++)
//求出边GE[d]两个顶点所在集合序号m1m2
if(s[i][GE[d].fromvex]==true)m1=i;
if(s[i][GE[d].endvex]==true)m2=i;
if(m1!=m2)
//若两集合序号不,则表明GE[d]生成树中一条边
//应将它加入到数组CT
CT[k-1]=GE[d];
k++;
for(j=0;j<n;j++)
//合并两个集合,并将另置空集
s[m1][j]=s[m1][j]||s[m2][j];
s[m2][j]=false;
d++;//d后移位置,以便扫描GE下一条边
//释放s动态分配数组空间
for(i=0;i<n;i++)delete[]s[i];
delete[]s;
若利用图8-5(d)所示边集数组调用此算法,则最后得到CT数组如表8-2所示。
表8-2数组CT
begintabularc|c|c|c|c|c|
hline
CT&0&1&2&3&4
hline
fromvex&0&1&1&1&0
hline
endvex&4&2&3&5&1
hline
weight&4&5&8&12&18
hline
endtabular
以上两个算法时间复杂度均O(n^2),普里姆算法空间复杂度O(1),克鲁斯卡尔算法空间复杂度O(n^2)。
```
当连通网中不存在权值相同边时，无论采用什么方法得到最小生成树都唯一，但若存在着相同权值边则得到最小生成树可能不唯一，当然最小生成树权相同。
section8.2最短路径
subsection8.2.1最短路径概念
由图概念可知，图中，若一顶点到另一项点存在着一条路径(本节只讨论无回路简单路径)，则路径长度该路径上所经过边数目，它也等于该路径上顶点数减1。由于一项点到另一项点可能存在着多条路径，每条路径上所经过边数可能不同，即路径长度不同，把路径长度最短(即经过边数最少)那条路径叫做最短路径，其路径长度叫做最短路径长度或最短距离。
图最短路径问题不只是对无权图而言，若图带权图，则把顶点i到图其余任顶点j一条路径上所经过边权值之定义该路径带权路径长度，v_i到v_j可能不止一条路径，把带权路径长度最短（即其值最小）那条路径也称做最短路径，其权值也称做最短路径长度或最短距离。
如图8-6所示，v_0simv_4共有3条路径：0,4、0,1,3,40,1,2,4，其带权路径长度分别30,2338，可知最短路径0,1,3,4，最短距离23。
(a)带权图
(b)邻接矩阵
图8-6带权图对应邻接矩阵
实际上，这两类最短路径问题可合并一类，只要把无权图上每条边标上数值1权就归属于有权图，所以以后讨论，若不特别指明，均认为求带权图最短路径问题。
求图最短路径问题用途很广。，若用图表示城市之间运输网，图顶点代表城市，图上边表示两端点对应城市之间存在着运输线，边上权表示该运输线上运输时间或单位重量运费，考虑到两城市间海拔高度不同，流水方向不同因素，将造成来回运输时间或运费不同，所以这种图通常有向图。如何能够使一城市到另一城市运输时间最短或者运费最省呢？这就是求两城市间最短路径问题。
求图最短路径问题包括两个方面：求图一顶点到其余各项点最短路径；求图
每对顶点之间最短路径。下面分别进行讨论。
section8.2.2一顶点到其余各顶点最短路径
对于具有n个顶点e条边图G,某一项点v_i(称此源点)到其余任一项点v_j(称此终点)最短路径,可能它们之间边(i,j)或langlei,jrangle,也可能经过k个(1leqkleqn-2,最多经过除源点终点之外所有顶点)中间顶点k+1条边所形成路径。图8-6,v_0到v_1最短路径就是它们之间有向边langle0,1rangle,其长度3;v_0到v_4最短路径经过两个中间点v_1v_3以及3条有向边langle0,1rangle,langle1,3ranglelangle3,4rangle,其长度23。
那么,如何求出源点i到图其余每顶点最短路径呢?狄克斯特拉(Dijkstra)于1959年提出解决此问题一般算法,具体做法按照源点到其余每一顶点最短路径长度升序依次求出源点到各顶点最短路径及长度,每次求出源点i到终点m最短路径及长度后,都要以该顶点m作为新考虑中间点,用v_i到v_m最短路径最短路径长度对v_i到其他尚未求出最短路径那些终点当前最短路径及长度作必要地修改,使之成为当前新最短路径最短路径长度,当进行n-2次(因最多考虑n-2个中间点)后算法结束。
狄克斯特拉算法需要设置集合,用S表示,其作用保存已求得最短路径终点序号,它初值只有元素,即源点i,以后每求出源点i到终点m最短路径,就将该顶点m并入S集合,以便作为新考虑中间点;还需要设置具有权值类型一维数组textdist[n],该数组第j个元素textdist[j]用来保存源点i到终点j目前最短路径长度,它初值(i,j)或langlei,jrangle边上权值,若v_i到v_j没有边,则权值MaxValue,以后每考虑新中间点时,textdist[j]值可能变小;另外,再设置与textdist数组相对应、类型edgenode一维指针数组path,该数组第j个元素textpath[j]指向单链表,该单链表中保存着源点i到终点j目前最短路径,即顶点序列,当v_i到v_j存在着一条边时,则textpath[j]初始指向由顶点ij构成单链表,否则textpath[j]初值为空。
此算法执行过程:首先S集合以外顶点(即待求出最短路径终点)所对应textdist数组元素,查找出其值最小元素,假定textdist[m],该元素值就是从源点i到终点m最短路径长度(证明从略),对应textpath数组元素textpath[m]所指向单链表链接着源点i到终点m最短路径,即经过顶点序列或称边序列;接着把己求得最短路径终点m并入集合S;然后以v_m作为新考虑中间点,对S集合以外每个顶点j,比较textdist[m]+textGA[m][j](textGA图G邻接矩阵)与textdist[j]大小,若前者小于后者,表明加入新中间点v_m之后,v_i到v_j路径长度比原来变短,应用它替换textdist[j]原值,使textdist[j]始终保持到目前为止最短路径长度,同时把textpath[m]单链表复制到textpath[j]上,并其后插入v_j结点,使之构成源点i到终点j目前最短路径。重复n-2次上述运算过程,即可textdist数组得到源点i到其余每个顶点最短路径长度,textpath数组得到相应最短路径。
为了简便起见,可采用一维数组s[n]来保存已求得最短路径终点集合S,具体做法:若顶点j集合S,则令数组元素s[j]值真,否则假。这样,当判断顶点j是否集合S以外时,只要判断对应数组元素s[j]是否假即可。
，对于图8-6来说，若求源点v_0到其余各顶点最短路径，则开始时3个一维数组s,distpath值如表8-3所示。
表8-3初始状态
begintabularc|c|c|c|c|c|
hline&0&1&2&3&4
hlines&1&0&0&0&0
hlinedist&0&3&infty&infty&30
hlinepath&&v_0,v_1&&&v_0,v_4
hline
endtabular
开始进行第1次运算，求出源点v_0到第1个终点最短路径。首先s元素0对应dist元素，查找出值最小元素，求得dist[1]值最小，所以第1个终点v_1，最短距离dist[1]=3，最短路径path[1]=0,1，接着把s[1]置真(1)，表示v_1已加入S集合，然后以v_1新考虑中间点，对s数组元素假(0)每个顶点j（此时2leqjleq4）目前最短路径长度dist[j]目前最短路径path[j]进行必要修改，因dist[1]+GA[1][2]=3+25=28，小于dist[2]=infty，所以将28赋给dist[2]，将path[1]并上v_2后赋给path[2]，同理因dist[1]+GA[1][3]=3+8=11，小于dist[3]=infty，所以将11赋给dist[3]，将path[1]并上v_3后赋给path[3]，最后再看v_0到v_4，以v_1作为新考虑中间点情况，由于v_1到v_4没有出边，所以GA[1][4]=infty，故dist[1]+GA[1][4]不小于dist[4]，因此dist[4]path[4]无需修改，应维持原值。至此，第1次运算结束，3个一维数组当前状态如表8-4所示。
表8-4得到终点v_1begintabularc|c|c|c|c|c|
hline&0&1&2&3&4
hlines&1&1&0&0&0
hlinedist&0&3&28&11&30
hlinepath&&v_0,v_1&v_0,v_1,v_2&v_0,v_1,v_3&v_0,v_4
hline
endtabular
接着进行第2次运算，求出源点v_0到第2个终点最短路径。首先s数组元素0对应dist元素，查找出值最小元素，求得dist[3]值最小，所以第2个终点v_3，最短距离dist[3]=11，最短路径path[3]=0,1,3，接着把s[3]置1，然后以v_3作为新考虑中间点，对s元素0每个顶点j（此时j=2,4）dist[j]path[j]进行必要修改，因dist[3]+GA[3][2]=11+4=15，小于dist[2]=28，所以将15赋给dist[2]，将path[3]并上v_2后赋给path[2]，同理，因dist[3]+GA[3][4]=11+12=23，小于dist[4]=30，所以将23赋给dist[4]，将path[3]并上v_4后赋给path[4]。至此，第2次运算结束，3个一维数组当前状态如表8-5所示。
表8-5得到终点v_3begintabularc|c|c|c|c|c|
hline&0&1&2&3&4
hlines&1&1&0&1&0
hlinedist&0&3&15&11&23
hlinepath&&v_0,v_1&v_0,v_1,v_3,v_2&v_0,v_1,v_3&v_0,v_1,v_3,v_4
hline
endtabular
然后进行第3次运算，求出源点v_0到第3个终点最短路径。首先s元素
0对应dist元素,查找出值最小元素dist[2]，所以求得第3个终点v_2，最短距离dist[2]=15，最短路径path[2]=(0,1,3,2)，接着把s[2]置1，然后以v_2作为新考虑中间点，对s元素0每个顶点j（此时只有v_4）dist[j]path[j]进行必要修改，因dist[2]+GA[2][4]=15+10=25，大于dist[4]=23，所以无需修改，原值不变。至此，第3次运算结束，3个一维数组当前状态如表8-6所示。
表8-6得到终点v_2begintabular|c|c|c|c|c|c|
hline&0&1&2&3&4
hlinemultirow3s&multicolumn5|c|begintabularl
0
1
endtabular
hlinedist&0&3&15&11&23
hlinepath&&v_0,v_1&v_0,v_1,v_3,v_2&v_0,v_1,v_3&v_0,v_1,v_3,v_4
hline
endtabular
由于图中有5个顶点，只需运算3次，即n-2次，虽然此时还有顶点未加入S集合，但它最短路径及最短距离已经最后确定，所以整个运算结束。最后dist得到源点v_0到每个顶点最短路径长度，path得到相应最短路径。
如果用图形表示上述过程每次运算结果，则对应图形分别如图8-7(b)～图8-7(e)所示，其中实线有向边所指向顶点集合S顶点，虚线有向边所指向顶点集合S外顶点；S集合顶点上所标数值源点v_0到该顶点最短路径长度，源点v_0到该顶点所经过有向边v_0到该顶点最短路径；S集合外顶点上所标数值源点v_0到该顶点目前最短路径长度，v_0到该顶点所经过有向边v_0到该顶点目前最短路径。为了便于对照分析，把图8-6(a)重画于图8-7(a)。
(a)带权图
(b)初始状态
(c)得到终点v_1(d)得到终点v_3(e)得到终点v_2图8-7利用狄克斯特拉算法求最短路径图形说明
根据以上分析举例，不难给出狄克斯特拉算法描述如下。
voidDijkstra(adjmatrixGA,intdist[],
edgenodepath[],inti,intn)
//利用狄克斯德拉算法求图GA顶点i到其余每个顶点间
//最短距离最短路径，它们分别存于数组distpath
intj,k,w,m;
//定义作为集合使用动态数组s
bools=newbool[n];
//分别给s,distpath数组赋初值
for(j=0;j<n;j++)
if(j==i)s[j]=true;elses[j]=false;
dist[j]=GA[i][j];
if(dist[j]<MaxValue&&j!=i)
edgenodep1=newedgenode;
edgenodep2=newedgenode;
p1->adjvex=i;p2->adjvex=j;p2->next=NULL;
p1->next=p2;path[j]=p1;
else
path[j]=NULL;
//共进行n-2次循环，每次求出源点i到终点m最短路径及长度
for(k=1;k<=n-2;k++)
//求出第k个终点m
w=MaxValue;m=i;
for(j=0;j<n;j++)
if(s[j]==false&&dist[j]<w)
w=dist[j];m=j;
//若条件成立，则把顶点m并入集合S，否则退出循环，因为剩余
//顶点，其最短路径长度均MaxValue，无需再计算下去
if(m!=i)s[m]=true;
elsebreak;
//对s元素false对应distpath元素作必要修改
for(j=0;j<n;j++)
if(s[j]==false&&dist[m]+GA[m][j]<dist[j])
dist[j]=dist[m]+GA[m][j];
PATH(path,m,j);//调用此函数，由到顶点m最
//短路径顶点j构成到顶点j目前最短路径
PATH函数定义如下。
voidPATH(edgenodepath,intm,intj)
//由到顶点m最短路径顶点j构成到顶点j目前最短路径
edgenodep,q,s;
//把顶点j当前最短路径清除掉
p=path[j];
while(p!=NULL)
path[j]=p->next;
deletep;
p=path[j];
//把到顶点m最短路径复制过来到顶点j最短路径上
p=path[m];
while(p!=NULL)
q=newedgenode;
q->adjvex=p->adjvex;
if(path[j]==NULL)path[j]=q;
elses->next=q;
s=q;
p=p->next;
//把顶点j加入到path[j]单链表最后，形成新目前最短路径
q=newedgenode;
q->adjvex=j;
q->next=NULL;
s->next=q;
8.2.3每对顶点之间最短路径
求图每对顶点之间最短路径指把图任意两个顶点v_iv_j(ineqj)之间最短路径都计算出来。若图有n个顶点，则共需要计算n(n-1)条最短路径。解决此问题有两种方法：第1种分别以图每个顶点源点共调用n次狄克斯特拉算法，因狄克斯特拉算法时间复杂度O(n^2)，所以此方法时间复杂度O(n^3)；第2种采用下面介绍弗洛伊德（Floyd）算法，此算法时间复杂度仍为O(n^3)，但比较简单。
弗洛伊德算法从图邻接矩阵开始，按照顶点v_0,v_1,cdots,v_n-1次序，分别以每个顶点v_k(0leqk<n-1)作为新考虑中间点，第k-1次运算得到A^(k-1)(A^(-1))图邻接矩阵GA基础上，求出每对顶点v_i到v_j目前最短路径长度A^(k)[i][j]，计算公式：A^(k)[i][j]=min(A^(k-1)[i][j],A^(k-1)[i][k]+A^(k-1)[k][j])quad(0leqileqn-1,;0leqjleqn-1)其中，min函数表示取其参数表较小值，参数表前项表在第k-1次运算后得到v_i到v_j目前最短路径长度，后项表示考虑以v_k作为新中间点所得到v_i到v_j
路径长度。若后项小于前项，则表明以v_k作为中间点（不排除已经以v_0,v_1,cdots,v_n-1
一部分作为其中间点）使得v_i到v_j路径长度变短，所以应把它值赋给A^(k)[i][j]，否则把A^(k-1)[i][j]值赋给A^(k)[i][j]。总之，使A^(k)[i][j]保存第k次运算后得到v_i到v_j
目前最短路径长度。当k0取到n-1后，矩阵A^(n-1)就是最后得到结果，其中每个元素A^(n-1)[i][j]就是从顶点v_i到v_j最短路径长度。
对于上面计算公式，当i=j时变为：A^(k)[i][i]=min(A^(k-1)[i][i],A^(k-1)[i][k]+A^(k-1)[k][i])quad(0leqileqn-1)若k=0，则参数表前项A^(-1)[i][i]=GA[i][i]=0，后项A^(-1)[i][0]+A^(-1)[0][i]必定大于等于0，所以A^(0)对角线元素同A^(-1)对角线元素一样，均0。同理，当k=1,2,cdots,n-1时，A^(k)对角线元素也均0。
对于上面计算公式，当i=k或j=k时分别变为：beginaligned
A^(k)[k][j]&=min(A^(k-1)[k][j],A^(k-1)[k][k]+A^(k-1)[k][j])quad(0leqjleqn-1)
A^(k)[i][k]&=min(A^(k-1)[i][k],A^(k-1)[i][k]+A^(k-1)[k][k])quad(0leqileqn-1)
endaligned每个参数表后一项都由它前一项加上A^(k-1)[k][k]所组成，因A^(k-1)[k][k]=0，所
以A^(k)[k][j]A^(k)[i][k]分别取上一次运算结果A^(k-1)[k][j]A^(k-1)[i][k]值，也就是说，
矩阵A^(k)第k行第k列上元素均取上一次运算结果。
下面以如图8-8(a)所示每对顶点之间最短路径长度例来说明弗洛伊德算法运算过程。
n
(a)有向带权图
(b)邻接矩阵
(c)第0次运算结果
(d)第1次运算结果
(e)第2次运算结果
(f)第3次运算结果
图8-8弗洛伊德算法求最短路径运算过程
(1)令k取0，即以v_0作为新考虑中间点，对图8-8(b)所示A^(-1)每对顶点之
间路径长度进行必要修改后得到第0次运算结果A^(0)，如图8-8(c)所示。A^(0)，
第0行第0列用虚线框起来表示i=kj=k情况，它们同对角线上元素一样A^(-1)对应值，对于其他6个元素，若v_i通过新中间点v_0然后到v_j路径长度A^(-1)[i][0]+
A^(-1)[0][j]小于原来路径长度A^(-1)[i][j]，则用前者修改之，否则仍保持原值。因v_2到v_1路径长度A^(-1)[2][1]=5，通过新中间点v_0后变短，即为A^(-1)[2][0]+A^(-1)[0][1]=3+1=4，
所以修改4,对应路径2,0,1;同样,v_2到v_3路径长度通过新中间点v_0后也由8变为7,所以修改7,对应路径2,0,3;剩余4对顶点路径长度,因加入v_0作为新中间点后仍不变短,所以保持原值不变。
(2)令k=1,即以v_1作为新考虑中间点,对A^(0)每对顶点之间路径长度进行必要修改后得到第1次运算结果A^(1),如图8-8(d)所示。此时第1行第1列同对角线元素一样,取上一次值,对于其他6个元素,若v_i通过新中间点v_1然后到v_j路径长度A^(0)[i][1]+A^(0)[1][j]小于原来路径长度A^(0)[i][j],则用前者修改之,否则仍保持原值。因v_0到v_2路径长度A^(0)[0][2]=infty,通过新中间点v_1后变短,即为A^(0)[0][1]+A^(0)[1][2]=1+9=10,所以修改10,对应路径0,1,2;v_0到v_3路径长度A^(0)[0][3]=4,通过新中间点v_1后变短,即为A^(0)[0][1]+A^(0)[1][3]=1+2=3,所以也修改3,对应路径0,1,3;v_2到v_3路径长度A^(0)[2][3]=7,通过新中间点v_1后也变短,即为A^(0)[2][1]+A^(0)[1][3]=4+2=6,所以第一次修改基础上又重新修改6,对应路径A^(0)[2][1]路径2,0,1并上A^(0)[1][3]路径1,3,即为2,0,1,3;剩余3对顶点路径长度,因加入新中间点v_1后不变短,所以仍保持原值不变。
(3)令k=2,即以v_2作为新考虑中间点,对A^(1)每对顶点路径长度进行必要地修改,得到第2次运算结果,如图8-8(e)所示。同上两次分析过程一样,请读者分析这一次结果。
(4)令k=3,即以v_3作为新考虑中间点,这也最后要考虑中间点,A^(2)基础上进行运算,得到运算结果A^(3),如图8-8(f)所示,也请读者自行分析。A^(3)每个元素A^(3)[i][j]值就是图8-8(a)顶点v_i到v_j最短路径长度。当然相应最短路径也可以,通过另设矩阵记录下来。
通过以上分析可知,每次运算,对i=k,j=k或i=j那些元素无需进行计算,因为它们不会修改,对于其余元素,只有满足A^(k-1)[i][k]+A^(k-1)[k][j]<A^(k-1)[i][j]元素才会修改,即把小于号左边两个元素之赋给A^(k)[i][j],这两个元素,前者列号等于k,后者行号等于k,所以它们进行第k次运算整个过程,其值都不会改变,即上一次运算结果,故每一次运算都可以原数组上“就地”进行,即用新修改值替换原值即可,不需要使用两个数组交替进行。
假设有n个顶点带权图G邻接矩阵用GA表示,与GA同类型,求每对顶点之间最短路径长度二维数组用A表示,A初值等于GA。弗洛伊德算法需要A上进行n次运算,每次以v_k(0leqkleqn-1)作为新考虑中间点,求出每对顶点之间当前最短路径长度,最后一次运算后,A每个元素A[i][j]就是图G顶点v_i到顶点v_j最短路径长度。利用C++语言编写弗洛伊德算法如下,假定该算法不需要记录每对顶点之间最短路径,只需要记录每对顶点之间最短长度。
voidFloyd(adjmatrixGA,adjmatrixA,intn)
//利用弗洛伊德算法求GA表示图每对顶点之间最短长度
//对应保存于二维数组A
inti,j,k;
```cpp
//给二维数组A赋初值,它等于图邻接矩阵GA
for(i=0;i<n;i++)
for(j=0;j<n;j++)
A[i][j]=GA[i][j];
//依次以每个顶点作为中间点,逐步优化数组A
for(k=0;k<n;k++)
for(i=0;i<n;i++)
for(j=0;j<n;j++)
if(i==k||j==k||i==j)continue;
if(A[i][k]+A[k][j]<A[i][j])
A[i][j]=A[i][k]+A[k][j];
用下面程序调试弗洛伊德算法。
include<iostream.h>
include<stdlib.h>
include<strstrea.h>//使用字符串流所需系统头文件
include<string.h>
typedefintVertexType;//定义顶点值类型
typedefintWeightType;//定义边上权值类型
constintMaxVertexNum=10;//定义图最多顶点数
constWeightTypeMaxValue=1000;//定义无边上特定权值
typedefVertexTypevexlist[MaxVertexNum];//定义vexlist存储顶点信息数组类型
typedefintadjmatrix[MaxVertexNum][MaxVertexNum];//定义adjmatrix存储邻接矩阵数组类型
include"采用邻接矩阵存储图常用运算.cpp"
voidFloyed(adjmatrixGA,adjmatrixA,intn)
弗洛伊德算法,函数定义同上
voidmain()
intn,k1,k2;
cout<<"输入待处理图顶点数:";
cin>>n;
```
cout<<"输入图有无向有无权选择(0无,非0有):";ncin>>k1>>k2;nadjmatrixga;nInitMatrix(ga,k2);ncout<<"输入图边集:"<<endl;nchara=newchar[100];n//cin>>a;//输入图边集nstrcpy(a,"<0,1>1,<0,3>4,<1,2>9,<1,3>2,<2,0>3,<2,1>5,");nstrcat(a,"<2,3>8,<3,2>6");//字符数组a保存图8-8（a）边集nCreateMatrix(ga,n,a,k1,k2);ncout<<"以二元组形式输出邻接矩阵ga:"<<endl;nPrintMatrix(ga,n,k1,k2);nadjmatrixgb;nInitMatrix(gb,k2);nFloyed(ga,gb,n);//每对顶点最短路径保存gbncout<<"以二元组形式输出邻接矩阵gb:"<<endl;nPrintMatrix(gb,n,k1,k2);nnn程序运行结果如下。nn输入待处理图顶点数:4n输入图有无向有无权选择(0无,非0有):11n输入图边集:n以二元组形式输出邻接矩阵ga:nV=0,1,2,3nE=<0,1>1,<0,3>4,<1,2>9,<1,3>2,<2,0>3,<2,1>5,<2,3>8,<3,2>6,n以二元组形式输出邻接矩阵gb:nV=0,1,2,3nE=<0,1>1,<0,2>9,<0,3>4,<1,0>11,<1,2>8,<1,3>2,<2,0>3,<2,1>4,n<2,3>6,<3,0>9,<3,1>10,<3,2>6,nnsection8.3拓扑排序nnsubsection8.3.1拓扑排序概念nn较大工程经常分成许多子工程，把这些子工程称做活动（activity）。整个工程，有些子工程（活动）必须其他有关子工程完成之后才能开始，也就是说，子工程开始以它所有前序子工程结束先决条件，但有些子工程没有先决条件，可以安排任何时间开始。为了形象地反映出整个工程各个子工程（活动）之间先后关系，可用有向图来表示，图中顶点代表活动（子工程），图中有向边代表活动
先后关系，即有向边起点活动终点活动前序活动，只有当起点活动完成之后，其终点活动才能进行。通常，把这种顶点表示活动、边表示活动间先后关系有向图称做顶点活动网（ActivityOnVertexnetwork,AOVnetwork）。
，计算机专业学生必须完成如图8-9所示全部课程。
begintabularccc
hline课程代号&课程名称&先修课程
hlineC1&高等数学&无
C2&程序设计基础&无
C3&离散数学&C1,C2
C4&数据结构&C3,C5
C5&算法语言&C2
C6&编译技术&C4,C5
C7&操作系统&C4,C9
C8&普通物理&C1
C9&计算机原理&C8
hline
endtabular
图8-9课程表
这里用课程代表活动，学习一门课程就表示进行一项活动，学习每门课程先决条件学完它全部先修课程。学习《数据结构》课程就必须安排学完它两门先修课程《离散数学》《算法语言》之后。学习《高等数学》课程则可以随时安排，因为它基础课程，没有先修课。用AOV网来表示这种课程安排先后关系，如图8-10所示。图中每个顶点代表一门课程，每条有向边代表起点对应课程终点对应课程先修课。从图可以清楚地看出各课程之间先修后续关系。课程C5先修课C2，后续课程C4C6；C6先修课C4C5，它无后续课。
AOV网应该有向无环图，即不应该带有回路，因为若带有回路，则回路上所有活动都无法进行。如图8-11所示具有三个顶点回路，由<A,B>边可得B活动必须A活动之后，由<B,C>边可得C活动必须B活动之后，所以推出C活动必然A活动之后，但由<C,A>边可得C活动必须A活动之前，从而出现矛盾，使每一项活动都无法进行。这种情况若程序出现，则称为死锁或死循环，应该必须避免。
begintabularccc
includegraphics[width=0.4textwidth]image1.png&multicolumn2cincludegraphics[width=0.2textwidth]image2.png
图8-10AOV网&multicolumn2c图8-11三个顶点回路
endtabular
AOV网中，若不存在回路，则所有活动可排列成线性序列，使得每个活动所有前驱活动都排该活动前面，把此序列叫做拓扑序列（topologicalorder），由AOV
网构造拓扑序列过程叫做拓扑排序（topologicalsort）。AOV网拓扑序列不是唯一，满足上述定义任一线性序列都称做它拓扑序列。，下面3个序列都图8-10拓扑序列，当然还可以写出许多。
(1)C1,C8,C9,C2,C3,C5,C4,C7,C6。
(2)C2,C1,C3,C5,C4,C6,C8,C9,C7。
(3)C1,C2,C3,C8,C9,C5,C4,C6,C7。
由AOV网构造出拓扑序列实际意义：如果按照拓扑序列顶点次序，开始每一项活动时，能够保证它所有前驱活动都已完成，从而使整个工程顺序进行，不会出现冲突情况。
由AOV网构造拓扑序列拓扑排序算法主要循环执行以下两步，直到不存在入度0顶点为止。
(1)选择入度0顶点并输出之。
(2)网中删除此顶点及所有出边。
循环结束后，若输出顶点数小于网中顶点数，则输出“有回路”信息，否则输出顶点序列就是一种拓扑序列。
如图8-12(a)所示为例，来说明拓扑排序算法执行过程。
(1)图8-12(a)v_0v_1入度都0，不妨选择v_0并输出之，接着删去顶点v_0及出边<0,2>，得到结果如图8-12(b)所示。
(2)图8-12(b)只有入度0顶点v_1，输出v_1，接着删去v_1它三条出边<1,2>,<1,3><1,4>，得到结果如图8-12(c)所示。
(3)图8-12(c)v_2v_4入度都0，不妨选择v_2并输出之，接着删去v_2及两条出边<2,3><2,5>，得到结果如图8-12(d)所示。
(4)图8-12(d)上依次输出顶点v_3、v_4v_5，并每个顶点输出后删除该顶点及出边，操作都很简单，不再赘述。
n
(a)AOV网
n
(b)删除v_0后
n
(c)删除v_1后
n
(d)删除v_2后
n
图8-12拓扑排序图形说明
8.3.2拓扑排序算法
为了利用C++语言计算机上实现AOV网拓扑排序,AOV网采用邻接表表示较方便。对于图8-12(a),对应邻接表,如图8-13所示。
![image](attachment://figure_8_13.png)
图8-13图8-12（a）链接表
拓扑排序算法,需要设置包含n个元素一维整型数组,设用mathbfd表示,用它来保存AOV网中每个顶点入度值。对于图8-12(a),得到数组mathbfd初始值:
![image](attachment://array_d.png)
进行拓扑排序,为了把所有入度0顶点都保存起来,而且又便于插入、删除以及节省存储,最好方法把它们链接成栈。另外,保存入度数组mathbfd,当顶点v_i入度0时,下标i元素mathbfd[i]值0,该元素也就空闲下来,正好可利用它作为链栈结点使用,保存下入度0顶点序号,这样就可以把所有入度0顶点通过数组mathbfd对应元素静态地链接成栈。对于删除入边而新产生入度0顶点就压入此栈,输出入度0顶点就是删除栈顶元素。这个链栈,栈顶指针top指向入度0顶点,其值数组mathbfd中下入度0元素下标,此处元素值又数组mathbfd另入度0元素下标,以此类推,最后入度0元素值-1,表示栈底。
根据如图8-13所示邻接表,建立入度0初始栈过程如下。
(1)开始置链栈空,即给链栈指针top赋初值-1。
top=-1;
(2)将入度0元素mathbfd[0]进栈,mathbfd[0]=texttop;operatornametop=0;此时top指向mathbfd[0]元素,表示顶点v_0入度0,而mathbfd[0]值-1,表明栈底。
(3)将入度0元素mathbfd[1]进栈,即:
d[1]=top;top=1;
此时top指向d[1]元素，表示顶点v_1入度0，而d[1]值0，表明下入度0元素d[0]，即对应下入度0顶点v_0，d[0]值-1，所以此栈当前有两个元素d[1]d[0]。
（4）因d[2]~d[5]值均不0，即对应v_2simv_5入度均不0，所以它们均不进栈。至此，初始栈建立完毕，得到数组d:
[
beginarray|c|c|c|c|c|c|
hline
0&1&2&3&4&5
hline
-1&0&2&2&1&3
hline
endarray
]uparrowtop=1
由此可知，数组d具有两方面功能：存储所有顶点入度；链接入度0顶点形成链栈。
将入度0顶点利用上述链栈链接起来后，拓扑算法循环执行“选择入度0顶点并输出之”，可通过输出栈顶指针top所代表顶点序号来实现；“AOV网中删除刚输出顶点（假定v_j，其中j等于top值）及所有出边”，可通过首先做退栈处理，使top指向下—个入度0元素，然后遍历v_j邻接表，分别把所有邻接点入度减1，若减1后入度0则令该元素进栈操作来实现。，该循环终止条件“直到不存在入度0顶点为止”，可通过判断栈空来实现。
对于图8-12(a)，当删除由top值所代表顶点v_1及所有出边后，数组d变为:
[
beginarray|c|c|c|c|c|c|
hline
0&1&2&3&4&5
hline
-1&0&1&1&0&3
hline
endarray
]uparrowtop=4
当依次删除top所表示每个顶点及所有出边后，数组d变化分别如图8-14所示。
[
beginarray|c|c|c|c|c|c|
hline
0&1&2&3&4&5
hline
-1&0&1&1&0&2
hline
endarray
]uparrowtop=0
(a)删除顶点v_4及所有出边
[
beginarray|c|c|c|c|c|c|
hline
0&1&2&3&4&5
hline
-1&0&-1&-1&0&1
hline
endarray
]uparrowtop=3
(c)删除顶点v_2及所有出边
[
beginarray|c|c|c|c|c|c|
hline
0&1&2&3&4&5
hline
-1&0&-1&1&0&2
hline
endarray
]uparrowtop=2
(b)删除顶点v_0及所有出边
[
beginarray|c|c|c|c|c|c|
hline
0&1&2&3&4&5
hline
-1&0&-1&-1&0&-1
hline
endarray
]uparrowtop=5
(d)删除顶点v_3及所有出边
图8-14数组d变化示意图
当删除顶点v_5及所有出边后，top值-1，表示栈空，至此此算法执行结束，得到拓扑序列:1,4,0,2,3,5。
根据以上分析，给出拓扑排序算法具体描述如下。
voidToposort(adjlistGL,intn)//对用邻接表GL表示有向图进行拓扑排序
inti,j,k,top,m=0;//m用来统计拓扑序列顶点数
edgenodep;
//定义存储图中每个顶点入度一维整型数组d
intd=newint[n];
//初始化数组d每个元素值为0
for(i=0;i<n;i++)d[i]=0;
//利用数组d对应元素统计出每个顶点入度
for(i=0;i<n;i++)
p=G[i];
while(p!=NULL)
j=p->adjvex;d[j]++;p=p->next;
//初始化用于链接入度0元素栈栈顶指针top-1
top=-1;
//建立初始栈
for(i=0;i<n;i++)
if(d[i]==0)d[i]=top;top=i;
//每循环一次删除顶点及所有出边
while(top!=-1)
j=top;
top=d[top];
cout<<j<<'';
m++;
p=G[j];
while(p!=NULL)
k=p->adjvex;
d[k]--;
if(d[k]==0)
d[k]=top;top=k;
p=p->next;
cout<<endl;
//当输出顶点数小于图中顶点数时,输出有回路信息
if(m<n)cout<<"Thenetworkhasacycle!"<<endl;
delete[]d;//删除动态分配数组d
拓扑排序实际上对邻接表表示图G进行遍历过程，依次访问入度0顶点邻接表，若AOV图没有回路，则需要扫描邻接表中所有边结点，加上算法开始时，建立入度数组d需要访问表头向量每个域单链表中每个结点，所以此算法时间复杂度O(n+e)。
section8.4关键路径
subsection8.4.1顶点事件发生时间
与上节AOV网相对应AOE网,即边表示活动网络。它与AOV网比较,更具有实用价值,通常用它表示工程计划或进度。
AOE网是有向带权图,图中边表示活动(子工程),边上权表示该活动持续时间(durationtime),即完成该活动所需要时间;图中顶点表示事件,每个事件活动之间转接点,即表示它所有入边活动到此完成,所有出边活动从此开始。AOE网中有两个特殊顶点(事件),称作源点,表示整个工程开始,亦即最早活动起点,显然它只有出边,没有入边;另称作汇点,表示整个工程结束,亦即最后活动终点,显然它只有入边,没有出边。除这两个顶点外,其余顶点都既有入边,也有出边,入边活动出边活动转接点。AOE网中,若包含有n个事件,通常令源点第0个事件(假定0开始编号),汇点第n-1个事件,其余事件编号(即顶点序号)分别1simn-2。
如图8-15所示AOE网,该网中包含有11项活动9个事件。如边<0,1>表示活动a_1,持续时间(即权值)6,若以天为单位,即a_1需要6天完成,它以v_0事件起点,以v_1事件终点;边<4,6><4,7>分别表示活动a_7a_8,它们持续时间分别9天7天,它们均以v_4事件起点,但分别以v_6v_7事件终点。该网中源点汇点分别第0个事件v_0最后事件v_8,它们分别表示整个工程开始结束。
![image]
图8-15AOE网
对于AOE网,待研究问题:
(1)整个工程至少需要多长时间完成?
(2)哪些活动影响工程进度关键?
AOE网中,顶点事件发生或出现必须它所有入边活动(或称前驱活动)都完成之后,也就是说,只要有入边活动没有完成,该事件就不可能发生。显然,事件最早发生时间它所有入边活动,或者说最后入边活动刚完成时间。同样,活动开始必须它起点事件发生之后,也就是说,顶点事件没有发生时,它所有出边活动(或称后继活动)都不可能开始。显然活动最早开始时间它起
点事件最早发生时间。
若用mathrmve[j]表示顶点v_j事件最早发生时间,用mathrme[i]表示v_j一条出边活动a_i最早开始时间，则有mathrme[i]=mathrmve[j]。对于AOE网中源点事件来说，因为它没有入边，所以随时都可以发生，整个工程开始时间就是它发生时间，亦即最早发生时间，通常把此时间定义0，即mathrmve[0]=0，从此开始推出其他事件最早发生时间。图8-15所示AOE网中，v_4事件发生必须a_4a_5活动都完成之后，而a_4a_5活动开始又必须分别v_1v_2事件发生之后，v_1v_2事件发生又必须分别a_1a_2活动完成之后，因a_1a_2活动都起于源点，其最早开始时间均0，所以a_1a_2完成时间分别64，这也分别v_1v_2最早发生时间，以及a_4a_5最早开始时间，故a_4a_5完成时间分别75，由此可知，v_4事件最早发生时间7，即所有入边活动最后完成时间。
以上分析可知，事件发生有待于它所有入边活动全部完成，而每个入边活动开始完成又有待于前驱事件发生，而每个前驱事件发生又有待于它们所有入边活动完成……总之，事件发生源点到该顶点所有路径上活动都完成之后，显然，其最早发生时间应等于源点到该顶点所有路径上最长路径长度。这里所说路径长度指带权路径长度，即等于路径上所有活动持续时间之。源点v_0到顶点v_4共有两条路径，长度分别75，所以v_4最早发生时间7。源点v_0到汇点v_8有多条路径，通过分析可知，其最长路径长度18，所以汇点v_8最早发生时间18。汇点事件发生，表明整个工程所有活动都已完成，所以完成图8-15所对应工程至少需要18天。
现在接着讨论如何源点v_0最早发生时间0出发，求出其余各事件最早发生时间。求事件v_k最早发生时间（即源点v_0simv_k最长路径长度）常用方法：由它每个前驱事件v_j最早发生时间（即源点v_0simv_j最长路径长度）分别加上相应入边<j,k>上权，其值最大者就是v_k最早发生时间。由此可知，必须按照拓扑序列顶点次序（即拓扑有序）求出各个事件最早发生时间，才能保证求事件最早发生时间时，它所有前驱事件最早发生时间都已求出。
设mathrmve[k]表示v_k事件最早发生时间，mathrmve[j]表示v_k前驱事件v_j最早发生时间，operatornamedut(<j,k>)表示边<j,k>上权，p表示v_k顶点所有入边集合，则AOE网中每个事件v_k(0leqslantkleqslantn-1)最早发生时间可由下式，按照拓扑有序计算出来。mathrmve[k]=maxleftmathrmve[j]+operatornamedut(<j,k>)rightquad(1leqslantkleqslantn-1,<j,k>inp,mathrmve[0]=0)按照此公式拓扑有序计算出图8-15所示AOE网中每个事件最早发生时间如下。
beginaligned&mathrmve[0]=0&mathrmve[1]=mathrmve[0]+operatornamedut(<0,1>)=0+6=6&mathrmve[2]=mathrmve[0]+operatornamedut(<0,2>)=0+4=4&mathrmve[3]=mathrmve[0]+operatornamedut(<0,3>)=0+5=5&mathrmve[4]=maxleftmathrmve[1]+operatornamedut(<1,4>),mathrmve[2]+operatornamedut(<2,4>)right&=max6+1,4+1=7&mathrmve[5]=mathrmve[3]+operatornamedut(<3,5>)=5+2=7&mathrmve[6]=mathrmve[4]+operatornamedut(<4,6>)=7+9=16endaligned
mathrmve[7]=maxmathrmve[4]+operatornamedut(<4,7>),mathrmve[5]+operatornamedut(<5,7>)=max7+7,7+4=14mathrmve[8]=maxmathrmve[6]+operatornamedut(<6,8>),mathrmve[7]+operatornamedut(<7,8>)=max16+2,14+4=18最后得到ve(8)就是汇点最早发生时间，从而可知整个工程至少需要18天完成。
不影响整个工程按时完成前提下，一些事件可以不最早发生时间发生，而允许向后推迟一些时间发生，把最晚必须发生时间叫做该事件最迟发生时间。同样，不影响整个工程按时完成前提下，一些活动可以不最早开始时间开始，而允许向后推迟一些时间开始，把最晚必须开始时间叫做该活动最迟开始时间。AOE网中任事件若最迟发生时间仍没有发生或任一项活动最迟开始时间仍没有开始，则必将影响整个工程按时完成，使工期拖延。若用mathrmvl[k]表示顶点v_k事件最迟发生时间，用mathrmI[i]表示v_k一条入边<j,k>上活动a_i最迟开始时间，用operatornamedut(<j,k>)表示a_i持续时间，则有I[i]=mathrmvl[k]-operatornamedut(<j,k>)因a_i活动最迟完成时间也就是它终点事件v_k最迟发生时间，所以a_i最迟开始时间应等于v_k最迟发生时间减去a_i持续时间，或者说，要比v_k最迟发生时间提前a_i所需要时间开始。
为了保证整个工程按时完成，所以把汇点最迟发生时间定义它最早发生时间，即mathrmvl[n]=mathrmve[n]。其他每个事件最迟发生时间应等于汇点最迟发生时间减去该事件顶点到汇点最长路径长度，或者说，每个事件最迟发生时间比汇点最迟发生时间所提前时间应等于该事件顶点到汇点最长路径上所有活动持续时间之。求事件v_j最迟发生时间常用方法：由它每个后继事件v_k最迟发生时间分别减去相应出边<j,k>上权，其值最小者就是v_j最迟发生时间。由此可知，必须按照逆拓扑有序求出各个事件最迟发生时间，这样才能保证求事件最迟发生时间时，它所有后继事件最迟发生时间都已求出。
设mathrmvl[j]表示待求v_j事件最迟发生时间，mathrmvl[k]表示v_j后继事件v_k最迟发生时间，operatornamedut(<j,k>)表示边<j,k>上权，s表示v_j顶点所有出边集合，则AOE网中每个事件v_j(0leqslantjleqslantn-1)最迟发生时间由下式，按照逆拓扑有序计算出来。mathrmvl[j]=leftbeginarraylmathrmve[n-1]minmathrmvl[k]-operatornamedut(<j,k>)endarrayquad(j=n-1)right.(0leqslantjleqslantn-2,<j,k>ins)按照此公式逆拓扑有序计算得出图8-15所示AOE网中每个事件最迟发生时间如下。beginaligned&mathrmvl[8]=mathrmve[8]=18&mathrmvl[7]=mathrmvl[8]-operatornamedut(<7,8>)=18-4=14&mathrmvl[6]=mathrmvl[8]-operatornamedut(<6,8>)=18-2=16&mathrmvl[5]=mathrmvl[7]-operatornamedut(<5,7>)=14-4=10&mathrmvl[4]=minmathrmvl[7]-operatornamedut(<4,7>),mathrmvl[6]-operatornamedut(<4,6>)&=min14-7,16-9=7&mathrmvl[3]=mathrmvl[5]-operatornamedut(<3,5>)=10-2=8endaligned
mathrmvl[2]=mathrmvl[4]-operatornamedut(<2,4>)=7-1=6mathrmvl[1]=mathrmvl[4]-operatornamedut(<1,4>)=7-1=6beginalignedmathrmvl[0]&=minmathrmvl[1]-operatornamedut(<0,1>),mathrmvl[2]-operatornamedut(<0,2>),mathrmvl[3]-operatornamedut(<0,3>)&=min6-6,6-4,8-5=0endalignedsection8.4.2计算关键路径方法算法
AOE网中每个事件最早发生时间最迟发生时间计算出来后,可根据它们计算出每个活动最早开始时间最迟开始时间。设事件v_j最早发生时间mathrmve[j],它后继事件v_k最迟发生时间mathrmvl[k],则边<j,k>上活动a_i最早开始时间mathrme[i]最迟开始时间[i]计算公式重新列出如下。leftbeginarraylmathrme[i]=mathrmve[j]mathrml[i]=mathrmvl[k]-operatornamedut(<j,k>)endarrayright.根据此计算公式可计算出AOE网中每活动a_i最早开始时间mathrme[i],最迟开始时间[i]开始时间余量[i]-mathrme[i]。如图8-16所示列出图8-15每一活动这3个时间。
|a_i|a_1|a_2|a_3|a_4|a_5|a_6|a_7|a_8|a_9|a_10|a_11|
|---|---|---|---|---|---|---|---|---|---|---|---|
|mathrme[i]|0|0|0|6|4|5|7|7|7|16|14|
|[i]|0|2|3|6|6|8|7|7|10|16|14|
|[i]-mathrme[i]|0|2|3|0|2|3|0|0|3|0|0|
图8-16计算出图8-15每个活动3个时间
其中,有些活动开始时间余量不0,表明这些活动不最早开始时间开始,至多向后拖延相应开始时间余量所规定时间开始也不会延误整个工程进展。对于活动a_5,它最早可以整个工程开工后第4天开始,至多向后拖延两天,即第6天开始。有些活动开始时间余量0,表明这些活动只能最早开始时间开始,并且必须持续时间内按时完成,否则将拖延整个工期。把开始时间余量0活动称为关键活动,由关键活动所形成源点到汇点每一条路径称为关键路径。由图8-15关键活动构成两条关键路径0,1,4,6,80,1,4,7,8,如图8-17所示。
![Picture1]
项活动开始时间余量0,故它们都关键活动。
求AOE网关键路径后,可通过加快关键活动(即缩短它持续时间)来实现缩短整个工程工期。但并不是加快任何关键活动都可以缩短其整个工程工期，只有加快那些包括所有关键路径上关键活动才能达到这个目的。，加快图8-17关键活动a_11速度，使之由4天完成变为3天完成，则不能使整个工程工期由18天变为17，因为另一条关键路径0,1,4,6,8不包括活动a_11，这只能使它所在关键路径0,1,4,7,8变为非关键路径。而活动a_1a_4包括所有关键路径，若活动a_1由6天变为4天完成，则整个工程工期可由18天缩短16天。另一方面，关键路径可以变化，提高某些关键活动速度可能使原来非关键路径变为新关键路径，因而关键活动速度提高有限度。，图8-15关键活动a_1由6改为4后，路径0,2,4,6,80,2,4,7,8都变成关键路径，此时，再提高a_1速度也不能使整个工程工期提前。
下面给出用邻接表GL表示AOE网求关键路径算法。
voidCripath(adjlistGL,intn)//求邻接表GL表示AOE网关键路径
inti,j,k;
edgenodep;
//动态定义具有n个元素三个一维整型数组v,vevl
intv=newint[n];//保存拓扑排序顶点序列
intve=newint[n];//保存每个事件最早发生时间
intvl=newint[n];//保存每个事件最迟发生时间
//调用拓扑排序算法,使排序结果存于数组v
Toposort(GL,v,n);//需对上一节介绍此算法做必要修改,即
//参数表增加intv[]一项,把输出语句更换v[m]=j即可
//给每个事件最早发生时间置初值0
for(i=0;i<n;i++)ve[i]=0;
//求出每个事件最早发生时间
for(i=0;i<n;i++)
j=v[i];
p=GL[j];
while(p!=NULL)
k=p->adjvex;
if(ve[k]<ve[j]+p->weight)ve[k]=ve[j]+p->weight;
p=p->next;
//把每个事件最迟发生时间都置ve[n-1],以作为它们初值
for(i=0;i<n;i++)vl[i]=ve[n-1];
//求出每个事件最迟发生时间
for(i=n-1;i>=0;i--)
j=v[i];
p=GL[j];
while(p!=NULL)
```cpp
k=p->adjvex;
if(vl[j]>vl[k]-p->weight)vl[j]=vl[k]-p->weight;
p=p->next;
//输出AOE网中每活动最早开始时间,最迟开始时间以及开始时间余量
for(i=0;i<n;i++)
p=GL[i];
while(p!=NULL)
j=p->adjvex;
cout<<'<i<'<<i<<','<<j<<'>';
//输出有向边<i,j>,用它表示该边上活动ak
cout<<"ve["<<i<<"]";
cout<<vl[j]-p->weight<<"";
cout<<vl[j]-p->weight-ve[i]<<endl;//输出ak开始时间余量
p=p->next;
求关键路径算法时间复杂度同拓扑排序算法一样，也O(n+e)，ne分别表示图顶点数和边数。
利用下面程序调试图拓扑排序算法关键路径算法。
include<iostream.h>
include<stdlib.h>
include<strstrea.h>
constintMaxVertexNum=20;
typedefintWeightType;
structedgenode
intadjvex;
WeightTypeweight;
edgenodenext;
;
typedefedgenodeadjlist[MaxVertexNum];
include"采用邻接表存储图常用运算.cpp"
voidToposort(adjlistGL,intv[],intn)
//对用邻接表GL表示有向图进行拓扑排序
voidCripath(adjlistGL,intn)
//求邻接表GL表示AOE网关键路径
```
```cpp
voidmain()
intn,k1,k2;
cout<<"输入待处理图顶点数：";
cin>>n;
cout<<"输入图有无向有无权选择（0无，非0有）：";
cin>>k1>>k2;
adjlistgl;
InitAdjjoin(gl);
cout<<"输入图边集：";
chara=newchar[100];
cin>>a;
CreateAdjjoin(gl,n,a,k1,k2);
Cripath(gl,n);
程序一次输入运行结果如下。
输入待处理图顶点数:9
输入图有无向有无权选择（0无，非0有）：11
输入图边集：<0,1>6,<0,2>4,<0,3>5,<1,4>1,<2,4>1,<3,5>2,<4,6>9,<4,7>7,<5,7>4,<6,8>2,<7,8>4<0,3>0,3,3<0,2>0,2,2<0,1>0,0,0<1,4>6,6,0<2,4>6,6,2<3,5>5,8,3<4,7>7,7,0<4,6>7,7,0<5,7>7,10,3<6,8>16,16,0<7,8>14,14,0
第2章线性表
section2.1线性表定义抽象数据类型
subsection2.1.1线性表定义
线性表（linearlist）具有相同属性数据元素有限序列。该序列中所含元素个数称为线性表长度，用n表示，ngeq0。当n=0时，表示线性表空表，即表中不包含任何元素。设序列第i个元素a_i(1leqileqn)，则线性表一般表示：(a_1,a_2,cdots,a_i,a_i+1,cdots,a_n)其中a_1第1个元素，又称作表头元素，a_2第2个元素，a_n最后元素，又称作表尾元素。
线性表可以用标识符来命名，如用A命名上面线性表，则A=(a_1,a_2,cdots,a_i,a_i+1,cdots,a_n)线性表元素通常按照元素值或关键字有序排列。也就是说，线性表元素按照前后位置线性有序，即第i个元素a_i逻辑上第i-1个元素a_i-1后继，第i+1个元素a_i+1前驱，其中第1个元素a_1没有前驱，最后元素a_n没有后继。线性表一种线性结构，用二元组表示：textlinear_list=(A,R)其中，A=a_i|1leqileqn,ngeq0,a_iintextElemTypeR=rr=langlea_i,a_i+1rangle|1leqileqn-1对应逻辑图如图2-1所示。
n(图2-1线性表逻辑结构示意图)
线性表使用元素类型ElemType一种通用数据类型标识符，可以通过typedef语句使用前把它定义任何一种具体类型。若把它定义整数类型，则：
typedefintElemType;
由线性表定义可知，线性表长度可变，当向线性表插入元素时，其长度就增加1，当线性表删除元素时，其长度就减少1。
线性表一种线性结构，反过来，任何线性数据结构都可以用线性表形式表示出来，
这只要按照元素之间逻辑关系把它们顺序排列即可。对于第1章中列举线性数据结构linearity可用线性表表示:(05,01,03,08,02,07,04,06,09,10)因此，以后对线性表讨论就代表对任何线性数据结构讨论。
日常生活所见到各种各样表都线性表，人事档案表、职工工资表、学生成绩表、图书目录表列车时刻表。这些表通常都以关键字段（又称域或属性）值升序排列，职工工资表按职工号字段升序排列，学生成绩表按学生号字段升序排列，列车时刻表按开出时间字段升序排列。线性表中若存在着按值升序或降序排列字段，则称该字段有序字段，该线性表有序表，否则若不存在任何有序字段，则无序表。对于字符串或由一篇文章所建立文本文件，它也线性表，其元素类型字符，它们只是按照前后位置有序，而不是按照每个字符ASCII码有序，所以无序表。
下面给出几个线性表具体例子：
B=('a','b','c','4','7','+','-','','/')
C=(25,38,12,49,63,54,20,18,34,47)
D=("BASIC","PASCAL","FORTRAN","COBOL","VC++","JAVA")
E=("序号","姓名","性别","年龄","单位","职称","联系电话","E-mail")
F=(a,b,c,d,e,f,g,h,i,j,k,x,y,z)
其中B元素字符型；C元素整型；D元素字符串型；E元素也字符串型；F元素可任何类型，它同上面线性表A元素一样，每个元素都用标识符抽象表示，其目的便于做一般性考虑。
再，对于第1章表1-1和表1-2，若只考虑各记录之间位置上前后关系，即按职工号升序排列次序，则均线性表，每个线性表元素均相应记录类型。
subsection2.1.2线性表抽象数据类型
线性表抽象数据类型包括数据操作两个部分。数据部分线性表，假定用标识符L表示，它可以采用顺序、链接、散列、索引任一种方法存储到计算机，其存储类型用标识符ListType表示。操作部分对线性表所做各种操作（运算），包括：向线性表插入元素、线性表删除元素、求线性表长度、判断线性表是否为空。下面定义线性表抽象数据类型，只给出对线性表一些基本典型操作，因为线性表实际应用丰富广泛，所以不可能也没有必要给出其所有操作。
ADTLinearListis
Data:
具有ListType类型线性表L
Operation:
voidInitList(ListType&L);//初始化L为空
voidClearList(ListType&L);//清除L所有元素
intLengthList(ListType&L);//返回L长度
boolEmptyList(ListType&L);//判断L是否为空
ElemTypeGetList(ListType&L,intpos);//返回L第pos个元素值
voidTraverseList(ListType&L);//遍历输出L所有元素
boolFindList(ListType&L,ElemType&item);//L查找并返回元素
boolUpdateList(ListType&L,constElemType&item);//修改L元素
boolInsertList(ListType&L,ElemTypeitem,intpos);//向L插入元素
boolDeleteList(ListType&L,ElemType&item,intpos);//L删除元素
voidSortList(ListType&L);//对L所有元素重新按给定条件排序
endLinearList
上面对面线性表L运算，第3~7种运算不需要改变线性表状态，所以其参数说明前可以使用const保留字，拒绝函数体中对线性表修改，以保证数据安全性，其余运算需要函数体中改变线性表，所以不能使用此保留字。插入运算，item参数用来保存待插入元素，pos参数用来给定插入条件，人为约定当posgeq1同时posleqn+1时，则把item插入到线性表第pos个位置上，其中n表示线性表长度；当pos=-1时，则把item插入到线性表末尾位置，即最后元素后面位置；当pos=0时，则把线性表看作有序表，item插入后仍保持有序。删除运算，item参数用来保存待删除元素值或某个域值，并保存返回删除元素完整值，pos参数用来给定删除条件，人为约定当posgeq1同时posleqn时，则删除线性表第pos个位置上元素并通过item参数返回值；当pos=-1时，则删除线性表表尾元素，即最后元素并通过item参数返回值；当pos=0时，则删除线性表第一个值或某个域值等于item元素并通过item参数返回值。
subsection2.1.3操作举例
【例2-1】设线性表L1=(25,38,19,42,33)，i=2,x=60,y=42，则对L1一组操作及结果如下。
LengthList(L1);//返回L1长度5
EmptyList(L1);//L1非空，返回false
GetList(L1,i);//返回L1第i个元素值，因i=2，所以返回值38
InsertList(L1,x,6);//向L1末尾插入x，L1变为(25,38,19,42,33,60)
InsertList(L1,54,1);//向L1表头插入元素54，L1变为(54,25,38,19,42,33,60)
DeleteList(L1,y,0);//删除L1中值y元素，L1变为(54,25,38,19,33,60)
DeleteList(L1,y,3);//删除L1第3个元素，L1变为(54,25,19,33,60)
SortList(L1);//L1改变(19,25,33,54,60)
InsertList(L1,35,0);//插入35后L1变为(19,25,33,35,54,60)
【例2-2】课程（course）记录结构：
structcourse
charCname[20];//课程名称
intChour;//开课学时
intCterm;//开课学期
以课程记录元素类型线性表L2,如表2-1所示。
表2-1课程计划安排表
|课程名称|开课学时|开课学期|课程名称|开课学时|开课学期|
|---|---|---|---|---|---|
|高等数学|90|1|计算机组成原理|90|2|
|离散数学|72|2|程序设计基础|63|3|
|英语|72|1||||
对L2进行一组操作如下，首先定义具有course记录结构x、y、zw对象并对其赋初值。
coursex=left("",72right);//给xChour域赋初值72
coursey=("程序设计基础");//给yCname域赋初值"程序设计基础"
coursez=left("text英语",80,1right);//给z赋初值left("text英语",80,1right)coursew=left("text数据结构",72,4right);//给w赋初值left("text数据结构",72,4right)GetList(L2,3);//返回值("英语",72,1)
FindList(L2,x);//查找与x开课学时相等第一个元素并由x返回
//为了实现课程记录之间直接比较,需要事先重载等于
//号运算符,使其实际上Chour域上进行比较
FindList(L2,y);//查找与y值中课程名称相等第一个元素并由y返回
//为了实现课程记录之间直接比较,也需要重载等于
//号运算符,使其实际上Cname域上进行比较
UpdateList(L2,z);//用z更新L2课程名称"英语"第一个元素,使
//得该元素修改("英语",80,1)。此函数体中若进行
//记录之间直接比较,则也需要事先重载等于号运算符,
//使其实际上进行课程名称之间比较
InsertList(L2,w,6);//L2末尾添加一条w记录
DeleteList(L2,y,0);//L2删除与yCname域值相等第一条记录,
//即删除L2第5条记录("程序设计基础",63,3)
SortList(L2);//假定按开课学时升序排列,则排序后结果如表2-2所示
表2-2对L2操作后结果
|课程名称|开课学时|开课学期|课程名称|开课学时|开课学期|
|---|---|---|---|---|---|
|离散数学|72|2|高等数学|90|1|
|数据结构|72|4|计算机组成原理|90|2|
|英语|80|1||||
section2.2线性表顺序存储操作实现
subsection2.2.1线性表顺序存储结构
线性表存储结构有顺序、链接、索引、散列多种方式,顺序存储结构其中最简单、最常见一种。线性表顺序存储结构可叙述:将线性表所有元素按照其逻辑
顺序依次存储到计算机存储器指定存储位置开始一块连续存储空间，线性表第一个元素存储位置就是指定存储空间开始存储位置，第i个元素(2leqileqn)紧接着存储第i-1个元素存储位置后面。
设线性表元素类型ElemType，则每个元素所占用存储空间大小（即字节数）sizeof(ElemType)，整个线性表所占用存储空间大小ntimessizeof(ElemType)，第i个元素存储位置a+(i-1)timessizeof(ElemType)，其中n表示线性表长度，1leqileqn，a整个线性表占用存储空间开始位置。
C/C++语言，定义数组就定义一块可供用户使用连续存储空间，该存储空间起始位置就是由数组名表示地址常量。因此，线性表顺序存储结构利用数组来实现，数组基本类型就是线性表元素类型，数组大小（又称数组长度，它等于数组包含元素个数，亦即存储元素位置数）要大于等于线性表长度。线性表第1个元素存储数组起始位置，即下标0位置上，第2个元素存储下标1位置上，以此类推，第n个元素（即最后表尾元素）存储下标n-1位置上。用具有ElemType类型数组list[MaxSize]存储线性表A=(a_1,a_2,cdots,a_i,a_i+1,cdots,a_n)，则A所对应顺序存储结构如图2-2所示。
begintabularc|c
hline下标位置&数组（线性表）存储空间
hline0&a_1
hline1&a_2
hlinevdots&vdots
hlinei-1&a_i
hlinei&a_i+1
hlinevdots&vdots
hlinen-1&a_n
hlinevdots&vdots
hlineMaxSize-1&
hline
endtabular
图2-2线性表顺序存储结构示意图
数组list下标的上界MaxSize决定所有线性表最大长度，当线性表长度大于MaxSize时，其尾部多余元素将无法存储，发生这种情况时需要重新分配存储空间，使得MaxSize值更大一些。
定义线性表顺序存储类型时，需要定义数组来存储线性表所有元素定义整型变量来存储线性表长度。假定数组用list[MaxSize]表示，整型变量用size表示，则元素类型ElemType线性表顺序存储类型可描述：
ElemTypelist[MaxSize];
intsize;
为了便于进行线性表操作，可以把用于存储线性表元素数组存储线性表长度变量统一说明记录类型，设该记录类型用List表示，则定义如下。
structList
ElemTypelist[MaxSize];
;
intsize;
;
若要对存储线性表数组空间采用动态分配，并且其数组长度能够按需要增加，则可以定义出如下List类型:
structList
ElemTypelist;//存线性表元素动态存储空间指针
intsize;//存线性表长度
intMaxSize;//规定list数组长度
;
当初始化此类型线性表时，要使list指针指向大小MaxSize动态数组空间。
subsection2.2.2顺序存储下线性表操作实现
顺序存储方式下，线性表抽象数据类型所列出每操作具体实现如下。
section1.初始化线性表
初始化线性表需要完成动态存储空间初始分配，并且把线性表置空。
voidInitList(List&L)
//初始定义数组长度10,以后可增减,或者附加形参给定初始数组长度
L.MaxSize=10;
//动态存储空间分配
L.list=newElemType[L.MaxSize];
if(L.list==NULL)
cout<<"动态可分配存储空间用完,退出运行!"<<endl;
exit(1);
//置线性表长度0,即为空表
L.size=0;
此算法if语句用于判断动态分配是否成功，若成功L.list指针非空，若分配失败，即系统没有存储空间可供动态分配，则L.list指针值为空。当分配失败时通过执行此语句退出程序运行。现在计算机系统，操作系统功能强大，内存外存空间都能够用于动态存储分配，所以通常不会出现动态存储分配失败情况。所以，编程时通常省略对动态存储分配失败情况处理语句。此情况下，若出现动态存储分配失败，系统会自动停止运行程序。
section2.删除线性表所有元素，使之成为空表
此操作需要释放动态存储空间，并且把线性表长度置0。
voidClearList(List&L)
if(L.list!=NULL)
delete[]L.list;
L.list=NULL;
L.MaxSize=0;
L.size=0;
3.得到线性表长度
intLengthList(List&L)
returnL.size;
4.检查线性表是否为空
boolEmptyList(List&L)
returnL.size==0;
若线性表L为空，则返回真，否则返回假。
5.得到线性表指定序号pos元素
ElemTypeGetList(List&L,intpos)
if(pos<1||pos>L.size)//若pos越界则退出程序
cerr<<"posisoutrange!"<<endl;
exit(1);
returnL.list[pos-1];//返回线性表第pos个元素值
若所给pos值不存在越界问题，则可直接使用表达式L.list[pos-1]线性表L取出第pos个元素。要取出线性表L第5个元素，则表示L.list[4]。
6.遍历线性表
遍历线性表就是从线性表第1个元素起，按照元素之间逻辑顺序，依次访问每元素，并且每个元素只访问一次，直到访问完所有元素为止。顺序存储方式下，线性表元素之间存储顺序与其逻辑顺序相同，因为元素后继元素紧接着存储该元素所在位置下存储位置上。若元素数组存储空间存储位置下标
i,则它后继元素存储位置必为下标i+1。所以遍历线性表就是依次访问list[0]~list[n-1]每元素，并且每个元素仅访问一次。当访问元素时，可根据需要作任意处理，我们算法中且以打印该元素值代之。若线性表元素类型记录类型，则打印元素值需要有对该类型重载插入操作符（<）函数支持。
voidTraverseList(List&L)
for(inti=0;i<L.size;i++)
cout<<L.list[i]<<'';
cout<<endl;
当然，对于记录类型，若此函数cout输出语句中是依次输出元素每域值，而不是把元素作为整体输出，则不需要重载插入操作符。
7.线性表查找具有给定值第1个元素
boolFindList(List&L,ElemType&item)
for(inti=0;i<L.size;i++)
if(L.list[i]==item)
item=L.list[i];
returntrue;
returnfalse;
当线性表L查找到与item值或某个域值相等元素时，则由item返回该元素整体值，并由该函数返回真，表明查找成功，否则由函数返回假，表明查找失败。
当元素类型ElemType记录类型时，调用此函数必须要有对该类型进行等于号(==)重载支持，若没有，则应该修改if条件表达式，使比较相应域上进行，并且此域必须简单数据类型。另外，若用于比较元素类型或某个域类型字符串，则需要使用字符串比较函数strcmp，因为使用等于号直接比较指针值，而不是比较所指字符串。如当ElemType字符串类型(char)时，if条件表达式应修改：
(strcmp(L.list[i],item)==0)
8.更新线性表具有给定值第1个元素
boolUpdateList(List&L,constElemType&item)
for(inti=0;i<L.size;i++)
if(L.list[i]==item)
L.list[i]=item;//进行修改（更新）赋值操作
returntrue;
returnfalse;
该函数与FindList函数定义类似,FindList函数查找成功后由item带回元素值,而UpdateList函数查找成功后,用item值修改元素值。
线性表查找更新算法,运行时间主要取决于比较元素次数,当第1个元素list[0]等于待查找或更新元素时,则只需要比较一次就结束操作,对应时间复杂度O(1),这是最好情况;当前n-1元素比较均不成立,只有比较到最后元素list[n-1](n线性表长度L.size)才等于待查找或更新元素时,则需要经过n次比较完成操作,对应时间复杂度O(n),这是最差情况:当元素值互不相同,并且都有相同概率left(text即平均概率frac1nright)等于待查找或更新元素时,则需要比较元素平均次数frac1nsum_i=1^ni=fracn+12,对应时间复杂度O(n),这是平均情况。当经过依次同线性表所有n个元素比较后,仍找不到与给定值相等元素,则表明查找失败,算法执行returnfalse语句后结束,此种情况下时间复杂度同样O(n)。所以无论查找成功或失败,顺序查找线性表时间复杂度均O(n)。
section9.向线性表按给定条件插入元素
当该函数pos参数0时,则需要实现有序表上插入,并且要保证插入新元素后仍有序表。有序表上查找插入位置最简单常用方法顺序比较法,它第1个元素起,依次取出每元素同待插入元素item进行比较,当item小于某元素值时比较结束,此元素位置就是item插入位置。若比较到表尾后仍满足不了条件,表明item大于所有元素,则应把item插入到表尾,成为新表尾元素。另外,当元素类型记录时,则必须对该类型进行小于号重载后才能实现item<L.list[i]直接比较。
,有序表为A=(25,36,40,48,55,72,83),当向其中插入16时,其插入位置表头,即第1个元素25位置;当向其中插入50时,其插入位置55元素位置;当向其中插入92时,其插入位置表尾,即最后元素83后面位置。
当该函数pos参数等于-1,要求把item插入到线性表表尾,即第L.size+1个元素位置上。
当该函数pos参数大于等于1,同时小于等于线性表长度加1时,则直接把item插入到线性表第pos个元素位置上。
线性表第pos个元素位置插入新元素前,还要检查存储线性表动态数组空间是否具有空闲位置,若没有,则要扩大原有空间。
为了实现第pos个元素位置插入新元素,还要把该位置开始其后所有元素均后移位置,以使空出第pos个元素位置,用于写入新元素。
完成插入后,要使线性表长度域增1,然后返回真结束算法。
根据以上分析编写出此算法如下。
boolInsertList(List&L,ElemTypeitem,intpos)
```cpp
//检查pos值是否有效,若无效则无法插入,返回假
if(pos<-1||pos>L.size+1)
cout<<"pos值无效!"<<endl;returnfalse;
//求出按值有序插入时item插入位置,使之保存到pos
inti;
if(pos==0)
for(i=0;i<L.size;i++)
if(item<L.list[i])break;
pos=i+1;//pos保存新插入元素序号
//得到表尾插入位置,保存pos
elseif(pos==-1)pos=L.size+1;
//若线性表存储空间用完,则重新分配大一倍存储空间
if(L.size==L.MaxSize)
intk=sizeof(ElemType);//计算每个元素存储空间长度
L.list=(ElemType)realloc(L.list,2L.MaxSizek);
//线性表动态存储空间扩展原来2倍,原内容不变
if(L.list==NULL)
cout<<"动态可分配存储空间用完,退出运行!"<<endl;
exit(1);
L.MaxSize=2L.MaxSize;//把线性表空间大小修改新长度
//待插入位置及所有后续位置元素,从后向前依次后移位置
for(i=L.size-1;i>=pos-1;i--)
L.list[i+1]=L.list[i];
//把item值赋给已空出、下标pos-1位置,它第pos个元素位置
L.list[pos-1]=item;
//线性表长度增1
L.size++;
//返回真表示插入成功
returntrue;
这个算法,运行时间主要花费第2步为寻找插入位置所需比较元素次数第5步为空出插入位置所需移动元素次数。新元素插入下标位置i,则元素比较次数i+1次,元素移动次数n-i次(n线性表长度L.size),两者相加n+1次。也就是说,当进行有序插入时,不管新元素插入什么位置上,进行元素比较移动总次数不变,均n+1,当进行按位置插入时,只需要考虑移动元素次数,插入所有位置概率相等情况下,平均移动次数frac1n+1sum_i=0^n(n-i)=fracn2,所以此算法时间复杂度O(n)。特殊地,当规定表尾插入时,其时间复杂度O(1)。
```
10.线性表删除符合给定条件第1个元素
此算法同插入元素算法类似，具体描述如下。
boolDeleteList(List&L,ElemType&item,intpos)
//检查线性表是否为空，若则无法删除，返回假
if(L.size==0)
cout<<"线性表为空，删除无效!"<<endl;
returnfalse;
//检查pos值是否有效，若无效则无法删除，返回假
if(pos<-1||pos>L.size)
cout<<"pos值无效!"<<endl;returnfalse;
//求出按值删除时item删除位置，使之保存到pos
inti;
if(pos==0)
for(i=0;i<L.size;i++)
if(item==L.list[i])break;
if(i==L.size)returnfalse;//无元素可删返回假
pos=i+1;
//得到被表尾元素序号，保存pos
elseif(pos==-1)pos=L.size;
//把删除元素值赋给变参item带回
item=L.list[pos-1];
//将待删除元素位置后面所有元素，从前向后依次前移位置
for(i=pos;i<L.size;i++)
L.list[i-1]=L.list[i];
//线性表长度减1
L.size--;
//若线性表存储空间空余太多，则进行适当缩减
if((float)(L.size)/L.MaxSize<0.4&&L.MaxSize>10)
intk=sizeof(ElemType);//计算每个元素存储空间长度
L.list=(ElemType)realloc(L.list,L.MaxSizek/2);
//线性表动态存储空间缩减原来一半
L.MaxSize=L.MaxSize/2;//把线性表空间大小修改新长度
//返回真表示删除成功
returntrue;
这个算法，运行时间主要花费第3步为寻找删除元素位置所需比较元素次数第6步为填补删除元素位置所需移动元素次数上。删除元素下标位置i，
则元素比较次数i+1次,元素移动次数n-i-1次(n线性表长度L.size),两者相加n次。也就是说,当进行按值删除时,不管删除什么位置上元素,进行元素比较移动总次数不变,均n,当进行按位置删除元素时,只需要考虑移动元素次数,删除所有位置上元素概率相等情况下,平均移动次数frac1nsum_i=0^n-1(n-i-1)=fracn-12,所以此算法时间复杂度O(n)。特殊地,当规定删除表尾元素时,其时间复杂度O(1)。
11.对线性表进行排序
对线性表进行排序就是按照元素值或某个域值升序(或降序)排列元素,使之成为有序表。对顺序存储线性表(数组)进行排序方法很多,本小节只介绍一种简单插入排序方法,其他方法将第10章中专门讨论。
插入排序方法:把线性表list[0]~list[n-1]中共n个元素看作有序表无序表,开始时有序表中只有元素list[0](元素总是认为有序),无序表中含有n-1个元素list[1]~list[n-1],以后每次无序表中取出第1个元素,把它插入到前面有序表中合适位置,使之成为新有序表,这样有序表就增加元素,无序表就减少元素,经过n-1次后,有序表中含有n个元素,无序表变为空表,整个线性表就成为有序表。
如何第i次(1leqileqn-1)把无序表中第1个元素list[i]插入到前面有序表list[0]~list[i-1]呢?一种方法:有序表表尾元素list[i-1]开始,依次向前使每元素list[j](0leqj<i-1)同x(用来临时保存list[i]值)进行比较,若x<list[j],则把list[j]后移位置,直到x>=list[j]或j<0为止,此时已空出下标i+1位置就是x插入位置,把x值插入到list[j+1]即可。
假定线性表(42,65,80,74,28,44,36,65),则插入排序过程,如图2-3所示,其中中括号内表示每次排序后得到有序表,中括号后面待排序无序表。beginarraylllllllll0&1&2&3&4&5&6&7hline42&65&80&74&28&44&36&65endarray(1)[4265]807428443665
(2)[426580]7428443665
(3)[42657480]28443665
(4)[2842657480]443665
(5)[284244657480]3665
(6)[28364244657480]65
(7)[2836424465657480]
图2-3线性表插入排序过程
用C++语言描述插入排序算法如下。
voidSortList(List&L)//对L所有元素重新按给定条件排序
inti,j;
ElemTypex;
for(i=1;i<L.size;i++)//共循环n-1次
x=L.list[i];//把无序表中第1个元素暂存x
for(j=i-1;j>=0;j--)//向前顺序进行比较移动
if(x<L.list[j])L.list[j+1]=L.list[j];
elsebreak;
L.list[j+1]=x;//把x写入到已经空出j+1位置
插入排序，共需要进行n-1次元素插入，每次插入最少需比较一次移动两次元素，最多需比较i次移动i+2次元素，平均需比较fraci+12次移动fraci2+2次元素。若分别用C_min、C_maxC_textave表示元素总比较次数最小值、最大值平均值，用M_min、M_maxM_textave表示元素总移动次数最小值、最大值平均值，则它们值分别:beginaligned
&C_min=sum_i=1^n-11=n-1
&C_max=sum_i=1^n-1i=frac12n(n-1)
&C_textave=sum_i=1^n-1fraci+12=frac14left(n^2+n-2right)
endalignedbeginaligned
&M_min=sum_i=1^n-12=2(n-1)
&M_max=sum_i=1^n-1(i+2)=frac12left(n^2+3n-4right)
&M_textave=sum_i=1^n-1left(fraci2+2right)=frac14left(n^2+7n-8right)
endaligned所以插入排序算法最好情况下时间复杂度O(n)，平均最差情况下时间均O(n^2)。
利用现成向线性表插入元素InsertList算法，也可以很方便地编写出SortList排序算法。该算法需要首先定义临时线性表并进行初始化，接着将形参线性表L每元素通过InsertList算法依次插入到临时线性表，最后把临时线性表赋给L。用C++语言描述如下。
voidSortList(List&L)
Lista;
InitList(a);
for(inti=0;i<L.size;i++)
InsertList(a,L.list[i],0);
ClearList(L);
L=a;
该算法时间复杂度同上面插入排序算法相同，均O(n^2)。
调试上述算法程序如下。
include<iostream.h>
include<stdlib.h>
typedefintElemType;
structList
ElemTypelist;//存线性表元素动态存储空间指针
intsize;//存线性表长度
intMaxSize;//规定list数组长度
;
//添加上面介绍11个算法
voidmain()
inta[12]=3,6,9,12,15,18,21,24,27,30,33,36;
inti;ElemTypex;
Listt;
InitList(t);
for(i=0;i<12;i++)InsertList(t,a[i],i+1);
InsertList(t,48,13);InsertList(t,40,0);
cout<<GetList(t,4)<<''<<GetList(t,9)<<endl;
TraverseList(t);
cout<<"输入待查找元素值：";
cin>>x;
if(FindList(t,x))cout<<"查找成功!"<<endl;
elsecout<<"查找失败!"<<endl;
cout<<"输入待删除元素值：";
cin>>x;
if(DeleteList(t,x,0))cout<<"删除成功!"<<endl;
elsecout<<"删除失败!"<<endl;
for(i=0;i<6;i++)
DeleteList(t,x,i+1);
TraverseList(t);
cout<<"按值插入，输入待插入元素值：";
cin>>x;
if(InsertList(t,x,0))cout<<"插入成功!"<<endl;
elsecout<<"插入失败!"<<endl;
TraverseList(t);
cout<<"线性表长度:"<<LengthList(t)<<endl;
if(EmptyList(t))cout<<"线性表为空!"<<endl;
elsecout<<"线性表不空!"<<endl;
ClearList(t);
运行这个程序，得到一次运行结果如下。
1227
3691215182124273033364048
输入待查找元素值:21
查找成功!
输入待删除元素值:15
删除成功!
6122127334048
按值插入,输入待插入元素值:8
插入成功!
68122127334048
线性表长度:8
线性表不空!
仔细分析此结果，增强对算法理解。
2.3线性表应用举例
用线性表来管理商品库存表。商品库存表已经保存文本文件a:goods.dat，每个商品记录包含有4项内容：商品代号、商品名称、最低库存量当前库存量。商品库存表中具体内容如表2-3所示。
表2-3商品库存表
|商品代号|商品名称|最低库存量|当前库存量|
|----------|--------------|------------|------------|
|Y-12|toothbrush|10|25|
|F-13|soap|20|48|
|W-01|toiletpaper|10|36|
|M-48|towel|15|90|
|C-24|chinacup|10|52|
|S-05|schoolbag|5|20|
可以事先通过调用下面函数A盘上建立库存表文件。
voidSetupGoodsFile(charfname)
ofstreamofstr(fname);//定义输出文件流对象ofstr
if(!ofstr)
cerr<<"File'goods'nocreate!"<<endl;
exit(1);
chara[30];
for(inti=0;i<6;i++)
cin.getline(a,30);
ofstr<<a<<endl;
ofstr.close();
此函数，for循环体每循环一次，要求键盘上输入一条商品记录，每个域值之间
用空格分开,最后以按下回车键结束,该条记录存入到字符数组a,然后写入到文件。
根据商品库存表中商品记录结构,可定义记录类型如下。
structgoods
charcode[5];//商品代号
charname[15];//商品名称
intminq;//最低库存量
intcurq;//当前库存量
;
通过typedef语句将该类型定义线性表通用元素类型ElemType。
typedefgoodsElemType;
商品库存表中,以商品代号域作为查找字段域,则对应重载等于号运算符函数定义:
booloperator==(constElemType&e1,constElemType&e2)
return(strcmp(e1.code,e2.code)==0);
同样,插入排序算法使用小于号运算符需如下重载函数支持:
booloperator<(constElemType&e1,constElemType&e2)
return(strcmp(e1.code,e2.code)==-1);
用于打印输出使用插入操作符也需要进行重载,定义如下:
ostream&operator<<(ostream&ostr,constElemType&x)
ostr.setf(ios::left);//设置每个区域内按左对齐显示
ostr<<setw(6)<<x.code<<setw(12)<<x.name;
ostr<<setw(4)<<x.minq<<setw(4)<<x.curq<<endl;
returnostr;
对商品库存表管理就是首先把它读入到内存线性表,接着对它进行必要处理,然后把处理后结果写回到文件。对商品库存表处理假定包括如下选项。
(1)打印（遍历）库存表。
(2)按商品代号修改记录当前库存量,若查找到对应记录,则键盘上输入其修正量,把它累加到当前库存量域后,再把该记录写回原有位置,若没有查找到对应记录,则表明一条新记录,应接着键盘上输入该记录商品名称、最低库存量当前库存量值,然后把该记录追加到库存表中。
(3)按商品代号删除指定记录。
(4)按商品代号对库存表中记录排序。
顺序存储方式下对线性表各种操作函数假定包含list.cpp程序文件,则实现库存表管理完整程序如下。
//程序2-1.cpp
include<iostream.h>
include<stdlib.h>
include<iomanip.h>
include<string.h>
include<fstream.h>
structgoods//商品记录类型
charcode[5];//商品代号
charname[15];//商品名称
intminq;//最低库存量
intcurq;//当前库存量
;
typedefgoodsElemType;
structList
ElemTypelist;//存线性表元素动态存储空间指针
intsize;//存线性表长度
intMaxSize;//规定list数组长度
;
booloperator>=(constElemType&e1,constElemType&e2)
return(strcmp(e1.code,e2.code)==0);
booloperator<(constElemType&e1,constElemType&e2)
return(strcmp(e1.code,e2.code)==-1);
ostream&operator<<(ostream&ostr,constElemType&x)
ostr.setf(ios::left);//设置每个区域内按左对齐显示
ostr<<setw(6)<<x.code<<setw(12)<<x.name;
ostr<<setw(4)<<x.minq<<setw(4)<<x.curq<<endl;
returnostr;
```cpp
include"list.cpp"
voidSetupGoodsList(List&L,charfname)
//把文件中所存商品表顺序读入内存线性表以便处理
ifstreamifstr(fname,ios::in|ios::nocreate);
if(!ifstr)
cerr<<"File'goods'notfound!"<<endl;
exit(1);
goodsg;
inti=1;
while(ifstr>>g.code)
ifstr>>g.name>>g.minq>>g.curq;
InsertList(L,g,i++);
ifstr.close();
voidWriteGoodsFile(charfname,List&L)
//把线性表中所存商品表重新写回到文件
ofstreamofstr(fname);
if(!ofstr)
cerr<<"File'goods'nocreate!"<<endl;
exit(1);
goodsg;
intn=LenthList(L);
for(inti=1;i<=n;i++)
g=GetList(L,i);
ofstr<<g.code<<""<<g.name<<""
<<g.minq<<""<<g.curq<<endl;
ofstr.close();
voidmain()
ListL2;//说明线性表L2
InitList(L2);//初始化L2
SetupGoodsList(L2,"a:goods.dat");//读文件到线性表
inti,flag=1;
while(flag)//当flag真时执行循环
cout<<"1打印整个库存表"<<endl;
cout<<"2修改库存表中记录"<<endl;
```
cout<<"3删除库存表中记录"<<endl;
cout<<"4对库存表排序"<<endl;
cout<<"5结束处理过程"<<endl;
cout<<"输入你选择:";
cin>>i;
while(i<1||i>5)
cout<<"请重新输入选择(1-5):";
cin>>i;
cout<<endl;
switch(i)
case1:
TraverseList(L2);//打印
break;
case2://修改
goodsg;
intx;
cout<<"输入待修改商品代号:";
cin>>g.code;
if(FindList(L2,g))
cout<<"输入该商品修正量:";
cin>>x;
g.curq+=x;
if(UpdateList(L2,g))cout<<"完成更新!"<<endl;
else
cout<<"输入新商品记录其余字段内容:"<<endl;
cin>>g.name>>g.minq>>g.curq;
InsertList(L2,g,LengthList(L2)+1);
cout<<"新记录已插入到表尾!"<<endl;
break;
case3://删除
cout<<"输入待删除商品商品代号:";
cin>>g.code;
if(DeleteList(L2,g,0))
cout<<"代号"<<g.code<<">"记录删除!"<<endl;
elsecout<<"代号"<<g.code<<">"记录不存在!"<<endl;
break;
case4://排序
SortList(L2);
cout<<"商品表中记录已按商品代号排序!"<<endl;
break;
case5://结束
cout<<"本次处理结束,再见!"<<endl;
flag=0;
WriteGoodsFile("a:goods.dat",L2);//把线性表写回文件
同学们可以上机运行此程序并分析运行结果。
section2.4线性表链接存储结构
section1.链接存储概念
顺序存储链接存储数据两种最基本存储结构。顺序存储，每个存储结点只含有所存元素本身信息，元素之间逻辑关系通过数组下标位置简单计算出来。线性表顺序存储，若元素存储对应数组下标位置i，则它前驱元素对应数组下标位置i-1，它后继元素对应数组下标位置i+1。链接存储，每个存储结点不仅含有所存元素本身信息，而且含有元素之间逻辑关系信息，其存储结点（简称结点）结构如图2-4所示。
begintabular|c|c|c|c|c|
hlinedata&p_1&p_2&cdots&p_m
hline
endtabularhline
图2-4结点结构
其中data表示值域，用来存储元素，p_1,p_2,cdots,p_m(mgeqslant1)均指针域，每个指针域值其对应后继元素或前驱元素所在结点（以后简称后继结点或前驱结点）存储位置。通过结点指针域（又称为链域）可以访问到对应后继结点或前驱结点，该后继结点或前驱结点称为指针域（链域）所指向（或链接）结点。若结点某个指针域不需要指向任何结点，则令它值空，即数值0，用常量NULL表示。
数据顺序存储，由于每个元素存储位置都可以通过简单计算得到，所以可以随机存取数据任一元素，对任一元素存取时间都相同，这是一种随机存取机制；而数据链接存储，由于每个元素存储位置保存它前驱结点或后继结点，所以只有当访问到其前驱结点或后继结点后才能够按指针访问到该结点，这是一种顺序存取机制。
数据链接存储表示又称为链表。当链表每个结点只含有指针域时，则称为单链表，否则称为多链表。
section2.线性表链接存储
由于线性表每个元素至多只有前驱元素后继元素，即数据元素之间1：1逻辑关系，所以当进行链接存储时，一种最简单也最常用方法：每个结点中除包含有数值域外，只设置指针域，用以指向其后继结点，这样构成链表称为线性单向链接表，简称单向链表或单链表；另一种可以采用方法：每个结点中除包
含有数值域外，设置有两个指针域，分别用以指向其前驱结点后继结点，这样构成链接表称为线性双向链接表，简称双向链表或双链表。单链表双链表都线性链表。
设线性表：A=(a_1,a_2,cdots,a_i,a_i+1,cdots,a_n)若分别用单链表双链表表示，则对应存储结构如图2-5所示。
(a)单链表
(b)双链表
图2-5线性表链接存储结构示意图
每个结点指针域同它所指向后继结点或前驱结点用带箭头线段相连接，表示该指针域值所指向结点存储位置。若指针域值空（即NULL），则图形通常用符号“∧”表示。由于线性表第1个元素无前驱元素，最后元素无后继元素，所以对应链接存储，第1个结点前驱指针域空，最后结点后继指针域空。
单链表中，由于每个结点只包含有指向后继结点指针，所以当访问结点后，只能接着访问它后继结点，而无法访问它前驱结点。双向链表，由于每个结点既包含有指向后继结点指针，又包含有指向前驱结点指针，所以当访问结点后，既可以依次向后访问每结点，也可以依次向前访问每结点。
线性表链接存储，存储第1个元素结点称为表头结点，存储最后元素结点称为表尾结点，其余中间结点。每个链接表都需要设置指针指向表头结点，称为表头指针。虽然表头指针只指向表头结点，但表头指针出发，沿着结点链（即指针域值）可以依次访问到每结点，所以通常就以表头指针来命名链接表。若单链表表头指针H，双链表表头指针B，则可分别称它们H单链表B双链表。
线性表顺序存储，逻辑上相邻元素，其对应存储位置也相邻，所以当进行插入或删除运算时，通常需要平均移动半个表元素，这是相当费时操作。线性表链接存储，逻辑上相邻元素，其对应存储位置通过指针来链接，因而每个结点存储位置可以任意安排，不必要求相邻，所以当进行插入或删除运算时，只需修改相关结点指针域即可，这既方便又省时操作，灵活性强。由于链接表每个结点带有指针域，因而存储空间上比顺序存储要付出较大代价。
3.单链表上插入删除操作
单链表中插入删除结点，如图2-6所示。
a结点（即存放元素a结点简称；另外，有时也用该结点地址称该结点，把a结点称为p结点，即p指针所指向结点）后面插入b结点前后状态，其插入操作过程如下。
(1)将a结点指针域值q（即指向后继c结点指针）赋给b结点指针域。
(2)将指向b结点指针（即指针变量s值）赋给a结点指针域。cdotsrightarrowprightarrow[a]rightarrowqrightarrow[c]rightarrowcdotsquadcdotsrightarrowprightarrow[a]rightarrowsrightarrow[b]rightarrowqrightarrow[c]rightarrowcdots(a)插入结点前
(b)插入结点后
图2-6单链表中插入结点示意图
注意:单链表表头插入新结点，则首先要吧原表头指针赋给新结点指针域，然后再把新结点存储位置赋给表头指针变量。
思考：单链表表尾插入新结点，情况又如何呢？它同中间或表头插入情况有何异同？
单链表中删除x结点后面y结点前后状态，如图2-7所示，其删除操作过程如下。cdotsrightarrowprightarrow[x]rightarrowqrightarrow[y]rightarrowrrightarrow[z]rightarrowcdotsquadcdotsrightarrowprightarrow[x]rightarrowrrightarrow[z]rightarrowcdotssrightarrow[y]
(a)删除结点前
(b)删除结点后
图2-7单链表中删除结点示意图
(1)将x结点指针域值q（即指向后继y结点指针）赋给临时指针变量s，以便处理回收该结点。
(2)将y结点指针域值r（即指向后继z结点指针）赋给x结点指针域。
注意：单链表中删除表头结点，则首先要把表头指针赋给临时指针变量，以便处理回收该结点，然后再把原表头结点指针域值（即指向原表头后继结点指针）赋给表头指针变量，使其下结点成为新表头结点。
思考：若单链表中删除表尾结点，情况又如何呢？它同删除中间或表头结点情况有何异同？
4.单链表中结点类型
In单链表中，每个结点类型用LNode表示，它包括存储元素数值域，用data表示，其类型用通用类型标识符ElemType表示，还包括存储后继元素位置指针域，用next表示，其类型指向本身结点指针类型LNode，则LNode类型定义如下。
structLNode
ElemTypedata;
LNodenext;
;
因为每个指针类型大小等于整型(int)大小（即4个字节），所以LNode类型大小等于元素类型大小sizeof(ElemType)加上4个字节。若ElemType表示int，则LNode类型大小8个字节，也就是说，每个LNode类型结点（对象）占用8个字节存储空间。
程序2-2使用LNode类型实例。键盘上输入三个数值依次5、108，则该程序运行结果也5、108。
//程序2-2.cpp
include<iostream.h>
typedefintElemType;//规定元素类型整型
structLNode
ElemTypedata;
LNodenext;
;//定义单链表结点
voidmain()
LNodex,y,z;//定义LNode类型三个结点x,yz
LNodep=&x;//定义LNode类型指针变量p并初始指向x结点
cin>>x.data>>y.data>>z.data;//给x,y,z数值域输入数据
x.next=&y;y.next=&z;z.next=NULL;//把x,y,z链接单链表
while(p!=NULL)//表头开始输出每个结点值（即数据域值）
cout<<p->data<<"";//输出指针p所指向结点值
p=p->next;//使p指向链表下结点
cout<<endl;
程序2-3同上面程序2-2具有相同功能，都建立具有三个结点单链表，然后再依次输出单链表中每个结点值。但程序2-2，单链表中每个结点静态结点，即由静态分配所产生结点，而程序2-3，单链表中每个结点动态结点，即由动态分配所产生结点。
//程序2-3.cpp
include<iostream.h>
typedefintElemType;//规定元素类型整型
structLNode
ElemTypedata;
LNodenext;
;//定义单链表结点类型
voidmain()
LNodep,q,p1;
p1=newLNode;//动态产生结点并将其地址赋给pp1指针
for(inti=0;i<3;i++)
q=newLNode;//q指向新动态结点
```cpp
cin>>q->data;//键盘输入整数赋给q结点值域
p->next=q;//将q结点链接到p结点之后
p=q;//使p指针后移,指向后继新结点q
p->next=NULL;//置链表最后结点指针域空
p=p1->next;//链表表头结点p1结点指针域所指向结点
while(p!=NULL)
cout<<p->data<<"";//输出p结点值,即其数值域值
p=p->next;//使p指向链表下结点
cout<<endl;
单链表中结点既可以来自静态或动态产生独立结点（以上两个程序所示），也可以来自静态或动态产生数组元素（结点），若来自数组结点（元素），则next域指向后继结点所在下标，所以它应定义整数类型。用ALNode表示数组结点类型，则对应定义如下。
structALNode
ElemTypedata;
intnext;
;
由数组结点构造单链表所属数组类型可定义如下。
typedefALNodeALinkList[MaxSize];
ALinkList定义包含有MaxSize个元素、元素类型ALNode数组类型。由该类型对象（即数组）构造单链表时，通常下标0元素不作为单链表中结点使用，而是用它指针域保存表头指针，这样，数组最多能够提供MaxSize-1个结点。另外，当结点无后继结点时，其指针域应赋予数值0，表示空指针。
利用ALinkList类型数组构成单链表情况，如图2-8(a)所示。表头指针下标0位置next域值4，单链表结构示意图，如图2-8(b)所示。表头指针用f表示，每个指针上标出数值就是该指针具体值。
begintabular|c|c|c|c|c|c|c|c|c|c|c|
hlinedata&0&1&2&3&4&5&6&7&8&(cdots)
hlinenext&4&3&8&6&7&2&0&5&1&
hline
endtabular
(a)数组构成单链表
frightarrow44rightarrow75rightarrow50rightarrow57rightarrow62rightarrow68rightarrow75rightarrow83rightarrow94rightarrow0
(b)单链表结构
图2-8利用数组建立单链表示意图
```
可以看出，该单链表中各数据元素之间逻辑顺序如下。44,50,57,62,68,75,83,94由数组建立单链表时，通常将所有空闲元素链接起来构成空闲单链表，空闲单链表表头指针也需要用元素结点指针域保存起来，假定使用1号（即下标1）指针域。这种数组链接存储线性表长度至多MaxSize-2，因为0号1号元素均表头指针所占有。当对整个数组进行初始化时，不仅置单链表为空，即把0赋给0号元素指针域，而且将全部MaxSize-2个空闲结点链接起来构成空闲单链表，同时把它表头指针（即2）赋给1号元素指针域。对数组进行初始化后情况，如图2-9所示。
begintabular|c|c|c|c|c|c|c|c|c|c|
hlinedata&0&1&2&3&4&5&6&7&MaxSize-1
hlinenext&0&2&3&4&5&6&7&8&0
hline
endtabular
图2-9空闲单链表
向数组单链表插入新元素时，首先空闲表中取出（即删除）表头结点作为保存新元素结点使用，然后再把该结点按条件插入到单链表中；当数组单链表删除元素结点时，首先单链表中取出这个结点，然后再把该结点插入到空闲单链表表头。
数组元素单链表空闲单链表结点总数，任何时候都等于MaxSize-2，当空闲单链表为空时，则元素单链表为满，此时无法再向它插入新结点。
，下面数组，链接存储线性表(35,68,57,26,70)，空闲单链表中依次包含有3,5,8号元素结点，MaxSize=10，如图2-10所示。
begintabular|c|c|c|c|c|c|c|c|c|c|
hlinedata&0&1&2&3&4&5&6&7&8
hlinenext&4&3&6&5&2&8&9&0&0
hline
endtabular
图2-10元素空闲单链表
5.双向链表结点类型插入与删除操作
对于双向链表也可进行以上对单链表那样讨论，若双向链表采用独立结点构成，则结点类型定义:
structDNode
ElemTypedata;
DNodeleft;
DNoderight;
;
若双向链表采用数组元素结点构成，则结点类型应定义:
structADNode
ElemTypedata;
intleft;
intright;
;
其中，DNodeADNode结点类型标识符，该类型包含有3个域：数值域（data），左指针域（left）右指针域（right），left域用于指向前驱结点，right域用于指向后继结点。
设pq分别具有DNode类型指针变量，若双向链表p结点之后插入q结点，则需要修改4个指针域值，操作步骤如下。
(1)使p结点后继结点成为q结点后继结点。
q->right=p->right;
(2)若p结点有后继结点，则使q结点成为该结点前驱结点。
if(p->right)p->right->left=q;
(3)使p结点成为q结点前驱结点。
q->left=p;
(4)使q结点成为p结点后继结点。
p->right=q;
插入过程如图2-11所示。
(a)插入结点
(b)插入过程
(c)插入完成后链接
图2-11双向链表插入结点示意图
若删除双向链表p指针所指向结点，假定p结点前后都存在着结点，则只需要修改两个指针，其操作步骤如下。
(1)修改p结点前驱结点右指针，使之指向p结点后继结点。
p->left->right=p->right;
(2)修改p结点后继结点左指针域，使之指向p结点前驱结点。
p->right->left=p->left;
(3)回收p结点。
deletep;
删除过程如图2-12所示。
(a)删除前状态
(b)删除过程
(c)删除后状态
图2-12双向链表删除结点示意图
6.带表头附加结点线性链表
线性表链接存储,为了方便表头插入删除结点,使得与其他地方所做操作相同,需要表头结点(即保存第一个元素结点)前面增加结点,把它称之为表头附加结点,此时表头附加结点指针域指向表头结点,而表头指针由原来指向第一个元素结点改为指向表头附加结点。仍以存储以前给出线性表A为例,如图2-13所示。此时单链表中指向第一个结点指针H->next,双向链表指向第一个结点指针B->right。
Hrightarrowfboxsquarerightarrowfboxa_1rightarrowfboxa_2rightarrowcdotsrightarrowfboxa_n
(a)带表头附加结点单链表
Brightarrowfboxtrianglerightarrowfboxa_1rightarrowfboxa_2rightarrowcdotsrightarrowfboxa_n
(c)带表头附加结点双向链表
Hrightarrowfboxsquare
(b)带表头附加结点空单链表
Brightarrowfboxtriangle
(d)带表头附加结点空双向链表
图2-13带表头附加结点单链表双向链表
7.循环链表
单链表中,让表尾结点(即最后结点)指针域指向表头结点或表头附加结点(若采用的话);双向链表,若让表尾结点右指针域指向表头结点或表头附加结点,而让表头结点或表头附加结点左指针域指向表尾结点,则就构成循环链表。带有表头附加结点循环单链表循环双向链表,如图2-14所示。
Hrightarrowfboxsquarerightarrowfboxa_1rightarrowfboxa_2rightarrowcdotsrightarrowfboxa_n
(a)循环单链表
Brightarrowfboxsquarerightarrowfboxa_1rightarrowfboxa_2rightarrowcdotsrightarrowfboxa_n
(c)循环双向链表
Hrightarrowfboxsquare
(b)循环单链空表
Brightarrowfboxsquare
(d)循环双向空表
图2-14带表头附加结点循环单链表循环双向链表
对于由数组元素结点构成单链表,其下标0元素结点指针域保存元素单链表表头指针,所以该结点成为元素单链表附加表头结点,而元素单链表最后结点指针域0表示空指针,它正好表头附加结点下标,由此构成带表头附加结点循环单链表。空闲表最后结点指针域置整数0表示空指针,若置整数1则可构成带表头附加结点循环空闲表。
对于独立分配存储空间结点,通常由指针所指向,若使用指针p,则p就表示该结点,p->datap->next就分别表示该结点数值域指针域。对于数组元素结点,它由数组名下标值标识,假定数组名a,下标值k,则a[k]就表示该结点,a[k].dataa[k].next就分别表示该结点数值域指针域,元素单链表表头指针a[0].next,空闲单链表表头指针a[1].next。了解独立结点元素结点访问上差别后,学会独立结点所构成单链表上进行各种运算算法,也就不难写出对元素单链表进行各种运算算法。
section2.5线性表操作单链表上实现
每个单链表都有表头指针,用HL表示,由表头指针可以访问到单链表中任何结点,所以要对单链表进行操作,必须给出表头指针。假定以HL表头指针单链表是由LNode类型动态结点所组成,并且不带有表头附加结点,下面给出对线性表抽象数据类型列举每一操作单链表上具体实现,即C++语言算法描述。
section1.初始化单链表
voidInitList(LNode&HL)
HL=NULL;//置单链表为空
section2.删除单链表中所有结点,使之成为空表
删除单链表中所有结点,需要遍历单链表,通过delete操作释放访问每结点所占存储空间,然后把表头指针置空。
voidClearList(LNode&HL)
LNodecp;//将用cp(currentpointer)指向待处理结点
LNodenp;//将用np(nextpointer)指向cp后继结点
cp=HL;//表头指针赋给cp
while(cp!=NULL)
np=cp->next;//保存下结点地址
deletecp;//删除当前结点,即处理结点
cp=np;//使下结点成为当前结点
HL=NULL;//置单链表为空
3.得到单链表长度
由于单链表构成,没有给出单链表长度,所以此算法需要遍历单链表,对访问结点进行计数,最后返回计数值。
intLenthList(LNodeHL)
inti=0;//用来统计单链表中结点个数
while(HL!=NULL)//遍历单链表,统计结点数
i++;
HL=HL->next;
returni;//返回单链表长度
因为该运算需要访问单链表中每个结点,不改变表头指针,即不会改变单链表状态,所以定义表头指针HL值参。对于指针值参只需要占用字(即4个字节)存储空间,它与使用引用参数传送时需要保存实参地址所需要存储空间大小相同,由此不会增加存储空间传送参数值时间。对于上面第1第2种操作,由于需要通过函数体操作修改调用函数时实际表头指针值,所以必须定义引用参数。
4.检查单链表是否为空
boolEmptyList(LNodeHL)
returnHL==NULL;
5.得到单链表中第pos个结点元素
要访问单链表中第pos个结点,必须表头开始依次访问过该结点之前所有结点后才能够实现,即只能够采用顺序存取,而不能够随机存取任结点。
ElemTypeGetList(LNodeHL,intpos)
if(pos<1)
cerr<<"posisoutrange!"<<endl;
exit(1);
inti=0;//统计已遍历结点数,i初值0
while(HL!=NULL)//遍历到第pos个结点或表为空时止
i++;
if(i==pos)break;
HL=HL->next;
if(HL!=NULL)//返回结点值
returnHL->data;
else
cerr<<"posisoutrange!"<<endl;
exit(1);
6.遍历单链表
遍历单链表并打印出每个结点值。
voidTraverseList(LNodeHL)
while(HL!=NULL)//表头开始依次输出每个结点值
cout<<HL->data<<"";
HL=HL->next;
cout<<endl;
7.单链表中查找出等于给定值第1个元素
boolFindList(LNodeHL,ElemType&item)
while(HL!=NULL)
if(HL->data==item)//查找成功由item带回完整值
item=HL->data;
returntrue;
elseHL=HL->next;//HL指向后继结点
returnfalse;
8.更新单链表中等于给定值第1个元素
boolUpdateList(LNodeHL,constElemType&item)
while(HL!=NULL)//查找元素
if(HL->data==item)break;
elseHL=HL->next;
if(HL==NULL)returnfalse;//没有更新元素，返回假
else
HL->data=item;//更新元素
returntrue;
9.向单链表中按给定条件插入元素
其插入过程如下。
(1)判定pos值,若小于-1则表明pos值无效,返回假。
(2)新插入元素动态分配结点并赋值。
(3)根据pos值所表示不同条件,寻找新结点插入位置,为此需要表头开始顺序查找新元素插入位置,查找过程必须保留当前待比较结点地址及其前驱结点地址,以便插入时使用。
(4)插入位置上完成插入新结点操作,即把新结点链接到当前结点前驱结点之间。若插入位置表头,则需要做特殊处理。
boolInsertList(LNode&HL,ElemTypeitem,intpos)
//pos值小于-1返回假
if(pos<-1)
cout<<"pos值无效!"<<endl;returnfalse;
//item元素建立新结点
LNodenewptr;
newptr=newLNode;
newptr->data=item;
//寻找新结点插入位置
LNodecp=HL;//用cp指向当前结点(即待查结点),初始指向表头
LNodeap=NULL;//用ap(aheadpointer)指向cp前驱结点,初始为空
if(pos==0)//按值寻找插入位置
while(cp!=NULL)
if(item<cp->data)break;//找到新元素插入位置,退出循环
else
ap=cp;//apcp指针均后移,实现顺序向后比较
cp=cp->next;
elseif(pos==-1)//查找表尾位置
while(cp!=NULL)ap=cp;cp=cp->next;
else//按序号pos值寻找插入位置
inti=0;
while(cp!=NULL)
i++;
if(i==pos)break;//找到新元素插入位置,退出循环
else
ap=cp;cp=cp->next;
```cpp
if(cp==NULL&&i+1<pos)
cout<<"pos值超出单链表长度加1!"<<endl;
returnfalse;
//完成新结点插入操作
if(ap==NULL)
newptr->next=HL;//把新结点插入到表头
HL=newptr;
else
//把新结点插入到非表头位置，即插入到apcp结点之间
newptr->next=cp;//cp指针也可能为空,此时为表尾
ap->next=newptr;
returntrue;
10.单链表中删除符合给定条件第1个元素
删除算法执行步骤如下。
(1)若单链表为空则返回假。
(2)若pos值小于-1时则返回假。
(3)根据pos值所表示条件单链表中查找删除结点，为此需要单链表中顺序查找，直到查找成功或失败为止。查找过程需要保留待比较当前结点前驱结点地址，以便删除结点时使用。
(4)删除查找到结点，对表头结点非表头结点要做不同处理。
(5)回收删除结点存储空间。
(6)删除成功返回真。
boolDeleteList(LNode&HL,ElemType&item,intpos)//L删除元素
//单链表为空，无法删除，返回假
if(HL==NULL)
cerr<<"单链表为空，删除操作无效!"<<endl;
returnfalse;
//pos值小于-1返回假
if(pos<-1)
cout<<"pos值无效!"<<endl;returnfalse;
//寻找删除元素结点
LNodecp=HL;//用cp指向当前结点(即待查结点)，初始指向表头
LNodeap=NULL;//用ap(aheadpointer)指向cp前驱结点，初始为空
if(pos==0)//按值查找删除结点
```
```cpp
while(cp!=NULL)
if(item==cp->data)break;//找到删除结点cp,退出循环
else
ap=cp;
cp=cp->next;
if(cp==NULL)
cout<<"单链表中没有相应结点可删除!"<<endl;
returnfalse;
elseif(pos==-1)
while(cp->next!=NULL)ap=cp;cp=cp->next;
else
inti=0;
while(cp!=NULL)
i++;
if(i==pos)break;//找到删除结点cp,退出循环
else
ap=cp;
cp=cp->next;
if(cp==NULL)
cout<<"pos值无效!"<<endl;returnfalse;
//删除cp所指向结点
if(ap==NULL)HL=HL->next;//删除表头结点
elseap->next=cp->next;//删除非表头结点,也可以表尾结点
//回收删除结点存储空间
deletecp;
//删除成功返回真
returntrue;
11.对单链表进行数据排序
假定待排序单链表由表头指针HL所指向，对结点值按照从小到大次序进行排序链接时，首先建立空单链表，然后把HL每个结点取出并按值依次插入到新建立单链表中，最后由引用参数HL带回新建单链表表头指针。下面就是对单链表进行插入排序算法。
voidSortList(LNode&HL)
```
```c
//建立反映排序结果新单链表并初始化为空
LNodeSL;
InitList(SL);
//从待排序HL单链表中依次取出每个结点,按值插入到新单链表中
LNoder=HL;//r指向待取出排序结点,初始HL表头结点
while(r!=NULL)
//新插入r结点SL顺序查找找出插入位置
LNodet=r->next;//t指向r后继结点
LNodecp=SL;//用cp初始指向SL单链表表头
LNodeap=NULL;//用ap指向cp前驱结点,初始为空
while(cp!=NULL)
if(r->data<cp->data)break;//找到插入点,退出循环
else
ap=cp;//apcp指针均后移,实现顺序向后比较
cp=cp->next;
//实现插入操作
if(ap==NULL)
r->next=SL;//把r结点插入到表头
SL=r;
else
r->next=cp;//把r结点插入apcp结点之间
ap->next=r;//cp可能为空,则r成为SL表尾
//使r指向原单链表下结点
r=t;
//由引用参数带回新单链表表头指针
HL=SL;
上面对单链表进行11种操作算法，第1、4种算法时间复杂度O(1)；第2、3及5~10种算法时间复杂度O(n)；第11种算法时间复杂度O(n^2)。若只单链表表头插入或删除结点，其时间复杂度均O(1)。上述每个算法空间复杂度均O(1)。由于对单链表插入删除元素操作只进行元素比较，不进行元素移动，而对顺序存储线性表操作既需要元素比较，又需要元素移动，所以当处理数据量较大，同时每个数据占用字节数较多时，相同数量级情况下，顺序表操作往往比单链表操作要花费更多时间。
要上机调试上述对单链表操作算法，只要对本章第2节调试程序稍加修改即可。主要把顺序表List类型定义替换LNode结点类型定义，把主函数表对象t类型List替换LNode。
对于由数组元素结点构成单链表，其操作算法与上述独立结点构成单链表的情
```
况类似,下面仅给出初始化单链表、按值插入元素按值删除元素算法,其他算法不难由同学们写出。
(1)初始化单链表。
voidInitList(ALinkListAL)//参数说明等同于ALNodeAL[MaxSize]
//将循环单链表置空,下标0结点表头附加结点
AL[0].next=0;
//结点依次链接构成空闲链接表
for(inti=2;i<MaxSize-1;i++)
AL[i].next=i+1;
//将带表头附加结点空闲链接表最后结点指针域置空
AL[MaxSize-1].next=0;
//下标1结点指针域指向空闲链接表第1个结点
AL[1].next=2;
(2)向有序单链表按值插入元素。
boolInsertList(ALinkListAL,constElemType&item)
intnewptr;
newptr=AL[1].next;//空闲表中取出表头结点
if(newptr==0)
cerr<<"没有空闲结点可用!"<<endl;
returnfalse;
AL[1].next=AL[newptr].next;//空闲表第2个结点成为新表头结点
AL[newptr].data=item;//item值赋给插结点值域
intap,cp;
ap=0;cp=AL[0].next;//分别给apcp赋初值
while(cp!=0)//查找新结点插入位置
if(item<AL[cp].data)break;
else
ap=cp;cp=AL[cp].next;
AL[newptr].next=cp;//插入时不用特殊处理表头情况
AL[ap].next=newptr;
returntrue;
(3)单链表中删除等于给定值第1个元素。
boolDeleteList(ALinkListAL,ElemType&item)
//单链表为空,无法删除元素,返回假
if(AL[0].next==0)
cerr<<"Linkedlistisanempty!"<<endl;
returnfalse;
//查找删除结点及前驱结点
intap,cp;
ap=0;cp=AL[0].next;
while(cp!=0)
if(AL[cp].data==item)break;
elseap=cp;cp=AL[cp].next;
//若不存在删除元素则返回假
if(cp==0)
cerr<<"Deletedelementisnotexist!"<<endl;
returnfalse;
//单链表中删除查找到下标cp结点，不用特殊考虑表头情况
AL[ap].next=AL[cp].next;
//把删除结点插入到空闲表表头
AL[cp].next=AL[1].next;
AL[1].next=cp;
//删除成功返回数值假
returnfalse;
2.6多项式计算
subsection2.6.1多项式表示与求值
多项式表示与求值线性表应用典型实例。
由数学知识可知，多项式P(x)一般表示：P(x)=a_0+a_1x^1+a_2x^2+cdots+a_nx^n其中，n整数，ngeqslant0，a_nneq0，a_0sima_n-1每个系数可以0，也可以不0。
section1.多项式第1种线性表表示与运算
为了处理P(x)，可把所有项系数用线性表来表示：(a_0,a_1,a_2,cdots,a_n)把这个线性表用顺序存储结构或链接存储结构保存起来，就可以进行多项式有关运算。若采用顺序存储结构，对应List类型对象P，其中P.list[]按x指数升序存储相应系数，即存储上面线性表，P.size存储多项式项数，它等于x最高次幂加1，则求此多项式值算法描述如下。
doublePolySum1(List&P,doublex)
//用sum计算累加，首先把常数项a_0值赋给它作为其初值
doublesum=P.list[0];
//用w计算x次幂，初值1
doublew=1;
//累加计算多项式值
for(inti=1;i<P.size;i++)
w=x;//计算出xi次幂
sum+=P.list[i]w;//把新项a_ix^i值累加到sum
//返回求出多项式值
returnsum;
若多项式线性表采用链接存储结构，则求值算法描述如下。
doublePolySum1(LNodeP,doublex)
LNodet=P;//用t指向多项式单链表表头结点
doublesum=t->data;//用sum计算累加，初值常数项a_0值
doublew=1;//用w计算x次幂，初值1
t=t->next;//t指向第二个结点，即值a_1结点
while(t!=NULL)
w=x;//使w累乘xsum+=t->dataw;//把新项值累加到sum
t=t->next;//使t指向下—个结点
returnsum;//返回求出多项式值
假定多项式5+3x^2-6x^3+2x^5，对应线性表(5,0,3,-6,0,2)，若采用链接存储，计算程序如下。
include<iostream.h>
include<stdlib.h>
typedefdoubleElemType;
structLNode
ElemTypedata;//定义单链表结点类型
LNodenext;
;
//单链表有关操作函数定义
voidmain()
```cpp
LNodea;
InitList(a);
ElemTyper[6]=5,0,3,-6,0,2;
inti;
for(i=5;i>=0;i--)InsertList(a,r[i],1);
cout<<"线性表a:";
TraverseList(a);
cout<<"线性表长度:"<<LengthList(a)<<endl;
doubley=PolySum1(a,2);
cout<<"x值为2时多项式值:"<<y<<endl;
ClearList(a);
```
主函数for语句，按r数组元素排列逆序依次单链表表头插入，正好能够得到按指数升序链接单链表。这样建立单链表，其时间复杂度O(n)。若把数组r元素依次插入到单链表表尾，其建立成单链表时间复杂度O(n^2)。此程序运行结果：
线性表a:503-602
线性表长度:6
x值为2时多项式值:33
section2.多项式第2种线性表表示与运算
多项式，往往会出现许多缺项。P(x)=1+6x^5-3x^12+7x^60，其中只有4项，缺少57项，或者说57项系数均0。若仍采用上述定义形式线性表，将浪费存储空间运算时间，不可取。为此，通常采用另一种形式线性表来表示，该线性表每个元素对应多项式非零项，每个元素包含两个域：系数域（coef）指数域（exp），用来分别表示对应项系数x指数，并且线性表元素应按照指数升序排列，它按指数有序有序表。P(x)多项式这种线性表表示：(1,0,6,5,-3,12,7,60)将线性表元素类型定义Term结构类型，则描述：
```cpp
structTerm
doublecoef;//系数
intexp;//指数
;
```
通过使用如下定义语句将Term类型与通用线性表元素类型ElemType对应起来。
```cpp
typedefTermElemType;
```
利用顺序存储结构存储这种线性表多项式求值算法如下。
```cpp
doublePolySum2(List&P,doublex)
```
```cpp
//给作为累加变量sum赋初值0
doublesum=0;
//累加计算多项式值
for(inti=0;i<P.size;i++)
inty=P.list[i].exp;//把新项x指数赋给y
sum+=P.list[i].coefpow(x,y);//把新项值累加到sum
//返回所求结果
returnsum;
函数使用pow(x,y)求xy次幂函数,该函数定义math.h头文件。利用链接存储结构存储这种线性表多项式求值算法如下。
doublePolySum2(LNodeP,doublex)
LNodet=P;
doublesum=0;
while(t!=NULL)
inty=t->data.exp;
sum+=t->data.coefpow(x,y);
t=t->next;
returnsum;
用下面程序来调用求顺序存储多项式值算法。由于把结构类型Term作为线性表元素类型ElemType使用,所以整个程序必须包含相应运算符重载函数定义,使得元素之间小于、等于、插入运算有效。当然不通过运算符重载也可行,则需要修改相应操作算法,使之进行比较元素某个域值(exp域值),而不是整个元素值,依次输出元素每个域值,而不是整个结构元素值。
include<iostream.h>
include<stdlib.h>
include<math.h>
structTerm
doublecoef;//系数
intexp;//指数
;
typedefTermElemType;
structList
ElemTypelist;//存线性表元素动态存储空间指针
intsize;//存线性表长度
intMaxSize;//规定list数组长度
;
```
booloperator!=(constElemType&e1,constElemType&e2)
returne1.exp!=e2.exp;
booloperator<(constElemType&e1,constElemType&e2)
returne1.exp<e2.exp;
ostream&operator<<(ostream&ostr,constElemType&x)
ostr<<x.coef<<''<<x.exp<<'';
returnostr;
include"list.cpp"//该程序文件保存着对线性表各种操作算法
doublePolySum2(List&P,doublex)
//上面给出函数定义
voidmain()
Lista1,a2;
InitList(a1);InitList(a2);
Termr1[4]=5,0,3,2,-6,3,2,5;
Termr2[4]=1,0,6,5,-3,12,7,60;
inti;
for(i=0;i<4;i++)//把r1每个元素依次插入线性表a1表尾
InsertList(a1,r1[i],-1);
for(i=0;i<4;i++)//把r2每个元素依次插入线性表a2表尾
InsertList(a2,r2[i],-1);
cout<<"线性表a1:";
TraverseList(a1);
cout<<"线性表a2:";
TraverseList(a2);
doubley1=PolySum2(a1,2);
doubley2=PolySum2(a2,2);
cout<<y1<<''<<y2<<endl;
ClearList(a1);ClearList(a2);
执行这个程序得到结果:
线性表a1:5032-6325
线性表a2:1065-312760
338.07045e+018
2.6.2两个多项式相加
下面以多项式链接存储结构为例讨论两个多项式P_1P_2相加算法，返回它们多项式。
两个多项式相加就是使对应项相加，若另多项式没有对应项（即指数相同项），则把它直接复制到结果。：
[P_1(x)=5+3x^2-6x^3+2x^5]
[P_2(x)=3+4x-2x^2+3x^3-2x^5+9x^6]P_1、P_2相加结果P_3(x)=8+4x+x^2-3x^3+9x^6。
因为每个单链表都按指数域值有序单链有序表，所以此相加过程就是两个单链有序表合并过程，当然要遵循多项式相加合并规则。
1.实现相加运算第1种算法
设计此题算法时，首先将两个指针t1t2分别指向两个多项式单链表p1p2表头结点，并定义初始化新单链表p3作为结果单链表；然后当t1t2所指结点非空时，比较它们指针域值大小，将较小结点值插入到p3单链表中，若两者相等，则将系数域值相加，当不为零时同归一结点指数域值组成元素值插入到p3单链表中，让t1t2指针后移，以便向下继续比较处理；最后当出现有单链表处理结束时，把另单链表中未处理每个结点值插入到p3单链表中。由此得到算法如下。
LNodePolyAdd1(LNodep1,LNodep2)
//定义表示结果多项式单链表p3并初始化为空
LNodep3;
InitList(p3);
//分别定义t1t2指针，初始分别指向p1p2单链表
LNodet1=p1,t2=p2;
//当两个表同时不空时处理过程
while(t1&&t2)
//将t1所指结点值按指数有序插入到p3单链表中，实际插到表尾
if(t1->data.exp<t2->data.exp)
InsertList(p3,t1->data,1);
t1=t1->next;
//将t2所指结点值按指数有序插入到p3单链表中
elseif(t2->data.exp<t1->data.exp)
InsertList(p3,t2->data,-1);
t2=t2->next;
//将t1t2所指结点值合并后按指数有序插入到p3单链表中
else
doublea=t1->data.coef+t2->data.coef;
if(a!=0)
Termitem=a,t1->data.exp;
InsertList(p3,item,-1);
t1=t1->next;
t2=t2->next;
//将p1单链表中剩余结点复制到p3单链表中
while(t1!=NULL)
InsertList(p3,t1->data,-1);
t1=t1->next;
//将p2单链表中剩余结点复制到p3单链表中
while(t2!=NULL)
InsertList(p3,t2->data,-1);
t2=t2->next;
//返回结果单链表表头指针p3
returnp3;
这个算法，t1rightarrowdata.exp<t2rightarrowdata.expt2rightarrowdata.exp<t1rightarrowdata.exp表达式也可以分别改写t1rightarrowdata<t2rightarrowdatat2rightarrowdata<t1rightarrowdata，因为进行两个Term结构对象小于号重载运算符函数比较其相应指数域。
此算法依次扫描两个单链表中每个结点，每次把结点值或两个对应结点合并值按指数有序插入到结果单链表中，因为每次插入指数值都大于结果单链表中已有结点值，所以只要依次插入到表尾即可。设两个加数多项式单链表长度分别mn，则扫描过程时间复杂度O(m+n)，每次插入过程时间复杂度也O(m+n)，因为每次都插入到结果单链表表尾，所以整个算法时间复杂度O((m+n)^2)。
section2.实现相加运算第2种算法
每次向结果单链表插入时不是调用插入算法InsertList，而是设法记住结果单链表表尾结点位置，直接把新结点链接到表尾，这样插入每个结点时间复杂度O(1)，整个算法时间复杂度就变为O(m+n)，从而大大提高算法时间效率，算法如下。
LNodePolyAdd2(LNodep1,LNodep2)
//定义结果单链表p3，并让它指向附加表头结点，这会使处理方便
LNodep3;
p3=newLNode;
//分别定义t1,t2t3指针，初始分别指向p1,p2p3单链表
LNodet1=p1,t2=p2,t3=p3;
//当两个表同时不空时处理过程
while(t1&&t2)
//将t1所指结点值赋给t3结点值域，t1指针后移
if(t1->data.exp<t2->data.exp)
t3=t3->next=newLNode;//p3尾部插入新结点并使t3指向它
t3->data=t1->data;
t1=t1->next;
//将t2所指结点值赋给t3结点值域，t2指针后移
elseif(t1->data.exp>t2->data.exp)
t3=t3->next=newLNode;
t3->data=t2->data;
t2=t2->next;
//将两结点合并后值赋给t3结点值域，t1t2指针同时后移
else
doublea=t1->data.coef+t2->data.coef;
if(a!=0)
Termitem=a,t1->data.exp;
t3=t3->next=newLNode;
t3->data=item;
t1=t1->next;
t2=t2->next;
//将p1单链表中剩余结点复制到p3单链表中
while(t1)
t3=t3->next=newLNode;
t3->data=t1->data;
t1=t1->next;
//将p2单链表中剩余结点复制到p3单链表中
while(t2)
t3=t3->next=newLNode;
t3->data=t2->data;
t2=t2->next;
//将p3单链表表尾结点指针域置空
t3->next=NULL;
//让t3指向p3所指附加表头结点，以便删除
t3=p3;
//使p3指向结果单链表第1个元素结点
p3=t3->next;
```c
//释放原附加表头结点
deletet3;
//返回结果单链表表头指针p3
returnp3;
算法使用p3单链表是带有表头附加结点单链表,这给插入运算带来方便,不需要对空表时插入做特殊处理,待整个运算完成后再把附加表头结点删除,使p3单链表又成为一般形式单链表。对带有表头附加结点单链表进行删除也同样方便,删除表头结点删除其他位置结点操作完全相同,因为始终不需要修改表头指针。
可以使用下面主函数调用上面多项式加法函数。
voidmain()
LNodea,b;
InitList(a);InitList(b);
Termra[4]=5,0,3,2,-6,3,2,5;
Termrb[6]=3,0,4,1,-2,2,3,3,-2,5,9,6;
inti;
for(i=3;i>=0;i--)InsertList(a,ra[i],1);//每次插入到表头
for(i=5;i>=0;i--)InsertList(b,rb[i],1);//每次插入到表头
cout<<"线性表a:";
TraverseList(a);
cout<<"线性表b:";
TraverseList(b);
LNodec=PolyAdd2(a,b);//或者使用PolyAdd1(a,b)调用
cout<<"线性表c:";
TraverseList(c);
ClearList(a);ClearList(b);ClearList(c);
程序执行后结果如下:
线性表a:5032-6325
线性表b:3041-2233-2596
线性表c:804112-3396
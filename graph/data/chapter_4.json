{
  "entities": [
    {
      "type": "数据结构",
      "ID": "04DS001",
      "name": "栈",
      "attributes": {
        "难度": "入门",
        "内容": "又称堆栈，是一种运算受限的线性表，仅允许在表的一端（栈顶）进行插入（进栈/入栈）和删除（出栈/退栈）运算。具有后进先出（LIFO）的特性。另一端称为栈底。应用：表达式求值、括号匹配、递归实现、进制转换等。",
        "存储开销": "依赖具体实现（顺序或链式）",
        "核心特性": "后进先出 (LIFO)",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON001",
      "name": "栈顶",
      "attributes": {
        "难度": "入门",
        "内容": "栈允许进行插入和删除操作的一端。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON002",
      "name": "栈底",
      "attributes": {
        "难度": "入门",
        "内容": "栈不允许进行插入和删除操作的一端，与栈顶相对。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON003",
      "name": "栈顶元素",
      "attributes": {
        "难度": "入门",
        "内容": "位于栈顶位置的元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG001",
      "name": "进栈",
      "attributes": {
        "难度": "入门",
        "内容": "向栈顶插入一个新元素，使其成为新的栈顶元素。也称压栈、入栈。顺序栈实现通常 O(1)，链栈实现 O(1)。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "直接操作",
        "适用场景": "向栈中添加元素",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG002",
      "name": "出栈",
      "attributes": {
        "难度": "入门",
        "内容": "删除栈顶元素，使其下面的相邻元素成为新的栈顶元素。也称弹栈、退栈。顺序栈实现通常 O(1)，链栈实现 O(1)。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "直接操作",
        "适用场景": "从栈中移除并获取元素",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON004",
      "name": "后进先出表",
      "attributes": {
        "难度": "入门",
        "内容": "Last In First Out (LIFO)，描述栈的操作特性，最后进入栈的元素最先被移出。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG003",
      "name": "读取栈顶元素",
      "attributes": {
        "难度": "入门",
        "内容": "返回栈顶元素的值，但不改变栈的状态（不删除元素）。也称 Peek。顺序栈实现 O(1)，链栈实现 O(1)。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "访问操作",
        "适用场景": "查看栈顶元素",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG004",
      "name": "检查栈是否为空",
      "attributes": {
        "难度": "入门",
        "内容": "判断栈中是否包含任何元素。顺序栈实现 O(1)，链栈实现 O(1)。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "状态检查",
        "适用场景": "判断栈空条件",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG005",
      "name": "初始化栈",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空栈。对于动态分配空间的实现，还包括分配初始内存。",
        "时间复杂度": "O(1) 或 O(MaxSize)",
        "空间复杂度": "O(1) 或 O(MaxSize)",
        "设计思想": "初始化",
        "适用场景": "使用栈之前",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG006",
      "name": "清除栈",
      "attributes": {
        "难度": "入门",
        "内容": "移除栈中所有元素，使其变为空栈。对于动态分配空间的实现，还可能包括释放内存。",
        "时间复杂度": "O(1) 或 O(N)",
        "空间复杂度": "O(1)",
        "设计思想": "重置",
        "适用场景": "清空栈内容",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS002",
      "name": "顺序栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组（顺序存储结构）实现的栈。需要一个数组存储元素和一个整型变量（栈顶指针）指示栈顶位置。",
        "存储开销": "固定或动态数组开销，可能存在空间浪费",
        "核心特性": "基于数组，访问 O(1)",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS003",
      "name": "数组",
      "attributes": {
        "难度": "入门",
        "内容": "一种线性数据结构，用连续的内存空间存储相同类型的元素集合。可通过索引直接访问元素。",
        "存储开销": "元素数量 * 单个元素大小",
        "核心特性": "连续存储，随机访问 O(1)",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON005",
      "name": "栈顶指针",
      "attributes": {
        "难度": "入门",
        "内容": "用于指示栈顶元素位置的变量。在顺序栈中通常是数组下标；在链栈中是指向栈顶结点的指针。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON006",
      "name": "栈满",
      "attributes": {
        "难度": "入门",
        "内容": "顺序栈的状态，表示存储空间已被完全占用，无法再插入新元素（除非动态扩容）。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON007",
      "name": "栈空",
      "attributes": {
        "难度": "入门",
        "内容": "栈的状态，表示栈中不包含任何元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS004",
      "name": "链栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用链式存储结构（通常是单链表）实现的栈。栈顶指针指向链表的头结点。",
        "存储开销": "结点数量 * (数据大小 + 指针大小)",
        "核心特性": "基于链表，动态增长，插入删除 O(1)",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS005",
      "name": "单链表",
      "attributes": {
        "难度": "入门",
        "内容": "一种链式数据结构，每个结点包含数据域和指向下一个结点的指针域。",
        "存储开销": "结点数量 * (数据大小 + 指针大小)",
        "核心特性": "非连续存储，插入删除（特定位置）O(1)，查找 O(N)",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON008",
      "name": "结点",
      "attributes": {
        "难度": "入门",
        "内容": "链式存储结构中的基本单元，通常包含数据域和指向其他结点的指针域。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG007",
      "name": "括号配对检查",
      "attributes": {
        "难度": "中等",
        "内容": "检查一个表达式或代码段中的括号（如 '()', '[]', '{}'）是否正确配对和嵌套。通常使用栈来实现。",
        "时间复杂度": "O(N)",
        "空间复杂度": "O(N)",
        "设计思想": "栈应用",
        "适用场景": "语法分析、代码检查",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG008",
      "name": "进制转换",
      "attributes": {
        "难度": "入门",
        "内容": "将一个数值从一种进制表示转换为另一种进制表示。例如，十进制转二进制、八进制等。使用栈可以方便地处理除基取余法得到的逆序数位。",
        "时间复杂度": "O(log_r N)",
        "空间复杂度": "O(log_r N)",
        "设计思想": "栈应用、数论",
        "适用场景": "数值表示转换",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON009",
      "name": "算术表达式",
      "attributes": {
        "难度": "入门",
        "内容": "由操作数、运算符和括号组成的式子，用于表示数学计算。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON010",
      "name": "中缀表示",
      "attributes": {
        "难度": "入门",
        "内容": "算术表达式的常规书写方式，运算符位于其操作数之间。计算时需考虑运算符优先级和括号。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON011",
      "name": "后缀表示",
      "attributes": {
        "难度": "入门",
        "内容": "算术表达式的一种表示法，运算符位于其操作数之后。也称逆波兰式。计算时无需考虑优先级和括号，只需顺序扫描。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON012",
      "name": "操作数",
      "attributes": {
        "难度": "入门",
        "内容": "算术表达式中参与运算的数据，可以是常量、变量或函数返回值。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON013",
      "name": "运算符",
      "attributes": {
        "难度": "入门",
        "内容": "算术表达式中表示运算操作的符号，如 +, -, *, /。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON014",
      "name": "运算符优先级",
      "attributes": {
        "难度": "入门",
        "内容": "规定不同运算符在计算时的先后顺序，如乘除优先于加减。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG009",
      "name": "后缀表达式求值",
      "attributes": {
        "难度": "中等",
        "内容": "计算后缀表示（逆波兰式）的算术表达式的值。通常使用栈来存储操作数和中间结果。",
        "时间复杂度": "O(N)",
        "空间复杂度": "O(N)",
        "设计思想": "栈应用",
        "适用场景": "计算后缀表达式",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG010",
      "name": "中缀表达式转换为后缀表达式",
      "attributes": {
        "难度": "中等",
        "内容": "将常规的中缀算术表达式转换为等价的后缀表达式（逆波兰式）。通常使用栈来暂存运算符。",
        "时间复杂度": "O(N)",
        "空间复杂度": "O(N)",
        "设计思想": "栈应用",
        "适用场景": "表达式转换，便于后续求值",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON015",
      "name": "递归",
      "attributes": {
        "难度": "中等",
        "内容": "一种解决问题的方法，其中函数直接或间接调用自身来解决规模更小的子问题。需要有明确的终止条件。在计算机中通常通过调用栈来实现。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG011",
      "name": "阶乘",
      "attributes": {
        "难度": "入门",
        "内容": "计算非负整数 n 的阶乘 (n!)。递归定义为 n! = n * (n-1)!，且 0! = 1。可用递归或循环实现。",
        "时间复杂度": "O(N)",
        "空间复杂度": "O(N)（递归）或 O(1)（循环）",
        "设计思想": "递归、循环",
        "适用场景": "数学计算、组合问题",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG012",
      "name": "布尔量组合",
      "attributes": {
        "难度": "中等",
        "内容": "生成 n 个布尔变量（取值为 0 或 1）的所有可能组合。共有 2^n 种组合。通常使用递归实现。",
        "时间复杂度": "O(N * 2^N)",
        "空间复杂度": "O(N)",
        "设计思想": "递归、回溯",
        "适用场景": "组合生成、状态枚举",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG013",
      "name": "全排列",
      "attributes": {
        "难度": "中等",
        "内容": "生成 n 个不同元素的所有可能排列顺序。共有 n! 种排列。通常使用递归实现。",
        "时间复杂度": "O(N * N!)",
        "空间复杂度": "O(N)",
        "设计思想": "递归、回溯、交换",
        "适用场景": "组合问题、搜索",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG014",
      "name": "迷宫求解",
      "attributes": {
        "难度": "中等",
        "内容": "寻找从迷宫入口到出口的一条可行路径。常用方法包括深度优先搜索（DFS，可用递归或栈实现）和广度优先搜索（BFS，用队列实现）。",
        "时间复杂度": "O(M*N) (M, N为迷宫尺寸)",
        "空间复杂度": "O(M*N)",
        "设计思想": "递归、回溯、DFS、图搜索",
        "适用场景": "路径查找、图遍历",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG015",
      "name": "汉诺塔",
      "attributes": {
        "难度": "中等",
        "内容": "经典的递归问题。将 n 个大小不同的圆盘从起始柱借助辅助柱移动到目标柱，每次只能移动一个，且大盘不能在小盘之上。",
        "时间复杂度": "O(2^N)",
        "空间复杂度": "O(N)",
        "设计思想": "递归、分治",
        "适用场景": "递归教学、问题分解",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS006",
      "name": "队列",
      "attributes": {
        "难度": "入门",
        "内容": "简称队，是一种运算受限的线性表，允许在表的一端（队尾）进行插入（入队），在另一端（队首）进行删除（出队）。具有先进先出（FIFO）的特性。应用：广度优先搜索、任务调度、缓冲区管理、渡口管理等。",
        "存储开销": "依赖具体实现（顺序或链式）",
        "核心特性": "先进先出 (FIFO)",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON016",
      "name": "队首",
      "attributes": {
        "难度": "入门",
        "内容": "队列允许进行删除操作的一端。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON017",
      "name": "队尾",
      "attributes": {
        "难度": "入门",
        "内容": "队列允许进行插入操作的一端。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG016",
      "name": "入队",
      "attributes": {
        "难度": "入门",
        "内容": "向队尾插入一个新元素，使其成为新的队尾元素。也称进队。顺序队列实现通常 O(1)（非满时），链队实现 O(1)。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "直接操作",
        "适用场景": "向队列中添加元素",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG017",
      "name": "出队",
      "attributes": {
        "难度": "入门",
        "内容": "删除队首元素，使其后继元素成为新的队首元素。也称离队。顺序队列实现 O(1)，链队实现 O(1)。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "直接操作",
        "适用场景": "从队列中移除并获取元素",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON018",
      "name": "队首元素",
      "attributes": {
        "难度": "入门",
        "内容": "位于队首位置的元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON019",
      "name": "队尾元素",
      "attributes": {
        "难度": "入门",
        "内容": "位于队尾位置的元素。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON020",
      "name": "先进先出表",
      "attributes": {
        "难度": "入门",
        "内容": "First In First Out (FIFO)，描述队列的操作特性，最先进入队列的元素最先被移出。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG018",
      "name": "读取队首元素",
      "attributes": {
        "难度": "入门",
        "内容": "返回队首元素的值，但不改变队列的状态。也称 PeekQueue。顺序队列实现 O(1)，链队实现 O(1)。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "访问操作",
        "适用场景": "查看队首元素",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG019",
      "name": "检查队列是否为空",
      "attributes": {
        "难度": "入门",
        "内容": "判断队列中是否包含任何元素。顺序队列实现 O(1)，链队实现 O(1)。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "状态检查",
        "适用场景": "判断队列空条件",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG020",
      "name": "初始化队列",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空队列。对于动态分配空间的实现，还包括分配初始内存。",
        "时间复杂度": "O(1) 或 O(MaxSize)",
        "空间复杂度": "O(1) 或 O(MaxSize)",
        "设计思想": "初始化",
        "适用场景": "使用队列之前",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG021",
      "name": "清除队列",
      "attributes": {
        "难度": "入门",
        "内容": "移除队列中所有元素，使其变为空队列。对于动态分配空间的实现，还可能包括释放内存。",
        "时间复杂度": "O(1) 或 O(N)",
        "空间复杂度": "O(1)",
        "设计思想": "重置",
        "适用场景": "清空队列内容",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS007",
      "name": "顺序队列",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组（顺序存储结构）实现的队列。通常实现为循环队列以有效利用空间。需要数组、队首指针和队尾指针。",
        "存储开销": "固定或动态数组开销，可能需要牺牲一个空间单元或使用额外变量区分队空和队满",
        "核心特性": "基于数组，通常为循环结构",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON021",
      "name": "队首指针",
      "attributes": {
        "难度": "入门",
        "内容": "用于指示队首元素位置（或队首元素前一个位置）的变量。在顺序队列中是数组下标；在链队中是指向队首结点的指针。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON022",
      "name": "队尾指针",
      "attributes": {
        "难度": "入门",
        "内容": "用于指示队尾元素位置的变量。在顺序队列中是数组下标；在链队中是指向队尾结点的指针。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS008",
      "name": "链队",
      "attributes": {
        "难度": "入门",
        "内容": "使用链式存储结构（通常是带尾指针的单链表）实现的队列。需要队首和队尾两个指针。",
        "存储开销": "结点数量 * (数据大小 + 指针大小)",
        "核心特性": "基于链表，动态增长，入队出队 O(1)",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS009",
      "name": "优先级队列",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的队列，其中每个元素关联一个优先级。出队操作总是移除优先级最高的元素。通常使用堆来实现。",
        "存储开销": "依赖实现（通常是堆）",
        "核心特性": "按优先级出队",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON023",
      "name": "队空",
      "attributes": {
        "难度": "入门",
        "内容": "队列的状态，表示队列中不包含任何元素。在循环队列中通常通过 front == rear 判断。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "概念",
      "ID": "04CON024",
      "name": "队满",
      "attributes": {
        "难度": "入门",
        "内容": "顺序队列（尤其是循环队列）的状态，表示存储空间已被完全占用。判断条件通常为 (rear+1)%MaxSize == front。",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS010",
      "name": "线性表",
      "attributes": {
        "难度": "入门",
        "内容": "由n（n>=0）个相同类型数据元素组成的有限序列。元素之间存在一对一的线性关系。栈和队列是运算受限的线性表。",
        "存储开销": "依赖具体实现（顺序或链式）",
        "核心特性": "元素有序，一对一关系",
        "教学视频": "未知",
        "教学材料": "未知",
        "外部资源": "未知",
        "相关习题": "未知",
        "相关实验": "未知"
      }
    }
  ],
  "relations": [
    {
      "type": "继承",
      "关系ID": "04REL001",
      "source": "04DS001",
      "target": "04DS010",
      "attributes": {
        "约束条件": "运算受限（仅限一端操作）"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL002",
      "source": "04DS001",
      "target": "04CON001",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL003",
      "source": "04DS001",
      "target": "04CON002",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL004",
      "source": "04DS001",
      "target": "04CON003",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL005",
      "source": "04DS001",
      "target": "04CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL006",
      "source": "04ALG001",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL007",
      "source": "04ALG002",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL008",
      "source": "04ALG003",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL009",
      "source": "04ALG004",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL010",
      "source": "04ALG005",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL011",
      "source": "04ALG006",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL012",
      "source": "04DS002",
      "target": "04DS001",
      "attributes": {
        "约束条件": "使用顺序存储实现"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL013",
      "source": "04DS002",
      "target": "04DS003",
      "attributes": {
        "使用角色": "底层存储"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL014",
      "source": "04DS002",
      "target": "04CON005",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL015",
      "source": "04DS002",
      "target": "04CON006",
      "attributes": {
        "依赖强度": "中"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL016",
      "source": "04DS002",
      "target": "04CON007",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL017",
      "source": "04DS004",
      "target": "04DS001",
      "attributes": {
        "约束条件": "使用链式存储实现"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL018",
      "source": "04DS004",
      "target": "04DS005",
      "attributes": {
        "使用角色": "底层存储"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL019",
      "source": "04DS004",
      "target": "04CON005",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL020",
      "source": "04DS004",
      "target": "04CON008",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL021",
      "source": "04ALG007",
      "target": "04DS001",
      "attributes": {
        "使用角色": "核心工具"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL022",
      "source": "04ALG008",
      "target": "04DS001",
      "attributes": {
        "使用角色": "存储中间结果"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL023",
      "source": "04CON010",
      "target": "04CON009",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL024",
      "source": "04CON011",
      "target": "04CON009",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL025",
      "source": "04CON009",
      "target": "04CON012",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL026",
      "source": "04CON009",
      "target": "04CON013",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL027",
      "source": "04CON010",
      "target": "04CON014",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL028",
      "source": "04ALG009",
      "target": "04DS001",
      "attributes": {
        "使用角色": "存储操作数和中间结果"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL029",
      "source": "04ALG010",
      "target": "04DS001",
      "attributes": {
        "使用角色": "存储运算符"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL030",
      "source": "04CON015",
      "target": "04DS001",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL031",
      "source": "04ALG011",
      "target": "04CON015",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL032",
      "source": "04ALG011",
      "target": "04DS001",
      "attributes": {
        "使用角色": "隐式调用栈"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL033",
      "source": "04ALG012",
      "target": "04CON015",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL034",
      "source": "04ALG012",
      "target": "04DS001",
      "attributes": {
        "使用角色": "隐式调用栈"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL035",
      "source": "04ALG013",
      "target": "04CON015",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL036",
      "source": "04ALG013",
      "target": "04DS001",
      "attributes": {
        "使用角色": "隐式调用栈"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL037",
      "source": "04ALG014",
      "target": "04CON015",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL038",
      "source": "04ALG014",
      "target": "04DS001",
      "attributes": {
        "使用角色": "隐式调用栈 或 显式路径记录"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL039",
      "source": "04ALG015",
      "target": "04CON015",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL040",
      "source": "04ALG015",
      "target": "04DS001",
      "attributes": {
        "使用角色": "隐式调用栈"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL041",
      "source": "04DS006",
      "target": "04DS010",
      "attributes": {
        "约束条件": "运算受限（队首出、队尾入）"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL042",
      "source": "04DS006",
      "target": "04CON016",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL043",
      "source": "04DS006",
      "target": "04CON017",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL044",
      "source": "04DS006",
      "target": "04CON018",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL045",
      "source": "04DS006",
      "target": "04CON019",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL046",
      "source": "04DS006",
      "target": "04CON020",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL047",
      "source": "04ALG016",
      "target": "04DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL048",
      "source": "04ALG017",
      "target": "04DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL049",
      "source": "04ALG018",
      "target": "04DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL050",
      "source": "04ALG019",
      "target": "04DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL051",
      "source": "04ALG020",
      "target": "04DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL052",
      "source": "04ALG021",
      "target": "04DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL053",
      "source": "04DS007",
      "target": "04DS006",
      "attributes": {
        "约束条件": "使用顺序存储（通常循环）实现"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL054",
      "source": "04DS007",
      "target": "04DS003",
      "attributes": {
        "使用角色": "底层存储"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL055",
      "source": "04DS007",
      "target": "04CON021",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL056",
      "source": "04DS007",
      "target": "04CON022",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL057",
      "source": "04DS007",
      "target": "04CON023",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL058",
      "source": "04DS007",
      "target": "04CON024",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL059",
      "source": "04DS008",
      "target": "04DS006",
      "attributes": {
        "约束条件": "使用链式存储实现"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL060",
      "source": "04DS008",
      "target": "04DS005",
      "attributes": {
        "使用角色": "底层存储"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL061",
      "source": "04DS008",
      "target": "04CON008",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL062",
      "source": "04DS008",
      "target": "04CON021",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL063",
      "source": "04DS008",
      "target": "04CON022",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "变体",
      "关系ID": "04REL064",
      "source": "04DS006",
      "target": "04DS009",
      "attributes": {
        "变体类型": "按优先级出队"
      }
    }
  ]
}
{
  "entities": [
    {
      "type": "数据结构",
      "ID": "06DS001",
      "name": "二叉搜索树",
      "attributes": {
        "难度": "中等",
        "内容": "又称二叉排序树。或为空树，或满足：左子树所有结点关键字小于根，右子树所有结点关键字大于等于根，左右子树本身也是二叉搜索树。中序遍历结果为有序序列。",
        "存储开销": "链式存储，O(n)空间",
        "核心特性": "有序性 (左<根<=右)",
        "适用场景": "高效查找、插入、删除有序数据"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS002",
      "name": "二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "每个结点最多有两个子结点（左孩子和右孩子）的树结构。",
        "存储开销": "链式或顺序存储，O(n)空间",
        "核心特性": "分支结构，每个结点度最多为2",
        "适用场景": "表示层次关系，多种特殊树的基础"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG001",
      "name": "中序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树遍历方式之一（左子树-根结点-右子树）。对于二叉搜索树，得到有序序列。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) (递归), O(1) (线索化)",
        "设计思想": "递归/迭代",
        "适用场景": "遍历二叉树，获取二叉搜索树的有序序列"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG002",
      "name": "二叉搜索树查找",
      "attributes": {
        "难度": "入门",
        "内容": "在二叉搜索树中根据结点值与给定值的比较，递归或迭代地在左子树或右子树中查找元素。",
        "时间复杂度": "O(logn) (平均), O(n) (最差)",
        "空间复杂度": "O(logn)/O(n) (递归), O(1) (非递归)",
        "设计思想": "分治，比较",
        "适用场景": "在二叉搜索树中定位元素"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG003",
      "name": "二叉搜索树更新",
      "attributes": {
        "难度": "入门",
        "内容": "在二叉搜索树中查找到指定元素后，用新值更新该元素。",
        "时间复杂度": "O(logn) (平均), O(n) (最差)",
        "空间复杂度": "O(logn)/O(n) (递归), O(1) (非递归)",
        "设计思想": "查找后修改",
        "适用场景": "修改二叉搜索树中结点的值"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG004",
      "name": "二叉搜索树插入",
      "attributes": {
        "难度": "入门",
        "内容": "在二叉搜索树中查找合适的插入位置（作为叶子结点），然后插入新元素，保持二叉搜索树性质。",
        "时间复杂度": "O(logn) (平均), O(n) (最差)",
        "空间复杂度": "O(logn)/O(n) (递归), O(1) (非递归)",
        "设计思想": "查找定位后链接",
        "适用场景": "构建或扩展二叉搜索树"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG005",
      "name": "二叉搜索树删除",
      "attributes": {
        "难度": "中等",
        "内容": "从二叉搜索树中删除指定元素。分三种情况：删除叶子结点、删除单支结点、删除双支结点（通常用中序前驱或后继替换）。",
        "时间复杂度": "O(logn) (平均), O(n) (最差)",
        "空间复杂度": "O(logn)/O(n) (递归), O(1) (非递归)",
        "设计思想": "分类讨论，替换与重链接",
        "适用场景": "维护二叉搜索树"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG006",
      "name": "递归查找 (BST)",
      "attributes": {
        "难度": "入门",
        "内容": "使用递归方法实现二叉搜索树的查找操作。",
        "时间复杂度": "O(logn) (平均), O(n) (最差)",
        "空间复杂度": "O(logn) (平均), O(n) (最差)",
        "设计思想": "递归，分治",
        "适用场景": "BST元素定位的递归实现"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG007",
      "name": "非递归查找 (BST)",
      "attributes": {
        "难度": "入门",
        "内容": "使用迭代（循环）方法实现二叉搜索树的查找操作。",
        "时间复杂度": "O(logn) (平均), O(n) (最差)",
        "空间复杂度": "O(1)",
        "设计思想": "迭代，分治",
        "适用场景": "BST元素定位的迭代实现，节省栈空间"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG008",
      "name": "CreateBSTree",
      "attributes": {
        "难度": "入门",
        "内容": "利用数组中的n个元素，通过重复调用插入操作来建立一棵二叉搜索树。",
        "时间复杂度": "O(n log n) (平均), O(n^2) (最差)",
        "空间复杂度": "O(n) (树结构), 插入过程空间见插入算法",
        "设计思想": "迭代调用插入",
        "适用场景": "从一个无序序列构建二叉搜索树"
      }
    },
    {
      "type": "概念",
      "ID": "06CON001",
      "name": "中序前驱",
      "attributes": {
        "难度": "入门",
        "内容": "在二叉树的中序遍历序列中，位于某结点之前的那个结点。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON002",
      "name": "中序后继",
      "attributes": {
        "难度": "入门",
        "内容": "在二叉树的中序遍历序列中，位于某结点之后的那个结点。"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS003",
      "name": "堆",
      "attributes": {
        "难度": "中等",
        "内容": "一种特殊的完全二叉树。分为小根堆（父结点值<=子结点值）和大根堆（父结点值>=子结点值）。",
        "存储开销": "通常使用数组顺序存储，O(n)空间",
        "核心特性": "完全二叉树结构，堆属性（父子关系）",
        "适用场景": "优先级队列实现，堆排序"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS004",
      "name": "完全二叉树",
      "attributes": {
        "难度": "入门",
        "内容": "深度为k，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为完全二叉树。除最后一层外，其余层都是满的，最后一层结点从左向右连续排列。",
        "存储开销": "适合顺序存储，O(n)空间",
        "核心特性": "结构特性，结点按层序编号连续",
        "适用场景": "堆的基础结构，高效利用顺序存储"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS005",
      "name": "小根堆",
      "attributes": {
        "难度": "中等",
        "内容": "父结点的值小于或等于其子结点值的堆。",
        "存储开销": "通常使用数组顺序存储，O(n)空间",
        "核心特性": "堆顶元素为整个堆的最小值",
        "适用场景": "快速获取最小值，升序堆排序，优先级队列（小顶优先）"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS006",
      "name": "大根堆",
      "attributes": {
        "难度": "中等",
        "内容": "父结点的值大于或等于其子结点值的堆。",
        "存储开销": "通常使用数组顺序存储，O(n)空间",
        "核心特性": "堆顶元素为整个堆的最大值",
        "适用场景": "快速获取最大值，降序堆排序，优先级队列（大顶优先）"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG009",
      "name": "向堆插入",
      "attributes": {
        "难度": "中等",
        "内容": "将新元素添加到堆的末尾（数组末尾），然后通过与其父结点比较和交换（上滤），自下而上调整以维持堆属性。",
        "时间复杂度": "O(logn)",
        "空间复杂度": "O(1)",
        "设计思想": "上滤调整",
        "适用场景": "向堆中添加新元素"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG010",
      "name": "从堆删除",
      "attributes": {
        "难度": "中等",
        "内容": "通常指删除堆顶元素。将堆顶元素与堆底元素交换，移除堆底元素，然后将新的堆顶元素通过与其子结点比较和交换（下滤），自上而下调整以维持堆属性。",
        "时间复杂度": "O(logn)",
        "空间复杂度": "O(1)",
        "设计思想": "下滤调整",
        "适用场景": "从堆中获取并移除极值元素（最小或最大）"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS007",
      "name": "优先级队列",
      "attributes": {
        "难度": "中等",
        "内容": "一种抽象数据类型，允许存储元素及其关联的优先级，并支持快速访问最高（或最低）优先级的元素。",
        "存储开销": "取决于实现，使用堆为O(n)",
        "核心特性": "按优先级出队",
        "适用场景": "任务调度，事件驱动模拟，图算法（如Dijkstra）"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS008",
      "name": "数组",
      "attributes": {
        "难度": "入门",
        "内容": "在连续内存空间中存储相同类型数据元素的集合。",
        "存储开销": "O(n)",
        "核心特性": "随机访问O(1)，连续存储",
        "适用场景": "存储序列数据，作为其他数据结构（如堆、哈希表）的基础"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS009",
      "name": "哈夫曼树",
      "attributes": {
        "难度": "中等",
        "内容": "又称最优二叉树，指对于n个带权叶子结点构成的所有二叉树中，带权路径长度(WPL)最小的那棵二叉树。",
        "存储开销": "链式存储，O(n)空间",
        "核心特性": "带权路径长度最小",
        "适用场景": "哈夫曼编码（数据压缩）"
      }
    },
    {
      "type": "概念",
      "ID": "06CON003",
      "name": "路径",
      "attributes": {
        "难度": "入门",
        "内容": "树中从一个结点到另一个结点的唯一结点序列。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON004",
      "name": "路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "一条路径上所经过的分支（边）的数量。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON005",
      "name": "结点权",
      "attributes": {
        "难度": "入门",
        "内容": "赋予树中结点的一个具有特定意义的数值（权重）。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON006",
      "name": "带权路径长度",
      "attributes": {
        "难度": "入门",
        "内容": "树中一个结点的权值与其到根结点路径长度的乘积。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON007",
      "name": "树带权路径长度 (WPL)",
      "attributes": {
        "难度": "入门",
        "内容": "树中所有叶子结点的带权路径长度之和。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG011",
      "name": "构造哈夫曼树",
      "attributes": {
        "难度": "中等",
        "内容": "一种贪心算法。初始时每个带权结点为一棵树，重复选择权值最小的两棵树合并为一棵新树（新权值为两者之和），直到只剩一棵树为止。",
        "时间复杂度": "O(n log n) (使用优先队列优化选择过程)",
        "空间复杂度": "O(n)",
        "设计思想": "贪心",
        "适用场景": "构建哈夫曼树"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG012",
      "name": "哈夫曼编码",
      "attributes": {
        "难度": "中等",
        "内容": "利用哈夫曼树进行的一种变长、无前缀编码方法。常用于数据压缩，频率高的字符编码短，频率低的字符编码长。",
        "时间复杂度": "O(n) (生成编码表)",
        "空间复杂度": "O(n) (存储编码表)",
        "设计思想": "基于哈夫曼树的路径表示",
        "适用场景": "无损数据压缩，通信编码"
      }
    },
    {
      "type": "概念",
      "ID": "06CON008",
      "name": "无前缀编码",
      "attributes": {
        "难度": "入门",
        "内容": "一种编码方案，其中没有任何一个码字是另一个码字的前缀。这保证了编码序列可以被唯一地解码。"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS010",
      "name": "线索二叉树",
      "attributes": {
        "难度": "中等",
        "内容": "利用二叉树结点中的空指针域（原本指向NULL的指针），存放指向该结点在某种遍历次序下的前驱或后继结点的指针（称为线索）。需要额外的标志位区分指针是孩子还是线索。",
        "存储开销": "链式存储，O(n)空间，每个结点增加两个标志位",
        "核心特性": "利用空指针，加速特定遍历",
        "适用场景": "需要频繁进行特定非递归遍历（尤其是中序）且希望空间复杂度为O(1)的场景"
      }
    },
    {
      "type": "概念",
      "ID": "06CON009",
      "name": "线索",
      "attributes": {
        "难度": "入门",
        "内容": "在线索二叉树中，存放在结点空指针域的、指向其遍历前驱或后继结点的指针。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON010",
      "name": "前驱线索",
      "attributes": {
        "难度": "入门",
        "内容": "指向结点在特定遍历序列中前驱结点的线索，通常存放在左空指针域。也称左线索。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON011",
      "name": "后继线索",
      "attributes": {
        "难度": "入门",
        "内容": "指向结点在特定遍历序列中后继结点的线索，通常存放在右空指针域。也称右线索。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG013",
      "name": "线索化",
      "attributes": {
        "难度": "中等",
        "内容": "对普通二叉树进行遍历，并将其空指针域修改为指向相应遍历序列中的前驱或后继结点的过程。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) (递归实现)",
        "设计思想": "遍历过程中设置线索",
        "适用场景": "将普通二叉树转换为线索二叉树"
      }
    },
    {
      "type": "概念",
      "ID": "06CON012",
      "name": "线索标志域",
      "attributes": {
        "难度": "入门",
        "内容": "线索二叉树结点中额外的标志位（如ltag, rtag），用于区分对应的指针域是指向孩子结点（值为0/false）还是指向线索（值为1/true）。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG014",
      "name": "中序线索化",
      "attributes": {
        "难度": "中等",
        "内容": "在对二叉树进行中序遍历的同时，添加中序前驱和中序后继线索。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(h) (递归实现)",
        "设计思想": "结合中序遍历设置线索",
        "适用场景": "创建中序线索二叉树"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG015",
      "name": "线索中序遍历",
      "attributes": {
        "难度": "入门",
        "内容": "利用中序线索二叉树中的线索，实现非递归且空间复杂度为O(1)的中序遍历。",
        "时间复杂度": "O(n)",
        "空间复杂度": "O(1)",
        "设计思想": "迭代，利用线索查找后继",
        "适用场景": "高效遍历中序线索二叉树"
      }
    },
    {
      "type": "数据结构",
      "ID": "06DS011",
      "name": "平衡二叉树",
      "attributes": {
        "难度": "高级",
        "内容": "简称AVL树。它首先是一棵二叉搜索树，并且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树也都是一棵平衡二叉树。",
        "存储开销": "链式存储，O(n)空间，通常结点需存储平衡因子",
        "核心特性": "自平衡，查找/插入/删除均为O(logn)",
        "适用场景": "需要高效稳定查找、插入、删除性能的动态集合"
      }
    },
    {
      "type": "概念",
      "ID": "06CON013",
      "name": "平衡因子",
      "attributes": {
        "难度": "入门",
        "内容": "二叉树中某个结点的左子树高度减去右子树高度的值。在AVL树中，平衡因子只能是-1, 0, 或 1。"
      }
    },
    {
      "type": "概念",
      "ID": "06CON014",
      "name": "最小不平衡子树",
      "attributes": {
        "难度": "入门",
        "内容": "在向AVL树插入或删除结点后，以距离插入/删除结点最近的、且平衡因子的绝对值大于1的结点作为根的子树。"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG016",
      "name": "LL型调整",
      "attributes": {
        "难度": "中等",
        "内容": "AVL树的旋转操作之一。当在结点A的左孩子B的左子树上插入导致A失衡时进行。对A进行右单旋转。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "旋转",
        "适用场景": "AVL树插入/删除后LL型失衡的恢复"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG017",
      "name": "RR型调整",
      "attributes": {
        "难度": "中等",
        "内容": "AVL树的旋转操作之一。当在结点A的右孩子B的右子树上插入导致A失衡时进行。对A进行左单旋转。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "旋转",
        "适用场景": "AVL树插入/删除后RR型失衡的恢复"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG018",
      "name": "LR型调整",
      "attributes": {
        "难度": "中等",
        "内容": "AVL树的旋转操作之一。当在结点A的左孩子B的右子树上插入导致A失衡时进行。先对B进行左单旋转，再对A进行右单旋转。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "双旋转",
        "适用场景": "AVL树插入/删除后LR型失衡的恢复"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG019",
      "name": "RL型调整",
      "attributes": {
        "难度": "中等",
        "内容": "AVL树的旋转操作之一。当在结点A的右孩子B的左子树上插入导致A失衡时进行。先对B进行右单旋转，再对A进行左单旋转。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "双旋转",
        "适用场景": "AVL树插入/删除后RL型失衡的恢复"
      }
    },
    {
      "type": "算法",
      "ID": "06ALG020",
      "name": "平衡二叉树插入",
      "attributes": {
        "难度": "高级",
        "内容": "在平衡二叉树（AVL树）中插入一个新结点。首先执行标准的二叉搜索树插入，然后从插入点回溯到根，检查并调整路径上可能出现的失衡结点（通过LL, RR, LR, RL旋转）。",
        "时间复杂度": "O(logn)",
        "空间复杂度": "O(logn) (递归回溯) / O(1) (迭代实现)",
        "设计思想": "BST插入 + 回溯检查 + 平衡旋转",
        "适用场景": "向AVL树中添加元素并维持平衡"
      }
    }
  ],
  "relations": [
    {
      "type": "继承",
      "关系ID": "06REL001",
      "source": "06DS002",
      "target": "06DS001",
      "attributes": {
        "约束条件": "左子树结点 < 根结点 <= 右子树结点"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL002",
      "source": "06ALG001",
      "target": "06DS001",
      "attributes": {
        "必需性": "否"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL003",
      "source": "06ALG002",
      "target": "06DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL004",
      "source": "06ALG003",
      "target": "06DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL005",
      "source": "06ALG004",
      "target": "06DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL006",
      "source": "06ALG005",
      "target": "06DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "优化",
      "关系ID": "06REL007",
      "source": "06ALG006",
      "target": "06ALG007",
      "attributes": {
        "优化方向": "空间复杂度"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL008",
      "source": "06ALG006",
      "target": "06DS001",
      "attributes": {
        "必需性": "否"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL009",
      "source": "06ALG007",
      "target": "06DS001",
      "attributes": {
        "必需性": "否"
      }
    },
    {
      "type": "使用",
      "关系ID": "06REL010",
      "source": "06ALG008",
      "target": "06ALG004",
      "attributes": {
        "使用角色": "核心步骤"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL011",
      "source": "06ALG005",
      "target": "06CON001",
      "attributes": {
        "依赖强度": "强 (用于删除双支结点策略)"
      }
    },
    {
      "type": "继承",
      "关系ID": "06REL012",
      "source": "06DS004",
      "target": "06DS003",
      "attributes": {
        "约束条件": "满足堆属性 (父子节点关键字关系)"
      }
    },
    {
      "type": "继承",
      "关系ID": "06REL013",
      "source": "06DS003",
      "target": "06DS005",
      "attributes": {
        "约束条件": "父结点 <= 子结点"
      }
    },
    {
      "type": "继承",
      "关系ID": "06REL014",
      "source": "06DS003",
      "target": "06DS006",
      "attributes": {
        "约束条件": "父结点 >= 子结点"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL015",
      "source": "06ALG009",
      "target": "06DS003",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL016",
      "source": "06ALG010",
      "target": "06DS003",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "使用",
      "关系ID": "06REL017",
      "source": "06DS007",
      "target": "06DS003",
      "attributes": {
        "使用角色": "常用实现"
      }
    },
    {
      "type": "使用",
      "关系ID": "06REL018",
      "source": "06DS003",
      "target": "06DS008",
      "attributes": {
        "使用角色": "顺序存储实现"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL019",
      "source": "06CON004",
      "target": "06CON003",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL020",
      "source": "06CON006",
      "target": "06CON004",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL021",
      "source": "06CON006",
      "target": "06CON005",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL022",
      "source": "06CON007",
      "target": "06CON006",
      "attributes": {
        "依赖强度": "强 (定义基础)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL023",
      "source": "06DS009",
      "target": "06CON007",
      "attributes": {
        "依赖强度": "强 (定义核心：WPL最小)"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL024",
      "source": "06ALG011",
      "target": "06DS009",
      "attributes": {
        "必需性": "是 (构造算法)"
      }
    },
    {
      "type": "使用",
      "关系ID": "06REL025",
      "source": "06ALG012",
      "target": "06DS009",
      "attributes": {
        "使用角色": "核心结构"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL026",
      "source": "06ALG012",
      "target": "06CON008",
      "attributes": {
        "依赖强度": "强 (哈夫曼编码是无前缀编码)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL027",
      "source": "06CON010",
      "target": "06CON009",
      "attributes": {
        "依赖强度": "强 (是线索的一种)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL028",
      "source": "06CON011",
      "target": "06CON009",
      "attributes": {
        "依赖强度": "强 (是线索的一种)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL029",
      "source": "06ALG013",
      "target": "06CON009",
      "attributes": {
        "依赖强度": "强 (线索化的目标是建立线索)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL030",
      "source": "06DS010",
      "target": "06CON009",
      "attributes": {
        "依赖强度": "强 (定义核心)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL031",
      "source": "06DS010",
      "target": "06CON012",
      "attributes": {
        "依赖强度": "强 (结构组成部分)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL032",
      "source": "06CON010",
      "target": "06CON001",
      "attributes": {
        "依赖强度": "强 (指向前驱)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL033",
      "source": "06CON011",
      "target": "06CON002",
      "attributes": {
        "依赖强度": "强 (指向后继)"
      }
    },
    {
      "type": "变体",
      "关系ID": "06REL034",
      "source": "06DS002",
      "target": "06DS010",
      "attributes": {
        "变体类型": "利用空指针域增加前驱/后继线索"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL035",
      "source": "06ALG014",
      "target": "06DS010",
      "attributes": {
        "必需性": "是 (用于创建中序线索)"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL036",
      "source": "06ALG015",
      "target": "06DS010",
      "attributes": {
        "必需性": "否 (是其上的遍历算法)"
      }
    },
    {
      "type": "使用",
      "关系ID": "06REL037",
      "source": "06ALG015",
      "target": "06CON002",
      "attributes": {
        "使用角色": "核心逻辑 (通过InorderNext查找后继)"
      }
    },
    {
      "type": "继承",
      "关系ID": "06REL038",
      "source": "06DS001",
      "target": "06DS011",
      "attributes": {
        "约束条件": "左右子树高度差绝对值<=1"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL039",
      "source": "06DS011",
      "target": "06CON013",
      "attributes": {
        "依赖强度": "强 (定义和维护平衡的核心)"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL040",
      "source": "06ALG016",
      "target": "06DS011",
      "attributes": {
        "必需性": "是 (用于恢复平衡)"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL041",
      "source": "06ALG017",
      "target": "06DS011",
      "attributes": {
        "必需性": "是 (用于恢复平衡)"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL042",
      "source": "06ALG018",
      "target": "06DS011",
      "attributes": {
        "必需性": "是 (用于恢复平衡)"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL043",
      "source": "06ALG019",
      "target": "06DS011",
      "attributes": {
        "必需性": "是 (用于恢复平衡)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL044",
      "source": "06ALG016",
      "target": "06CON014",
      "attributes": {
        "依赖强度": "强 (调整对象)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL045",
      "source": "06ALG017",
      "target": "06CON014",
      "attributes": {
        "依赖强度": "强 (调整对象)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL046",
      "source": "06ALG018",
      "target": "06CON014",
      "attributes": {
        "依赖强度": "强 (调整对象)"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "06REL047",
      "source": "06ALG019",
      "target": "06CON014",
      "attributes": {
        "依赖强度": "强 (调整对象)"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "06REL048",
      "source": "06ALG020",
      "target": "06DS011",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "使用",
      "关系ID": "06REL049",
      "source": "06ALG020",
      "target": "06ALG004",
      "attributes": {
        "使用角色": "基础插入逻辑"
      }
    },
    {
      "type": "使用",
      "关系ID": "06REL050",
      "source": "06ALG020",
      "target": "06ALG016",
      "attributes": {
        "使用角色": "可能调用的平衡恢复操作"
      }
    },
    {
      "type": "使用",
      "关系ID": "06REL051",
      "source": "06ALG020",
      "target": "06ALG017",
      "attributes": {
        "使用角色": "可能调用的平衡恢复操作"
      }
    },
    {
      "type": "使用",
      "关系ID": "06REL052",
      "source": "06ALG020",
      "target": "06ALG018",
      "attributes": {
        "使用角色": "可能调用的平衡恢复操作"
      }
    },
    {
      "type": "使用",
      "关系ID": "06REL053",
      "source": "06ALG020",
      "target": "06ALG019",
      "attributes": {
        "使用角色": "可能调用的平衡恢复操作"
      }
    }
  ]
}
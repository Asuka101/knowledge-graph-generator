{
  "entities": [
    {
      "type": "数据结构",
      "ID": "04DS001",
      "name": "栈",
      "attributes": {
        "难度": "入门",
        "内容": "运算受限的线性表，其限制是仅允许在表的一端进行插入和删除运算。允许操作的一端称为栈顶，另一端称为栈底。具有后进先出（LIFO）的特性。也称堆栈。",
        "存储开销": "依赖实现 (顺序栈O(MaxSize), 链栈O(N))",
        "核心特性": "后进先出 (LIFO), 运算受限"
      }
    },
    {
      "type": "概念",
      "ID": "04CON001",
      "name": "栈顶",
      "attributes": {
        "难度": "入门",
        "内容": "对栈进行插入和删除运算的一端。栈顶的第一个元素称为栈顶元素。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON002",
      "name": "栈底",
      "attributes": {
        "难度": "入门",
        "内容": "栈的不允许进行插入和删除运算的一端。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG001",
      "name": "入栈 (Push)",
      "attributes": {
        "难度": "入门",
        "内容": "向栈顶插入一个新元素，使其成为新的栈顶元素。也称进栈。",
        "时间复杂度": "O(1) (均摊)",
        "空间复杂度": "O(1)",
        "设计思想": "基本栈操作",
        "适用场景": "修改栈内容"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG002",
      "name": "出栈 (Pop)",
      "attributes": {
        "难度": "入门",
        "内容": "删除栈顶元素，使其下面的相邻元素成为新的栈顶元素。也称退栈。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "基本栈操作",
        "适用场景": "修改栈内容"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG003",
      "name": "初始化栈 (InitStack)",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空栈。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1) 或 O(MaxSize) / O(1) (取决于实现)",
        "设计思想": "初始化操作",
        "适用场景": "使用栈之前"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG004",
      "name": "读取栈顶元素 (Peek)",
      "attributes": {
        "难度": "入门",
        "内容": "返回栈顶元素的值，但不删除该元素，栈的状态不变。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "访问操作",
        "适用场景": "查看栈顶元素"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG005",
      "name": "判断栈空 (EmptyStack)",
      "attributes": {
        "难度": "入门",
        "内容": "检查栈是否包含任何元素。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "状态检查",
        "适用场景": "进行出栈或读取操作前检查"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG006",
      "name": "清空栈 (ClearStack)",
      "attributes": {
        "难度": "入门",
        "内容": "移除栈中所有元素，使其成为空栈。",
        "时间复杂度": "O(1) (顺序栈重置指针) 或 O(N) (链栈释放节点)",
        "空间复杂度": "O(1)",
        "设计思想": "重置操作",
        "适用场景": "需要重用栈对象时"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS002",
      "name": "顺序栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组（顺序存储结构）和栈顶指针实现的栈。通常top=-1表示空，top=MaxSize-1表示满（或接近满）。插入删除操作的时间复杂度为O(1)（不考虑扩容）。",
        "存储开销": "O(MaxSize) 固定或动态分配的连续空间",
        "核心特性": "顺序存储, 后进先出"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS003",
      "name": "数组",
      "attributes": {
        "难度": "入门",
        "内容": "在连续内存空间中存储相同类型元素的集合，可通过下标随机访问。",
        "存储开销": "连续内存块，大小固定（静态）或可调整（动态）",
        "核心特性": "随机访问 (O(1)), 顺序存储"
      }
    },
    {
      "type": "概念",
      "ID": "04CON003",
      "name": "栈顶指针",
      "attributes": {
        "难度": "入门",
        "内容": "在顺序栈中，指示栈顶元素在数组中位置（通常是下标）的变量。"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS004",
      "name": "链栈",
      "attributes": {
        "难度": "入门",
        "内容": "使用链式存储结构（通常是单链表）实现的栈。栈顶指针指向链表的第一个（或最后一个，取决于实现）结点。插入删除操作的时间复杂度为O(1)。",
        "存储开销": "O(N) 非连续空间，N为元素个数",
        "核心特性": "链式存储, 后进先出, 动态大小"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS005",
      "name": "单链表",
      "attributes": {
        "难度": "入门",
        "内容": "通过结点指针串联的数据结构，每个结点包含数据域和指向下一个结点的指针域。",
        "存储开销": "O(N) 非连续空间",
        "核心特性": "动态大小, 插入删除高效（若有指针）, 顺序访问"
      }
    },
    {
      "type": "概念",
      "ID": "04CON004",
      "name": "结点",
      "attributes": {
        "难度": "入门",
        "内容": "链式存储结构的基本组成单元，通常包含数据域和（一个或多个）指针域。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG007",
      "name": "括号配对检查算法",
      "attributes": {
        "难度": "中等",
        "内容": "通过栈检查表达式中的括号（如(), [], {}）是否正确配对。遇左括号入栈，遇右括号检查栈顶是否为对应左括号，匹配则出栈，不匹配或最后栈非空则错误。",
        "时间复杂度": "O(N) (N为输入串长度)",
        "空间复杂度": "O(N) (最坏情况栈深度)",
        "设计思想": "栈应用",
        "适用场景": "编译器语法分析, 代码编辑器"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG008",
      "name": "十进制转R进制算法",
      "attributes": {
        "难度": "入门",
        "内容": "将十进制数转换为其他进制（如二进制、八进制）的算法。采用逐次除基数取余数的方法，将余数入栈，转换完成后依次出栈得到结果。",
        "时间复杂度": "O(log_r N) (N为十进制数大小)",
        "空间复杂度": "O(log_r N) (栈深度)",
        "设计思想": "栈应用, 数制转换",
        "适用场景": "进制转换"
      }
    },
    {
      "type": "概念",
      "ID": "04CON005",
      "name": "算术表达式",
      "attributes": {
        "难度": "入门",
        "内容": "由操作数（常量、变量、函数、表达式）、运算符（单目、双目）以及改变运算次序的括号组成的式子。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON006",
      "name": "操作数",
      "attributes": {
        "难度": "入门",
        "内容": "算术表达式中运算的对象或运算量。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON007",
      "name": "运算符",
      "attributes": {
        "难度": "入门",
        "内容": "算术表达式中执行运算的符号，如+、-、*、/。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON008",
      "name": "中缀表达式",
      "attributes": {
        "难度": "入门",
        "内容": "运算符位于其操作数之间的常规算术表达式表示法。计算时需要考虑运算符优先级和括号。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON009",
      "name": "后缀表达式",
      "attributes": {
        "难度": "入门",
        "内容": "运算符位于其操作数之后的算术表达式表示法，也称逆波兰式。计算时无需考虑优先级和括号，只需按运算符出现顺序操作即可，通常借助栈进行求值。",
        "难度": "入门"
      }
    },
    {
      "type": "概念",
      "ID": "04CON010",
      "name": "运算符优先级",
      "attributes": {
        "难度": "入门",
        "内容": "规定不同运算符在计算时执行先后的规则，例如乘除运算优先于加减运算。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG009",
      "name": "后缀表达式求值算法",
      "attributes": {
        "难度": "中等",
        "内容": "使用栈计算后缀表达式的值。从左到右扫描表达式，遇到操作数压入栈；遇到运算符，弹出所需数量的操作数进行运算，并将结果压回栈。表达式扫描完毕后，栈中唯一的值即为结果。",
        "时间复杂度": "O(N) (N为表达式长度)",
        "空间复杂度": "O(N) (最坏情况栈深度)",
        "设计思想": "栈应用",
        "适用场景": "计算器, 解释器"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG010",
      "name": "中缀转后缀算法",
      "attributes": {
        "难度": "中等",
        "内容": "将中缀表达式转换为等价的后缀表达式。使用一个栈来暂存运算符。扫描中缀表达式，操作数直接输出，运算符根据优先级规则和栈顶运算符比较后决定入栈或出栈，括号控制操作符的出栈时机。",
        "时间复杂度": "O(N)",
        "空间复杂度": "O(N) (运算符栈深度)",
        "设计思想": "栈应用, 表达式转换",
        "适用场景": "编译器, 解释器, 后缀表达式求值的前处理"
      }
    },
    {
      "type": "概念",
      "ID": "04CON011",
      "name": "递归",
      "attributes": {
        "难度": "中等",
        "内容": "一种算法设计技术，函数或过程直接或间接调用自身来解决问题。通常将大问题分解为相似的子问题。需要明确的终止条件（基本情况）和递归步骤。系统通常使用调用栈来实现递归。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG011",
      "name": "阶乘递归算法",
      "attributes": {
        "难度": "入门",
        "内容": "计算非负整数n阶乘(n!)的递归实现。定义f(n) = n * f(n-1)，基本情况f(0) = 1。",
        "时间复杂度": "O(N)",
        "空间复杂度": "O(N) (递归深度/调用栈)",
        "设计思想": "递归",
        "适用场景": "阶乘计算 (教学)"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG012",
      "name": "布尔组合递归算法",
      "attributes": {
        "难度": "中等",
        "内容": "生成n个布尔变量所有可能的2^n种组合。通过递归地对每一位设置true或false，然后处理下一位。",
        "时间复杂度": "O(N * 2^N) (输出时间)",
        "空间复杂度": "O(N) (递归深度)",
        "设计思想": "递归, 枚举",
        "适用场景": "生成所有组合状态"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG013",
      "name": "全排列递归算法",
      "attributes": {
        "难度": "中等",
        "内容": "生成n个不同元素的所有n!种排列。通过递归地确定每一个位置的元素（通过交换），然后对剩余元素进行全排列。",
        "时间复杂度": "O(N * N!) (输出时间)",
        "空间复杂度": "O(N) (递归深度)",
        "设计思想": "递归, 回溯",
        "适用场景": "生成所有排列顺序"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG014",
      "name": "迷宫求解递归算法",
      "attributes": {
        "难度": "中等",
        "内容": "使用递归（深度优先搜索）从迷宫入口寻找通往出口的路径。尝试向邻近的可通行且未访问的格子移动，如果找到出口则成功返回，否则回溯尝试其他方向。",
        "时间复杂度": "O(M*N) (M, N为迷宫尺寸)",
        "空间复杂度": "O(M*N) (标记数组+递归深度)",
        "设计思想": "递归, 回溯, 深度优先搜索",
        "适用场景": "路径查找, 图遍历"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG015",
      "name": "汉诺塔递归算法",
      "attributes": {
        "难度": "中等",
        "内容": "解决汉诺塔问题的经典递归算法。将n个盘子从源柱移动到目标柱（借助辅助柱）分解为：移动n-1个盘子到辅助柱，移动第n个盘子到目标柱，移动n-1个盘子从辅助柱到目标柱。",
        "时间复杂度": "O(2^N)",
        "空间复杂度": "O(N) (递归深度)",
        "设计思想": "递归, 分治",
        "适用场景": "经典递归问题教学"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS006",
      "name": "队列",
      "attributes": {
        "难度": "入门",
        "内容": "运算受限的线性表，允许在一端（队尾）进行插入，而在另一端（队首）进行删除。具有先进先出（FIFO）的特性。也称队。",
        "存储开销": "依赖实现 (顺序队列O(MaxSize), 链队O(N))",
        "核心特性": "先进先出 (FIFO), 运算受限"
      }
    },
    {
      "type": "概念",
      "ID": "04CON012",
      "name": "队尾 (rear)",
      "attributes": {
        "难度": "入门",
        "内容": "队列中允许插入元素的一端。在实现中通常由队尾指针指示。"
      }
    },
    {
      "type": "概念",
      "ID": "04CON013",
      "name": "队首 (front)",
      "attributes": {
        "难度": "入门",
        "内容": "队列中允许删除元素的一端。在实现中通常由队首指针指示。"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG016",
      "name": "入队 (EnQueue)",
      "attributes": {
        "难度": "入门",
        "内容": "向队尾添加一个新元素，使其成为新的队尾元素。也称进队。",
        "时间复杂度": "O(1) (均摊)",
        "空间复杂度": "O(1)",
        "设计思想": "基本队列操作",
        "适用场景": "修改队列内容"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG017",
      "name": "出队 (DeQueue/OutQueue)",
      "attributes": {
        "难度": "入门",
        "内容": "移除并返回队首元素，其后继元素（若存在）成为新的队首元素。也称离队。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "基本队列操作",
        "适用场景": "处理队列元素"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG018",
      "name": "初始化队列 (InitQueue)",
      "attributes": {
        "难度": "入门",
        "内容": "创建一个空队列。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1) 或 O(MaxSize) / O(1) (取决于实现)",
        "设计思想": "初始化操作",
        "适用场景": "使用队列之前"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG019",
      "name": "读取队首元素 (PeekQueue)",
      "attributes": {
        "难度": "入门",
        "内容": "返回队首元素的值，但不删除该元素，队列状态不变。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "访问操作",
        "适用场景": "查看队首元素"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG020",
      "name": "判断队空 (EmptyQueue)",
      "attributes": {
        "难度": "入门",
        "内容": "检查队列是否包含任何元素。",
        "时间复杂度": "O(1)",
        "空间复杂度": "O(1)",
        "设计思想": "状态检查",
        "适用场景": "进行出队或读取操作前检查"
      }
    },
    {
      "type": "算法",
      "ID": "04ALG021",
      "name": "清空队列 (ClearQueue)",
      "attributes": {
        "难度": "入门",
        "内容": "移除队列中所有元素，使其成为空队。",
        "时间复杂度": "O(1) (顺序队列重置指针) 或 O(N) (链队释放节点)",
        "空间复杂度": "O(1)",
        "设计思想": "重置操作",
        "适用场景": "需要重用队列对象时"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS007",
      "name": "顺序队列 (循环队列)",
      "attributes": {
        "难度": "入门",
        "内容": "使用数组和队首(front)、队尾(rear)指针实现的队列。通常采用循环方式利用数组空间（循环队列），通过取模运算处理边界，以避免“假溢出”。",
        "存储开销": "O(MaxSize) 固定或动态分配的连续空间",
        "核心特性": "顺序存储, 先进先出, 循环利用空间"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS008",
      "name": "链队",
      "attributes": {
        "难度": "入门",
        "内容": "使用链式存储结构（通常是带头尾指针的单链表）实现的队列。front指向队首结点，rear指向队尾结点。入队在链表尾部操作，出队在链表头部操作，时间复杂度均为O(1)。",
        "存储开销": "O(N) 非连续空间",
        "核心特性": "链式存储, 先进先出, 动态大小"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS009",
      "name": "优先级队列",
      "attributes": {
        "难度": "中等",
        "内容": "一种抽象数据类型，类似于队列，但每个元素都有一个关联的“优先级”。删除操作总是移除优先级最高的元素。插入操作按优先级确定位置。常用堆实现。",
        "存储开销": "依赖实现 (如堆O(N))",
        "核心特性": "按优先级出队"
      }
    },
    {
      "type": "数据结构",
      "ID": "04DS010",
      "name": "线性表",
      "attributes": {
        "难度": "入门",
        "内容": "由n（n>=0）个相同类型数据元素组成的有限序列。元素之间存在一对一的逻辑关系。是栈和队列的基础数据结构类型。",
        "存储开销": "依赖实现 (顺序表O(N), 链表O(N))",
        "核心特性": "元素有序（逻辑上）, 有限性"
      }
    }
  ],
  "relations": [
    {
      "type": "操作绑定",
      "关系ID": "04REL001",
      "source": "04ALG001",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL002",
      "source": "04ALG002",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL003",
      "source": "04DS001",
      "target": "04CON001",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL004",
      "source": "04DS001",
      "target": "04CON002",
      "attributes": {
        "依赖强度": "强"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL005",
      "source": "04ALG003",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL006",
      "source": "04ALG004",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL007",
      "source": "04ALG005",
      "target": "04DS001",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL008",
      "source": "04ALG006",
      "target": "04DS001",
      "attributes": {
        "必需性": "否"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL009",
      "source": "04DS002",
      "target": "04DS001",
      "attributes": {
        "父类 ID": "04DS001",
        "子类 ID": "04DS002",
        "约束条件": "使用顺序存储实现"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL010",
      "source": "04DS002",
      "target": "04DS003",
      "attributes": {
        "使用方ID": "04DS002",
        "被使用的数据结构 ID": "04DS003",
        "使用角色": "核心存储机制"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL011",
      "source": "04DS002",
      "target": "04CON003",
      "attributes": {
        "实体 ID": "04DS002",
        "概念 ID": "04CON003",
        "依赖强度": "强"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL012",
      "source": "04DS004",
      "target": "04DS001",
      "attributes": {
        "父类 ID": "04DS001",
        "子类 ID": "04DS004",
        "约束条件": "使用链式存储实现"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL013",
      "source": "04DS004",
      "target": "04DS005",
      "attributes": {
        "使用方ID": "04DS004",
        "被使用的数据结构 ID": "04DS005",
        "使用角色": "核心存储机制"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL014",
      "source": "04DS005",
      "target": "04CON004",
      "attributes": {
        "实体 ID": "04DS005",
        "概念 ID": "04CON004",
        "依赖强度": "强"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL015",
      "source": "04ALG007",
      "target": "04DS001",
      "attributes": {
        "使用方ID": "04ALG007",
        "被使用的数据结构 ID": "04DS001",
        "使用角色": "核心工具"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL016",
      "source": "04ALG008",
      "target": "04DS001",
      "attributes": {
        "使用方ID": "04ALG008",
        "被使用的数据结构 ID": "04DS001",
        "使用角色": "结果暂存与逆序"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL017",
      "source": "04CON008",
      "target": "04CON005",
      "attributes": {
        "实体 ID": "04CON008",
        "概念 ID": "04CON005",
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL018",
      "source": "04CON009",
      "target": "04CON005",
      "attributes": {
        "实体 ID": "04CON009",
        "概念 ID": "04CON005",
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL019",
      "source": "04CON008",
      "target": "04CON010",
      "attributes": {
        "实体 ID": "04CON008",
        "概念 ID": "04CON010",
        "依赖强度": "强"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL020",
      "source": "04ALG009",
      "target": "04DS001",
      "attributes": {
        "使用方ID": "04ALG009",
        "被使用的数据结构 ID": "04DS001",
        "使用角色": "操作数/中间结果存储"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL021",
      "source": "04ALG009",
      "target": "04CON009",
      "attributes": {
        "实体 ID": "04ALG009",
        "概念 ID": "04CON009",
        "依赖强度": "强"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL022",
      "source": "04ALG010",
      "target": "04DS001",
      "attributes": {
        "使用方ID": "04ALG010",
        "被使用的数据结构 ID": "04DS001",
        "使用角色": "运算符暂存"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL023",
      "source": "04ALG010",
      "target": "04CON008",
      "attributes": {
        "实体 ID": "04ALG010",
        "概念 ID": "04CON008",
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL024",
      "source": "04ALG010",
      "target": "04CON009",
      "attributes": {
        "实体 ID": "04ALG010",
        "概念 ID": "04CON009",
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL025",
      "source": "04ALG010",
      "target": "04CON010",
      "attributes": {
        "实体 ID": "04ALG010",
        "概念 ID": "04CON010",
        "依赖强度": "强"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL026",
      "source": "04CON011",
      "target": "04DS001",
      "attributes": {
        "使用方ID": "04CON011",
        "被使用的数据结构 ID": "04DS001",
        "使用角色": "系统实现（调用栈）"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL027",
      "source": "04ALG011",
      "target": "04CON011",
      "attributes": {
        "实体 ID": "04ALG011",
        "概念 ID": "04CON011",
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL028",
      "source": "04ALG012",
      "target": "04CON011",
      "attributes": {
        "实体 ID": "04ALG012",
        "概念 ID": "04CON011",
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL029",
      "source": "04ALG013",
      "target": "04CON011",
      "attributes": {
        "实体 ID": "04ALG013",
        "概念 ID": "04CON011",
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL030",
      "source": "04ALG014",
      "target": "04CON011",
      "attributes": {
        "实体 ID": "04ALG014",
        "概念 ID": "04CON011",
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL031",
      "source": "04ALG015",
      "target": "04CON011",
      "attributes": {
        "实体 ID": "04ALG015",
        "概念 ID": "04CON011",
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL032",
      "source": "04DS006",
      "target": "04CON012",
      "attributes": {
        "实体 ID": "04DS006",
        "概念 ID": "04CON012",
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL033",
      "source": "04DS006",
      "target": "04CON013",
      "attributes": {
        "实体 ID": "04DS006",
        "概念 ID": "04CON013",
        "依赖强度": "强"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL034",
      "source": "04ALG016",
      "target": "04DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL035",
      "source": "04ALG017",
      "target": "04DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL036",
      "source": "04ALG018",
      "target": "04DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL037",
      "source": "04ALG019",
      "target": "04DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL038",
      "source": "04ALG020",
      "target": "04DS006",
      "attributes": {
        "必需性": "是"
      }
    },
    {
      "type": "操作绑定",
      "关系ID": "04REL039",
      "source": "04ALG021",
      "target": "04DS006",
      "attributes": {
        "必需性": "否"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL040",
      "source": "04DS007",
      "target": "04DS006",
      "attributes": {
        "父类 ID": "04DS006",
        "子类 ID": "04DS007",
        "约束条件": "使用顺序存储实现 (循环数组)"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL041",
      "source": "04DS007",
      "target": "04DS003",
      "attributes": {
        "使用方ID": "04DS007",
        "被使用的数据结构 ID": "04DS003",
        "使用角色": "核心存储机制"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL042",
      "source": "04DS007",
      "target": "04CON013",
      "attributes": {
        "实体 ID": "04DS007",
        "概念 ID": "04CON013",
        "依赖强度": "强"
      }
    },
    {
      "type": "理论依赖",
      "关系ID": "04REL043",
      "source": "04DS007",
      "target": "04CON012",
      "attributes": {
        "实体 ID": "04DS007",
        "概念 ID": "04CON012",
        "依赖强度": "强"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL044",
      "source": "04DS008",
      "target": "04DS006",
      "attributes": {
        "父类 ID": "04DS006",
        "子类 ID": "04DS008",
        "约束条件": "使用链式存储实现"
      }
    },
    {
      "type": "使用",
      "关系ID": "04REL045",
      "source": "04DS008",
      "target": "04DS005",
      "attributes": {
        "使用方ID": "04DS008",
        "被使用的数据结构 ID": "04DS005",
        "使用角色": "核心存储机制 (带头尾指针)"
      }
    },
    {
      "type": "变体",
      "关系ID": "04REL046",
      "source": "04DS009",
      "target": "04DS006",
      "attributes": {
        "基础 ID": "04DS006",
        "变体 ID": "04DS009",
        "变体类型": "增加优先级约束"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL047",
      "source": "04DS001",
      "target": "04DS010",
      "attributes": {
        "父类 ID": "04DS010",
        "子类 ID": "04DS001",
        "约束条件": "运算受限（仅一端）"
      }
    },
    {
      "type": "继承",
      "关系ID": "04REL048",
      "source": "04DS006",
      "target": "04DS010",
      "attributes": {
        "父类 ID": "04DS010",
        "子类 ID": "04DS006",
        "约束条件": "运算受限（头删尾插）"
      }
    }
  ]
}
设数组 a 中含有$n$个元素，简单选择排序的方法是：需要依次进行$n-1$次循环，每次把 a 中$n$个元素看为一个有序表和一个无序表，第 1 次有序表为空，无序表含有全部$n$个元素，从无序表中顺序查找出一个最小值，把它与此表中第一个元素 a[0]交换其值，经此次后 a[0]成为最小值元素；接着进行第二次循环处理时，有序表中有一个元素 a[0]，无序表中有$n-1$个元素 a[1]~a[n-1]，第 2 次从当前无序表中查找一个最小值元素，把它与此表中第 1 个元素 a[1]交换其值，经此次后 a[1]成为此表的最小值元素，当然它小于等于 a[0]；然后进入第 3 次循环处理时，有序表中有两个元素 a[0]~a[1]，无序表中有$n-2$个元素 a[2]~a[n-1]，以此类推，进行$n-1$次循环处理时，有序表中已有$n-2$个元素 a[0]~a[n-3]，无序表中只有两个元素 a[n-2]~a[n-1]，从这两个元素中查找到最小值并交换到 a[n-2]位置后，整个数组中的元素就按值的升序排列好了。此排序方法与简单插入排序方法具有相同的时间复杂度，即为$O(n^2)$。

采用简单选择排序方法进行有序输出集合元素的算法如下。

void OutputSet1(Set& S)

{
    int i,j,k;
    ElemType *a=new ElemType[S.len]; //定义临时数组 a
    for(i=0;i<S.len; i++)
        a[i]=S.set[i]; //把集合元素赋给数组 a
    for(i=0; i<S.len-1; i++) {
        k=i; //k 暂存本次最小值元素的下标
        for(j=i+1; j<S.len; j++)
            if(a[j]<a[k]) k=j; //顺序查找找出本次最小值元素 a[k]
        ElemType x=a[i]; a[i]=a[k]; a[k]=x; //a[k]同 a[i]交换其值
        cout<<a[i]<<' ';
    }
    cout<<endl;
    delete []a;
}

7. 从集合中查找一个元素

此算法首先从集合中顺序查找值等于待查值 item 的元素，若存在则把该元素值赋给 item 引用参数带回，并返回真表示查找成功；若不存在，则返回假表示查找失败。

通常传递给 item 的待查值是一个元素的关键字，不是完整的记录。如对于学生记录，待查值是学号，对于产品记录，待查值是产品号。若查询到对应值的元素，则需要把该元素的完整值赋给 item 带回，以便使用。如可以通过 item 得到某个学生的成绩，某个产品的价格等。

bool FindSet(Set& S, ElemType& item) //从集合中查找一个元素
{
    for(int i=0; i<S.len; i++)
        if(S.set[i]==item) break;
    if(i<S.len) {

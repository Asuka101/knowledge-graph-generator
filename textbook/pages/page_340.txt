(2) 平方探查法。

平方探查法的探查序列为$d$,$d+1^2$,$d+2^2$,$\cdots$, 或表示为$(d+i^2)\%m$($0 \leq i \leq m-1$)。若使用递推公式表示，则为：$\left\{
\begin{array}{l}
d_0 = h(K) \\
d_i = (d_{i-1} + 2i - 1) \% m \quad (1 \leq i \leq m-1)
\end{array}
\right.$//因为$d+i^2$可分解为$d+(d-1)^2+2i-1$平方探查法是一种较好的处理冲突的方法，它能够较好地避免堆积现象。它的缺点是不能探查到散列表上的所有单元，但至少能探查到一半单元（证明从略）。例如，当$d_0=5$,$m=17$时，则至少能探查到下标依次为 5,6,9,14,4,13,7,3,1 的单元。不过在实际应用中，能探查到一半单元也就可以了，若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。

(3) 双散列函数探查法。

这种方法使用两个散列函数$h1$和$h2$，其中$h1$和前面的$h(K)$一样，以关键字为自变量，产生一个$0 \sim m-1$之间的数作为散列地址；$h2$也以关键字为自变量，产生一个$1 \sim m-1$之间的、并和$m$互素的数（即$m$不能被该数整除）作为探查序列的地址增量（即步长）。双散列函数的探查序列为：$\left\{
\begin{array}{l}
d_0 = h1(K) \\
d_i = (d_{i-1} + h2(K)) \% m \quad (1 \leq i \leq m-1)
\end{array}
\right.$由以上可知，对于线性探查法，探查序列的步长值是固定值 1；对于平方探查法，探查序列的步长值是探查次数$i$的两倍减 1；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。

2. 链接法

链接法就是把发生冲突的同义词元素（结点）用单链表链接起来的方法。在这种方法中，散列表中的每个单元（即下标位置）不是存储相应的元素，而是存储相应单链表的表头指针，单链表中的每个结点由动态分配产生，同时由于每个元素被存储在相应的单链表中，在单链表中可以任意的插入和删除结点，所以填充因子$\alpha$既可以小于等于 1，也可以大于 1。

当向采用链接法解决冲突的散列表中插入一个关键字为$K$的元素时，首先根据关键字$K$计算出散列地址$d$，接着把由该元素生成的动态结点插入到下标为$d$的单链表的表头（可插入到单链表中的任何位置，但插入表头最方便）。查找过程也与插入类似，首先计算出散列地址$d$，然后从下标为$d$的单链表中顺序查找关键字为$K$的元素，若查找成功则返回该元素的存储地址，若查找失败则返回空指针。

【例 9-3】一个数据表$B$为：$B=(18,75,60,43,54,90,46,31,58,73,15,34)$为了进行散列存储，假定采用的散列函数为：$h(K)=K\%13$当发生冲突时，若采用链接法处理，则得到的散列表，如图 9-5 所示。

用链接法处理冲突，虽然比开放定址法多占用一些存储空间用做链接指针，但它可以减少在插入和查找过程中同关键字平均比较的次数（即平均查找长度）。这是因为，在链接法中待比较的结点都是同义词结点，而在开放定址法中，待比较的结点不仅包含有同义

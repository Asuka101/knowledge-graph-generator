则元素的比较次数为$i+1$次, 元素的移动次数为$n-i-1$次 ($n$为线性表的长度 L.size), 两者相加为$n$次。也就是说, 当进行按值删除时, 不管删除什么位置上的元素, 进行元素比较和移动的总次数不变, 均为$n$, 当进行按位置删除元素时, 只需要考虑移动元素的次数, 在删除所有位置上元素概率相等情况下, 平均移动次数为$\frac{1}{n} \sum_{i=0}^{n-1}(n-i-1)=\frac{n-1}{2}$, 所以此算法的时间复杂度为$O(n)$。特殊地, 当规定删除表尾元素时, 其时间复杂度为$O(1)$。

11. 对线性表进行排序

对线性表进行排序就是按照元素的值或某个域的值的升序 (或降序) 排列元素, 使之成为一个有序表。对顺序存储的线性表 (数组) 进行排序的方法很多, 本小节只介绍一种简单的插入排序方法, 其他方法将在第 10 章中专门讨论。

插入排序的方法是: 把线性表 list[0]~list[n-1]中共$n$个元素看作一个有序表和一个无序表, 开始时有序表中只有一个元素 list[0] (一个元素总是认为是有序的), 无序表中含有$n-1$个元素 list[1]~list[n-1], 以后每次从无序表中取出第 1 个元素, 把它插入到前面有序表中的合适位置, 使之成为一个新的有序表, 这样有序表就增加了一个元素, 无序表就减少了一个元素, 经过$n-1$次后, 有序表中含有$n$个元素, 无序表变为一个空表, 整个线性表就成为了一个有序表。

如何在第$i$次$(1 \leq i \leq n-1)$把无序表中的第 1 个元素 list[i]插入到前面有序表 list[0]~list[i-1]中呢? 一种方法是: 从有序表表尾元素 list[i-1]开始, 依次向前使每一个元素 list[j]$(0 \leq j < i-1)$同 x (用来临时保存 list[i]的值) 进行比较, 若 x<list[j], 则把 list[j]后移一个位置, 直到 x>=list[j]或 j<0 为止, 此时已空出的下标为$i+1$的位置就是 x 的插入位置, 把 x 的值插入到 list[j+1]即可。

假定一个线性表为(42,65,80,74,28,44,36,65), 则插入排序的过程, 如图 2-3 所示, 其中中括号内表示每次排序后得到的有序表, 中括号后面为待排序的无序表。$\begin{array}{lllllllll}0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ \hline 42 & 65 & 80 & 74 & 28 & 44 & 36 & 65\end{array}$(1) [42 65] 80 74 28 44 36 65

(2) [42 65 80] 74 28 44 36 65

(3) [42 65 74 80] 28 44 36 65

(4) [28 42 65 74 80] 44 36 65

(5) [28 42 44 65 74 80] 36 65

(6) [28 36 42 44 65 74 80] 65

(7) [28 36 42 44 65 65 74 80]

图 2-3 线性表插入排序过程

用 C++语言描述插入排序算法如下。

void SortList(List &L) //对L中的所有元素重新按给定条件排序
{
    int i, j;

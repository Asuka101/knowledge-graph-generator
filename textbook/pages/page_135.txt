pot[1]=1;
for(col=2; col<=n; col++)
    pot[col]=pot[col-1]+num[col-1];
//对M.sm进行第2遍扫描,把每个元素行、列值互换写入到S.sm的确定位置
for(i=1; i<=t; i++) {
    int j=M.sm[i].col;                      //取待转换元素的列号
    int k=pot[j];                           //取待转换元素在S.sm中的位置
    S.sm[k].row=j;                          //以下3行存储被转换的元素
    S.sm[k].col=M.sm[i].row;
    S.sm[k].val=M.sm[i].val;
    pot[j]++;                               //使pot[j]指向下—个位置
}
//删除动态分配的数组
delete[] num;
delete[] pot;
//返回转置矩阵S
return S;
}

此算法的运行时间主要取决于4个for单重循环，故时间复杂度为$O(n+t)$，显然它比第一种转置算法的时间复杂度要好得多。当稀疏矩阵接近一般矩阵时，其时间复杂度变为$O(m\times n)$，与采用二维数组表示时相同。当然进行每一个元素转换的运算步骤要比使用二维数组时的直接赋值（即b[i][j]=a[j][i]）操作要复杂一些。

\section*{5. 稀疏矩阵的加法运算}

假定采用带行指针向量的存储结构进行稀疏矩阵的加法运算，设M1和M2为两个加数矩阵，M为和矩阵，即结果矩阵。两矩阵相加的前提条件是：两矩阵的大小相同，即行数和列数分别对应相等。两矩阵相加的结果仍为一个具有相同大小的矩阵，结果矩阵M中每个行单链表仍然要按列号有序，它是对M1和M2中对应行单链表的按列号有序的合并结果。当M1和M2中对应行单链表的两个结点分别具有相同的行号和列号时，若它们的元素值之和为0，则不在结果矩阵中建立结点，只有当其和不为0或者列号不同时，才需要在结果矩阵中建立结点。具体算法描述如下。

LMATRIX Add(LMATRIX& M1, LMATRIX& M2)
{
    LMATRIX M;  //暂存运算结果，以便返回
    InitMatrix(M);
//若两个矩阵尺寸不同，则给出错误信息并停止运行
    if((M1.m!=M2.m) || (M1.n!=M2.n)) {
        cerr<<"two matrix measurements are different!"<<endl;
        exit(1);
    }
//把其中一个加数矩阵的尺寸赋给结果矩阵
    M.m=M1.m; M.n=M1.n;

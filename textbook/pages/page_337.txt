的浪费。

2. 除留余数法

除留余数法是用关键字$K$除以散列表长度$m$所得余数作为散列地址的方法。对应的散列函数$h(K)$为:$h(K) = K \% m$这种方法在上面的例子中已经使用过。除留余数法计算较简单，适用范围广，是一种最常使用的方法。这种方法的关键是选好$m$，使得每一个关键字通过该函数转换后映射到散列空间上任一地址的概率都相等，从而尽可能减少发生冲突的可能性。例如，取$m$为奇数，比取$m$为偶数要好，因为当$m$为偶数时，它总是把关键字为偶数的元素散列到偶数单元中，把关键字为奇数的元素散列到奇数单元中，即把一个元素只散列到一半的存储空间中；当$m$为奇数时就不会出现这种问题，它能够把一个元素散列到整个存储空间中。结合处理冲突时对$m$的要求，最好取散列表的长度$m$为一个素数（即除1和本身之外，不能被任何数整除的数）。当然，要确保$m$的值大于等于待散列的数据表的长度$n$。根据装填因子$\alpha$最好为在$0.6 \sim 0.9$之间，所以$m$应取$1.1n \sim 1.7n$之间的一个素数为好。若$n=100$，则$m$最好取$113、127、139、143$等素数。

另外，当关键字$K$为一个字符串时，需要把它设法转换为一个整数，然后再用这个整数整除以$m$得到余数，即散列地址。下面的 Hash($K, m$) 函数就能够求出关键字$K$为字符串时的散列地址。其中，采用的把字符串$K$转换为整数的过程是：首先求出$K$的长度，即所含的字符个数，接着把每个字符的 ASCII 码（即该字符的整数值）累加到无符号整型量$h$上，并在每次累加之前把$h$的值左移 3 个二进制位，即扩大 8 倍。

```
int Hash(char *K,int m)
    //把字符串 K 转换为 0~m-1 之间的一个值作为对应记录的散列地址
{
    int len=strlen(K);                //求出字符串 K 的长度
    unsigned int h=0;                 //给累计变量 h 赋初值 0
    for(int i=0; i<len; i++) {        //采用一种方法计算 K 所对应的整数
        h<<=3;                        //h 的值左移 3 位
        h+=K[i];                      //把 K[i] 字符的整数值累加到 h 上
    }
    return h%m;                       //返回这个整数整除以 m 的余数
}
```

例如，一个记录的关键字$K$为 ab1，则调用上述函数时最后计算得到的$h$值为：$h = 97 \times 2^6 + 98 \times 2^3 + 49 = 7041$若$m$为 127，则返回的散列地址为 56。

3. 数字分析法

数字分析法是取关键字中某些取值较分散的数位作为散列地址的方法。它适合于所有关键字已知，并对关键字中每一位的取值分布情况作出了分析。例如，有一组关键字为

第1章绪论
数据结构是计算机科学与技术、软件开发与应用、网络安全、信息管理、电子商务等相关专业的一门专业基础课程，它专门研究从解决现实问题中抽象出来的数据如何在计算机系统中很好地表示、存取和处理的方法。这里所说的数居是广义的，它不仅包括数值数据、字符数据、逻辑数据等简单数据，而且还包括带有一定结构的各种复杂数据，如字符串、记录、向量、矩阵、表格、图形、音频、视频等数据。
用计算机存储数据不仅要存储数据的值，而且要存储数据之间的相互联系。如何存储它们之间的联系将出现各种不同的存储方法，总体上有顺序、链接、索引、散列等4种。
对数据进行处理的方法是根据数据处理的要求和目标而决定的，现在人们已经总结出了比较常用和有效的、解决相应问题的各种数据处理方法。掌握这些方法是进行各种软件开发和设计的基础。有了正确和有效的数据处理方法，还需要转换为在计算机上能够依次执行的一系列步骤，才能够得到运行结果，达到目标。为此，必须事先掌握一种计算机语言，如C或C++语言，用它来对数据处理方法和过程加以描述，即编写出程序代码，从而在计算机上调试和运行，实现设计要求。
section1.1常用术语
这一节，将对本教材中使用的一些常用术语给予大致的定义和说明。
数据(data)是人们利用便于书写、记忆和交流的符号对现实世界的事物及其活动所做的记录。如一个数值、一个单词、一句话、一篇文章、一幅图画等都被称为数据。当然，若要利用计算机存储、处理和加工数据，则必须按照一定规则对其进行二进制信息编码，变为二进制形式的数据。
数据元素(dataelement)简称元素，它是一个数据整体中相对独立的单位。如对于一个二维表格数据来说，每行信息就是它的数据元素；对于一个字符串数据来说，每个字符就是它的数据元素；对于一维数组数据来说，每个下标位置所存储的值就是它的数据元素。数据和数据元素是相对而言的。如对于一条记录信息来说，它是所属文件的一个数据元素，而它相对于所含的数据项而言又可看成数据。因此，在本书中，对数据和数据元素这两个术语的使用并不加以严格区别。
数据记录(datarecord)简称记录，它是数据处理领域组织数据的基本单位，数据中的每个数据元素在许多应用场合都被组织成记录的结构。一个数据记录由一个或多个数据项(item)所组成，每个数据项可以是简单数据项，即不可再分，如一个数值、字符等；也可以是组合数据项，如一个字符串、数组、记录、对象等。如表1-1所示的人事管理数据文件，每个记录表示一个职工的有关信息，它由职工号、姓名、性别、出生年月、本单位工
龄、学历、职级等7个数据项所组成。表中的第1行为表头行或目录行，它给出了该表中每条记录的结构。从表头行向下的每一行为一条记录，它给出了每个职工的具体信息。
表1-1人事管理数据文件
|职工号|姓名|性别|出生年月|本单位工龄|学历|职级|
|--------|------|------|----------|------------|------|------|
|11001|张金雨|男|1965/05|20|大专|正科|
|11002|刘洪水|男|1952/07|15|本科|正处|
|11003|赵书琴|女|1973/12|12|研究生|副处|
|12001|尚明|男|1958/03|25|本科|副处|
|12002|沈芬|女|1964/06|20|中专|科员|
|13001|刘江河|男|1982/07|3|本科|科员|
|14001|胡丽|女|1977/10|4|研究生|副科|
在一个表或文件中，若所有记录的某个数据项的对应值均不同，则每个值就能够唯一地标识一个记录，把这个数据项称为表或文件的关键数据项，简称关键项（keyitem），把关键项中的每个值称为所在记录的关键字（keyword或key）。在表1-1中，职工号数据项的值均不同，所以可把职工号作为关键项，该项中的每个值就是所在记录的关键字，如11001就是第1条职工记录的关键字，12002就是第5条记录的关键字。
在一个表或文件中，能作为关键项的数据项可能没有，可能只有一个，也可能多于一个。当没有时，可把多个有关的数据项联合起来，构成一个组合关键项，用组合关键项中的每一个组合值来唯一地标识一个记录，该组合值就是所在记录的关键字。
引入了关键项和关键字后，在以后的讨论中，经常利用关键项中的所有值来代替所有记录，利用每个关键字来代表所在的记录，而忽略其他非关键数据项。如表1-1中的数据可以简记为(11001,11002,11003,12001,12002,13001,14001)，第2条记录可以简记为11002。
数据处理(dataprocessing)是指利用计算机对数据进行存储、检索、插入、删除、合并、拆分、排序、统计、计算、转换、输入、输出等的处理过程。学习程序设计语言和数据结构知识是进行计算机数据处理及各种应用开发的软件基础。
数据结构(datastructure)是指数据以及相互之间的联系。它是根据人们解决实际问题的需要从问题本身所含数据之间的内在联系而抽象出来的。这种数据结构与如何利用计算机存储和处理无关，所以被称为数据的逻辑结构。数据的逻辑结构包括集合、线、树、图等基本结构，由它们的组合和嵌套可以形成较复杂的结构。一种数据结构必须被存储到计算机的存储器中才能够利用计算机处理。存储数据结构有各种不同的方法，大体上有顺序、链接、索引、散列等基本方法，由它们不同的组合和嵌套可以形成各种更为复杂的方法。每种存储方法都使数据在存储器中表现出相应的结构，称此为数据的存储结构或物理结构。数据的存储结构与其存储方法相对应，同样被分为顺序、链接、索引、散列等基本形式。一种数据的逻辑结构可以根据处理问题的需要选用任一种甚至几种存储结构进行存储。数据的逻辑结构和存储结构分别在现实世界层面和计算机世界层面上反映了数据的结构，有时统称它们为数据结构，但一般所说的数据结构是指数据的逻辑结构，不包含存储结构的含义。
为了更确切地描述一种数据结构，通常采用二元组表示：
B=(K,R)B代表一种数据结构，它由数据元素的集合K和K上二元关系的集合R所组成。其中K=leftk_imid1leqslantileqslantn,n>0rightR=leftr_jmid1leqslantjleqslantm,m>0right其中，k_i表示集合K中的第i个数据元素，n为K中数据元素的个数，特殊情况下，若n=0，则K是一个空集，此时B无结构，也可以说它具有任何结构；r_j表示集合R中的第j个二元关系（以后均简称关系），m为R中关系的个数，特殊情况下，若m=0，则R是一个空集，表明不考虑集合K中的元素之间存在着任何关系，彼此是独立的，就像数学中集合里的元素一样。在本书所讨论的数据结构中，一般只讨论m=1的情况，即R中只包含一个关系(R=leftr_1right)的情况。对于包含有多个关系的数据结构，可分别对每一个关系进行讨论。K上的一个关系r（以后直接用大写R表示）是序偶的集合。对于R中的任一序偶langlex,yrangle(x,yinK)，把x叫做序偶的第一元素，把y叫做序偶的第二元素，又称序偶的第一元素为第二元素的直接前驱（简称前驱），称第二元素为第一元素的直接后继（简称后继）。如在langlex,yrangle的序偶中，x为y的前驱，而y为x的后继。
一种数据结构还能够利用图形形象地表示出来，图形中的每个结点（又叫顶点）对应着一个数据元素，两结点之间带箭头的连线（又称为有向边或弧）对应着关系中的一个序偶，其中序偶的第一元素为有向边的起始结点，第二元素为有向边的终止结点，即箭头所指向的结点。
根据某公司人事简表，构造出一些典型的数据结构，如表1-2所示。
表1-2某公司人事简表
|职工号|姓名|性别|出生日期|职务|部门|
|---|---|---|---|---|---|
|01|万明华|男|1962-03-20|经理||
|02|赵宁|男|1968-06-14|主管|销售部|
|03|张利|女|1964-12-07|主管|财务部|
|04|赵书芳|女|1972-08-05|主任|办公室|
|05|刘永年|男|1959-08-15|科员|销售部|
|06|王明理|女|1975-04-01|科员|销售部|
|07|王敏|女|1972-06-28|科员|财务部|
|08|张才|男|1967-03-17|科员|财务部|
|09|马立仁|男|1975-10-12|科员|财务部|
|10|邢怀常|男|1976-07-05|科员|办公室|
表1-2中共有10条记录，每条记录都由6个数据项所组成，由于每条记录的职工号各不相同，所以可把每条记录的职工号作为该记录的关键字，并在下面的例子中，用记录的关键字来代表整个记录。
【例1-1】一种数据结构set=(K,R)，其中K=01,02,03,04,05,06,07,08,09,10R=在数据结构set中，只存在元素的集合，不存在关系的集合，或者说关系为空，这表
明只考虑表1-2中的每条记录，而不考虑它们之间的任何联系。具有这种特点的数据结构被称为集合结构，简称集合。对于集合结构，也可以看作按元素任意一种次序（如先后位置有序）排列的线性结构，在存储空间中可以根据需要按任一种存储方法进行存储。
【例1-2】一种数据结构linearity=(K,R)，其中K=01,02,03,04,05,06,07,08,09,10；R=langle05,01rangle,langle01,03rangle,langle03,08rangle,langle08,02rangle,langle02,07rangle,langle07,04rangle,langle04,06rangle,langle06,09rangle,langle09,10rangle对应的图形如图1-1所示。
![图1-1数据的线性结构示意图]
结合表1-2，可以看出：R是按职工年龄从大到小排列的关系。
在linearity中，每个数据元素有且仅有一个直接前驱元素（除结构中第1个元素05外），有且仅有一个直接后继元素（除结构中最后一个元素10外）。这种数据结构的特点是数据元素之间的1对1（1:1）联系，即线性关系。将具有这种特点的数据结构叫做线性结构，简称线。
【例1-3】一种数据结构tree=(K,R)，其中K=01,02,03,04,05,06,07,08,09,10；R=langle01,02rangle,langle01,03rangle,langle01,04rangle,langle02,05rangle,langle02,06rangle,langle03,07rangle,langle03,08rangle,langle03,09rangle,langle04,10rangle对应的图形如图1-2所示。
![图1-2数据的树形结构示意图]
结合表1-2可以看出：R是人员之间领导与被领导的关系。
图1-2像倒着画的一棵树，最上面的一个没有前驱只有后继的结点叫做树根结点，最下面一层的只有前驱没有后继的结点叫做树叶结点，除树根和树叶之外的结点叫做树枝结点（实际上，树根结点是一种特殊的树枝结点）。在一棵树中，每个结点有且只有一个前驱结点（除树根结点外），但可以有任意多个后继结点（树叶结点可看做具有0个后继结点）。这种数据结构的特点是数据元素之间的1对N（1:N）联系（Ngeq0），即层次关系。将具有这种特点的数据结构叫做树形结构，简称树。
【例1-4】一种数据结构graph=(K,R)，其中K=01,02,03,04,05,06,07；R=langle01,02rangle,langle02,01rangle,langle01,04rangle,langle04,01rangle,langle02,03rangle,langle03,02rangle,langle02,06rangle,langle06,02rangle,
<02,07>,<07,02>,<03,07>,<07,03>,<04,06>,<06,04>,<05,07>,<07,05>对应的图形如图1-3所示。
从图1-3可以看出，R是K上的对称关系，即若存在langlex,yrangle，则必存在langley,xrangle与之对应。为了简化起见，把langlex,yrangle和langley,xrangle这两个对称序偶用一个无序对(x,y)或(y,x)来代替；在图形表示中，把x结点和y结点之间两条相反的有向边用一条无向边来代替。这样R关系可改写为：R=(01,02),(01,04),(02,03),(02,06),(02,07),(03,07),(04,06),(05,07)对应的图形如图1-4所示。
如果说R中每个序偶里的两个元素所代表的人员是好友的话，那么r关系就是人员之间的友好关系。
从图1-3或图1-4可以看出，结点之间的联系是M对N（Mgeqslant0,Ngeqslant0）联系，即网状关系。也就是说，每个结点可以有任意多个前驱结点和任意多个后继结点。将具有这种特点的数据结构叫做图形结构，简称图。
从图形结构、树形结构和线性结构的定义可知，树形结构是图形结构的特殊情况（即M=1的情况），线性结构是树形结构的特殊情况（即N=1的情况）。为了区别于线性结构，将树形结构和图形结构统称为非线性结构。
【例1-5】一种数据结构B=(K,R)，其中K=k_1,k_2,k_3,k_4,k_5,k_6R=r_1,r_2r_1=langlek_3,k_2rangle,langlek_3,k_5rangle,langlek_2,k_1rangle,langlek_5,k_4rangle,langlek_5,k_6rangler_2=langlek_1,k_2rangle,langlek_2,k_3rangle,langlek_3,k_4rangle,langlek_4,k_5rangle,langlek_5,k_6rangle若用实线表示关系r_1，虚线表示关系r_2，则对应的图形如图1-5所示。
从图1-5可以看出：数据结构B是一种非线性的图形结构。但是，若只考虑关系r_1则为树形结构，若只考虑关系r_2则为线性结构。
数据类型(datatype)是对数据的取值范围、数据元素之间的结构以及允许施加操作的一种总体描述。每一种计算机设计语言都定义有自己的数据类型，一般有整数、实数（浮点数）、枚举、字符、字符串、指针、数组、记录、类、文件等数据类型。如整数类型在计算机系统中通常用两个字节或4个字节表示，若采用两个字节，则整数表示范围在-2^15sim2^15-1，即-32768~32767之间；若采用4个字节，则整数表示范围在-2^31sim2^31-1，即-2147483648~2147483647之间。对整数类型的数据允许施加的操作（运算）通常有：单目取正或取负运算，双目加、减、乘、除、取模等运算双目等于、不等于、大于、大于等于、小于、小于等于等关系（比较）运算以及赋值运算等。字符类型在计算机中通常用一个字节或两个字节表示，无符号表示范围分别在0~255或0~32767之间，能够分别至多对256或32768种字符进行编码。对字符类型的数据允许进行的操作主要为赋值和各种关系运算。字符串类型是字符顺序排列的线性结构，每一个具体的字符串（其最大长度由具体语言规定）都是字符串类型中的一个值，对字符串的操作主要有求串长度、串复制、两串连接和两串比较等。
数据类型可分为简单类型和结构类型两大类。任一种简单类型中的每个数据都是无法再分割的整体，如一个整数、实数、字符、指针、枚举值、逻辑值等都是无法再分割的整体。任一种结构类型都是由简单类型数据按照一定的规则构造而成的，并且结构类型仍可以包含结构类型，所以一种结构类型中的数据（即结构数据）可以分解为若干个简单数据或结构数据，每个结构数据仍可再分。如数组就是一种结构类型，它由固定个数的同一元素类型的数据按线性结构排列而成，数组类型中的每一个数组值包含有固定个数的同一类型数据，每个数据（元素）都可以通过下标运算符直接访问。记录也是一种结构类型，它由固定个数的不同（也可以相同）类型的数组据线性结构排列而成，记录型中的每一个记录值包含有固定个数的不同类型数据，每个数据（域）都可以通过成员运算符直接访问。
无论是简单类型还是结构类型都有“型”和“值”的概念，一种数据类型中的任一数据称为该类型中的一个值（又称为实例），该值（实例）与所属数据类型具有完全相同的结构，数据类型所规定的操作就是在值上进行的。所以在一般的叙述中，并不明确指出是“型”还是“值”，应根据实际情况加以理解，如提到记录时，当讨论的是记录结构则认为是记录型，当讨论的是具体一条记录则认为是记录值。
抽象数据类型（AbstractDataType,ADT）由一种数据结构和在其上的所有操作（运算）所组成。抽象数据类型包含有一般数据类型的含义，但含义比一般数据类型更广、更抽象。一般数据类型通常由具体语言系统内部定义，直接提供给编程者定义数据并进行相应的运算，因此称它们为系统预定义数据类型。抽象数据类型通常由编程者根据已有数据类型定义，包括定义其所含数据（数据结构）和在这些数据上所进行的操作。在定义抽象数据类型时，就是定义其数据的逻辑结构和操作说明，不考虑数据的存储结构和操作的具体实现（即具体操作代码），使得抽象数据类型具有很好的通用性和可移植性，便于用任何一种语言，特别是面向对象的语言实现。
抽象数据类型在C++语言中是通过“类”类型来实现的，其数据部分通常定义为类的私有（private）或保护（protected）的数据成员，它只允许给该类或派生类直接使用，操作
部分通常定义为类的公共(public)的成员函数,它既可以提供给该类或派生类使用也可以提供给其他的类或函数使用,操作部分只给出操作说明(即函数声明),操作的具体实现通常在一个单独文件中给出,使它与类的定义(即声明)相分离,当然在编译时将被连接在一起,类的声明通常被存放在一个专门的头文件(其扩展名为.h)中,这样能够较好地实现信息的隐藏和封装,符合面向对象程序设计(Object-OrientedProgramming,OOP)的思想。
在本书中,为了更好地理解数据结构和相应运算的实现(即函数编程代码),采用传统的记录结构类型来定义抽象数据类型中的数据(或称数据结构)部分,采用普通函数格式来定义抽象数据类型中的每个操作的实现。虽然本书通常没有直接采用“类”类型来实现抽象数据类型,但读者通过学习后很容易做到,并且在相配套的实验教材《数据结构课程实验》中,给出了用类类型实现的程序,有兴趣的读者可以参考。
在本书中,描述每一种抽象数据类型将采用如下格式。
ADT<抽象数据类型名>is
Data:<数据描述>Operations:<操作声明>end<抽象数据类型名>【例1-6】把矩形定义及其运算设计成一种抽象数据类型,其数据部分包括矩形的长度和宽度,操作部分包括初始化矩形的尺寸、求矩形的周长和面积。
假定该抽象数据类型名用RECTangle(矩形)表示,定义矩形长度和宽度的数据用length和width表示,并假定其类型为单精度浮点型(float),初始化矩形数据的函数名用InitRectangle表示,求矩形周长的函数名用Circumference(周长)表示,求矩形面积的函数名用Area(面积)表示,则矩形的ADT描述如下。
ADTRECTangleis
Data:
floatlength,width;
Operations:
voidInitRectangle(structRectangle&r,floatlen,floatwid);
floatCircumference(structRectangle&r);
floatArea(structRectangle&r);
endRECTangle
其中参数mathrmr的类型名structRectangle表示一个用户定义的记录(结构)类型,其保留字struct在C语言中必须使用,而在C++语言中则可被省略不写。该类型包括矩形的长度和宽度两个域,用来统一描述此抽象数据类型所含的数据部分,用C/C++语言定义如下。
structRectangle
floatlength,width;
;
初始化矩形数据的函数定义如下。
voidInitRectangle(structRectangle&r,floatlen,floatwid)
r.length=len;/把len值赋给r的length域/
r.width=wid;/把wid值赋给r的width域/
该函数把两个值参数len和wid的值分别赋给引用参数r的length域和width域，实现对一个矩形r的初始化。求矩形周长和求矩形面积的函数分别定义如下。
floatCircumference(structRectangle&r)
return2(r.length+r.width);
floatArea(structRectangle&r)
returnr.lengthr.width;
这两个函数分别具有一个矩形引用参数（也可采用值参），调用执行后分别计算并返回被引用矩形的周长和面积。
在函数参数中，有引用参数和值参数之分，若在参数类型和参数名之间使用&符号，则就定义该参数为引用参数，否则为值参数。对于引用参数，函数被调用时，它被看成对应的调用参数（即实参）的别名，函数中访问它就是访问对应的实参；对于值参数，当函数被调用时，将为它分配存储空间，并用对应实参的值初始化，在函数体中对值参数的访问与对应的实参无关，当函数调用结束后将自动释放掉为值参数所分配的存储空间。在C语言中不能使用引用参数，它是在C++语言中增加的。通过在C语言中使用指针参数可以实现引用的功能。如可将上面求矩形面积的函数修改如下。
floatArea(structRectangler)
returnr->lengthr->width;
若采用C++类来描述抽象数据类型RECTangle，则如下所示。
classRECTangle
private:
floatlength,width;
public:
RECTangle(floatlen,floatwid)
length=len;width=wid;
floatCircumference(void)
return2(length+width);
floatArea(void)
returnlengthwidth;
;
用C++语言编写出完整的程序如下。
/程序1-1.cpp/
include<iostream.h>/在C语言中用include<stdio.h>代替/
structRectangle
floatlength,width;
;
voidInitRectangle(Rectangle&r,floatlen,floatwid);/函数声明/
floatCircumference(Rectangle&r);/函数声明/
floatArea(Rectangle&r);/函数声明/
voidmain(void)
floatx,y;//用于从键盘上输入一个矩形的长和宽
floatp,s;//用于保存矩形的周长和面积
Rectanglea;//定义一个矩形变量
cout<<"请输入一个矩形的长和宽!"<<endl;//输出提示信息
cin>>x>>y;//输入矩形的长和宽
InitRectangle(a,x,y);//对矩形a进行初始化
p=Circumference(a);//计算矩形a的周长
s=Area(a);//计算矩形a的面积
cout<<endl;
cout<<"矩形的周长为:"<p<<endl;//输出矩形周长
cout<<"矩形的面积为:"<s<<endl;//输出矩形面积
voidInitRectangle(Rectangle&r,floatlen,floatwid)
r.length=len;
r.width=wid;
floatCircumference(Rectangle&r)
return2(r.length+r.width);
floatArea(Rectangle&r)
returnr.lengthr.width;
在C语言中只能使用一种注释形式“/……/”，而在C++语言中若注释在行尾或者单独占据一行，则还可用双斜线“//”引出注释。
C++语言能够兼容C语言，也就是说，用C语言书写的程序可以原封不动地在C++语
言环境下运行，而C++语言对C语言做了许多改进和增强，如在输入、输出、参数定义、函数重载、运算符重载、模板、类等方面，所以用C++语言编写的程序不能在C语言环境下运行。
对于上面的程序，若要在C语言环境下运行，除了修改输入、输出等语句外，还要把引用参数修改为指针参数，把对应的实参修改为取地址的表达式，以及把结构类型加上struct保留字。改写后得到的C语言程序如下。
include<stdio.h>
structRectangle
floatlength,width;
;
voidInitRectangle(structRectangler,floatlen,floatwid);
floatCircumference(structRectangler);
floatArea(structRectangler);
voidmain()
floatx,y;
floatp,s;
structRectanglea;
printf("请输入一个矩形的长和宽!");
scanf("%f%f",&x,&y);
InitRectangle(&a,x,y);
p=Circumference(&a);
s=Area(&a);
printf("n");
printf("矩形的周长为:%fn",p);
printf("矩形的面积为:%fn",s);
voidInitRectangle(structRectangler,floatlen,floatwid)
r->length=len;
r->width=wid;
floatCircumference(structRectangler)
return2(r->length+r->width);
floatArea(structRectangler)
returnr->lengthr->width;
以后为简便起见，一般使用C++语言进行算法描述，若读者只会使用C语言，则掌握上面所述差别后，不难把每个算法转换为相应的C语言算法。
数据对象(dataobject)简称对象，它属于一种数据类型中的特定实例，该数据类型既可以是一般数据类型，也可以是抽象数据类型。如25为一个整型数据对象，'A'为一个字符数数据对象，语句charp定义p为一个字符指针对象，可以用来指向一个字符串，inta[10]定义a为一个含有10个整型数的数组对象，structRectangler1定义r1为一个Rectangle结构类型的对象，RECTanglerec定义rec为一个具有RECTangle抽象数据类型的对象。
算法(algorithm)就是解决特定问题的方法。描述一个算法可以采用文字叙述，也可以采用传统流程图、N-S图或PAD图等，但要在计算机上实现，则最终必须采用一种程序设计语言编写为程序。作为一个算法应具备如下5个特性。
(1)有穷性。一个算法必须在执行有穷步之后结束。
(2)确定性。算法中的每一步都必须具有确切的含义，无二义性。
(3)可行性。算法中的每一步都必须是可行的，也就是说，每一步都能够通过手工或机器可以接受的有限次操作在有限时间内实现。
(4)输入。一个算法可以有0个、1个或多个输入量，在算法被执行之前提供给算法。
(5)输出。一个算法执行结束后至少要有一个输出量，它是利用算法对输入量进行运算和处理的结果。
需要人们解决的特定问题可分为数值的和非数值的两类。解决数值问题的算法叫做数值算法，科学和工程计算方面的算法大都属于数值算法，如求解数值积分、求解线性方程组、求解代数方程和求解微分方程等。解决非数值问题的算法叫做非数值算法，数据处理方面的算法大都属于非数值算法，如在各种数据结构上进行的排序算法、查找算法、插入算法、删除算法和遍历算法等。数值算法和非数值算法并没有严格的区别，一般说来，在数值算法中主要进行算术运算，而在非数值算法中，则主要进行比较和逻辑运算。另一方面，特定的问题可能是递归的，也可能是非递归的，因而解决它们的算法就有递归算法和非递归算法之分。当然，从理论上讲，任何递归算法都可以通过使用循环、堆栈等技术转化为非递归算法。
在计算机领域，一个算法实质上是针对所处理问题的需要，在数据的逻辑结构和存储结构的基础上施加的一种运算。由于数据的逻辑结构和存储结构不是唯一的，在很大程度上可以由用户自行选择和设计，所以处理同一个问题的算法也不是唯一的。另外，即使对于具有相同的逻辑结构和存储结构而言，其算法的设计思想和技巧不同，编写出的算法也大不相同。学习数据结构课程的目的，就是学会根据数据处理问题的需要，为待处理的数据选择合适的逻辑结构和存储结构，进而按照结构化、模块化以及面向对象的程序设计方法设计出比较满意的算法（程序）。
section1.2算法描述
算法就是解决特定问题的方法，该方法可以借助各种工具描述出来。如从n个整数元素中查找出最大值，用流程图描述则如图1-6所示。
图1-6求n个元素中的最大值
若采用文字描述，则如下列步骤所示。
(1)给n个元素a_1sima_n输入数值。
(2)把第1个元素a_1赋给用于保存最大值元素的变量x。
(3)把表示下标的变量i赋初值2。
(4)如果i<=n，则需要向下执行来处理当前数据元素a_i，否则输出最大值x后结束算法。
(5)如果a_i>x，则将a_i赋给x，否则不改变x的值，这使得x始终保存着当前比较过的所有元素的最大值。
(6)使下标i增1，以指示下一个元素。
(7)转向第(4)步继续执行下一次的循环处理过程。
若要在计算机上实现一个算法，则最终必须采用一种程序设计语言进行描述。对于上述算法，采用C++语言描述如下。
```cpp
//程序1-2.cpp
include<iostream.h>
constintn=10;//假定n等于10
voidmain(void)
inti,x,a[n];//用a[0]~a[n-1]保存a1~an元素
cout<<"请输入10个整数：";
for(i=0;i<n;i++)
cin>>a[i];
```
x=a[0];i=1;
while(i<n)
if(a[i]>x)x=a[i];
i++;
cout<<"10个整数中的最大值为:"<<x<<endl;
本书对所有算法一般采用文字和C++语言两种描述,文字描述给出算法的思路和执行步骤,C++语言描述给出在机器上实现的代码。
section1.3算法评价
对于解决同一个问题,往往能够编写出许多不同的算法。例如,对于数组排序问题,就能够根据不同的排序方法对应编写出各不相同的多种算法。进行算法评价的目的,既在于从解决同一问题的不同算法中选择出较为合适的一种,也在于知道如何对现有算法进行改进或者独立创新,从而设计出更好的算法。一般从如下5个方面对算法进行评价。
section1.正确性
正确性(correctness)是设计和评价一个算法的首要条件,如果一个算法不正确,即不能完成或不能较好地完成所要求的任务,其他方面也就无从谈起。一个正确的算法是指在合理的数据输入下,能够在有限的运行时间内得出正确的结果。通过采用各种典型的输入数据上机反复调试算法,使得算法中的每段代码都被测试过,若发现错误及时修正,最终可以验证出算法的正确性。当然,要从理论上证明一个算法的正确性,并不是一件容易的事,也不属于本课程所研究的范围,故不进行讨论。
section2.稳健性
稳健性(robustness)是指一个算法对不合理（又称不正确、非法、错误等）数据输入的反应和处理能力。一个好的算法应该能够识别错误数据并进行相应的处理。对错误数据的处理一般包括打印错误信息、调用错误处理程序、返回标识错误的特定信息、中止程序运行等。
section3.可读性
可读性(readability)是指一个算法供人们阅读的容易程度。一个可读性好的算法,应该使用便于识别和记忆的、与描述的事物或实现的功能相一致的标识符,应该符合结构化和模块化的程序设计思想,应该对其中的每个功能模块、重要数据类型或语句加以注释,应该建立有相应的文档,对整个算法的功能、结构、使用及有关事项进行说明。
section4.时间复杂度
时间复杂度(timecomplexity)或称时间复杂性,又称计算复杂度(computational
complexity),它是算法有效性的量度之一,量度有效性的另一个指标是空间复杂度。时间复杂度是一个算法运行时间的相对度量。一个算法的运行时间是指在计算机上从开始到结束运行所花费的时间长短,它大致等于计算机执行一种简单操作(如赋值、比较、计算、转向、返回、输入和输出等)所需的时间与算法中进行简单操作次数的乘积。因为执行一种简单操作所需的时间随机器而异,它是由机器本身硬件环境决定的,与算法无关,所以只讨论影响运行时间的另一个因素——算法中进行简单操作次数的多少。
不管一个算法是简单还是复杂,最终都是被编译后分解成简单操作再通过CPU来具体执行的。因此,每个算法都对应着一定的简单操作的次数。显然,在一个算法中,进行简单操作的次数越少,其运行时间也就相对的越短;次数越多,其运行时间也就相对的越长。所以,通常把算法中包含简单操作次数的多少叫做该算法的时间复杂度,用它来衡量一个算法的运行时间性能(或称计算性能)。
若解决一个问题的规模为n,即所处理的数据中包含有n个元素,则算法的时间复杂度通常是n的一个函数,假定记为f(n)。下面通过例子来分析算法的时间复杂度。
【算法1-1】累加求和。
intSum(intb[],intn)
inti,s=0;
for(i=0;i<n;i++)
s+=b[i];
returns;
计算机执行这个算法时,函数体中第1条定义并赋初值语句和第3条返回语句都各执行一次简单操作,第2条for循环语句所包含的简单操作的次数可进行如下分解计算。
i=0;//1次
mark1:if(i>=n)gotomark2;//n+1次
s+=b[i];//n次
i++;//n次
gotomark1;//n次
mark2:returns;
把第2条语句分解后的每一条简单语句的执行次数加起来,就得到了它包含的简单操作的次数,即为4n+2。因此,算法1-1的时间复杂度为:f(n)=4n+4【算法1-2】矩阵相加。
voidMatrixAdd(inta[MS][MS],intb[MS][MS],intc[MS][MS],intn)
//实现矩阵a[n,n]和b[n,n]的加法,其和存入c[n,n]中
//MS为大于等于n的常量
inti,j;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
c[i][j]=a[i][j]+b[i][j];
运行此算法需要执行的简单操作的次数就等于双重for循环语句所包含的简单操作的次数，对该语句可进行如下分解计算。
i=0;//1次
mark1:if(i>=n)gotomark4;//n+1次
j=0;//n次
mark2:if(j>=n)gotomark3;//(n(n+1))次
c[i][j]=a[i][j]+b[i][j];//nn次
j++;//nn次
gotomark2;//nn次
mark3:i++;//n次
gotomark1;//n次
mark4:;
把分解后的每一条简单语句的执行次数加起来，就得到了它所包含的简单操作的次数。因此，算法1-2的时间复杂度为:f(n)=4n^2+5n+2【算法1-3】简单选择排序。
voidSelectSort(intb[],intn)
inti,j,k,x;
for(i=0;i<n-1;i++)
k=i;
for(j=i+1;j<n;j++)
if(b[j]<b[k])k=j;
x=b[i];
b[i]=b[k];
b[k]=x;
此算法包含有双重for循环，外层for循环的循环变量为i，它从0取值到n-2，对于i的每一取值，首先通过k=i赋初值语句和内层for循环语句，在b[i]~b[n-1]之间顺序查找出具有最小值的元素b[k]，然后通过3条赋值语句交换b[i]和b[k]的值，使得b[i]为b[i]~b[n-1]之间的最小值。这样，当算法执行结束后，数组b中的n个元素就按照其值从小到大的次序排列好了。
要计算出该算法包含的简单操作的次数，可将双重for循环语句分解如下:
i=0;//1次
mark1:if(i>=n-1)gotomark4;//n次
k=i;//n-1次
j=i+1;//n-1次
mark2:if(j>=n)gotomark3;/sum_i=0^n-2(n-i)=(n+2)(n-1)/2次
if(b[j]<b[k])k=j;/sum_i=0^n-2(n-i-1)=n(n-1)/2次
j++;/n(n-1)/2次
gotomark2;/n(n-1)/2次
mark3:x=b[i];/n-1次
b[i]=b[k];/n-1次
b[k]=x;/n-1次
i++;/n-1次
gotomark1;/n-1次
mark4:;
把分解后的每一条简单语句的执行次数加起来，就得到了它所包含的简单操作的次数。算法1-3的时间复杂度为：f(n)=2n^2+7n-7从以上分析可以看出，一个算法的时间复杂度的计算是相当繁琐的，特别对于较复杂的算法更是如此。实际上，一般也没有必要精确地计算出算法的时间复杂度，只要大致计算出相应的数量级(order)即可。下面接着讨论时间复杂度f(n)的数量级表示。
设f(n)的一个辅助函数为g(n)，定义为当n大于等于某一足够大的正整数n_0时，存在着两个正的常数A和B（其中A≤B），使得A≤fracf(n)g(n)≤B均成立，则称g(n)是f(n)的同数量级函数。把f(n)表示成数量级的形式为：f(n)=O(g(n))其中，大写字母O为英文order（即数量级）一词的第1个字母。这种表示的意思是指g(n)同f(n)只相差一个常数倍。
例如，在算法1-1中，当n≥1（即取n_0为1）时，4≤frac4n+4n≤8均成立，则g(n)=n；在算法1-2中，当n≥2（即取n_0为2）时，4≤frac4n^2+5n+2n^2≤7均成立，则g(n)=n^2；对于算法1-3，当n≥3（即取n_0为3）时，2≤frac2n^2+7n-7n^2≤4均成立，则g(n)也等于n^2。由此不难发现，当f(n)是n的多项式时，g(n)则为f(n)的最高次幂，它与f(n)中的其余项和最高次幂的系数都无关。若把算法1-1、算法1-2和算法1-3的时间复杂度分别用数量级的形式表示，则分别为O(n)、O(n^2)和O(n^2)。
算法的时间复杂度采用数量级的形式表示后，将给求一个算法的f(n)带来很大方便，这时只需要分析影响一个算法时间复杂度的主要部分即可，不必对每一步都进行详细的分析；同时，对主要部分的分析也可简化，一般只要分析清楚循环体内简单操作的执行次数或递归函数的调用次数即可。例如，对于算法1-1，只要根据for循环中的循环体被执行的次数n，就可求出其时间复杂度为O(n)；对于算法1-2，只要弄清楚双重循环内赋值操作的执行次数为n^2，就可求出其时间复杂度为O(n^2)；对于算法1-3，只要能够求出内层for循
环体的执行次数为sum_i=0^n-2(n-i-1)=frac12n(n-1)=frac12n^2-frac12n，就可得到其时间复杂度为O(n^2)。
算法的时间复杂度通常具有O(1)、O(sqrtn)、O(n)、O(lgn)、O(ntimeslgn)、O(n^2)、O(n^3)、O(2^n)和O(n!)等形式。O(1)表示算法的时间复杂度为常量，它不随数据量n的改变而改变，如访问一个数据表中第1个元素时，无论该表的大小如何，其时间复杂度均为O(1)。O(sqrtn)表示算法的时间复杂度与数据量大小n的平方根成正比，如计算满足不等式sum_k=1^ikleqn中的最大i值时，其算法的时间复杂度就是O(sqrtn)。这是因为计算i的时间复杂度的f(n)为left[sqrt2n+frac14-frac12right]，对应的g(n)为sqrtn。具有O(n)数量级的算法被称为线性算法，其运行时间与n成正比，如对一个表进行顺序查找时，其时间复杂度就是O(n)。有一些算法的时间复杂度为O(lgn)，即与n的对数成正比，如在有序表上进行二分查找的算法就是如此。对数组进行排序的各种简单算法为O(n^2)数量级的，当n加倍时，其运行时间将增长4倍；对数组进行排序的各种改进算法为O(ntimeslgn)数量级的，当n加倍时，其运行时间只是原来的2left(1+frac1lgnright)倍。做两个n阶矩阵的乘法运算时，其时间复杂度为O(n^3)。求具有n个元素集合的所有子集的算法，其时间复杂度应为O(2^n)，因为对于含有n个元素的集合来说，共有2^n个不同的子集。求具有n个元素的全排列的算法的时间复杂度为O(n!)，因为它共含有n!种不同的排列。
对于不同的n值，各种典型的数量级所对应的值如表1-3所示。可以看出，当n较大时，若时间复杂度为指数或阶乘数量级，则相应的算法是无效的，即不能实际运行的。如假定一台计算机每秒能做1亿次简单操作，则对于一个n值为32的具有阶乘数量级的算法，则至少要运行8.34times10^17个世纪才能完成，这显然是不可能实现的，是一个无效的算法。从表中还可以看出，当n大于一定的值后，随着n值的增大，各种数量级对应值的增长速度是大不相同的，对数的值的增长速度最慢，平方根稍快，线性值较快，其余依次为线性与对数的乘积、平方、立方、指数和阶乘，即阶乘的增长速度最快。例如，当n增长到两倍时，lgn增长到1.25倍，sqrtn增长到约1.4倍，ntimeslgn增长到2.5倍，n^2增长到4倍，n^3增长到8倍，2^n增长到2^2n倍，n!增长到(2n)!倍。因此，当n大于一定的值后，各种不同数量级对应的值存在着如下关系：O(lgn)<O(sqrtn)<O(n)<O(ntimeslgn)<O(n^2)<O(n^3)<O(2^n)<O(n!)表1-3算法复杂度的不同数量级变化对照表
|n|lgn|sqrtn|ntimeslgn|n^2|n^3|2^n|n!|
|-----|---------|-----------|---------------|-------|-------|-------|------|
|4|2|2|8|16|64|16|24|
|8|3|2.83|24|64|512|256|80320|
|10|3.32|3.16|33.2|100|1000|1024|3628800|
|16|4|4|64|256|4096|65536|2.1×10^13|
|32|5|5.66|160|1024|32768|4.3×10^9|2.6×10^35|
|128|7|11.31|896|16384|2097152|3.4×10^38|∞|
|1024|10|32|10240|1048576|1.07×10^9|∞|∞|
|10000|13.29|100|132877|10^8|10^12|∞|∞|
一个算法的时间复杂度还可以具体分为最好、最差（又称最坏）和平均3种情况讨论。下面结合从一维数组a[n]中顺序查找其值等于给定值item的元素的算法进行说明。
intSequenceSearch(inta[],intn,intitem)
//若查找成功则返回元素的下标，否则返回-1
for(inti=0;i<n;i++)
if(a[i]==key)returni;
return-1;
此算法的时间复杂度主要取决于for循环体被反复执行的次数。最好情况是第1个元素a[0]的值就等于item，此时只需要进行元素的一次比较就查找成功，相应的时间复杂度为O(1)；最差情况是最后一个元素a[n-1]的值等于item，此时需要进行同全部n个元素的比较才能查找成功，相应的时间复杂度为O(n)；平均情况是：每一个元素都有相同的概率left(text即均为frac1nright)等于给定值item，则查找成功需要同元素进行比较的平均次数为frac1nsum_i=1^ni=frac12(n+1)，相应的时间复杂度为O(n)，它同最坏情况具有相同的数量级，因为它们之间的比较次数只在系数项和常数项上有差别，而在n的指数上没有差别。
当在数组a上顺序比较n个全部元素后仍找不到等于给定值item的元素，则表明查找失败，这种情况所对应的时间复杂度也为O(n)。
在一个算法中，最好情况的时间复杂度最容易求出，但它通常没有多大的实际意义，因为数据一般都是随意分布的，出现最好情况分布的概率极小；最差情况的时间复杂度也容易求出，它比最好情况有实际意义，通过它可以估计到算法运行时所需要的相对最长时间，并且能够使用户知道如何设法改变数据的排列次序，尽量避免或减少最差情况的发生；平均情况下的时间复杂度的计算要困难一些，因为它往往需要概率统计等方面的数学知识，有时还需要经过严格的理论推导才能求出，但平均情况的时间复杂度最有实际意义，它确切地反映了运行一个算法的平均快慢程度，通常就用它来表示一个算法的时间复杂度。对于大多数算法来说，平均和最差这两种情况下的时间复杂度的数量级形式往往是相同的，它们主要是差别在最高次幂的系数上。另外有一些算法，其最好、最差和平均情况下的时间复杂度或相应的数量级都是相同的，如对于介绍过的算法1-1、算法1-2和算法1-3就是如此。
5.空间复杂度
空间复杂度(spacecomplexity)或称空间复杂性是对一个算法在运行过程中临时占用存储空间大小的量度，它也是衡量算法有效性的一个指标。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间、算法的输入/输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间等3个方面。
算法的输入/输出数据所占用的存储空间是由要解决的问题所决定的，是通过参数表由
调用函数传递来的,对于引用参数将不占有这方面的空间,而对于值参数将占有这方面的空间。所以在允许的情况下，尽量采用引用参数或指针参数，减少使用值参数，对于数据类型长度较大的参数更应如此。
存储算法本身所占用的存储空间与算法书写的长短成正比,要压缩这方面的存储空间,就必须编写出较短的算法,如编写成递归算法通常就比相应的非递归算法要短。
算法在运行过程中临时占用的存储空间随算法的不同而异,有的算法只需要占用少量的临时工作单元,而且不随问题规模的大小而改变,称这种算法是“就地”进行的,是节省存储的算法,如本节中介绍过的几个算法都是如此。有的算法需要占用的临时工作单元数与解决问题的规模n有关,它随着n的增大而增大,当n较大时,将占用较多的存储单元,将在第10章中介绍的快速排序和归并排序算法就属于这种情况。
分析一个算法所占用的存储空间要从各方面综合考虑。如对于递归算法来说,一般都比较简短,算法本身所占用的存储空间较少,但运行时需要一个附加的工作栈,从而占用较多的临时工作单元;若写成非递归算法,一般可能比较长,算法本身占用的存储空间较多,但运行时将可能需要较少的存储单元。
一个算法的空间复杂度通常是考虑在运行过程中为局部变量分配的存储空间的大小,它包括为参数表中值参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。若一个算法为递归算法,其空间复杂度为递归所使用的工作栈空间的大小,它等于一次调用所分配的临时存储空间的大小乘以被调用的次数(即为递归调用的次数加1,这个1表示开始进行的一次非递归调用)。算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量,即不随被处理数据量n的大小而改变时,则表示为O(1),当一个算法的空间复杂度以2为底的n的对数成正比时,则表示为O(logn),当一个算法的空间复杂度与n成线性比例关系时,则表示为O(n)。
注意:若形参为数组,则其实质上为一个指针值参数,只需要为它分配一个存储由实参传送来的一个地址指针的空间,即一个机器字长空间,通常为2或4个字节。
对于一个算法,其时间复杂度和空间复杂度往往是相互影响的,当追求一个较好的时间复杂度时,可能会使空间复杂度的性能变差,即可能导致占用较多的存储空间;反之,当追求一个较好的空间复杂度时,可能会使时间复杂度的性能变差,即可能导致占用较长的运行时间。另外,算法的所有性能之间都存在着或多或少的相互影响。因此,当设计一个算法(特别是大型算法)时,要综合考虑算法的各项性能、算法的使用频率、算法处理的数据量的大小、算法描述语言的特性、算法运行的机器系统环境等诸多因素,通过权衡利弊才能够设计出比较满意的算法。
1.4与算法描述有关的C++知识
下面对C++语言的有关内容做简要说明,为以后各章分析和编写算法做准备,此部分可不作为教学讲授内容,而留给学生自学。
1.4.1包含文件语句
包含文件语句以关键字include开头，后跟用尖括号或双引号括起来的头文件名，行末尾不需要使用分号。下面介绍几个常用的系统头文件的作用。
1.include<iostream.h>
在程序的开始使用该语句后，在其后的每一个函数中，都可以使用标准输入设备（键盘）流对象cin、标准输出设备（屏幕）流对象cout和标准错误输出设备（屏幕）流对象cerr，以及使用用于输入的提取操作符“>”和用于输出的插入操作符“<”进行数据输入/输出操作。对于基本类型为char、short、int、long、char（字符串型）、float、double、longdouble的数据能够直接进行输入和输出；对于非字符指针类型的指针型数据能够直接输出指针（即操作数地址）；对于其他类型的数据，只有通过对“>”和“<”操作符重载后才能直接输入和输出，当然若数据中的元素为基本数据类型，则可对其元素直接输入和输出。例如，一种记录结构类型如下。
structworker
intid;
charname[20];
floatwage;
若要对该记录类型的一个对象（用wk表示）输入或输出数据，可使用如下输入或输出语句。
cin>>wk.id>>wk.name>>wk.wage;
cout<wk.id<<"""<wk.name<<"""<wk.wage<<endl;
若要对记录整体进行输入或输出，则必须对该类型进行提取或插入操作符的重载，它们的重载函数定义如下。
istream&operator>>(istream&istr,worker&x)
istr>>x.id>>x.name>>x.wage;
returnistr;
ostream&operator<<(ostream&ostr,constworker&x)
ostr<x.id<<"""<x.name<<"""<x.wage<<endl;
returnostr;
按照上述定义后，可使用如下语句对worker类型的对象wk进行输入或输出。
cin>>wk;
cout<<wk;
执行第1条语句时将把实际参数cin和wk引用（即按址）传送给被调用函数中的istr和x形参，使得istr和x分别被取代（或称易名）为cin和wk，函数中对istr和x的操作实际上就是对cin和wk的操作。该函数返回istr（即cin），以便能够在同一条输入语句中连续使用“>>”操作符对多个对象进行输入。
注意：当在同一行上输入多个数据时，从键盘上输入的数据之间必须用空格相隔开。
执行第2条语句时将把实际参数cout和wk引用（即按址）传送给被调用函数中的ostr和x形参，使得ostr和x分别被取代为cout和wk，函数中对ostr和x的操作实际上就是对cout和wk的操作。该函数返回ostr（即cout），以便能够在同一条输出语句中连续使用“<<”操作符对多个数据进行输出。
另外，在使用include<iostream.h>语句之后的函数中，允许使用换行符常量endl和空指针常量NULL，它们分别表示换行符“n”和数值0（即空指针值“0”）。
2.include<stdlib.h>
在stdlib.h头文件中含有voidexit(int)、intrand(void)、voidsrand(unsigned)等函数的原型。exit(int)函数的作用是结束程序的执行，一般用整数值0调用该函数表示正常结束，用整数值1调用该函数表示非正常结束。如利用new操作符没有分配到所需要的存储块时，应输出“存储分配失败！”错误信息并调用exit(1)函数终止程序运行。rand()函数的作用是返回0~32767之间的一个随机整数。利用rand()%n可以产生0~n-1范围内的一个随机整数。srand(unsigned)函数的作用是初始化随机数发生器，当参数不同时，接着由rand()函数所产生的随机数序列也不同。若在rand()函数前没有执行过srand函数，则产生的是参数值为1的随机数序列，即相当于调用了一次srand(1)函数。下面是一个产生随机数的程序。
```cpp
//程序1-3.cpp
include<iostream.h>
include<stdlib.h>
voidmain(void)
inti;
for(i=0;i<10;i++)
cout<<(rand()%100)<"";
cout<<endl;
srand(2);
for(i=0;i<10;i++)
cout<<(rand()%100)<"";
cout<<endl;
srand(1);
for(i=0;i<10;i++)
cout<<(rand()%100)<"";
```
cout<<endl;
该程序运行后的显示结果如下。
4167340692478586264
4516989584509031516
4167340692478586264
下面程序在每次运行时,将会得到完全不同的运行结果。因为在srand函数的参数中使用了time(0)函数,此函数原型定义在time.h头文件中,它返回从1970年1月1日零时算起至当前时间为止的秒数。由于当前时间是时刻变化的,所以可以使每次运行程序时调用srand函数的实参值均不同,从而使系统生成每次均不同的随机数序列。
//程序1-4.cpp
include<iostream.h>//支持输入/输出函数
include<stdlib.h>//支持随机数函数
include<time.h>//支持时间函数
voidmain()
inti,x;
srand(time(0));
for(i=0;i<10;i++)
x=rand()%100;
cout<<x<<"";
cout<<endl;
在stdlib.h头文件中还包含有voidcalloc(unsignedintn,unsignedintsize)、voidmalloc(unsignedintsize)、voidrealloc(voidp,unsignedintsize)、voidfree(voidp)等函数的原型。calloc函数用来动态分配n个连续存储位置,每个位置含有存储一个数据元素的size个字节,整个动态存储空间的大小为ntimestextsize个字节,用来最多存储n个数据元素。malloc函数用来动态分配大小为size个字节的新存储空间。realloc函数用来动态分配大小为size个字节的新存储空间,并把p所指向的原动态存储空间的内容复制到新分配得到的动态存储空间中,同时自动释放掉p所指向的原动态存储空间。上述3个函数都返回新分配的动态存储空间的首地址,通常需要将它转换为每个存储位置所存数据的指针类型,若动态存储分配失败,则都将返回NULL表示失败。free函数释放由参数p所指向的动态存储空间。以上4个函数在C语言或C++语言环境中都可以使用。另外,在C++语言中还能够使用new和delete运算符来非常方便地进行动态存储空间的分配和释放。
下面程序给出了上述函数应用的例子,其中定义指针p下的3行语句具有相同功能。
//程序1-5.cpp
include<iostream.h>
include<stdlib.h>
voidmain(void)
intp;
//p=(int)malloc(8sizeof(int));
//p=(int)calloc(8,sizeof(int));
p=newint[8];
for(inti=0;i<8;i++)
p[i]=ii;
p=(int)realloc(p,12sizeof(int));
for(i=8;i<12;i++)
p[i]=2i;
for(i=0;i<12;i++)
cout<<p[i]<<"";
cout<<endl;
free(p);
该程序的运行结果为:
01491625364916182022
3.include<fstream.h>
fstream.h为使用文件流类的头文件，其中定义有输入文件流类ifstream、输出文件流类ofstream和输入/输出文件流类fstream，利用它们可以为编程者定义相应的文件流对象，从而对外存上的文件进行输入/输出操作。例如:
ifstreaminput("xxk1.dat",ios::in|ios::nocreate);
ofstreamoutput1("d:xxkxxk21.dat",ios::out),
ofstreamoutput2("xxk22.dat",ios::app);
fstreaminout("a:xxk3.dat",ios::in|ios::out);
在以上每一条语句中都定义了一个相应的文件流对象，其中的第1个参数给出要打开的实际文件，它为一个字符指针类型，第2个参数给出文件的打开方式。执行上述任一条语句后，若相应的文件被打开，则由文件流对象返回一个非0值，否则返回一个0值。当打开一个文件后，将在内存中开辟出一个相应的文件缓冲区，通过文件流对象访问缓冲区，实现对文件的读写操作。
上述第1条语句定义了输入文件流对象为input，要打开的文件为当前目录下的xxk1.dat，并由ios::in参数规定按输入（即由文件到内存）方式打开，此参数可以省，由ios::nocreate参数规定若指定文件不存在则不应去建立它，否则将建立它。打开一个用于输入的文件后，文件指针被自动指向文件内容的开始位置。
第2条语句定义了输出文件流对象为output1，要打开的文件为d盘xxk子目录下的xxk21.dat，并由ios::out参数规定按输出（即由内存到文件）方式打开，此参数可以缺省，若指定文件不存在，则自动在指定目录下建立文件名为xxk21.dat的空文件。打开一个用于输出的文件后，文件中的原有内容自动被清除掉。
第3条语句定义了输出文件流对象为output2,要打开的文件为当前目录下的xxk22.dat,n并由ios::app参数规定按追加输出方式打开，同样若文件不存在则自动建立它。打开一个用于追加输出的文件后，文件中的原有内容保持不变，文件指针被自动移到文件的末尾。n第4条语句定义了输入/输出文件流对象为inout,对应的文件为A盘根目录下的xxk3.dat,并规定既可对该文件进行输入操作，也可对该文件进行输出操作。打开一个同时用于输入和输出的文件后，文件中的原有内容不变，文件指针被自动移到文件内容的开始位置。nn当一个文件被打开后，可以按字符方式（又称ASCII码方式）或字节方式（又称二进制方式）进行访问。若向文件写入数据时采用的是字符方式，则从该文件中读出数据时也应该采用字符方式；同样，若写入数据是按字节方式进行的，则读出数据时也应按字节方式进行。数据按字符方式读出或写入，是通过使用文件流对象和提取操作符“>>”或插入操作符“<<”来实现的，就如同对标准输入/输出设备进行读写操作一样。值得注意的是：当以字符方式向文件写入数据时，数据之间必须以空格或回车换行符隔开，因为读取每一个数据时都是以这些符号作为结束标志的。nn数据按字节方式写入文件时，是把内存中由指定字符指针所指向的若干个字节的内容直接写入到文件中；数据按字节方式从文件读出时，是把从文件中读出的若干个字节的内容，直接存入到内存中由指定字符指针所指开始位置的存储区里。按字节方式读写文件比按字符方式读写文件要快，因为它不需要在读写过程中进行数据格式的转换。按字节方式读写文件若通过事先移动文件指针，还能够随机读写文件中从任何位置开始的内容，而对于按字符方式读写的文件，则一般只能进行顺序访问。利用文件流对象调用文件流类中的成员函数read(char,int)或write(char,int)，能够对文件按字节方式进行读出或写入操作，当不能够从文件中读出所规定的字节数时，read函数返回0值，否则返回非0值，若返回0值，则利用文件流对象调用文件流类中的成员函数gcount()可得到实际读取的字节数。nn下面列举一些简单的文件操作的例子。nn//程序1-6.cppninclude<iostream.h>ninclude<stdlib.h>ninclude<fstream.h>nvoidmain(void)nnofstreamf1("wr1.dat");nif(!f1)ncerr<<"wr1.datnotopen!";nexit(1);nnfor(inti=0;i<20;i++)nf1<<i<<"";nf1.close();n
该程序主函数中的第1条语句建立输出文件流f1，并使之与当前目录下的wr1.dat文件相联系，若该文件存在则打开并清空，否则在当前目录下建立它；若第1条语句执行时没有打开或建立wr1.dat文件，则第2条语句中的条件为真，显示出错误信息后终止程序执行；第3条语句把0sim19之间的整数按字符方式顺序写入到文件流f1所对应的文件中，在写入每个整数之后同时写入一个空格作为分隔符；第4条语句关闭与f1相联系的文件wr1.dat，即把相应的文件缓冲区归还给系统。
```cpp
//程序1-7.cpp
include<iostream.h>
include<stdlib.h>
include<fstream.h>
voidmain(void)
ifstreamf1("wr1.dat",ios::in|ios::nocreate);
if(!f1)
cerr<<"Files'wr1.dat'notfound!";
exit(1);
inti;
while(!f1.eof())
if(f1>>i)cout<<i<<"";//或改为：f1>>i;cout<<i<<"";
cout<<endl;
f1.close();
```
该程序主函数中的第1条语句建立输入文件流f1，并使之与当前目录下的文件wr1.dat相联系；若该文件没有被打开，则执行第2条语句时将显示出错误信息并退出程序的执行；第4条语句是一个while循环，当文件指针没有指向文件的末尾时，则f1.eof()的值为假（即为0值），否则为真（即为非0值），若每次利用f1>>i表达式从文件中读出一个整数到变量i中，则该表达式的值为真，否则为假，该循环的作用是从f1流所对应的文件开头，顺序读出每一个整数到变量i中，并把它输出到屏幕上，直到文件指针被移到文件结尾为止（每读出一个数据后，文件指针就向后移动一个数据位置）；第6条语句关闭f1对应的wr1.dat文件。
```cpp
//程序1-8.cpp
include<iostream.h>
include<stdlib.h>
include<fstream.h>
structworker
intid;
charname[20];
floatwage;
;
voidmain(void)
```
fstreamfl("wr2.dat",ios::in|ios::out);
workera[5]=111,"xuxiaokai",567.00,123,"weirong",524.00,
240,"hexiaoxin",620,360,"yuanwei",445.00,
378,"ningchen",486.00
;
for(inti=0;i<5;i++)
fl.write((char)&a[i],sizeof(worker));
fl.seekg(0);//把文件指针移到文件的开始位置
workerx;
while(!fl.eof())
if(fl.read((char)&x,sizeof(worker)))
cout<<x.id<<""<<x.name<<""<<x.wage<<endl;
cout<<"读出和显示文件中第4条记录:"<<endl;
fl.clear();//清除fl流中所有状态位,即恢复为0
fl.seekg(3sizeof(worker));//使文件指针指向
//第3个位置上的记录,文件开始为第0位置
fl.read((char)&x,sizeof(worker));
cout<<x.id<<""<<x.name<<""<<x.wage<<endl;
fl.close();
该程序首先把数组a中的5个记录按字节方式依次写入到输入/输出流对象fl所对应的文件wr2.dat中，接着从文件开始位置（即第0字节）起顺序读出每条记录并按行显示出来，最后重新读出和显示文件中的第4条记录。该程序运行后的显示结果如下。
111xuxiaokai567
123weirong524
240hexiaoxin620
360yuanwei445
378ningchen486
读出和显示文件中第4条记录:
360yuanwei445
4.include<string.h>
string.h为进行字符串操作的头函数，其中定义有一些字符串函数的原型。用户可以在程序中直接调用这些函数处理字符串。常用的字符串函数如下。
(1)求串长度。
intstrlen(constchars);
返回s指针所指字符串的长度，字符串的空结束符("'0'")不计算在内。
(2)串复制。
charstrcpy(chardest,constcharsrc);
把src所指字符串复制到dest指针所指的存储空间中，该函数返回dest指针。
(3)串连接。
charstrcat(chardest,constcharsrc);
把src所指字符串复制到dest所指字符串后面的存储空间中，连接后dest所指串的长度等于dest串原有长度与src串长度之和，该函数返回dest指针。注意，在dest所指字符串的后面要有足够的存储空间用于存储待连接的字符串。
(4)串比较。
intstrcmp(constchars1,constchars2);
把s1所指字符串同s2所指字符串比较，若s1串大于s2串则返回值大于0(通常为1)，若s1串小于s2串则返回值小于0(通常为-1)；若s1串等于s2串则返回值等于0。
(5)串定位。
charstrchr(constchars,intc);
从s所指字符串的开始顺序查找ASCII码为c值的字符（也可以把一个字符传递给参数c，实际上是传递该字符的ASCII码），若查找成功则返回指向该字符的指针，否则返回NULL。
(6)串右定位。
charstrrchr(constchars,intc);
它与串定位函数功能相似，唯一区别是它从s串的最后顺序向前查找。
(7)查找子串。
charstrstr(constchars1,constchars2);
从s1串中开始位置起顺序查找s2串的第1次出现，若查找成功则返回s1串中指向该子串开始位置的指针，否则返回NULL。
下面是使用字符串函数的实例。
//程序1-9.cpp
include<iostream.h>
include<string.h>
voidmain()
chara[20],str1="hello",str2="wang",str3;
strcpy(a,str1);
strcat(a,"");//在a串最后添加一个空格字符
strcat(a,str2);
cout<<(strlen(str1)<""<strlen(a)<endl;
cout<<(strcmp(a,str1)<""<strcmp(a+6,str2)
<""<strcmp(str1,str2)<endl;
str3=strchr(str1,'l');
cout<<str3-str1<<"";//输出str3指针所对应的下标位置
str3=strchr(str1,'1');
cout<<str3-str1<<endl;
str3=strstr(str2,"an");
cout<<str2<<""<<str3<<endl;
该程序运行后的显示结果如下，请读者结合程序分析其正确性。
510
10-1
23
wangang
section1.4.2数据类型
section1.简单类型
在C++语言中，简单类型包括整数类型、字符类型、布尔类型、浮点类型、指针类型、枚举类型和void类型。整数类型又分为短整型(shortint或short)、整型(int)和长整型(longint或long)3种，它们分别表示不同范围内的整数。字符类型的表示范围是ASCII字符集和汉字区位码字符集（每一个汉字为两个ASCII字符，现在国际上统一使用一种编码，叫做unicode编码，它对所有国家的字符统一采用双字节编码）。字符类型和每一种整数类型都可以使用前缀关键字signed或unsigned，使之成为相应的有符号或无符号数据类型，默认为signed类型。布尔类型也称为逻辑类型，它只有两个值0和1，分别用符号常量false和true表示，即为逻辑值“假”和“真”。浮点类型包括float类型、double类型和longdouble类型，用它们表示带小数点的数。指针类型用来表示内存中存储单元（字节）的位置（地址），它的基类型可以为任何类型，一个指针类型用一个类型标识符后缀一个星号()表示。枚举类型是用户自定义类型。void为一种特殊类型，它不取任何值，通常用它定义不返回值的函数类型，若带上“”后缀则定义指向任何类型的指针。
字符类型也可以被看作一种整数类型，每个字符的ASCII码被看作其中的一个整数值。每一种类型的数据可以根据需要被强制转换为另一种类型的数据，其转换格式为:
(<类型标识符>)<表达式>
或
(<类型标识符>)(<表达式>)
例如，假定x和y分别为int和float型，则int(y)的值为int型，其值为y值的整数部分，(char)&x的值为字符指针类型，其值为整型对象x的地址。
section2.结构类型
在C++语言中，结构类型包括数组、字符串、记录和文件等。
(1)数组。
数组是数目固定的具有同一类型的数据元素的顺序组合，按照数组中每个元素的下标位置可认为数组具有线性结构，用二元组描述如下：
array=(A,R)，其中A=lefta[i]mid0leqslantileqslantn-1,ngeqslant1rightR=leftlanglea[i],a[i+1]ranglemid0leqslantileqslantn-2righta[i]为数组中的下标为i的元素，n为大于等于1的整数，用来表明数组中元素的个数，数组元素的下标从0到n-1，数组中前后相邻位置上的两个元素为一个序偶，其前一元素a[i]是后一元素a[i+1]的前驱，而a[i+1]是a[i]的后继，第1个元素a[0]无前驱元素，最后一个元素a[n-1]无后继元素。
按数组下标的个数，可把数组分为一维、二维、三维等。
一维数组中的每个元素只包含有一个下标，二维数组中的每个元素包含有两个下标，第1个称为行下标，第2个称为列下标。
二维数组可看作是一维数组或嵌套，即首先把它看作是按行下标顺序排列的一维数组，该数组中的每个元素又都是按列下标顺序排列的一维数组。如对于一个二维数组b[m][n]，可视为一维数组b[m]，所含元素依次为b[0],b[1],…,b[m-1]，其中每一个元素b[i]（0leqslantileqslantm-1）又都是一个含有n个元素的一维数组，所含元素依次为b[i][0],b[i][1],…,b[i][n-1]。
同样，三维数组包含有3个下标，每个元素的位置由一组3个下标值唯一确定。三维数组是一维数组的3层嵌套结构。如对于一个三维数组c[p][m][n]，首先可视为一维数组c[p]，所含元素依次为c[0],c[1],…,c[p-1]，其中每一个元素c[k]（0leqslantkleqslantp-1）又都是一个含有m个元素的一维数组，所含元素依次为c[k][0],c[k][1],…,c[k][m-1]，这里的每一个元素c[k][i]（0leqslantileqslantm-1）也都是一个含有n个元素的一维数组，所含元素依次为c[k][i][0],c[k][i][1],…,c[k][i][n-1]。
数组的存储结构是顺序结构，即数组中第i+1个元素紧接着存储在第i个元素的存储位置的后面。如对于一维数组a[n]，则每个元素a[i]的存储位置的首字节地址为：textAddress(a[i])=Loc(a)+iLquad(0leqslantileqslantn-1)其中Loc(a)表示数组a的存储空间的首地址，L表示数组a中元素类型的大小，即每个元素所占用的字节数，可用sizeof(a[i])计算。由上述公式可知：元素a[0]的存储地址为Loc(a)，它就是整个数组的开始地址，a[1]的存储地址为Loc(a)+1L，a[2]的存储地址为Loc(a)+2L；…；a[n-1]的存储地址为Loc(a)+(n-1)L。
对于一个二维数组b[m][n]，每一行元素b[i]的存储位置（即存储该行n个元素的首字节地址）为：textAddress(b[i])=Loc(b)+iRSquad(0leqslantileqslantm-1)其中Loc(b)表示二维数组b的存储空间的首地址，RS表示顺序存储一行n个元素所占用存储空间的大小，它等于每个元素所占用的字节数L与一行上元素的个数n的乘积。因此上述计算公式可改写为：textAddress(b[i])=Loc(b)+inLquad(0leqslantileqslantm-1)对于二维数组b中的第i行（即下标为i的行），其中下标为j的元素b[i][j]的存储位置为：textAddress(b[i][j])=Loc(b)+inL+jLquad(0leqslantileqslantm-1,0leqslantjleqslantn-1)
对于三维或更高维数组，其每个元素的存储位置（即首字节地址）也容易计算出来。如对于三维数组c[p][m][n]，其相应的一维数组元素、二维数组元素和三维数组元素的存储位置的计算公式分别如下：textAddress(c[k])=textLoc(c)+kmnLquad(0leqkleqp-1)textAddress(c[k][i])=textLoc(c)+kmnL+inLquad(0leqkleqp-1,0leqileqm-1)textAddress(c[k][i][j])=textLoc(c)+kmnL+inL+jLquad(0leqkleqp-1,0leqileqm-1,0leqjleqn-1)上面对于多维数组的存储空间的分配是按照行序为主进行的，即第i行元素所占用的存储空间的后面紧接着保存第i+1行的元素。C、C++、BASIC、PASCAL、Java等大多数计算机语言对数组的存储空间分配都是按此方法进行的。但也有的计算机语言，如FORTRAN语言是采用列序为主进行的，即第i列元素所占用的存储空间的后面紧接着保存第i+1列的元素。如对于一个二维数组a[m][n]，若采用列序为主分配存储空间，则元素a[i][j]的存储位置为：textAddress(a[i][j])=textLoc(a)+jmL+iLquad(0leqileqm-1,0leqjleqn-1)对于以列序为主进行存储空间分配的三维数组，有兴趣的读者可进行类似的分析。
(2)字符串。
字符串类型是一种特殊的一维字符数组类型，该类型中的每一个值，从下标0位置保存的字符起到下标i位置(0leqi<n-1,n为一维下标上界）保存的ASCII码为0的空字符'0'止，连续i个字符（不含'0'字符在内）称为一个字符串。
一个字符串常量是用双引号括起来的一串字符，当把它作为初值赋给一个字符数组时，是把该常量中的每个字符依次写入到字符数组中从下标0开始的对应位置上，并在最后写入一个'0'字符作为字符串的结束标志。若一个字符串的长度为len，则它占据字符数组中0simtextlen位置，其中每个位置为一个字节，用来保存一个字符，0simtextlen-1位置保存字符串本身的字符，textlen位置保存空字符'0'。
在字符数组定义时，允许把一个字符串常量作为初值赋给字符数组，而在其他地方，要把一个字符串常量或一个字符数组中保存的字符串赋给一个字符数组时，则必须使用串复制函数strcpy。保存字符串的字符数组的数组名是一个字符指针常量，它不能作为左值使用，但在其他地方可以像字符指针变量一样使用。如当出现在输出语句时，不是输出数组名指针的值，而是输出以数组名指针为开始地址的、在字符数组中保存的一个字符串；当使用在输入语句时，不是把输入的一个字符串常量的存储地址赋给数组名指针，而是把该字符串保存到字符数组中，并在其后保存一个'0'字符。
注意：在键盘上输入的一个字符串常量，两边不要使用双引号作为起止符，它自动以非空格和非回车符作为字符串的第一个字符，以空格或回车符作为结束符，即其前一个字符是字符串的最后一个字符。
对字符串的运算操作主要有求串的长度、把一个串复制到另一个字符指针所指的字符数组空间中、比较两个串的大小、串输入和输出等。
注意：当把一个字符串赋值或复制到另一个字符串时，目的字符串的存储空间要大于等于源字符串的长度加1。
利用一维数组能够保存一个字符串，若要依次保存多个字符串，则需要定义一个二维数组，其中每一行对应的一维字符数组空间用来保存一个字符串。程序清单如下。
//程序1-10.cpp
include<iostream.h>
include<string.h>
voidmain()
chara[4][20]="Beijing","Shanghai","Tianjin","Guangzhou";
charp[20];
for(inti=0;i<4;i++)
cout<<a[i][0]<<endl;
strcpy(p,&a[0][0]);
for(i=1;i<4;i++)
if(strcmp(p,&a[i][0])<0)
strcpy(p,&a[i][0]);
cout<<endl<<p<<endl;
在该程序的主函数中，第1条语句定义了一个二维数组a[4][20]，该数组的行下标范围为0sim3，列下标范围为0sim19，每一行元素a[i]（0leqileq3）能够存储一个字符串，其字符串的最大长度应小于等于19，该语句同时对数组a进行初始化。第2条语句定义了一个一维字符数组p[20]。第3条语句显示出数组a中保存的每个字符串，其中&a[i][0]可以改写为a[i]。第4和第5条语句通过顺序比较查找出数组a中值最大的字符串，字符数组p用做在比较过程中保存当前最大值的字符串，其初值为数组a中第1个字符串a[0]（即&a[0][0]）。最后一条语句显示出已经在p中保存的最大值。该程序的运行结果如下。
Beijing
Shanghai
Tianjin
Guangzhou
Tianjin
(3)记录。
记录类型是多个不同数据类型（当然也可以相同）的组合体。记录类型中的每一个值（即具体记录）是记录类型中的一个实例，它由多个不同类型的具休数据所组成。一个记录中的所有数据成员逻辑上是集合结构，即成员之间没有任何次序，但物理存储上是顺序结构，它是按照记录类型定义中各成员定义的顺序存储的。一个记录所占用存储空间的大小等于各成员所占用存储空间的大小之和，此值可以通过sizeof运算符计算。
在C/C++语言中，记录被称为结构，通过使用struct关键字定义用户需要的记录（结构）类型。在struct关键字后要给出一个标识符作为记录类型名，在其后的大括号中要给出所含的每一个数据类型及其数据域名。访问记录中的某个数据域是通过成员选择操作符（.）或（->）来实现的，前者称为直接成员选择符，后者称为间接成员选择符。直接成员
选择符左面的操作数应为一个记录类型的对象（记录变量），而间接成员选择符左面的操作数应为一个指向记录类型对象的指针，它们右面的操作数均应为记录中的一个要访问的域名。通过“.”或“->”操作符能够读取记录中的任一个域的值，或者向记录中的任一个域写入数据。
在定义一个记录类型的对象时，可以同时对它进行初始化，用于初始化的记录值要用大括号括起来，各个域值按记录中对应类型定义的顺序给出，其前后域值之间要用逗号分开，若域值是一个字符串，则必须用双引号括起来，若是一个字符则必须用单引号括起来，若是一个数组或另一个记录则必须用大括号括起来。记录类型的对象还可以同简单类型的对象那样，允许使用赋值号把一个对象赋给另一个同一类型的对象。
下面定义了一个学生记录类型（student），它包含有4个域，分别为学号（num）、姓名（name）、性别（sex）和用于保存学生5门课程成绩及平均成绩的数组（result）。
```
structstudent
charnum[8];//每个学号不能超过7个字符
charname[10];//姓名不能超过9个字符
charsex;//假定用字符m和f分别表示男性和女性
doubleresult[6];//前5个元素保存5门课成绩,最后一个保存平均成绩
;
```
为了使用上述类型，下面给出了3条语句：第1条语句定义了一个student对象s1并赋予初值，第2条语句计算出s1记录中5门课程的平均成绩，第3条语句显示出s1的学号、姓名、性别和平均成绩。其显示结果为：980413左明华m77.6。
```
students1="980413","左明华",'m',76,83,64,90,75,0;
for(inti=0;i<5;i++)
s1.result[5]+=s1.result[i]/5;
cout<<s1.num<<""<<s1.name<<""<<s1.sex<<""<<s1.result[5]<<endl;
```
下面的程序定义了一个记录类型person，其大小为24个字节，它带有指向自身类型的指针next；另外两个域为字符串域name和整数域age。通过next域可以把该类型的结点（对象）链接起来，形成一个单链表。该程序把r1、r2和r3这3个结点依次链接起来，并使p指向这个单链表的头结点r1。程序最后通过while循环依次按左对齐显示出每个结点的name域和age域的值，其显示宽度分别为15和5。
```
//程序1-11.cpp
include<iostream.h>
include<iomanip.h>//该头文件包含iostream.h的全部内容,并包含
//更多的输入/输出格式控制功能,使用此条命令时可省略其上一条命令
structperson
charname[15];
intage;
personnext;
;
voidmain()
```
personr1=("shiliang",38),r2=("zhangtongwen",34),
r3=("panweidong",42);
personp;
r1.next=&r2;r2.next=&r3;r3.next=NULL;
p=&r1;
cout.setf(ios::left);//使显示数据在规定范围内左对齐,
//若把left改为right则为右对齐，默认设置为右对齐
while(p!=NULL)
cout<<setw(15)<<p->name<<setw(5)<<p->age<<endl;
p=p->next;
;
该程序运行后的显示结果如下:
shiliang38
zhangtongwen34
panweidong42
（4）文件。
文件是按位置有序的数据集合。如一篇文章，可看做按位置有序的字符集合；一个统计表，可看做按行位置有序的记录集合；一个二维数值矩阵，可看做先按行位置有序、对于同一行再按列位置有序的数值集合；一个具有树结构的图表，可看做先从上到下的层次有序、在同一层次上再按从左到右的位置有序的数据（结点）集合。它们均可看做相应文件。单从文件中数据的先后排列位置考虑，可以认为它具有线性结构。
在计算机中文件被存储在外存上，其存储结构由操作系统自动实现。在C++语言中，用户使用文件是通过定义与之相对应的文件流对象来实现的。通过输入文件流对象使文件中的数据按照其位置从前到后的次序依次流入到内存文件缓冲区中，从而被读取到指定的内存变量中；通过输出文件流对象，使输出到文件中的数据首先写入到文件缓冲区中，然后操作系统再把文件缓冲区中的内容写入到外存上相应文件的末尾。当然，对于字节文件，可以从任何指定位臵写入信息，也可以把信息写入到任何指定位臵开始的存储空间中。
对于一个字符文件，通过输入文件流类或输入/输出文件流类的对象打开后，主要采用以下4种操作方法从文件中读取数据。
①流类对象>>变量。
②流类对象.get（字符变量）。
③流类对象.get()。
④流类对象.getline（字符指针变量，整数量）。
第1种操作方法从流类对象所对应的文件中顺序读出一个数据（数据以空格或换行符隔开）到指定的内存变量中。第2种操作方法从流类对象所对应的文件中顺序读出一个字符到内存字符变量中。第3种操作方法同第2种类似，区别仅在于把读到的一个字符作为函数值返回。第4种操作方法从流类对象所对应的文件中顺序读出一行字符（以换行符或文件结束符作为行结束符，或者读到给定的第2个参数“整数量”的值减1个字符也作为
一行结束），并把它保存到以第1个参数给定的字符指针变量所指定的内存空间中，该内存空间最多只允许存储长度等于给定整数量值减1的一个字符串，并且其后自动存储一个字符串结束符'0'，通常所给的整数量的大小为字符指针变量所指定的存储空间的大小。当然这里的各种指定的变量可以为单独定义的变量或数组，也可以为数组中的元素或记录中的域。
上述第1、2、4种操作方法（或称函数调用、操作表达式等）都返回相应的流类对象的值，当读取成功时，其返回值为非0，读取失败（即遇到文件结束符，系统用符号常量EOF表示，其值为-1）时，其返回值为0。另外，其流类对象可以是文件流对象，也可以是标准输入流对象cin。若是cin，则表示从键盘输入数据，而不是从外存文件中输入数据。
对于一个字符文件，通过输出文件流类或输入/输出文件流类的对象打开后，主要采用以下两种操作方法向文件中写入数据。
(1)流类对象<<数据。
(2)流类对象.put（字符量）。
第1种操作方法向流类对象所对应的文件中顺序写入一个数据（常量、变量或表达式），每写入一个数据后，都要写入一个空格或换行符作为数据之间的分隔符。第2种操作方法向流类对象所对应的文件中顺序写入一个字符量。同样，其流类对象可以是文件流对象，也可以是标准输出流对象cout。若是cout，则将把数据输出到显示器屏幕上。
对于一个字节文件，通过输入文件流类、输出文件流类或输入/输出文件流类的对象打开后，主要采用以下两种操作方法从当前文件指针所指位置起读出或写入一定字节数的信息。
(1)流类对象.read（字符指针，读出字节数）。
(2)流类对象.write（字符指针，写入字节数）。
第1种操作方法是从流类对象所对应的文件中当前文件指针所指的字节位置起顺序读出一定字节数的内容送入由字符指针所指定的内存空间中，若读取成功则返回非0值，否则返回0值。第2种操作方法是向流类对象所对应的文件中当前文件指针所指的字节位置起顺序写入由内存字符指针所指向的一定字节数的内容。
从文件中读出或向文件中写入一个数据、一个字符或一定字节数的内容后，文件指针将自动后移一个数据、一个字符或一定字节数的位置。若需要随机地读写文件中从任何字节位置（文件中的字节从0开始编号）开始的信息，则首先必须使文件指针移动到那里。用于移动文件指针的函数如下。
(1)流类对象.seekg（pos,origin）。
(2)流类对象.seekp（pos,origin）。
第1种函数用于移动输入流或输入/输出文件中的文件指针，第2种函数用于移动输出文件中的文件指针。参数origin给出移动文件指针的参考位置，它为下列3种情况之一：ios::beg、ios::cur和ios::end，它们表示的参考位置分别为文件开始（即第0字节位置）、文件指针当前位置和文件结尾（即最后一个字节后的位罝）。参数origin可以省略，默认为文件开始位置。参数pos为一个整数，当为正时表示从参考位置起向右（即向后）移动的字节数，当为负时表示从参考位置起向左（即向前）移动的字节数。使用下面两个函数可以从输入或输出文件中返回文件指针的当前位置。
(1)流类对象.tellg()。
(2)流类对象.tellp()。
程序1-12是把从键盘上输入的文本原封不动地写入到A盘上wr1.dat文件中。当按Ctrl+Z键时表示输入的是文件结束符EOF,文本输入到此结束。
//程序1-12.cpp
include<iostream.h>
include<stdlib.h>
include<fstream.h>
voidmain()
charch;
ofstreamof1("a:wr1.dat");
ch=cin.get();
while(ch!=EOF)
of1.put(ch);
ch=cin.get();
of1.close();
将上面程序中的第9条赋值语句和第10条while循环语句改写为下面一条语句也是正确的。
while(cin.get(ch))of1.put(ch);
程序1-13以输入方式打开刚在A盘上建立的wr1.dat文件，把文件中的全部内容输出到屏幕，统计出文件中所含文本的行数，最后显示出文件长度（即所含字符数，向文件写入一个换行符时，实际上是同时写入回车和换行两个控制字符）和行数。
//程序1-13.cpp
include<iostream.h>
include<stdlib.h>
include<fstream.h>
voidmain()
ifstreamif1("a:wr1.dat",ios::nocreate);
if(!if1)
cout<<"filenotopen!";
exit(1);
charch;
inti=0;
if1.get(ch);
while(ch!=EOF)
cout<<ch;
```cpp
if(ch=='n')i=i+1;
if1.get(ch);
cout<<endl<<if1.tellg()<<endl;
if1.close();
cout<<i+1<<endl;//加1表示文件结束符所在的行
在程序中,表达式if1.get(ch)可替换为ch=if1.get(),表达式ch!=EOF可替换为!if1.eof()。
section1.4.3函数
在C/C++语言中，一个程序由若干个功能相对独立的函数模块所组成，其中必有一个定名为main的主函数模块。程序执行时将自动从主函数模块开始，其余为一般函数模块。主函数模块可以调用其他函数模块，其他函数模块之间也可以相互调用。允许一个函数（除主函数外）直接或间接地调用自身，这种情况称为直接或间接递归调用。
一个函数可以不返回任何值，此时函数类型被定义为void。对这种函数的调用只能作为函数语句使用。一个函数也可以返回一个简单或记录类型的值，此时函数类型被定义为一种简单类型（如int、int、char、char等）或记录类型（如student、person等），对这种函数的调用不能作为左值使用，只能作为右值使用。一个函数还可以返回一个简单类型或记录类型的引用，此时函数类型被定义为一种类型后缀引用说明符&（如int&、student&等），对这种函数的调用既可以作为左值使用，也可以作为右值使用。
程序1-14包含有一个主函数和3个重载的find函数，为了使它们在具有相同参数个数和类型的情况下重载，改变了参数之间的次序，使其各不相同。这3个find重载函数都是从数组b[n]中顺序查找找出pnum域的值为k（即k所指向的字符串）的元素，但返回值各不相同。int类型的find函数返回其元素的下标，若查找失败则返回n值；pupil型的find函数返回其元素的指针（即存储地址），若查找失败则返回空值NULL；pupil&型的find函数返回其元素的引用，这样可对被返回的变量赋值，若查找失败则显示错误信息后结束运行。
在主函数中，首先定义数组a[PN]，并为其赋初值，每个元素值为pupil类型的学生记录，包括学号和分数，如第1个学生的学号为010203，分数为78；接着按行显示出数组a中每个元素的值；再接着定义一个待修改的学生记录x，其学号为020101，其分数修改值为98；然后根据从键盘上输入的数字1、2和3决定调用哪一个find函数查找与x记录的学号相同的元素，从而对该元素进行修改；主函数最后又显示出数组a中每个元素的值，从显示结果可以看到，a[2]元素被修改了。
//程序1-14.cpp
include<iostream.h>
include<string.h>
include<stdlib.h>
constintPN=5;
structpupilcharpnum[8];intgrade;;
intfind(pupilb[],intn,chark);
```
pupilfind(intn,pupilb[],chark);
pupil&find(chark,pupilb[],intn);
voidmain()
pupila[PN]=(“010203”,78),(“010204”,92),(“020101”,85),
(“020301”,63),“040502”,87);
inti;
for(i=0;i<PN;i++)
cout<<a[i].pnum<<”“<<a[i].grade<<endl;
pupilx=(“020101”,98);
cout<<”请输入你的选择(1,2,3)?”;
cin>>i;
switch(i)
case1:
i=find(a,PN,x.pnum);
if(i<PN)a[i]=x;
elsecout<<x.pnum<<”notfound!”<<endl;
break;
case2:
pupilp;
p=find(PN,a,x.pnum);
if(p!=NULL)p=x;
elsecout<<x.pnum<<”notfound!”<<endl;
break;
case3:
find(x.pnum,a,PN)=x;
for(i=0;i<PN;i++)
cout<<a[i].pnum<<”“<<a[i].grade<<endl;
intfind(pupilb[],intn,chark)
for(inti=0;i<n;i++)
if(strcmp(b[i].pnum,k)==0)returni;
returni;
pupilfind(intn,pupilb[],chark)
for(inti=0;i<n;i++)
if(strcmp(b[i].pnum,k)==0)return&b[i];
returnNULL;
```cpp
pupil&find(chark,pupilb[],intn)
for(inti=0;i<n;i++)
if(strcmp(b[i].pnum,k)==0)returnb[i];
cerr<<k<<"notfound!"<<endl;
exit(1);
该程序运行结果如下。
01020378
01020492
02010185
02030163
04050287
请输入你的选择(1,2,3)?1
01020378
01020492
02010198
02030163
04050287
一个C++语言函数可以不带任何参数，此时函数名后的圆括号内为空，或使用void关键字表示；也可以带有一个或多个参数，它们被依次列到函数名后的圆括号内。函数中所带的每一个参数可分为值参数和引用参数两种方式，当在说明一个形参的类型说明符后带有引用说明符“&”时，则该形参被说明为引用参数，不带有引用说明符“&”时则被说明为值参数。对于函数中的值参数，它可以被说明为任何一种类型，包括任一种简单类型、任一种结构类型，还可以为一种函数类型，而对于引用参数，则可以被说明为除了数组类型和函数类型之外的任何类型。
函数中的值参数从调用该函数的实际参数中得到相应的值，值参数具有自己的存储空间，其内容的改变不会影响到对应的实际参数；引用参数从调用该函数的实际变量参数中得到其存储位置，这样引用参数和实际变量参数具有同一存储位置用于存储其内容，在函数执行过程中对引用参数的读写操作实际上就是对相应实参变量的读写操作，所以说对引用参数的改变将反映给对应的实参变量。
注意：当值参数为一个指针变量时，虽然对指针变量的值的改变不会影响对应的实参变量，但对指针变量所指存储位置中的内容的修改将影响到实参变量所指存储位置中的内容，因为形参指针变量和实参指针变量所指向的存储位置相同。例如，对于数组就是采用按值传送的，即传送实参的数组名的值（它是数组存储空间的首地址）给形参的数组名，这样对形参数组中元素的访问就是对实参数组中对应元素的访问。
程序1-15中的主函数依次调用了3个函数，其中fun1函数中的参数均为int型值参数，fun2函数中的参数均为int型引用参数，fun3函数中的参数均为int指针型值参数。根据程序和运行结果进行分析，从中体会参数的不同传送方式的作用。
```
```cpp
//程序1-15
include<iostream.h>
include<iomanip.h>
voidfun1(inta,intb);
voidfun2(int&a,int&b);
voidfun3(intp1,intp2);
voidmain()
intx=5,y=10;
cout<<"按值传送情况:"<<endl;
cout<<"main:"<<setw(10)<<"x="<<setw(3)<<x
<<setw(10)<<"y="<<setw(3)<<y<<endl;
fun1(x,y);
cout<<"main:"<<setw(10)<<"x="<<setw(3)<<x
<<setw(10)<<"y="<<setw(3)<<y<<endl;
cout<<endl;
cout<<"引用传送情况:"<<endl;
cout<<"main:"<<setw(10)<<"x="<<setw(3)<<x
<<setw(10)<<"y="<<setw(3)<<y<<endl;
fun2(x,y);
cout<<"main:"<<setw(10)<<"x="<<setw(3)<<x
<<setw(10)<<"y="<<setw(3)<<y<<endl;
cout<<endl;
cout<<"按值传送指针的情况:"<<endl;
cout<<"main:"<<setw(10)<<"x="<<setw(3)<<x
<<setw(10)<<"y="<<setw(3)<<y<<endl;
fun3(&x,&y);
cout<<"main:"<<setw(10)<<"x="<<setw(3)<<x
<<setw(10)<<"y="<<setw(3)<<y<<endl;
voidfun1(inta,intb)
a=a+b;
b=2a+3b;
cout<<"fun1:"<<setw(10)<<"a="<<setw(3)<<a
<<setw(10)<<"b="<<setw(3)<<b<<endl;
voidfun2(int&a,int&b)
a=a+b;
b=2a+3b;
cout<<"fun2:"<<setw(10)<<"a="<<setw(3)<<a
<<setw(10)<<"b="<<setw(3)<<b<<endl;
```
voidfun3(intp1,intp2)
p1+=p2;
p2-=1;
cout<<"fun3:"<<setw(10)<<"p1="<<setw(3)<<p1
<<setw(10)<<"p2="<<setw(3)<<p2<<endl;
该程序运行结果如下。
按值传送情况:
main:x=5y=10
fun1:a=15b=60
main:x=5y=10
引用传送情况:
main:x=5y=10
fun2:a=15b=60
main:x=15y=60
按值传送指针的情况:
main:x=15y=60
fun3:p1=75p2=59
main:x=75y=59
在程序1-16的swap函数中，使用了函数参数，该函数的函数名为p，不返回值，并带有两个整型值参。当调用swap函数时，其实参表中与函数形参对应的应是一个实际的函数名，并且该函数的原型应当与形参函数说明完全相同。在该程序的主函数中调用了swap函数，其实参数名print的值（即为该函数代码区的首址）将被传送给对应的形参数名p，这样在swap函数执行中对p函数的调用实际上就是对print函数的调用，因为执行的是print函数的代码。
//程序1-16
include<iostream.h>
voidswap(int&x,int&y,voidp(int,int));
voidprint(inta,intb);
voidmain()
intx=5,y=10;
swap(x,y,print);
print(x,y);
voidswap(int&x,int&y,voidp(int,int))
inttemp;
p(x,y);
temp=x;x=y;y=temp;
p(x,y);
voidprint(inta,intb)
cout<<a<<""<b<<endl;
该程序的运行结果如下。
510
105
105
section1.4.4运算符重载
在C++语言中,为满足应用的需要,允许对大多数运算符进行重载。经常需要使用的是在自定义的记录类型上对关系运算符进行重载,使得记录同记录之间、记录同其中一个域类型的数据之间也能够进行比较。假定一种记录类型为:
structpupilcharpnum[8];intgrade;;
下面是对具有pupil类型的两个记录进行相等运算符(==)重载的函数,通过比较两个记录中的pnum域的值是否相等来判断这两个记录是否相等,若相等则返回true,否则返回false。
booloperator==(pupilr1,pupilr2)
if(strcmp(r1.pnum,r2.pnum)==0)returntrue;
elsereturnfalse;
下面是对具有pupil类型的一个记录和一个字符串进行相等运算符(==)重载的函数,若记录中的pnum域的值等于一个给定的字符串,则认为它们相等,应返回true,否则认为它们不等,应返回false。
booloperator==(pupilr,charkey)
if(strcmp(r.pnum,key)==0)returntrue;
elsereturnfalse;
对于pupil类型的两个记录,若要由grade域的大小来决定这两个记录的大小,则进行大于运算符(>)重载的函数如下。
intoperator>(pupilr1,pupilr2)
returnr1.grade>r2.grade;
当r1记录的grade域的值大于r2记录的grade域的值时则返回1,表示r1>r2,否则返回0,表示r1<=r2。
在上面进行的大于运算符重载中，若一个参数为记录，另一个参数为整型数时，则重载函数如下:
intoperator>(pupilr,intkey)
returnr.grade>key;
在一个程序中使用以上运算符重载函数后，下面的各表达式都是合法的，其中假定ra和rb为pupil类型的对象，key为char或int类型的对象。
ra==rb;//若ra和rb的pnum域相等则返回真(1)，否则返回假（0）
ra==key;//若ra的pnum域等于key则返回真，否则返回假
ra>rb;//若ra的grade域值大于rb的grade域值则返1，否返0
ra>key;//若ra的grade域值大于key值则返回1，否则返回0
程序1-17是从pupil类型的数组a[5]中分别查找出学号为020301的记录和分数为最大的记录。
//程序1-17.cpp
include<iostream.h>
include<string.h>
structpupilcharpnum[8];intgrade;;
booloperator==(pupilr1,pupilr2)
if(strcmp(r1.pnum,r2.pnum)==0)returntrue;
elsereturnfalse;
booloperator==(pupilr,charkey)
if(strcmp(r.pnum,key)==0)returntrue;
elsereturnfalse;
intoperator>(pupilr1,pupilr2)
returnr1.grade>r2.grade;
intoperator>(pupilr,intkey)
returnr.grade>key;
voidmain()
pupila[5]="010203",78,"010204",92,"020101",85,
"020301",63,"040502",87;
```cpp
inti;
cout<<"查找出学号为020301的学生记录:"<endl;
charp="020301";
for(i=0;i<5;i++)
if(a[i].pnum==p)break;
if(i<5)cout<<a[i].pnum<<""<a[i].grade<<endl;
elsecout<<p<<"对应的记录没找到!"<endl;
cout<<"求出分数最高的学生记录:"<endl;
pupilb=a[0];
for(i=1;i<5;i++)
if(a[i]>b)b=a[i];
cout<b.pnum<<""<b.grade<<endl;
该程序运行后的打印结果为:
查找出学号为020301的学生记录:
02030163
求出分数最高的学生记录:
01020492
第2章 线 性 表

\section*{2.1 线性表的定义和抽象数据类型}

\subsection*{2.1.1 线性表的定义}

线性表（linear list）是具有相同属性的数据元素的一个有限序列。该序列中所含元素的个数称为线性表的长度，用$n$表示，$n \geq 0$。当$n=0$时，表示线性表是一个空表，即表中不包含任何元素。设序列中第$i$个元素为$a_i (1 \leq i \leq n)$，则线性表的一般表示为：$(a_1, a_2, \cdots, a_i, a_{i+1}, \cdots, a_n)$其中$a_1$为第1个元素，又称作表头元素，$a_2$为第2个元素，$a_n$为最后一个元素，又称作表尾元素。

一个线性表可以用一个标识符来命名，如用$A$命名上面的线性表，则$A=(a_1, a_2, \cdots, a_i, a_{i+1}, \cdots, a_n)$线性表中的元素通常是按照元素值或关键字有序排列的。也就是说，线性表中的元素是按照前后位置线性有序的，即第$i$个元素$a_i$在逻辑上是第$i-1$个元素$a_{i-1}$的后继，是第$i+1$个元素$a_{i+1}$的前驱，其中第1个元素$a_1$没有前驱，最后一个元素$a_n$没有后继。线性表是一种线性结构，用二元组表示为：$\text{linear\_list} = (A, R)$其中，$A=\{a_i | 1 \leq i \leq n, n \geq 0, a_i \in \text{ElemType}\}$R=\{r\}$r=\{\langle a_i, a_{i+1} \rangle | 1 \leq i \leq n-1\}$对应的逻辑图如图2-1所示。

\n(图2-1 线性表的逻辑结构示意图)

线性表中使用的元素类型ElemType是一种通用数据类型标识符，可以通过typedef语句在使用前把它定义为任何一种具体类型。若把它定义为整数类型，则为：

typedef int ElemType;

由线性表的定义可知，线性表的长度是可变的，当向线性表中插入一个元素时，其长度就增加1，当从线性表中删除一个元素时，其长度就减少1。

线性表是一种线性结构，反过来，任何线性数据结构都可以用线性表的形式表示出来，

这只要按照元素之间的逻辑关系把它们顺序排列即可。如对于第 1 章中列举的线性数据结构 linearity 可用线性表表示为:$(05,01,03,08,02,07,04,06,09,10)$因此，以后对线性表的讨论就代表了对任何线性数据结构的讨论。

在日常生活中所见到的各种各样的表都是线性表，如人事档案表、职工工资表、学生成绩表、图书目录表和列车时刻表等。这些表通常都是以关键字段（又称域或属性）的值的升序排列，如职工工资表按职工号字段的升序排列，学生成绩表按学生号字段的升序排列，列车时刻表按开出时间字段的升序排列。在一个线性表中若存在着按值的升序或降序排列的字段，则称该字段为有序字段，该线性表为有序表，否则若不存在任何有序字段，则为无序表。如对于一个字符串或由一篇文章所建立的文本文件，它也是一个线性表，其元素类型为字符，它们只是按照前后位置有序，而不是按照每个字符的 ASCII 码有序，所以为无序表。

下面给出几个线性表的具体例子：

B=('a','b','c','4','7','+','-','*','/')

C=(25,38,12,49,63,54,20,18,34,47)

D=("BASIC","PASCAL","FORTRAN","COBOL","VC++","JAVA")

E=("序号","姓名","性别","年龄","单位","职称","联系电话","E-mail")

F=(a,b,c,d,e,f,g,h,i,j,k,x,y,z)

其中 B 中的元素为字符型；C 中的元素为整型；D 中的元素为字符串型；E 中的元素也为字符串型；F 中的元素可为任何类型，它同上面线性表 A 中的元素一样，每个元素都是用标识符抽象表示的，其目的是便于做一般性的考虑。

再如，对于第 1 章表 1-1 和表 1-2，若只考虑各记录之间位置上的前后关系，即按职工号的升序排列次序，则均为一个线性表，每个线性表中的元素均为相应的记录类型。

\subsection{2.1.2 线性表的抽象数据类型}

线性表的抽象数据类型包括数据和操作两个部分。数据部分为一个线性表，假定用标识符 L 表示，它可以采用顺序、链接、散列、索引等任一种方法存储到计算机中，其存储类型用标识符 ListType 表示。操作部分为对线性表所做的各种操作（运算），包括：向线性表插入一个元素、从线性表中删除一个元素、求线性表长度、判断线性表是否为空等。在下面定义的线性表抽象数据类型中，只给出了对线性表的一些基本的和典型的操作，因为线性表的实际应用是丰富和广泛的，所以不可能也没有必要给出其所有操作。

ADT LinearList is

Data:

一个具有 ListType 类型的线性表 L

Operation:

void InitList(ListType &L); //初始化 L 为空

void ClearList(ListType &L); //清除 L 中的所有元素

int LengthList (ListType &L); //返回 L 的长度

bool EmptyList(ListType &L); //判断 L 是否为空
ElemType GetList(ListType &L, int pos); //返回 L 中第 pos 个元素的值
void TraverseList(ListType &L); //遍历输出 L 中的所有元素
bool FindList(ListType &L, ElemType& item); //从 L 中查找并返回元素
bool UpdateList(ListType &L, const ElemType& item); //修改 L 中元素
bool InsertList(ListType &L, ElemType item, int pos); //向 L 插入元素
bool DeleteList(ListType &L, ElemType& item, int pos); //从 L 删除元素
void SortList(ListType &L); //对 L 中的所有元素重新按给定条件排序
end LinearList

在上面对面线性表 L 的运算中，第3~7种运算不需要改变线性表的状态，所以在其参数说明前可以使用 const 保留字，拒绝在函数体中对线性表的修改，以保证数据的安全性，其余运算需要在函数体中改变线性表，所以不能使用此保留字。在插入运算中，item 参数用来保存待插入的元素，pos 参数用来给定插入条件，人为约定当$pos \geq 1$同时$pos \leq n+1$时，则把 item 插入到线性表中第 pos 个位置上，其中 n 表示线性表长度；当$pos = -1$时，则把 item 插入到线性表的末尾位置，即最后一个元素的后面位置；当$pos = 0$时，则把线性表看作有序表，item 被插入后仍保持有序。在删除运算中，item 参数用来保存待删除元素的值或某个域的值，并保存和返回被删除元素的完整值，pos 参数用来给定删除条件，人为约定当$pos \geq 1$同时$pos \leq n$时，则删除线性表中第 pos 个位置上的元素并通过 item 参数返回值；当$pos = -1$时，则删除线性表中的表尾元素，即最后一个元素并通过 item 参数返回值；当$pos = 0$时，则删除线性表中第一个值或某个域的值等于 item 的元素并通过 item 参数返回值。

\subsection*{2.1.3 操作举例}

【例 2-1】设线性表 L1=(25,38,19,42,33)，i=2, x=60, y=42，则对 L1 的一组操作及结果如下。

LengthList(L1); //返回 L1 的长度 5
EmptyList(L1); //L1 非空，返回 false
GetList(L1,i); //返回 L1 中第 i 个元素的值，因 i=2，所以返回值 38
InsertList(L1,x,6); //向 L1 末尾插入 x，L1 变为 (25,38,19,42,33,60)
InsertList(L1,54,1); //向 L1 表头插入元素 54，L1 变为 (54,25,38,19,42,33,60)
DeleteList(L1,y,0); //删除 L1 中值为 y 的元素，L1 变为 (54,25,38,19,33,60)
DeleteList(L1,y,3); //删除 L1 中第 3 个元素，L1 变为 (54,25,19,33,60)
SortList(L1); //L1 被改变为 (19,25,33,54,60)
InsertList(L1,35,0); //插入 35 后 L1 变为 (19,25,33,35,54,60)

【例 2-2】课程（course）记录的结构为：

struct course {
char Cname[20]; //课程名称
int Chour; //开课学时
int Cterm; //开课学期
}

以课程记录为元素类型的一个线性表 L2, 如表 2-1 所示。

表 2-1 课程计划安排表

| 课程名称 | 开课学时 | 开课学期 | 课程名称 | 开课学时 | 开课学期 |
| --- | --- | --- | --- | --- | --- |
| 高等数学 | 90 | 1 | 计算机组成原理 | 90 | 2 |
| 离散数学 | 72 | 2 | 程序设计基础 | 63 | 3 |
| 英语 | 72 | 1 |  |  |  |

对 L2 进行的一组操作如下，首先定义具有 course 记录结构的 x、y、z 和 w 对象并对其赋初值。

course$x=\left(" ", 72\right)$; //给$x$的 Chour 域赋初值 72
course$y=$("程序设计基础"); //给 y 的 Cname 域赋初值"程序设计基础"
course$z=\left(" \text { 英语", } 80,1\right)$; //给 z 赋初值$\left(" \text { 英语", } 80,1\right)$course$w=\left(" \text { 数据结构", } 72,4\right)$; //给 w 赋初值$\left(" \text { 数据结构", } 72,4\right)$GetList(L2,3); //返回值为 ("英语",72,1)
FindList (L2,x); //查找与$x$中开课学时相等的第一个元素并由$x$返回
//为了实现课程记录之间的直接比较, 需要事先重载等于
//号运算符, 使其实际上是在 Chour 域上进行比较
FindList (L2,y); //查找与$y$值中课程名称相等的第一个元素并由$y$返回
//为了实现课程记录之间的直接比较, 也需要重载等于
//号运算符, 使其实际上是在 Cname 域上进行比较
UpdateList (L2,z); //用$z$更新 L2 中课程名称为"英语"的第一个元素, 使
//得该元素被修改为 ("英语",80,1)。在此函数体中若进行
//记录之间的直接比较, 则也需要事先重载等于号运算符,
//使其实际上是进行课程名称之间的比较
InsertList (L2,w,6); //在 L2 末尾添加了一条 w 记录
DeleteList (L2,y,0); //从 L2 中删除与$y$的 Cname 域值相等的第一条记录,
//即删除 L2 中的第 5 条记录 ("程序设计基础",63,3)
SortList (L2); //假定按开课学时的升序排列, 则排序后的结果如表 2-2 所示

表 2-2 对 L2 操作后的结果

| 课程名称 | 开课学时 | 开课学期 | 课程名称 | 开课学时 | 开课学期 |
| --- | --- | --- | --- | --- | --- |
| 离散数学 | 72 | 2 | 高等数学 | 90 | 1 |
| 数据结构 | 72 | 4 | 计算机组成原理 | 90 | 2 |
| 英语 | 80 | 1 |  |  |  |

\section*{2.2 线性表的顺序存储和操作实现}

\subsection*{2.2.1 线性表的顺序存储结构}

线性表的存储结构有顺序、链接、索引、散列等多种方式, 顺序存储结构是其中最简单、最常见的一种。线性表的顺序存储结构可叙述为: 将线性表中的所有元素按照其逻辑

顺序依次存储到计算机存储器中的从指定存储位置开始的一块连续的存储空间中，线性表中的第一个元素的存储位置就是被指定存储空间中的开始存储位置，第$i$个元素$(2 \leq i \leq n)$被紧接着存储在第$i-1$个元素的存储位置的后面。

设线性表的元素类型为 ElemType，则每个元素所占用存储空间的大小（即字节数）为 sizeof(ElemType)，整个线性表所占用存储空间的大小为$n \times$sizeof(ElemType)，第$i$个元素的存储位置为$a + (i - 1) \times$sizeof(ElemType)，其中$n$表示线性表的长度，$1 \leq i \leq n$，$a$为整个线性表占用的存储空间的开始位置。

在 C/C++语言中，定义了一个数组就定义了一块可供用户使用的连续存储空间，该存储空间的起始位置就是由数组名表示的地址常量。因此，线性表的顺序存储结构是利用数组来实现的，数组的基本类型就是线性表中元素的类型，数组的大小（又称数组长度，它等于数组中包含的元素个数，亦即存储元素的位置数）要大于等于线性表的长度。线性表中的第 1 个元素被存储在数组的起始位置，即下标为 0 的位置上，第 2 个元素被存储在下标为 1 的位置上，以此类推，第$n$个元素（即最后表尾元素）被存储在下标为$n-1$的位置上。用具有 ElemType 类型的数组 list[MaxSize]存储线性表$A=(a_1, a_2, \cdots, a_i, a_{i+1}, \cdots, a_n)$，则$A$所对应的顺序存储结构如图 2-2 所示。

\begin{tabular}{c|c}
\hline 下标位置 & 数组（线性表）存储空间 \\
\hline 0 &$a_1$\\
\hline 1 &$a_2$\\
\hline$\vdots$&$\vdots$\\
\hline$i-1$&$a_i$\\
\hline$i$&$a_{i+1}$\\
\hline$\vdots$&$\vdots$\\
\hline$n-1$&$a_n$\\
\hline$\vdots$&$\vdots$\\
\hline MaxSize-1 & \\
\hline
\end{tabular}

图 2-2 线性表的顺序存储结构示意图

数组 list 下标的上界 MaxSize 决定了所有线性表的最大长度，当线性表的长度大于 MaxSize 时，其尾部多余的元素将无法被存储，发生这种情况时需要重新分配存储空间，使得 MaxSize 的值更大一些。

在定义一个线性表的顺序存储类型时，需要定义一个数组来存储线性表中的所有元素和定义一个整型变量来存储线性表的长度。假定数组用 list[MaxSize]表示，整型变量用 size 表示，则元素类型为 ElemType 的线性表的顺序存储类型可描述为：

ElemType list[MaxSize];
int size;

为了便于进行线性表的操作，可以把用于存储线性表元素的数组和存储线性表长度的变量统一说明在一个记录类型中，设该记录类型用 List 表示，则定义如下。

struct List {
    ElemType list[MaxSize];
};

int size;
};

若要对存储线性表的数组空间采用动态分配，并且其数组长度能够按需要增加，则可以定义出如下的 List 类型:

struct List {
    ElemType *list;                 //存线性表元素的动态存储空间的指针
    int size;                       //存线性表长度
    int MaxSize;                    //规定 list 数组的长度
};

当初始化此类型的一个线性表时，要使 list 指针指向大小为 MaxSize 的动态数组空间。

\subsection*{2.2.2 顺序存储下的线性表操作的实现}

在顺序存储方式下，在线性表抽象数据类型中所列出的每一个操作的具体实现如下。

\section*{1. 初始化线性表}

初始化线性表需要完成动态存储空间的初始分配，并且把线性表置为空。

void InitList(List &L)
{
    //初始定义数组长度为 10, 以后可增减, 或者附加一个形参给定初始数组长度
    L.MaxSize=10;
    //动态存储空间分配
    L.list=new ElemType[L.MaxSize];
    if(L.list==NULL) {
        cout<<"动态可分配的存储空间用完, 退出运行!"<<endl;
        exit(1);
    }
    //置线性表长度为 0, 即为空表
    L.size=0;
}

此算法中的 if 语句用于判断动态分配是否成功，若成功 L.list 指针非空，若分配失败，即系统中没有存储空间可供动态分配，则 L.list 指针值为空。当分配失败时通过执行此语句退出程序运行。现在计算机系统中，操作系统功能强大，内存和外存空间都能够用于动态存储分配，所以通常不会出现动态存储分配失败的情况。所以，在编程时通常省略对动态存储分配失败情况的处理语句。在此情况下，若出现动态存储分配失败，系统会自动停止运行程序。

\section*{2. 删除线性表中的所有元素，使之成为一个空表}

此操作需要释放动态存储空间，并且把线性表的长度置 0。

void ClearList(List &L)
{
    if(L.list!=NULL) {
        delete []L.list;
        L.list=NULL;
    }
    L.MaxSize=0;
    L.size=0;
}

3. 得到线性表的长度

int LengthList(List &L)
{
    return L.size;
}

4. 检查线性表是否为空

bool EmptyList(List &L)
{
    return L.size==0;
}

若线性表L为空，则返回真，否则返回假。

5. 得到线性表中指定序号为$pos$的元素

ElemType GetList(List &L, int pos)
{
    if(pos<1 || pos>L.size)          //若pos越界则退出程序
    {
        cerr<<"pos is out range!"<<endl;
        exit(1);
    }
    return L.list[pos-1];            //返回线性表中第$pos$个元素的值
}

若所给的$pos$值不存在越界问题，则可直接使用表达式$L$.list[$pos$-1]从线性表$L$中取出第$pos$个元素。如要取出线性表$L$中第5个元素，则表示为$L$.list[4]。

6. 遍历一个线性表

遍历一个线性表就是从线性表的第1个元素起，按照元素之间的逻辑顺序，依次访问每一个元素，并且每个元素只被访问一次，直到访问完所有元素为止。在顺序存储方式下，线性表中元素之间的存储顺序与其逻辑顺序相同，因为一个元素的后继元素被紧接着存储在该元素所在位置的下一个存储位置上。若一个元素在数组存储空间中的存储位置为下标

$i$, 则它的后继元素的存储位置必为下标$i+1$。所以遍历一个线性表就是依次访问 list[0]~ list[n-1]中的每一个元素，并且每个元素仅被访问一次。当访问一个元素时，可根据需要作任意处理，在我们的算法中且以打印该元素的值代之。若线性表中的元素类型为记录类型，则打印元素的值需要有对该类型重载插入操作符（$<$）函数的支持。

void TraverseList(List &L)
{
    for(int i=0; i<L.size; i++)
        cout<<L.list[i]<<' ';
    cout<<endl;
}

当然，对于记录类型，若在此函数的 cout 输出语句中是依次输出元素的每一个域的值，而不是把元素作为整体输出，则不需要重载插入操作符。

7. 从线性表中查找具有给定值的第 1 个元素

bool FindList(List &L,ElemType& item)
{
    for(int i=0; i<L.size; i++)
        if(L.list[i]==item){
            item=L.list[i];
            return true;
        }
    return false;
}

当从线性表 L 中查找到与 item 的值或某个域的值相等的元素时，则由 item 返回该元素的整体值，并由该函数返回真，表明查找成功，否则由函数返回假，表明查找失败。

当元素类型 ElemType 为记录类型时，调用此函数必须要有对该类型进行等于号 ($==$) 重载的支持，若没有，则应该修改 if 条件表达式，使比较在相应的域上进行，并且此域必须为简单数据类型。另外，若用于比较的元素类型或某个域的类型为字符串，则需要使用字符串比较函数 strcmp，因为使用等于号直接比较的是指针的值，而不是比较所指的字符串。如当 ElemType 为字符串类型 (char*) 时，if 条件表达式应修改为：

(strcmp(L.list[i],item)==0)

8. 更新线性表中具有给定值的第 1 个元素

bool UpdateList(List &L, const ElemType& item)
{
    for(int i=0; i<L.size; i++)
        if(L.list[i]==item){
            L.list[i]=item; //进行修改（更新）赋值操作
            return true;
        }
}

return false;
}

该函数与 FindList 函数的定义类似, FindList 函数是在查找成功后由 item 带回元素的值, 而 UpdateList 函数是在查找成功后, 用 item 的值修改元素的值。

在线性表查找和更新算法中, 运行时间主要取决于比较元素的次数, 当第 1 个元素 list[0] 等于待查找或更新的元素时, 则只需要比较一次就结束操作, 对应的时间复杂度为$O(1)$, 这是最好的情况; 当前$n-1$元素比较均不成立, 只有比较到最后一个元素 list[$n-1$] ($n$为线性表的长度 L.size) 才等于待查找或更新的元素时, 则需要经过$n$次比较完成操作, 对应的时间复杂度为$O(n)$, 这是最差的情况: 当元素值互不相同, 并且都有相同的概率$\left(\text { 即平均概率 } \frac{1}{n}\right)$等于待查找或更新的元素时, 则需要比较元素的平均次数为$\frac{1}{n} \sum_{i=1}^{n} i=\frac{n+1}{2}$, 对应的时间复杂度为$O(n)$, 这是平均情况。当经过依次同线性表中所有$n$个元素比较后, 仍找不到与给定值相等的元素, 则表明查找失败, 算法执行 return false 语句后结束, 此种情况下的时间复杂度同样为$O(n)$。所以无论查找成功或失败, 顺序查找线性表的时间复杂度均为$O(n)$。

\section*{9. 向线性表中按给定条件插入一个元素}

当该函数的 pos 参数为 0 时, 则需要实现在有序表上的插入, 并且要保证插入新元素后仍为一个有序表。在有序表上查找插入位置最简单和常用的方法是顺序比较法, 它从第 1 个元素起, 依次取出每一个元素同待插入的元素 item 进行比较, 当 item 小于某一个元素的值时比较结束, 此元素位置就是 item 的插入位置。若比较到表尾后仍满足不了条件, 表明 item 大于所有元素, 则应把 item 插入到表尾, 成为新的表尾元素。另外, 当元素类型为记录时, 则必须对该类型进行小于号重载后才能实现 item<L.list[i] 的直接比较。

例如, 一个有序表为 A = (25,36,40,48,55,72,83), 当向其中插入 16 时, 其插入位置为表头, 即第 1 个元素 25 的位置; 当向其中插入 50 时, 其插入位置为 55 元素的位置; 当向其中插入 92 时, 其插入位置在表尾, 即最后一个元素 83 的后面位置。

当该函数的 pos 参数等于 -1 , 要求把 item 插入到线性表的表尾, 即第 L.size+1 个元素的位置上。

当该函数的 pos 参数为大于等于 1 , 同时小于等于线性表长度加 1 时, 则直接把 item 插入到线性表的第 pos 个元素的位置上。

在线性表的第 pos 个元素的位置插入一个新元素前, 还要检查存储线性表的动态数组空间是否具有空闲位置, 若没有, 则要扩大原有的空间。

为了实现在第 pos 个元素的位置插入新元素, 还要把从该位置开始的其后所有元素均后移一个位置, 以使空出第 pos 个元素的位置, 用于写入新元素。

完成插入后, 要使线性表的长度域增 1 , 然后返回真结束算法。

根据以上分析编写出此算法如下。

bool InsertList(List &L, ElemType item, int pos)
{

```cpp
//检查 pos 值是否有效, 若无效则无法插入, 返回假
if(pos<-1 || pos>L.size+1) {
    cout<<"pos 值无效!"<<endl; return false;
}
//求出按值有序插入时 item 的插入位置, 使之保存到 pos 中
int i;
if(pos==0) {
    for(i=0; i<L.size; i++)
        if(item<L.list[i]) break;
    pos=i+1; //pos 中保存新插入的元素的序号
}
//得到表尾插入位置, 被保存在 pos 中
else if(pos==-1) pos=L.size+1;
//若线性表存储空间用完, 则重新分配大一倍的存储空间
if(L.size==L.MaxSize) {
    int k=sizeof(ElemType); //计算每个元素存储空间的长度
    L.list=(ElemType*)realloc(L.list, 2*L.MaxSize*k);
    //线性表动态存储空间扩展为原来的 2 倍, 原内容不变
    if(L.list==NULL) {
        cout<<"动态可分配的存储空间用完, 退出运行!"<<endl;
        exit(1);
    }
    L.MaxSize=2*L.MaxSize; //把线性表空间大小修改为新的长度
}
//待插入位置及所有后续位置元素, 从后向前依次后移一个位置
for(i=L.size-1; i>=pos-1; i--)
    L.list[i+1]=L.list[i];
//把 item 的值赋给已空出的、下标为 pos-1 的位置, 它为第 pos 个元素位置
L.list[pos-1]=item;
//线性表长度增 1
L.size++;
//返回真表示插入成功
return true;
}

在这个算法中, 运行时间主要花费在第 2 步为寻找插入位置所需的比较元素的次数和第 5 步为空出插入位置所需的移动元素的次数。新元素插入的下标位置为$i$, 则元素的比较次数为$i+1$次, 元素的移动次数为$n-i$次 ($n$为线性表的长度$L$.size), 两者相加为$n+1$次。也就是说, 当进行有序插入时, 不管新元素插入在什么位置上, 进行元素比较和移动的总次数不变, 均为$n+1$, 当进行按位置插入时, 只需要考虑移动元素的次数, 在插入所有位置概率相等情况下, 平均移动次数为$\frac{1}{n+1}\sum_{i=0}^{n}(n-i)=\frac{n}{2}$, 所以此算法的时间复杂度为$O(n)$。特殊地, 当规定在表尾插入时, 其时间复杂度为$O(1)$。
```

10. 从线性表中删除符合给定条件的第 1 个元素

此算法同插入元素的算法类似，具体描述如下。

bool DeleteList(List &L, ElemType& item, int pos)
{
    //检查线性表是否为空，若是则无法删除，返回假
    if(L.size==0) {
        cout<<"线性表为空，删除无效!"<<endl;
        return false;
    }
    //检查 pos 值是否有效，若无效则无法删除，返回假
    if(pos<-1 || pos>L.size) {
        cout<<"pos 值无效!"<<endl; return false;
    }
    //求出按值删除时 item 的删除位置，使之保存到 pos 中
    int i;
    if(pos==0) {
        for(i=0; i<L.size; i++)
            if(item==L.list[i]) break;
        if(i==L.size) return false; //无元素可删返回假
        pos=i+1;
    }
    //得到被表尾元素的序号，被保存在 pos 中
    else if(pos==-1) pos=L.size;
    //把被删除元素的值赋给变参 item 带回
    item=L.list[pos-1];
    //将待删除元素位置后面的所有的元素，从前向后依次前移一个位置
    for(i=pos; i<L.size; i++)
        L.list[i-1]=L.list[i];
    //线性表长度减 1
    L.size--;
    //若线性表存储空间空余太多，则进行适当缩减
    if((float)(L.size)/L.MaxSize<0.4 && L.MaxSize>10) {
        int k=sizeof(ElemType); //计算每个元素存储空间的长度
        L.list=(ElemType*)realloc(L.list, L.MaxSize*k/2);
        //线性表动态存储空间缩减为原来的一半
        L.MaxSize=L.MaxSize/2; //把线性表空间大小修改为新的长度
    }
    //返回真表示删除成功
    return true;
}

在这个算法中，运行时间主要花费在第 3 步为寻找删除元素位置所需的比较元素的次数和第 6 步为填补删除元素位置所需的移动元素的次数上。被删除元素的下标位置为$i$，

则元素的比较次数为$i+1$次, 元素的移动次数为$n-i-1$次 ($n$为线性表的长度 L.size), 两者相加为$n$次。也就是说, 当进行按值删除时, 不管删除什么位置上的元素, 进行元素比较和移动的总次数不变, 均为$n$, 当进行按位置删除元素时, 只需要考虑移动元素的次数, 在删除所有位置上元素概率相等情况下, 平均移动次数为$\frac{1}{n} \sum_{i=0}^{n-1}(n-i-1)=\frac{n-1}{2}$, 所以此算法的时间复杂度为$O(n)$。特殊地, 当规定删除表尾元素时, 其时间复杂度为$O(1)$。

11. 对线性表进行排序

对线性表进行排序就是按照元素的值或某个域的值的升序 (或降序) 排列元素, 使之成为一个有序表。对顺序存储的线性表 (数组) 进行排序的方法很多, 本小节只介绍一种简单的插入排序方法, 其他方法将在第 10 章中专门讨论。

插入排序的方法是: 把线性表 list[0]~list[n-1]中共$n$个元素看作一个有序表和一个无序表, 开始时有序表中只有一个元素 list[0] (一个元素总是认为是有序的), 无序表中含有$n-1$个元素 list[1]~list[n-1], 以后每次从无序表中取出第 1 个元素, 把它插入到前面有序表中的合适位置, 使之成为一个新的有序表, 这样有序表就增加了一个元素, 无序表就减少了一个元素, 经过$n-1$次后, 有序表中含有$n$个元素, 无序表变为一个空表, 整个线性表就成为了一个有序表。

如何在第$i$次$(1 \leq i \leq n-1)$把无序表中的第 1 个元素 list[i]插入到前面有序表 list[0]~list[i-1]中呢? 一种方法是: 从有序表表尾元素 list[i-1]开始, 依次向前使每一个元素 list[j]$(0 \leq j < i-1)$同 x (用来临时保存 list[i]的值) 进行比较, 若 x<list[j], 则把 list[j]后移一个位置, 直到 x>=list[j]或 j<0 为止, 此时已空出的下标为$i+1$的位置就是 x 的插入位置, 把 x 的值插入到 list[j+1]即可。

假定一个线性表为(42,65,80,74,28,44,36,65), 则插入排序的过程, 如图 2-3 所示, 其中中括号内表示每次排序后得到的有序表, 中括号后面为待排序的无序表。$\begin{array}{lllllllll}0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ \hline 42 & 65 & 80 & 74 & 28 & 44 & 36 & 65\end{array}$(1) [42 65] 80 74 28 44 36 65

(2) [42 65 80] 74 28 44 36 65

(3) [42 65 74 80] 28 44 36 65

(4) [28 42 65 74 80] 44 36 65

(5) [28 42 44 65 74 80] 36 65

(6) [28 36 42 44 65 74 80] 65

(7) [28 36 42 44 65 65 74 80]

图 2-3 线性表插入排序过程

用 C++语言描述插入排序算法如下。

void SortList(List &L) //对L中的所有元素重新按给定条件排序
{
    int i, j;

ElemType x;
for(i=1; i<L.size; i++) //共循环 n-1 次
{
    x=L.list[i]; //把无序表中的第 1 个元素暂存 x
    for(j=i-1; j>=0; j--) //向前顺序进行比较和移动
        if(x<L.list[j]) L.list[j+1]=L.list[j];
        else break;
    L.list[j+1]=x; //把 x 写入到已经空出的 j+1 位置
}

在插入排序中，共需要进行$n-1$次元素的插入，每次插入最少需比较一次和移动两次元素，最多需比较$i$次和移动$i+2$次元素，平均需比较$\frac{i+1}{2}$次和移动$\frac{i}{2}+2$次元素。若分别用$C_{\min}$、$C_{\max}$和$C_{\text{ave}}$表示元素的总比较次数的最小值、最大值和平均值，用$M_{\min}$、$M_{\max}$和$M_{\text{ave}}$表示元素的总移动次数的最小值、最大值和平均值，则它们的值分别为:$\begin{aligned}
& C_{\min}=\sum_{i=1}^{n-1} 1=n-1 \\
& C_{\max}=\sum_{i=1}^{n-1} i=\frac{1}{2} n(n-1) \\
& C_{\text{ave}}=\sum_{i=1}^{n-1} \frac{i+1}{2}=\frac{1}{4}\left(n^{2}+n-2\right)
\end{aligned}$$\begin{aligned}
& M_{\min}=\sum_{i=1}^{n-1} 2=2(n-1) \\
& M_{\max}=\sum_{i=1}^{n-1}(i+2)=\frac{1}{2}\left(n^{2}+3 n-4\right) \\
& M_{\text{ave}}=\sum_{i=1}^{n-1}\left(\frac{i}{2}+2\right)=\frac{1}{4}\left(n^{2}+7 n-8\right)
\end{aligned}$所以插入排序算法在最好情况下的时间复杂度为$O(n)$，在平均和最差情况下的时间均为$O(n^2)$。

利用现成的向线性表插入元素的 InsertList 算法，也可以很方便地编写出 SortList 排序算法。该算法需要首先定义一个临时线性表并进行初始化，接着将形参线性表 L 中的每一个元素通过 InsertList 算法依次插入到临时线性表中，最后把临时线性表赋给 L。用 C++语言描述如下。

void SortList (List & L)
{
    List a;
    InitList(a);
    for(int i=0; i<L.size; i++)
        InsertList(a, L.list[i],0);
    ClearList(L);
    L=a;
}

该算法的时间复杂度同上面插入排序算法相同，均为$O(n^2)$。
调试上述算法的程序如下。

#include<iostream.h>
#include<stdlib.h>
typedef int ElemType;

struct List {
    ElemType *list;          //存线性表元素的动态存储空间的指针
    int size;                //存线性表长度
    int MaxSize;             //规定 list 数组的长度
};

//添加上面介绍的 11 个算法

void main()
{
    int a[12]={3,6,9,12,15,18,21,24,27,30,33,36};
    int i; ElemType x;
    List t;
    InitList(t);
    for(i=0;i<12;i++) InsertList(t,a[i],i+1);
    InsertList(t,48,13);InsertList(t,40,0);
    cout<<GetList(t,4)<<' '<<GetList(t,9)<<endl;
    TraverseList(t);
    cout<<"输入待查找的元素值：";
    cin>>x;
    if(FindList(t,x)) cout<<"查找成功!"<<endl;
    else cout<<"查找失败!"<<endl;
    cout<<"输入待删除元素的值：";
    cin>>x;
    if(DeleteList(t,x,0)) cout<<"删除成功!"<<endl;
    else cout<<"删除失败!"<<endl;
    for(i=0; i<6; i++)
        DeleteList(t,x,i+1);
    TraverseList(t);
    cout<<"按值插入，输入待插入元素的值：";
    cin>>x;
    if(InsertList(t,x,0)) cout<<"插入成功!"<<endl;
    else cout<<"插入失败!"<<endl;
    TraverseList(t);
    cout<<"线性表长度:"<<LengthList(t)<<endl;
    if(EmptyList(t)) cout<<"线性表为空!"<<endl;
    else cout<<"线性表不空!"<<endl;
    ClearList(t);
}

运行这个程序，得到的一次运行结果如下。

12 27
3 6 9 12 15 18 21 24 27 30 33 36 40 48
输入待查找的元素值:21
查找成功!

输入待删除元素的值:15
删除成功!
6 12 21 27 33 40 48
按值插入, 输入待插入元素的值:8
插入成功!
6 8 12 21 27 33 40 48
线性表长度:8
线性表不空!

仔细分析此结果，增强对算法的理解。

*2.3 线性表应用举例

用线性表来管理一个商品库存表。商品库存表已经保存在文本文件 a:goods.dat 中，每个商品记录包含有 4 项内容：商品代号、商品名称、最低库存量和当前库存量。商品库存表中的具体内容如表 2-3 所示。

表 2-3 商品库存表

| 商品代号 | 商品名称     | 最低库存量 | 当前库存量 |
|----------|--------------|------------|------------|
| Y-12     | toothbrush   | 10         | 25         |
| F-13     | soap         | 20         | 48         |
| W-01     | toiletpaper  | 10         | 36         |
| M-48     | towel        | 15         | 90         |
| C-24     | chinacup     | 10         | 52         |
| S-05     | schoolbag    | 5          | 20         |

可以事先通过调用下面函数在 A 盘上建立库存表文件。

void SetupGoodsFile(char* fname)
{
    ofstream ofstr(fname);              //定义输出文件流对象 ofstr
    if (!ofstr) {
        cerr<<"File 'goods' no create!"<<endl;
        exit(1);
    }
    char a[30];
    for(int i=0; i<6; i++) {
        cin.getline(a,30);
        ofstr<<a<<endl;
    }
    ofstr.close();
}

在此函数中，for 循环体每循环一次，要求从键盘上输入一条商品记录，每个域值之间

用空格分开, 最后以按下回车键结束, 该条记录被存入到字符数组 a 中, 然后被写入到文件中。

根据商品库存表中商品记录的结构, 可定义记录类型如下。

struct goods
{
    char code[5]; //商品代号
    char name[15]; //商品名称
    int minq; //最低库存量
    int curq; //当前库存量
};

通过 typedef 语句将该类型定义为线性表的通用元素类型 ElemType。

typedef goods ElemType;

在商品库存表中, 以商品代号域作为查找字段域, 则对应的重载等于号运算符的函数定义为:

bool operator ==(const ElemType& e1, const ElemType& e2)
{
    return (strcmp(e1.code,e2.code)==0);
}

同样, 在插入和排序算法中使用的小于号运算符需如下的重载函数支持:

bool operator <(const ElemType& e1, const ElemType& e2)
{
    return (strcmp(e1.code,e2.code)==-1);
}

用于打印输出使用的插入操作符也需要进行重载, 定义如下:

ostream& operator <<(ostream& ostr, const ElemType& x)
{
    ostr.setf(ios::left); //设置每个区域内按左对齐显示
    ostr<<setw(6)<<x.code<<setw(12)<<x.name;
    ostr<<setw(4)<<x.minq<<setw(4)<<x.curq<<endl;
    return ostr;
}

对商品库存表的管理就是首先把它读入到内存线性表中, 接着对它进行必要的处理,然后把处理后的结果写回到文件中。对商品库存表的处理假定包括如下选项。
(1) 打印（遍历）库存表。
(2) 按商品代号修改记录的当前库存量, 若查找到对应的记录, 则从键盘上输入其修正量, 把它累加到当前库存量域后, 再把该记录写回原有位置, 若没有查找到对应的记录,则表明是一条新记录, 应接着从键盘上输入该记录的商品名称、最低库存量和当前库存量的值, 然后把该记录追加到库存表中。

(3) 按商品代号删除指定记录。

(4) 按商品代号对库存表中的记录排序。

在顺序存储方式下对线性表的各种操作函数假定包含在 list.cpp 程序文件中, 则实现库存表管理的完整程序如下。

//程序 2-1.cpp
#include<iostream.h>
#include<stdlib.h>
#include<iomanip.h>
#include<string.h>
#include<fstream.h>

struct goods //商品记录类型
{
    char code[5];          //商品代号
    char name[15];         //商品名称
    int minq;              //最低库存量
    int curq;              //当前库存量
};

typedef goods ElemType;

struct List {
    ElemType *list;        //存线性表元素的动态存储空间的指针
    int size;              //存线性表长度
    int MaxSize;           //规定 list 数组的长度
};

bool operator >=(const ElemType& e1, const ElemType& e2)
{
    return (strcmp(e1.code,e2.code)==0);
}

bool operator <(const ElemType& e1, const ElemType& e2)
{
    return (strcmp(e1.code,e2.code)==-1);
}

ostream& operator <<(ostream& ostr, const ElemType& x)
{
    ostr.setf(ios::left);  //设置每个区域内按左对齐显示
    ostr<<setw(6)<<x.code<<setw(12)<<x.name;
    ostr<<setw(4)<<x.minq<<setw(4)<<x.curq<<endl;
    return ostr;
}

```cpp
#include"list.cpp"

void SetupGoodsList(List& L, char* fname)
{
    //把文件中所存商品表顺序读入内存线性表中以便处理
    ifstream ifstr(fname,ios::in|ios::nocreate);
    if(!ifstr) {
        cerr<<"File 'goods'not found!"<<endl;
        exit(1);
    }
    goods g;
    int i=1;
    while(ifstr>>g.code) {
        ifstr>>g.name>>g.minq>>g.curq;
        InsertList(L,g,i++);
    }
    ifstr.close();
}

void WriteGoodsFile(char* fname, List& L)
{
    //把线性表中所存的商品表重新写回到文件中
    ofstream ofstr(fname);
    if(!ofstr) {
        cerr<<"File 'goods' no create!"<<endl;
        exit(1);
    }
    goods g;
    int n=LenthList(L);
    for(int i=1; i<=n; i++){
        g=GetList(L,i);
        ofstr<<g.code<<" "<<g.name<<" "
             <<g.minq<<" "<<g.curq<<endl;
    }
    ofstr.close();
}

void main()
{
    List L2;                              //说明一个线性表 L2
    InitList(L2);                         //初始化L2
    SetupGoodsList(L2,"a:goods.dat");     //读文件到线性表
    int i,flag=1;
    while(flag)                           //当flag为真时执行循环
    {
        cout<<"1 打印整个库存表"<<endl;
        cout<<"2 修改库存表中的记录"<<endl;
}
```

cout<<"3 删除库存表中的记录"<<endl;
cout<<"4 对库存表排序"<<endl;
cout<<"5 结束处理过程"<<endl;
cout<<"输入你的选择: ";
cin>>i;
while(i<1 || i>5){
    cout<<"请重新输入选择 (1-5): ";
    cin>>i;
}
cout<<endl;
switch(i) {
case 1:
    TraverseList(L2);          //打印
    break;
case 2:                        //修改
    goods g;
    int x;
    cout<<"输入待修改的商品代号:";
    cin>>g.code;
    if(FindList(L2,g)) {
        cout<<"输入该商品的修正量:";
        cin>>x;
        g.curq+=x;
        if(UpdateList(L2,g)) cout<<"完成更新!"<<endl;
    }
else {
    cout<<"输入新商品记录的其余字段的内容:"<<endl;
    cin>>g.name>>g.minq>>g.curq;
    InsertList(L2,g,LengthList(L2)+1);
    cout<<"新记录已被插入到表尾!"<<endl;
}
break;
case 3:                       //删除
    cout<<"输入待删除商品的商品代号:";
    cin>>g.code;
    if(DeleteList(L2,g,0))
        cout<<"代号为"<<g.code<<">"的记录被删除!"<<endl;
    else cout<<"代号为"<<g.code<<">"的记录不存在!"<<endl;
    break;
case 4:                       //排序
    SortList(L2);
    cout<<"商品表中的记录已按商品代号排序!"<<endl;
    break;
case 5:                       //结束
    cout<<"本次处理结束,再见!"<<endl;

flag=0;
}
WriteGoodsFile("a:goods.dat",L2); //把线性表写回文件
}

同学们可以上机运行此程序并分析运行结果。

\section*{2.4 线性表的链接存储结构}

\section*{1. 链接存储的概念}

顺序存储和链接存储是数据的两种最基本的存储结构。在顺序存储中，每个存储结点只含有所存元素本身的信息，元素之间的逻辑关系是通过数组下标位置简单计算出来的。如在线性表的顺序存储中，若一个元素存储在对应数组中的下标位置为$i$，则它的前驱元素在对应数组中的下标位置为$i-1$，它的后继元素在对应数组中的下标位置为$i+1$。在链接存储中，每个存储结点不仅含有所存元素本身的信息，而且含有元素之间逻辑关系的信息，其存储结点（简称结点）的结构如图 2-4所示。

\begin{tabular}{|c|c|c|c|c|}
\hline data &$p_{1}$&$p_{2}$&$\cdots$&$p_{m}$\\
\hline
\end{tabular}\\\hline

图2-4 结点的结构

其中 data 表示值域，用来存储一个元素，$p_{1}, p_{2}, \cdots, p_{m}(m \geqslant 1)$均为指针域，每个指针域的值为其对应的后继元素或前驱元素所在结点（以后简称为后继结点或前驱结点）的存储位置。通过结点的指针域（又称为链域）可以访问到对应的后继结点或前驱结点，该后继结点或前驱结点称为指针域（链域）所指向（或链接）的结点。若一个结点中的某个指针域不需要指向任何结点，则令它的值为空，即数值 0，用常量 NULL 表示。

在数据的顺序存储中，由于每个元素的存储位置都可以通过简单计算得到，所以可以随机存取数据中的任一元素，对任一元素的存取时间都相同，这是一种随机存取机制；而在数据的链接存储中，由于每个元素的存储位置是保存在它的前驱结点或后继结点中的，所以只有当访问到其前驱结点或后继结点后才能够按指针访问到该结点，这是一种顺序存取机制。

数据的链接存储表示又称为链表。当链表中的每个结点只含有一个指针域时，则被称为单链表，否则被称为多链表。

\section*{2. 线性表的链接存储}

由于线性表中的每个元素至多只有一个前驱元素和一个后继元素，即数据元素之间是 1：1 的逻辑关系，所以当进行链接存储时，一种最简单也最常用的方法是：在每个结点中除包含有数值域外，只设置一个指针域，用以指向其后继结点，这样构成的链表被称为线性单向链接表，简称单向链表或单链表；另一种可以采用的方法是：在每个结点中除包

含有数值域外，设置有两个指针域，分别用以指向其前驱结点和后继结点，这样构成的链接表被称为线性双向链接表，简称双向链表或双链表。单链表和双链表都是线性链表。

设一个线性表为：$A=(a_1, a_2, \cdots, a_i, a_{i+1}, \cdots, a_n)$若分别用单链表和双链表表示，则对应的存储结构如图 2-5 所示。

(a) 单链表

(b) 双链表

图 2-5 线性表的链接存储结构示意图

每个结点的指针域同它所指向的后继结点或前驱结点用一个带箭头的线段相连接，表示该指针域的值为所指向结点的存储位置。若一个指针域的值为空（即 NULL），则在图形中通常用符号“∧”表示。由于线性表中的第 1 个元素无前驱元素，最后一个元素无后继元素，所以在对应的链接存储中，第 1 个结点的前驱指针域为空，最后一个结点的后继指针域为空。

在单链表中，由于每个结点只包含有一个指向后继结点的指针，所以当访问过一个结点后，只能接着访问它的后继结点，而无法访问它的前驱结点。在双向链表中，由于每个结点既包含有一个指向后继结点的指针，又包含有一个指向前驱结点的指针，所以当访问过一个结点后，既可以依次向后访问每一个结点，也可以依次向前访问每一个结点。

在线性表的链接存储中，存储第 1 个元素的结点称为表头结点，存储最后一个元素的结点称为表尾结点，其余为中间结点。每个链接表都需要设置一个指针指向表头结点，被称为表头指针。虽然表头指针只指向表头结点，但从表头指针出发，沿着结点的链（即指针域的值）可以依次访问到每一个结点，所以通常就以表头指针来命名一个链接表。若单链表的表头指针为 H，双链表的表头指针为 B，则可分别称它们为 H 单链表和 B 双链表。

在线性表的顺序存储中，逻辑上相邻的元素，其对应的存储位置也相邻，所以当进行插入或删除运算时，通常需要平均移动半个表的元素，这是相当费时的操作。在线性表的链接存储中，逻辑上相邻的元素，其对应的存储位置是通过指针来链接的，因而每个结点的存储位置可以任意安排，不必要求相邻，所以当进行插入或删除运算时，只需修改相关结点的指针域即可，这是既方便又省时的操作，灵活性强。由于链接表的每个结点带有指针域，因而在存储空间上比顺序存储要付出较大的代价。

3. 在单链表上的插入和删除操作

在单链表中插入和删除结点，如图 2-6 所示。

在 a 结点（即存放元素 a 的结点的简称；另外，有时也用该结点的地址称该结点，把 a 结点称为 p 结点，即 p 指针所指向的结点）的后面插入 b 结点的前后状态，其插入操作的过程如下。
(1) 将 a 结点指针域的值 q（即指向后继 c 结点的指针）赋给 b 结点的指针域。

(2) 将指向 b 结点的指针（即指针变量 s 的值）赋给 a 结点的指针域。$\cdots \rightarrow$p$\rightarrow$[a]$\rightarrow$q$\rightarrow$[c]$\rightarrow \cdots \quad \cdots \rightarrow$p$\rightarrow$[a]$\rightarrow$s$\rightarrow$[b]$\rightarrow$q$\rightarrow$[c]$\rightarrow \cdots$(a) 插入结点前

(b) 插入结点后

图 2-6 在单链表中插入结点的示意图

注意: 在单链表的表头插入一个新结点，则首先要吧原表头指针赋给新结点的指针域，然后再把新结点的存储位置赋给表头指针变量。

思考：在单链表的表尾插入一个新结点，情况又如何呢？它同在中间或表头插入的情况有何异同？

从单链表中删除 x 结点后面的 y 结点的前后状态，如图 2-7 所示，其删除操作的过程如下。$\cdots \rightarrow$p$\rightarrow$[x]$\rightarrow$q$\rightarrow$[y]$\rightarrow$r$\rightarrow$[z]$\rightarrow \cdots \quad \cdots \rightarrow$p$\rightarrow$[x]$\rightarrow$r$\rightarrow$[z]$\rightarrow \cdots$s$\rightarrow$[y]

(a) 删除结点前

(b) 删除结点后

图 2-7 从单链表中删除结点的示意图

(1) 将 x 结点指针域的值 q（即指向后继 y 结点的指针）赋给一个临时指针变量 s，以便处理和回收该结点。

(2) 将 y 结点的指针域的值 r（即指向后继 z 结点的指针）赋给 x 结点的指针域。

注意：从单链表中删除表头结点，则首先要把表头指针赋给一个临时指针变量，以便处理和回收该结点，然后再把原表头结点指针域的值（即指向原表头后继结点的指针）赋给表头指针变量，使其下一个结点成为新的表头结点。

思考：若从单链表中删除表尾结点，情况又如何呢？它同删除中间或表头结点的情况有何异同？

4. 单链表中的结点类型

In 单链表中，每个结点的类型用 LNode 表示，它包括存储元素的数值域，用 data 表示，其类型用通用类型标识符 ElemType 表示，还包括存储后继元素位置的指针域，用 next 表示，其类型为指向本身结点的指针类型 LNode*，则 LNode 类型的定义如下。

struct LNode
{
    ElemType data;
    LNode* next;
};

因为每个指针类型的大小等于一个整型 (int) 的大小（即 4 个字节），所以 LNode 类型的大小等于元素类型的大小 sizeof(ElemType)加上 4 个字节。若 ElemType 表示 int，则 LNode 类型的大小为 8 个字节，也就是说，每个 LNode 类型的结点（对象）占用 8 个字节的存储空间。

程序 2-2 是使用 LNode 类型的一个实例。从键盘上输入的三个数值依次为 5、10 和 8，则该程序的运行结果也是 5、10 和 8。

//程序 2-2.cpp
#include<iostream.h>
typedef int ElemType; //规定元素类型为整型
struct LNode {
    ElemType data;
    LNode* next;
}; //定义单链表结点

void main()
{
    LNode x,y,z; //定义 LNode 类型的三个结点 x, y 和 z
    LNode* p=&x; //定义 LNode 类型的指针变量 p 并初始指向 x 结点
    cin>>x.data>>y.data>>z.data; //给 x, y, z 的数值域输入数据
    x.next=&y; y.next=&z; z.next=NULL; //把 x, y, z 链接为单链表
    while(p!=NULL) { //从表头开始输出每个结点的值（即数据域的值）
        cout<<p->data<<" "; //输出指针 p 所指向的结点的值
        p=p->next; //使 p 指向链表中的下一个结点
    }
    cout<<endl;
}

程序 2-3 同上面程序 2-2 具有相同的功能，都是建立一个具有三个结点的单链表，然后再依次输出单链表中每个结点的值。但在程序 2-2 中，单链表中的每个结点为静态结点，即由静态分配所产生的结点，而在程序 2-3 中，单链表中的每个结点为动态结点，即由动态分配所产生的结点。

//程序 2-3.cpp
#include<iostream.h>
typedef int ElemType; //规定元素类型为整型
struct LNode {
    ElemType data;
    LNode* next;
}; //定义单链表结点类型

void main()
{
    LNode *p,*q,*p1;
    p1=new LNode; //动态产生结点并将其地址赋给 p 和 p1 指针
    for(int i=0; i<3; i++) {
        q=new LNode; //q 指向一个新的动态结点

```cpp
cin>>q->data; //从键盘输入一个整数赋给 q 结点的值域
p->next=q;    //将 q 结点链接到 p 结点之后
p=q;          //使 p 指针后移, 指向后继新结点 q
}
p->next=NULL;  //置链表的最后一个结点的指针域为空
p=p1->next;    //链表的表头结点为 p1 结点的指针域所指向的结点
while(p!=NULL) {
    cout<<p->data<<" "; //输出 p 结点的值, 即其数值域的值
    p=p->next;         //使 p 指向链表中的下一个结点
}
cout<<endl;
}

单链表中的结点既可以来自静态或动态产生的独立结点（如以上两个程序所示），也可以来自静态或动态产生的数组中的元素（结点），若来自数组中的结点（元素），则 next 域指向的是后继结点所在的下标，所以它应被定义为整数类型。用 ALNode 表示数组中结点的类型，则对应的定义如下。

struct ALNode{
    ElemType data;
    int next;
};

由数组中的结点构造单链表的所属数组类型可定义如下。

typedef ALNode ALinkList[MaxSize];

ALinkList 被定义为包含有 MaxSize 个元素的、元素类型为 ALNode 的数组类型。由该类型的对象（即数组）构造单链表时，通常下标为 0 的元素不作为单链表中的结点使用，而是用它的指针域保存表头指针，这样，数组最多能够提供 MaxSize-1 个结点。另外，当一个结点无后继结点时，其指针域应被赋予数值 0，表示空指针。

利用 ALinkList 类型的数组构成单链表的情况，如图 2-8 (a) 所示。表头指针为下标 0 位置中 next 域的值 4，单链表的结构示意图，如图 2-8 (b) 所示。表头指针用 f 表示，每个指针上标出的数值就是该指针的具体值。

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline data & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \(\cdots\) \\
\hline next & 4 & 3 & 8 & 6 & 7 & 2 & 0 & 5 & 1 & \\
\hline
\end{tabular}

(a) 数组构成的单链表

f$\rightarrow$44$\rightarrow$75$\rightarrow$50$\rightarrow$57$\rightarrow$62$\rightarrow$68$\rightarrow$75$\rightarrow$83$\rightarrow$94$\rightarrow$0

(b) 单链表的结构

图 2-8 利用数组建立单链表示意图
```

可以看出，该单链表中各数据元素之间的逻辑顺序如下。$44, 50, 57, 62, 68, 75, 83, 94$由数组建立一个单链表时，通常将所有空闲元素链接起来构成一个空闲单链表，空闲单链表的表头指针也需要用一个元素结点的指针域保存起来，假定使用1号（即下标为1）的指针域。在这种数组中链接存储的线性表的长度至多为MaxSize-2，因为0号和1号元素均被表头指针所占有。当对整个数组进行初始化时，不仅置单链表为空，即把0赋给0号元素的指针域，而且将全部MaxSize-2个空闲结点链接起来构成空闲单链表，同时把它的表头指针（即2）赋给1号元素的指针域。对数组进行初始化后的情况，如图2-9所示。

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline data & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & MaxSize-1 \\
\hline next & 0 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 0 \\
\hline
\end{tabular}

图2-9 空闲单链表

向数组中的单链表插入一个新元素时，首先从空闲表中取出（即删除）表头结点作为保存新元素的结点使用，然后再把该结点按条件插入到单链表中；当从数组中的单链表删除一个元素结点时，首先从单链表中取出这个结点，然后再把该结点插入到空闲单链表的表头。

数组中的元素单链表和空闲单链表的结点总数，在任何时候都等于MaxSize-2，当空闲单链表为空时，则元素单链表为满，此时无法再向它插入新结点。

例如，在下面的数组中，链接存储的线性表为(35,68,57,26,70)，空闲单链表中依次包含有3,5,8号元素结点，MaxSize=10，如图2-10所示。

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline data & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
\hline next & 4 & 3 & 6 & 5 & 2 & 8 & 9 & 0 & 0 \\
\hline
\end{tabular}

图2-10 元素和空闲单链表

5. 双向链表中的结点类型和插入与删除操作

对于双向链表也可进行以上对单链表那样的讨论，若双向链表采用独立结点构成，则结点类型定义为:

struct DNode {
    ElemType data;
    DNode* left;
    DNode* right;
};

若双向链表采用数组中的元素结点构成，则结点类型应定义为:

struct ADNode {
    ElemType data;
    int left;
    int right;
};

其中，DNode 和 ADNode 为结点类型标识符，该类型包含有 3 个域：数值域（data），左指针域（left）和右指针域（right），left 域用于指向前驱结点，right 域用于指向后继结点。

设 p 和 q 分别是具有 DNode* 类型的指针变量，若在双向链表中 p 结点之后插入一个 q 结点，则需要修改 4 个指针域的值，操作步骤如下。

(1) 使 p 结点的后继结点成为 q 结点的后继结点。

q->right=p->right;

(2) 若 p 结点有后继结点，则使 q 结点成为该结点的前驱结点。

if (p->right) p->right->left=q;

(3) 使 p 结点成为 q 结点的前驱结点。

q->left=p;

(4) 使 q 结点成为 p 结点的后继结点。

p->right=q;

插入过程如图 2-11 所示。

(a) 插入结点

(b) 插入过程

(c) 插入完成后的链接

图 2-11 在双向链表中插入结点的示意图

若删除双向链表中 p 指针所指向的结点，假定 p 结点前后都存在着结点，则只需要修改两个指针，其操作步骤如下。

(1) 修改 p 结点的前驱结点的右指针，使之指向 p 结点的后继结点。

p->left->right=p->right;

(2) 修改 p 结点的后继结点的左指针域，使之指向 p 结点的前驱结点。

p->right->left=p->left;

(3) 回收 p 结点。

delete p;

删除过程如图 2-12 所示。

(a) 删除前的状态

(b) 删除过程

(c) 删除后的状态

图 2-12 在双向链表中删除结点的示意图

6. 带表头附加结点的线性链表

在线性表的链接存储中, 为了方便在表头插入和删除结点, 使得与在其他地方所做的操作相同, 需要在表头结点 (即保存第一个元素的结点) 的前面增加一个结点, 把它称之为表头附加结点, 此时表头附加结点的指针域指向表头结点, 而表头指针由原来指向第一个元素的结点改为指向表头附加结点。仍以存储以前给出的线性表 A 为例, 如图 2-13 所示。此时单链表中指向第一个结点的指针为 H->next, 双向链表中指向第一个结点的指针为 B->right。

H$\rightarrow$\fbox{$\square$}$\rightarrow$\fbox{$a_{1}$}$\rightarrow$\fbox{$a_{2}$}$\rightarrow$\cdots$\rightarrow$\fbox{$a_{n}$}

(a) 带表头附加结点的单链表

B$\rightarrow$\fbox{$\triangle$}$\rightarrow$\fbox{$a_{1}$}$\rightarrow$\fbox{$a_{2}$}$\rightarrow$\cdots$\rightarrow$\fbox{$a_{n}$}

(c) 带表头附加结点的双向链表

H$\rightarrow$\fbox{$\square$}

(b) 带表头附加结点的空单链表

B$\rightarrow$\fbox{$\triangle$}

(d) 带表头附加结点的空双向链表

图 2-13 带表头附加结点的单链表和双向链表

7. 循环链表

在单链表中, 让表尾结点 (即最后一个结点) 的指针域指向表头结点或表头附加结点 (若采用的话); 在双向链表中, 若让表尾结点的右指针域指向表头结点或表头附加结点,而让表头结点或表头附加结点的左指针域指向表尾结点, 则就构成了循环链表。带有表头附加结点的循环单链表和循环双向链表, 如图 2-14 所示。

H$\rightarrow$\fbox{$\square$}$\rightarrow$\fbox{$a_{1}$}$\rightarrow$\fbox{$a_{2}$}$\rightarrow$\cdots$\rightarrow$\fbox{$a_{n}$}

(a) 循环单链表

B$\rightarrow$\fbox{$\square$}$\rightarrow$\fbox{$a_{1}$}$\rightarrow$\fbox{$a_{2}$}$\rightarrow$\cdots$\rightarrow$\fbox{$a_{n}$}

(c) 循环双向链表

H$\rightarrow$\fbox{$\square$}

(b) 循环单链空表

B$\rightarrow$\fbox{$\square$}

(d) 循环双向空表

图 2-14 带表头附加结点的循环单链表和循环双向链表

对于由数组元素结点构成的单链表, 其下标为 0 的元素结点的指针域保存元素单链表的表头指针, 所以该结点成为元素单链表的附加表头结点, 而元素单链表的最后一个结点的指针域为 0 表示空指针, 它正好是表头附加结点的下标, 由此构成带表头附加结点的循环单链表。空闲表的最后一个结点的指针域被置为整数 0 表示空指针, 若被置为整数 1 则可构成带表头附加结点的循环空闲表。

对于独立分配存储空间的结点, 通常由指针所指向, 若使用的指针为 p, 则*p 就表示该结点, p->data 和 p->next 就分别表示该结点的数值域和指针域。对于数组中的元素结点, 它是由数组名和下标值标识的, 假定数组名为 a, 下标值为 k, 则 a[k] 就表示该结点, a[k].data 和 a[k].next 就分别表示该结点的数值域和指针域, 元素单链表的表头指针为 a[0].next, 空闲单链表的表头指针为 a[1].next。了解独立结点和元素结点在访问上的差别后, 学会在独立结点所构成的单链表上进行各种运算的算法, 也就不难写出对元素单链表进行各种运算的算法。

\section*{2.5 线性表操作在单链表上的实现}

每个单链表都有一个表头指针, 用 HL 表示, 由表头指针可以访问到单链表中的任何结点, 所以要对单链表进行操作, 必须给出表头指针。假定以 HL 为表头指针的单链表是由 LNode 类型的动态结点所组成, 并且不带有表头附加结点, 下面给出对线性表抽象数据类型中列举的每一操作在单链表上的具体实现, 即 C++语言算法描述。

\section*{1. 初始化单链表}

void InitList (LNode* &HL)

{
    HL=NULL;                          //置单链表为空
}

\section*{2. 删除单链表中的所有结点, 使之成为一个空表}

删除单链表中的所有结点, 需要遍历单链表, 通过 delete 操作释放被访问的每一个结点所占的存储空间, 然后把表头指针置为空。

void ClearList(LNode*& HL)
{
    LNode *cp;                        //将用 cp(current pointer) 指向待处理结点
    LNode *np;                        //将用 np(next pointer) 指向 cp 的后继结点
    cp=HL;                            //表头指针赋给 cp
    while(cp!=NULL) {
        np=cp->next;                  //保存下一个结点的地址
        delete cp;                    //删除当前结点, 即被处理的结点
        cp=np;                        //使下一个结点成为当前结点
    }
    HL=NULL;                          //置单链表为空
}

3. 得到单链表的长度

由于在单链表的构成中, 没有给出单链表的长度, 所以此算法需要遍历单链表, 对被访问的结点进行计数, 最后返回计数值。

int LenthList (LNode* HL)
{
    int i=0;                          //用来统计单链表中结点的个数
    while(HL!=NULL)                  //遍历单链表, 统计结点数
    {
        i++;
        HL=HL->next;
    }
    return i;                        //返回单链表长度
}

因为该运算需要访问单链表中的每个结点, 不改变表头指针, 即不会改变单链表的状态, 所以定义表头指针 HL 为值参。对于指针值参只需要占用一个字 (即 4 个字节) 的存储空间, 它与使用引用参数传送时需要保存实参地址所需要的存储空间大小相同, 由此不会增加存储空间和传送参数值时间。对于上面第 1 和第 2 种操作, 由于需要通过函数体操作修改调用函数时的实际表头指针的值, 所以必须被定义为引用参数。

4. 检查单链表是否为空

bool EmptyList (LNode* HL)
{
    return HL==NULL;
}

5. 得到单链表中第 pos 个结点中的元素

要访问单链表中的第$pos$个结点, 必须从表头开始依次访问过该结点之前的所有结点后才能够实现, 即只能够采用顺序存取, 而不能够随机存取任一个结点。

ElemType GetList (LNode* HL, int pos)
{
    if(pos<1) {
        cerr<<"pos is out range!"<<endl;
        exit(1);
    }
    int i=0;                         //统计已遍历的结点数, i 初值为 0
    while(HL!=NULL) {               //遍历到第 pos 个结点或表为空时止
        i++;
        if(i==pos) break;
        HL=HL->next;
    }
}

if(HL!=NULL)                      //返回结点值
    return HL->data;
else {
    cerr<<"pos is out range!"<<endl;
    exit(1);
}
}

6. 遍历一个单链表

遍历一个单链表并打印出每个结点的值。

void TraverseList(LNode* HL)
{
    while(HL!=NULL) {                    //从表头开始依次输出每个结点的值
        cout<<HL->data<<" ";
        HL=HL->next;
    }
    cout<<endl;
}

7. 从单链表中查找出等于给定值的第1个元素

bool FindList(LNode* HL, ElemType& item)
{
    while(HL!=NULL)
        if(HL->data==item) {              //查找成功由 item 带回完整值
            item=HL->data;
            return true;
        }
        else HL=HL->next;                 //HL指向后继结点
    return false;
}

8. 更新单链表中等于给定值的第1个元素

bool UpdateList(LNode* HL, const ElemType& item)
{
    while(HL!=NULL)                       //查找元素
        if(HL->data==item) break;
        else HL=HL->next;
    if(HL==NULL) return false;            //没有被更新的元素，返回假
    else {
        HL->data=item;                    //更新元素
        return true;
    }
}

9. 向单链表中按给定条件插入一个元素

其插入过程如下。

(1) 判定 pos 的值, 若小于-1则表明 pos 值无效, 返回假。

(2) 为新插入元素动态分配结点并赋值。

(3) 根据 pos 的值所表示的不同条件, 寻找新结点的插入位置, 为此需要从表头开始顺序查找新元素的插入位置, 在查找过程中必须保留当前待比较结点的地址及其前驱结点的地址, 以便插入时使用。

(4) 在插入位置上完成插入新结点操作, 即把新结点链接到当前结点和前驱结点之间。若插入的位置为表头, 则需要做特殊处理。

bool InsertList (LNode* &HL, ElemType item, int pos)
{
    //pos 值小于-1返回假
    if(pos<-1) {
        cout<<"pos 值无效!"<<endl; return false;
    }
    //为 item 元素建立新结点
    LNode* newptr;
    newptr=new LNode;
    newptr->data=item;
    //寻找新结点的插入位置
    LNode* cp=HL;                   //用 cp 指向当前结点(即待查结点), 初始指向表头
    LNode* ap=NULL;                 //用 ap(ahead pointer)指向 cp 的前驱结点, 初始为空
    if(pos==0) {                    //按值寻找插入位置
        while(cp!=NULL) {
            if(item<cp->data) break;        //找到新元素插入位置,退出循环
            else {
                ap=cp;                      //ap 和 cp 指针均后移,实现顺序向后比较
                cp=cp->next;
            }
        }
    }
    else if(pos==-1)                  //查找表尾位置
        while(cp!=NULL) {ap=cp; cp=cp->next;}
    else {                            //按序号 pos 的值寻找插入位置
        int i=0;
        while(cp!=NULL) {
            i++;
            if(i==pos) break;         //找到新元素插入位置,退出循环
            else {
                ap=cp; cp=cp->next;
            }
        }
    }
}

```cpp
if(cp==NULL && i+1<pos) {
    cout<<"pos 值超出单链表长度加 1!"<<endl;
    return false;
}
//完成新结点插入操作
if(ap==NULL) {
    newptr->next=HL; //把新结点插入到表头
    HL=newptr;
} else {
    //把新结点插入到非表头位置，即插入到 ap 和 cp 结点之间
    newptr->next=cp; //cp 指针也可能为空,此时为表尾
    ap->next=newptr;
}
return true;
}

10. 从单链表中删除符合给定条件的第 1 个元素

删除算法的执行步骤如下。
(1) 若单链表为空则返回假。
(2) 若 pos 值小于-1 时则返回假。
(3) 根据 pos 的值所表示的条件从单链表中查找被删除的结点，为此需要从单链表中顺序查找，直到查找成功或失败为止。在查找过程中需要保留待比较的当前结点和前驱结点的地址，以便删除结点时使用。
(4) 删除查找到的结点，对表头结点和非表头结点要做不同处理。
(5) 回收被删除结点的存储空间。
(6) 删除成功返回真。

bool DeleteList(LNode* &HL, ElemType& item, int pos) //从L删除元素
{
    //单链表为空，无法删除，返回假
    if(HL==NULL){
        cerr<<"单链表为空，删除操作无效!"<<endl;
        return false;
    }
    //pos 值小于-1 返回假
    if(pos<-1) {
        cout<<"pos 值无效!"<<endl; return false;
    }
    //寻找被删除的元素结点
    LNode* cp=HL; //用 cp 指向当前结点 (即待查结点)，初始指向表头
    LNode* ap=NULL; //用 ap(ahead pointer)指向 cp 的前驱结点，初始为空
    if(pos==0) { //按值查找被删除结点
```

```cpp
while(cp!=NULL) {
    if(item==cp->data) break;  //找到被删除结点 cp,退出循环
    else {
        ap=cp;
        cp=cp->next;
    }
}
if(cp==NULL) {
    cout<<"单链表中没有相应的结点可删除!"<<endl;
    return false;
}

else if(pos==-1)
    while(cp->next!=NULL) {ap=cp; cp=cp->next;}
else {
    int i=0;
    while(cp!=NULL) {
        i++;
        if(i==pos) break;  //找到被删除结点 cp,退出循环
        else {
            ap=cp;
            cp=cp->next;
        }
    }
    if(cp==NULL) {
        cout<<"pos 值无效!"<<endl; return false;
    }
}
//删除 cp 所指向的结点
if(ap==NULL) HL=HL->next;  //删除表头结点
else ap->next=cp->next;  //删除非表头结点,也可以是表尾结点
//回收被删除结点的存储空间
delete cp;
//删除成功返回真
return true;

11. 对单链表进行数据排序

假定待排序的单链表由表头指针 HL 所指向，对结点值按照从小到大次序进行排序链接时，首先建立一个空的单链表，然后把 HL 中的每个结点取出并按值依次插入到新建立的单链表中，最后由引用参数 HL 带回新建单链表的表头指针。下面就是对单链表进行的插入排序算法。

void SortList(LNode* &HL)
{
```

```c
//建立一个反映排序结果的新单链表并初始化为空
LNode* SL;
InitList(SL);
//从待排序的HL单链表中依次取出每个结点,按值插入到新单链表中
LNode* r=HL;                          //r指向待取出排序的一个结点,初始为HL表头结点
while(r!=NULL) {
    //为新插入的r结点在SL中顺序查找找出插入位置
    LNode* t=r->next;                 //t指向r的后继结点
    LNode* cp=SL;                     //用cp初始指向SL单链表的表头
    LNode* ap=NULL;                   //用ap指向cp的前驱结点,初始为空
    while(cp!=NULL) {
        if(r->data<cp->data) break;   //找到被插入点,退出循环
        else {
            ap=cp;                    //ap和cp指针均后移,实现顺序向后比较
            cp=cp->next;
        }
    }
    //实现插入操作
    if(ap==NULL) {
        r->next=SL;                   //把r结点插入到表头
        SL=r;
    }
    else {
        r->next=cp;                   //把r结点插入ap和cp结点之间
        ap->next=r;                   //cp可能为空,则r成为SL的表尾
    }
    //使r指向原单链表的下一个结点
    r=t;
}
//由引用参数带回新单链表的表头指针
HL=SL;
}

在上面对单链表进行的11种操作算法中，第1、4种算法的时间复杂度为$O(1)$；第2、3及5~10种算法的时间复杂度为$O(n)$；第11种算法的时间复杂度为$O(n^2)$。若只在单链表的表头插入或删除结点，其时间复杂度均为$O(1)$。上述每个算法的空间复杂度均为$O(1)$。由于对单链表的插入和删除元素的操作只进行元素的比较，不进行元素的移动，而对顺序存储的线性表操作既需要元素的比较，又需要元素的移动，所以当处理的数据量较大，同时每个数据占用的字节数较多时，在相同数量级的情况下，顺序表操作往往比单链表操作要花费更多的时间。

要上机调试上述对单链表操作的算法，只要对本章第2节的调试程序稍加修改即可。主要是把顺序表List类型定义替换为LNode结点类型定义，把主函数中的表对象t的类型List替换为LNode*。

对于由数组中元素结点构成的单链表，其操作算法与上述独立结点构成的单链表的情
```

况类似, 下面仅给出初始化单链表、按值插入元素和按值删除元素的算法, 其他算法不难由同学们写出。

(1) 初始化单链表。

void InitList(ALinkList AL) //参数说明等同于 ALNode AL[MaxSize]

{

//将循环单链表置空,下标 0 结点为表头附加结点

AL[0].next=0;

//结点依次链接构成空闲链接表

for(int i=2; i<MaxSize-1; i++)

AL[i].next=i+1;

//将带表头附加结点的空闲链接表的最后结点的指针域置空

AL[MaxSize-1].next=0;

//下标为 1 结点的指针域指向空闲链接表的第 1 个结点

AL[1].next=2;

}

(2) 向有序单链表按值插入一个元素。

bool InsertList (ALinkList AL, const ElemType& item)

{

int newptr;

newptr=AL[1].next; //从空闲表中取出表头结点

if(newptr==0) {

cerr<<"没有空闲结点可用!"<<endl;

return false;

}

AL[1].next=AL[newptr].next; //空闲表的第 2 个结点成为新的表头结点

AL[newptr].data=item; //item的值赋给被插结点的值域

int ap, cp;

ap=0; cp=AL[0].next; //分别给 ap 和 cp 赋初值

while(cp!=0) //查找新结点的插入位置

if(item<AL[cp].data) break;

else {

ap=cp; cp=AL[cp].next;

}

AL[newptr].next=cp; //插入时不用特殊处理表头情况

AL[ap].next=newptr;

return true;

}

(3) 从单链表中删除等于给定值的第 1 个元素。

bool DeleteList(ALinkList AL, ElemType& item)

{

//单链表为空, 无法删除元素, 返回假

if(AL[0].next==0) {
    cerr<<"Linkedlist is an empty!"<<endl;
    return false;
}
//查找被删除的结点及前驱结点
int ap, cp;
ap=0; cp=AL[0].next;
while(cp!=0)
    if(AL[cp].data==item) break;
    else {ap=cp; cp=AL[cp].next;}
//若不存在被删除的元素则返回假
if(cp==0){
    cerr<<"Deleted element is not exist!"<<endl;
    return false;
}
//从单链表中删除查找到的下标为 cp 的结点，不用特殊考虑表头情况
AL[ap].next=AL[cp].next;
//把删除的结点插入到空闲表的表头
AL[cp].next=AL[1].next;
AL[1].next=cp;
//删除成功返回数值假
return false;

*2.6 多项式计算

\subsection{2.6.1 多项式表示与求值}

多项式表示与求值是线性表应用的一个典型实例。
由数学知识可知，一个多项式$P(x)$的一般表示为：$P(x)=a_0+a_1x^1+a_2x^2+\cdots+a_nx^n$其中，$n$为整数，$n \geqslant 0$，$a_n \neq 0$，$a_0 \sim a_{n-1}$中的每个系数可以为 0，也可以不为 0。

\section{1. 多项式的第 1 种线性表表示与运算}

为了处理$P(x)$，可把所有项的系数用一个线性表来表示：$(a_0, a_1, a_2, \cdots, a_n)$把这个线性表用顺序存储结构或链接存储结构保存起来，就可以进行多项式的有关运算。若采用顺序存储结构，对应的 List 类型的对象为 P，其中 P.list[] 按 x 指数的升序存储相应的系数，即存储上面线性表，P.size 存储多项式中的项数，它等于 x 的最高次幂加 1，则求此多项式值的算法描述如下。

double PolySum1(List& P, double x)
{
    //用sum计算累加和，首先把常数项$a_0$的值赋给它作为其初值
    double sum=P.list[0];
    //用w计算$x$的次幂，初值为1
    double w=1;
    //累加计算多项式的值
    for(int i=1; i<P.size; i++) {
        w*=x;                          //计算出$x$的$i$次幂
        sum+=P.list[i]*w;              //把一个新项$a_i x^i$的值累加到sum中
    }
    //返回求出的多项式的值
    return sum;
}

若多项式线性表采用链接存储结构，则求值算法描述如下。

double PolySum1(LNode* P, double x)
{
    LNode *t=P;                        //用t指向多项式单链表的表头结点
    double sum=t->data;                //用sum计算累加和，初值为常数项$a_0$的值
    double w=1;                        //用w计算$x$的次幂，初值为1
    t=t->next;                         //t指向第二个结点，即值为$a_1$的结点
    while(t!=NULL) {
        w*=x;                          //使w累乘$x$sum+=t->data*w;                //把一个新项的值累加到sum中
        t=t->next;                     //使t指向下—个结点
    }
    return sum;                        //返回求出的多项式的值
}

假定一个多项式为$5+3x^2-6x^3+2x^5$，对应的线性表为$(5,0,3,-6,0,2)$，若采用链接存储，计算程序如下。

#include<iostream.h>
#include<stdlib.h>
typedef double ElemType;
struct LNode {
    ElemType data;                     //定义单链表结点类型
    LNode* next;
};

//单链表有关操作的函数定义

void main()
{

```cpp
LNode* a;
InitList(a);
ElemType r[6]={5,0,3,-6,0,2};
int i;
for(i=5; i>=0; i--) InsertList(a,r[i],1);
cout<<"线性表a:";
TraverseList(a);
cout<<"线性表长度:"<<LengthList(a)<<endl;
double y=PolySum1(a,2);
cout<<"x值为2时的多项式值:"<<y<<endl;
ClearList(a);
}
```

在主函数的 for 语句中，按$r$数组元素排列的逆序依次在单链表的表头插入，正好能够得到按指数升序链接的单链表。这样建立的单链表，其时间复杂度为$O(n)$。若把数组$r$中的元素依次插入到单链表的表尾，其建立成的单链表的时间复杂度为$O(n^2)$。此程序的运行结果为：

线性表 a:5 0 3 -6 0 2
线性表长度:6
x 值为 2 时的多项式值:33

\section*{2. 多项式的第 2 种线性表表示与运算}

在一个多项式中，往往会出现许多缺项。如$P(x)=1+6x^5-3x^{12}+7x^{60}$，其中只有 4 项，缺少 57 项，或者说 57 项的系数均为 0。若仍采用上述定义形式的线性表，将浪费存储空间和运算时间，是不可取的。为此，通常采用另一种形式的线性表来表示，该线性表中的每个元素对应多项式中的一个非零项，每个元素包含两个域：系数域（coef）和指数域（exp），用来分别表示对应项的系数和$x$的指数，并且线性表中的元素应按照指数的升序排列，它是按指数有序的一个有序表。$P(x)$多项式的这种线性表表示为：$(\{1,0\},\{6,5\},\{-3,12\},\{7,60\})$将线性表中的元素类型定义为 Term 结构类型，则描述为：

```cpp
struct Term {
    double coef;        //系数
    int exp;            //指数
};
```
通过使用如下的定义语句将 Term 类型与通用的线性表元素类型 ElemType 对应起来。

```cpp
typedef Term ElemType;
```

利用顺序存储结构存储这种线性表的多项式求值的算法如下。

```cpp
double PolySum2(List& P, double x)
{
```

```cpp
//给作为累加变量的 sum 赋初值为 0
double sum=0;
//累加计算多项式的值
for(int i=0; i<P.size; i++) {
    int y=P.list[i].exp;                      //把一个新项的 x 的指数赋给 y
    sum+=P.list[i].coef*pow(x,y);             //把新项的值累加到 sum 中
}
//返回所求结果
return sum;
}

在函数中使用的 pow(x,y)是求$x$的$y$次幂的函数, 该函数定义在 math.h 头文件中。利用链接存储结构存储这种线性表的多项式求值的算法如下。

double PolySum2(LNode* P, double x)
{
    LNode *t=P;
    double sum=0;
    while(t!=NULL) {
        int y=t->data.exp;
        sum+=t->data.coef*pow(x,y);
        t=t->next;
    }
    return sum;
}

用下面程序来调用求顺序存储的多项式值的算法。由于把结构类型 Term 作为线性表中的元素类型 ElemType 使用, 所以在整个程序中必须包含相应的运算符重载函数的定义,使得元素之间的小于、等于、插入等运算是有效的。当然不通过运算符重载也是可行的,则需要修改相应操作的算法, 使之进行比较的是元素的某个域的值 (如 exp 域的值), 而不是整个元素值, 依次输出元素的每个域的值, 而不是整个结构元素的值。

#include<iostream.h>
#include<stdlib.h>
#include<math.h>
struct Term {
    double coef;                   //系数
    int exp;                       //指数
};
typedef Term ElemType;
struct List {
    ElemType *list;                //存线性表元素的动态存储空间的指针
    int size;                      //存线性表长度
    int MaxSize;                   //规定 list 数组的长度
};
```

bool operator !=(const ElemType& e1, const ElemType& e2)
{
    return e1.exp!=e2.exp;
}
bool operator <(const ElemType& e1, const ElemType& e2)
{
    return e1.exp<e2.exp;
}
ostream& operator <<(ostream& ostr, const ElemType& x)
{
    ostr<<x.coef<<' '<<x.exp<<' ';
    return ostr;
}

#include"list.cpp"               //该程序文件保存着对线性表各种操作的算法

double PolySum2(List& P, double x)
{   //如上面给出的函数定义
}

void main()
{
    List a1,a2;
    InitList(a1); InitList(a2);
    Term r1[4]={{5,0},{3,2},{-6,3},{2,5}};
    Term r2[4]={{1,0},{6,5},{-3,12},{7,60}};
    int i;
    for(i=0; i<4; i++)           //把r1中的每个元素依次插入线性表a1的表尾
        InsertList(a1,r1[i],-1);
    for(i=0; i<4; i++)           //把r2中的每个元素依次插入线性表a2的表尾
        InsertList(a2,r2[i],-1);
    cout<<"线性表a1:";
    TraverseList(a1);
    cout<<"线性表a2:";
    TraverseList(a2);
    double y1=PolySum2(a1,2);
    double y2=PolySum2(a2,2);
    cout<<y1<<' '<<y2<<endl;
    ClearList(a1); ClearList(a2);
}

执行这个程序得到的结果为:

线性表a1:5 0  3 2  -6 3  2 5
线性表a2:1 0  6 5  -3 12  7 60
33 8.07045e+018

2.6.2 两个多项式相加

下面以多项式的链接存储结构为例讨论两个多项式$P_1$和$P_2$相加的算法，返回它们的和多项式。

两个多项式相加就是使对应项相加，若另一个多项式中没有对应项（即指数相同的项），则把它直接复制到结果中。如：
\[ P_1(x) = 5 + 3x^2 - 6x^3 + 2x^5 \]
\[ P_2(x) = 3 + 4x - 2x^2 + 3x^3 - 2x^5 + 9x^6 \]$P_1$、$P_2$的相加结果为$P_3(x) = 8 + 4x + x^2 - 3x^3 + 9x^6$。

因为每个单链表都是按指数域的值有序的单链有序表，所以此相加过程就是两个单链有序表的合并过程，当然要遵循多项式相加的合并规则。

1. 实现相加运算的第 1 种算法

设计此题的算法时，首先将两个指针 t1 和 t2 分别指向两个多项式单链表 p1 和 p2 的表头结点，并定义和初始化一个新的单链表 p3 作为结果单链表；然后当 t1 和 t2 所指结点非空时，比较它们的指针域值的大小，将较小的一个结点的值插入到 p3 单链表中，若两者相等，则将系数域的值相加，当不为零时同归一结点的指数域的值组成一个元素值插入到 p3 单链表中，让 t1 和 t2 指针后移，以便向下继续比较和处理；最后当出现有一个单链表处理结束时，把另一个单链表中未处理的每个结点的值插入到 p3 单链表中。由此得到的算法如下。

LNode* PolyAdd1(LNode* p1, LNode* p2)
{
    //定义表示结果多项式的单链表 p3 并初始化为空
    LNode* p3;
    InitList(p3);
    //分别定义 t1 和 t2 指针，初始分别指向 p1 和 p2 单链表
    LNode *t1=p1, *t2=p2;
    //当两个表同时不空时的处理过程
    while(t1 && t2) {
        //将 t1 所指结点的值按指数有序插入到 p3 单链表中，实际是插到表尾
        if(t1->data.exp<t2->data.exp) {
            InsertList(p3,t1->data,1);
            t1=t1->next;
        }
        //将 t2 所指结点的值按指数有序插入到 p3 单链表中
        else if(t2->data.exp<t1->data.exp) {
            InsertList(p3,t2->data,-1);
            t2=t2->next;
        }
        //将 t1 和 t2 所指结点的值合并后按指数有序插入到 p3 单链表中

else {
    double a=t1->data.coef+t2->data.coef;
    if(a!=0) {
        Term item={a,t1->data.exp};
        InsertList(p3,item,-1);
    }
    t1=t1->next;
    t2=t2->next;
}
//将p1单链表中的剩余结点复制到p3单链表中
while(t1!=NULL) {
    InsertList(p3,t1->data,-1);
    t1=t1->next;
}
//将p2单链表中的剩余结点复制到p3单链表中
while(t2!=NULL) {
    InsertList(p3,t2->data,-1);
    t2=t2->next;
}
//返回结果单链表的表头指针p3
return p3;
}

在这个算法中，$t1 \rightarrow data.exp < t2 \rightarrow data.exp$和$t2 \rightarrow data.exp < t1 \rightarrow data.exp$表达式也可以分别改写为$t1 \rightarrow data < t2 \rightarrow data$和$t2 \rightarrow data < t1 \rightarrow data$，因为进行两个Term结构对象小于号重载运算符函数比较的是其相应的指数域。

此算法依次扫描两个单链表中的每个结点，每次把一个结点的值或两个对应结点的合并值按指数有序插入到结果单链表中，因为每次插入的指数值都大于结果单链表中已有结点的值，所以只要依次插入到表尾即可。设两个加数多项式的单链表长度分别为$m$和$n$，则扫描过程的时间复杂度为$O(m+n)$，每次插入过程的时间复杂度也为$O(m+n)$，因为每次都插入到结果单链表的表尾，所以整个算法的时间复杂度为$O((m+n)^2)$。

\section*{2. 实现相加运算的第2种算法}

每次向结果单链表插入时不是调用插入算法InsertList，而是设法记住结果单链表的表尾结点的位置，直接把新结点链接到表尾，这样插入每个结点的时间复杂度为$O(1)$，整个算法的时间复杂度就变为$O(m+n)$，从而大大提高了算法的时间效率，算法如下。

LNode* PolyAdd2(LNode* p1, LNode* p2)
{
    //定义结果单链表p3，并让它指向附加表头结点，这会使处理方便
    LNode* p3;
    p3=new LNode;
    //分别定义t1,t2和t3指针，初始分别指向p1,p2和p3单链表

LNode *t1=p1, *t2=p2, *t3=p3;
//当两个表同时不空时的处理过程
while(t1 && t2) {
    //将t1所指结点的值赋给t3结点的值域，t1指针后移
    if(t1->data.exp<t2->data.exp) {
        t3=t3->next=new LNode;               //在p3尾部插入新结点并使t3指向它
        t3->data=t1->data;
        t1=t1->next;
    }
    //将t2所指结点的值赋给t3结点的值域，t2指针后移
    else if(t1->data.exp>t2->data.exp) {
        t3=t3->next=new LNode;
        t3->data=t2->data;
        t2=t2->next;
    }
    //将两结点合并后的值赋给t3结点的值域，t1和t2指针同时后移
    else {
        double a=t1->data.coef+t2->data.coef;
        if(a!=0) {
            Term item={a,t1->data.exp};
            t3=t3->next=new LNode;
            t3->data=item;
        }
        t1=t1->next;
        t2=t2->next;
    }
}
//将p1单链表中的剩余结点复制到p3单链表中
while(t1) {
    t3=t3->next=new LNode;
    t3->data=t1->data;
    t1=t1->next;
}
//将p2单链表中的剩余结点复制到p3单链表中
while(t2) {
    t3=t3->next=new LNode;
    t3->data=t2->data;
    t2=t2->next;
}
//将p3单链表的表尾结点的指针域置空
t3->next=NULL;
//让t3指向p3所指的附加表头结点，以便删除
t3=p3;
//使p3指向结果单链表的第1个元素结点
p3=t3->next;

```c
//释放原附加表头结点
delete t3;
//返回结果单链表的表头指针 p3
return p3;
}

算法中使用的 p3 单链表是带有表头附加结点的单链表, 这给插入运算带来方便, 不需要对空表时的插入做特殊处理, 待整个运算完成后再把附加表头结点删除, 使 p3 单链表又成为一般形式的单链表。对带有表头附加结点的单链表进行删除也同样方便, 删除表头结点和删除其他位置结点的操作完全相同, 因为始终不需要修改表头指针。

可以使用下面的主函数调用上面的多项式加法函数。

void main()
{
    LNode *a, *b;
    InitList(a);InitList(b);
    Term ra[4]={{5,0},{3,2},{-6,3},{2,5}};
    Term rb[6]={{3,0},{4,1},{-2,2},{3,3},{-2,5},{9,6}};
    int i;
    for(i=3; i>=0; i--) InsertList(a,ra[i],1); //每次插入到表头
    for(i=5; i>=0; i--) InsertList(b,rb[i],1); //每次插入到表头
    cout<<"线性表 a:";
    TraverseList(a);
    cout<<"线性表 b:";
    TraverseList(b);
    LNode *c=PolyAdd2(a,b); //或者使用 PolyAdd1(a,b)调用
    cout<<"线性表 c:";
    TraverseList(c);
    ClearList(a); ClearList(b); ClearList(c);
}

程序执行后的结果如下:

线性表 a:5 0 3 2 -6 3 2 5
线性表 b:3 0 4 1 -2 2 3 3 -2 5 9 6
线性表 c:8 0 4 1 1 2 -3 3 9 6
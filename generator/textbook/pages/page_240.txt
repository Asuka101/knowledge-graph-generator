{
    HBT.MaxSize=10;                           //初始定义数组长度为 10,以后可增减
    HBT.heap=new ElemType[HBT.MaxSize];      //动态分配存储堆的数组空间
    if(!HBT.heap) {
        cout<<"用于动态分配的内存空间用完, 退出运行!"<<endl;
        exit(1);
    }
    HBT.len=0;                                //设置 len 域的初值为 0
}

2. 清除堆

void ClearHeap(Heap&HBT)                      //清除 HBT,使之成为一个空堆
{
    if(HBT.heap!=NULL) {
        delete[] HBT.heap;
        HBT.heap=NULL;
        HBT.len=0;
        HBT.MaxSize=0;
    }
}

3. 检查一个堆是否为空

bool EmptyHeap(Heap&HBT)                      //判断 HBT 是否为空,是返真,否返假
{
    return HBT.len==0;
}

4. 向堆中插入一个元素

向堆中插入一个元素时, 首先将该元素写入到堆尾, 即堆中最后一个元素的后面, 亦即下标为$len$的位置上, 然后经调整为一个新堆。由于在原有堆上插入一个新元素后, 可能使以该元素为根的子树不为堆, 从而使整个树不为堆, 所以必须进行调整使之仍为一个堆。调整的方法很简单, 若新元素小于双亲结点的值, 就让它们互换位置; 新元素换到双亲位置后, 使得以该位置为根的子树成为堆, 但新元素可能还小于此位置的双亲结点的值, 从而使以上一层的双亲结点为根的子树不为堆, 还需要按上述方法继续调整, 这样持续传递上去, 直到以新位置的双亲结点为根的子树仍为一个堆或者调整到堆顶为止, 此时得到的整个树又成为一个堆。

对于图 6-4 (a) 所示的堆, 若向它插入一个新元素 50 时, 由于它不小于双亲结点的值 35, 所以以 35 为根的子树仍为一个堆, 从而使整个二叉树仍然是一个堆, 此次插入不需要作任何调整。插入新元素 50 后得到的堆, 如图 6-6 (a) 所示。

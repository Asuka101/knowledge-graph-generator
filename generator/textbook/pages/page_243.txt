//若条件成立则调整结束，退出循环
if (x<=HBT.heap[j]) break;
//孩子元素上移到双亲位置
HBT.heap[i]=HBT.heap[j];
//使i和j分别指向下一层结点
i=j; j=2*i+1;
}
HBT.heap[i]=x; //把待调整元素放到最终位置
return temp; //返回原堆顶元素

此算法的运行时间主要取决于 while 循环的执行次数，它等于堆顶新元素向孩子位置逐层下移的次数，此次数最多等于整个树的深度减 1，所以堆删除算法的时间复杂度同插入算法相同，均为$O(\log n)$。

在解决实际问题时，若每次只需要取出（即删除）具有最小值的元素，则适合采用堆这种数据结构，因为其插入和删除元素的时间复杂度均为$O(\log n)$。若采用线性表来实现这种功能，其插入和删除元素的时间复杂度将均为$O(n)$。

在计算机操作系统中，管理一个共享资源就需要使用一个堆，把等待使用该资源的所有用户按照优先级号组织起来，优先级最高的用户一定处于堆首位置，系统每次从这个堆中取出(删除)堆顶元素并为之服务，需要使用该资源的新用户被加入到等待使用该资源的堆中。

使用堆的一个完整程序如下，请读者阅读和分析。

#include<iostream.h>
#include<stdlib.h>
typedef int ElemType; //定义元素类型为整型
struct Heap {
    ElemType*heap; //定义堆的顺序存储类型
    int len;
    int MaxSize;
};

#include"堆运算.cpp" //假定在 heap.cpp 中保存着堆运算的各种算法

void main()
{
    int a[8]={23,56,40,62,38,55,10,16};
    Heap b; //定义一个堆b
    InitHeap(b); //初始化堆b
    int i,x;
    //向堆b中依次插入数组a中的每一个元素

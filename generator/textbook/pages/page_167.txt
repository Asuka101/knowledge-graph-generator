cout<<"对应的后缀算术表达式为: "<
cout<<b<<endl;
}
显示结果如下:
请输入一个中缀算术表达式:
12+(3*(20/4)-8)*6
对应的后缀算术表达式为:
12 3 20 4 / * 8 - 6 * +

\section*{4.6 栈与递归}

递归是一种非常重要的数学概念和解决问题的方法, 在计算机科学和数学等领域有着广泛地应用。当求解一个问题时, 是通过求解与它具有同样解法的子问题而得到的, 这就是递归。一个递归的求解问题必然包含有终止递归的条件, 当满足一定条件时就终止向下递归, 从而使最小的问题得到解决, 然后再依次返回解决较大的问题, 最后解决整个问题。解决递归问题的算法称为递归算法, 在递归算法中需要根据递归条件直接或间接地调用算法本身, 当满足终止条件时结束递归调用。当然对于一些简单的递归问题, 很容易把它转换为循环问题来解决, 从而使编出的算法更为有效。

【例4-4】采用递归算法求解正整数$n$的阶乘$(n!)$。

分析: 由数学知识可知,$n$阶乘的递归定义为: 它等于$n$乘以$(n-1)$的阶乘, 即$n!=n\times(n-1)!$,并且规定$0$的阶乘为$1$。设函数$f(n)=n!$, 则$f(n)$可表示为:$f(n)=\begin{cases} 
1 & (n=0) \\
n \times f(n-1) & (n>0)
\end{cases}$其中$n=0$为递归终止条件, 使函数返回$1$,$n>0$实现递归调用, 由$n$的值乘以$f(n-1)$的返回值, 求出$f(n)$的值。

用 C/C++语言编写出求解$n!$的递归函数如下:

long f(int n)
{
    if(n==0)
        return 1;
    else
        return n*f(n-1);
}

当从主程序或其他函数非递归调用此阶乘函数时, 首先把实参的值传送给形参$n$, 同时把调用后的返回地址保存起来, 以便调用结束后返回之用; 接着执行循环体, 当$n$等于 0 时则返回函数值 1 , 结束本次非递归调用或递归调用, 并按返回地址返回到进行本次调用的调用函数的位置继续向下执行, 当$n$大于 0 时, 则以实参$n-1$的值去调用本函数 (即递归调用), 返回$n$的值与本次递归调用所求值的乘积。因为进行一次递归调用, 传送给形

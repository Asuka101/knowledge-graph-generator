采用邻接矩阵表示图，便于查找图中任一条边或边上的权。如要查找边$(i,j)$或$<i,j>$, 则只要查找邻接矩阵中第$i$行第$j$列的元素$A[i,j]$是否为一个有效值（即非零值和非 MaxValue 值）。若该元素为一个有效值，则表明此边存在，否则此边不存在。邻接矩阵中的元素可以随机存取，所以查找一条边的时间复杂度为$O(1)$。这种存储表示也便于查找图中任一点的度，对于无向图，顶点$v_i$的度就是对应第$i$行或第$i$列上有效元素的个数；对于有向图，顶点$v_i$的出度就是对应第$i$行上有效元素的个数，顶点$v_i$的入度就是对应第$i$列上有效元素的个数。由于求任一点的度需访问对应一行或一列中的所有元素，所以其时间复杂度为$O(n)$，$n$表示图中的顶点数，即邻接矩阵的阶数。从图的邻接矩阵中查任一项点的一个邻接点或所有邻接点同样也很方便。如查找$v_i$的一个邻接点（对于无向图）或出边邻接点（对于有向图），则只要在第$i$行上查找出一个有效元素，以该元素所在的列号$j$为序号的顶点$v_j$就是所求的一个邻接点或出边邻接点。一般算法要求是依次查找出一个顶点$v_i$的所有邻接点（对于有向图则为出边邻接点或入边邻接点），此时需访问对应第$i$行或第$i$列上的所有元素，所以其时间复杂度为$O(n)$。

图的邻接矩阵的存储需要占用$n \times n$个整数存储位置（因顶点的序号为整数），所以其空间复杂度为$O(n^2)$。这种存储结构用于表示稠密图能够充分利用存储空间，但若用于表示稀疏图，则将使邻接矩阵变为稀疏矩阵，从而造成存储空间的很大浪费。

图的邻接矩阵表示，只是使用一个二维数组存储顶点之间相邻的关系，为了存储图中$n$个顶点元素的信息，通常还需要使用一个一维数组，用数组中下标为$i$的元素存储顶点$v_i$的信息。这两种数组的类型可定义如下。

const int MaxVertexNum={图的最大顶点数，它要大于等于具体图的顶点数$n$};

const int MaxEdgeNum={图的最大边数，它要大于等于具体图的边数$e$};

typedef int WeightType; //定义边的权值类型

const WeightType MaxValue={特定权值，它要大于图中所有有效权值之和};

typedef VertexType vexlist[MaxVertexNum]; //定义 vexlist 为存储顶点信息的数组类型

typedef int adjmatrix[MaxVertexNum][MaxVertexNum];

//定义 adjmatrix 为存储邻接矩阵的数组类型

图的顶点信息利用 vexlist 类型的一维数组存储后，能够根据顶点序号直接访问到相应元素，图中顶点之间的邻接关系利用邻接矩阵存储后，也能够根据任一条边的两个端点直接访问到相应元素，所以，可把它们看作是图的一种顺序存储。

\section*{1. 图的邻接矩阵存储的初始化算法}

void InitMatrix(adjmatrix GA, int k)$\{$//假定$k$等于 0 为无权图，$k$不等于 0 为有权图

int i,j;

for(i=0; i<MaxVertexNum; i++)

for(j=0; j<MaxVertexNum; j++)

if (i==j) GA[i][j]=0;

else if(k) GA[i][j]=MaxValue;

else GA[i][j]=0;$\}$

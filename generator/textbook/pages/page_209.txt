由上述分析中序遍历算法的执行过程可知，打印出的结点序列为:

C, B, D, A, E, G, F

类似地，若按照前序遍历算法和后序遍历算法遍历图 5-13 所示的二叉树，则打印出的结点序列分别为:

A, B, C, D, E, F, G 和 C, D, B, G, F, E, A

在二叉树的三种递归遍历算法中，对于每个算法都访问到了每个结点的每一个域，并且每个结点的每一个域仅被访问一次。所以其时间复杂度均为$O(n)$，$n$表示二叉树中结点的个数。另外在执行每个递归遍历算法时，系统都要使用一个栈，栈的最大深度等于二叉树的深度加 1，而二叉树的深度视其具体形态决定，若二叉树为理想平衡树或接近理想平衡树，则二叉树的深度大致为$\lceil \log_2 n \rceil$，所以其空间复杂度为$O(\log_2 n)$；若二叉树退化为一棵单支树（即最差的情况），则空间复杂度为$O(n)$，$n$同样为二叉树中的结点数。

上面所述的二叉树的遍历是按二叉树的递归结构进行的，另外，还可以按照二叉树的层次结构进行遍历，即按照从上到下、同一层从左到右的次序访问各结点。如图 5-13 所示的二叉树，按层遍历各结点的次序为:

A, B, E, C, D, F, G

按层遍历算法需要使用一个队列，开始时把整个树的根结点入队，然后每从队列中删除一个结点并输出该结点的值时，都把它的非空的左、右孩子结点入队，这样当队列空时算法结束。

4. 按层遍历算法

此算法为一个非递归算法，具体描述如下。

void LevelOrder(BTreeNode* BT)
    //按层遍历由 BT 指针所指向的二叉树
{
    const int MaxSize=30;                 //定义用于存储队列的数组长度
    BTreeNode* q[MaxSize];                //定义队列所使用的数组空间
    int front=0, rear=0;                  //定义队首指针和队尾指针，初始为空队
    BTreeNode* p;
    if(BT!=NULL) {
        rear=(rear+1)%MaxSize;
        q[rear]=BT;                       //将树根指针进队
    }
    while (front!=rear) {
        front=(front+1)%MaxSize;          //使队首指针指向队首元素
        p=q[front];
        cout<<p->data<<' ';               //输出队首元素所指结点的值
        if(p->left!=NULL) {
            rear=(rear+1)%MaxSize;
            q[rear]=p->left;              //若存在左孩子，则左孩子结点指针进队
        }

索遍历时, 需要扫描邻接表中的每个边结点, 所以其时间复杂度为$O(e)$; 两者的空间复杂度均为$O(n)$。

\section*{7.3 .2 广度优先搜索遍历}

广度优先搜索 (breadth-first search) 遍历类似于对树的按层遍历, 其过程为: 首先访问初始点$v_0$, 并将其标记为已访问过, 接着访问$v_0$的所有未被访问过的邻接点, 其访问次序可以任意, 假定依次为$v_{i1}, v_{i2}, \cdots, v_{in}$, 并均标记为已访问过, 然后再按照$v_{i1}, v_{i2}, \cdots, v_{in}$的次序, 访问每一个顶点的所有未被访问过的邻接点（次序任意）, 并均标记为已访问过, 以此类推, 直到图中所有和初始点$v_0$有路径相通的顶点都被访问过为止。

结合如图 7-12 所示的有向图 G8 分析从$v_0$出发进行广度优先搜索遍历的过程。

(1) 访问初始点$v_0$, 并将其标记为已访问过。

(2) 访问$v_0$的所有未被访问过的邻接点$v_1$和$v_2$, 并将它们标记为已访问过。

(3) 访问顶点$v_1$的所有未被访问过的邻接点$v_3$、$v_4$和$v_5$, 并将它们标记为已访问过。

(4) 访问顶点$v_2$的所有未被访问过的邻接点$v_6$（它的两个邻接点中的一个顶点$v_5$已被访问过），并将其标记为已访问过。

(5) 访问顶点$v_3$的所有未被访问过的邻接点$v_7$（只此一个邻接点且没有被访问），并将其标记为已访问过。

(6) 访问顶点$v_4$的所有未被访问过的邻接点，因$v_4$的邻接点$v_7$（只此一个）已被访问过，所以此次不访问任何顶点。

(7) 访问顶点$v_5$的所有未被访问过的邻接点$v_8$, 并将其标记为已访问过。

(8) 访问顶点$v_6$的所有未被访问过的邻接点，因$v_6$的仅一个邻接点$v_8$已被访问过，所以此次不访问任何顶点。

(9) 依次访问$v_7$和$v_8$的所有未被访问的邻接点，因它们均没有邻接点，所以整个遍历过程到此结束。

从以上对有向图 G8 进行广度优先搜索遍历的过程分析可知，从初始点$v_0$出发，得到的访问各顶点的次序为：$v_0, v_1, v_2, v_3, v_4, v_5, v_6, v_7, v_8$。

在广度优先搜索遍历中，先被访问的顶点，其邻接点亦先被访问，所以在算法的实现中需要使用一个队列，用来依次记住被访问过的顶点。算法开始时，将初始点$v_0$访问后插入队列中，以后每次从队列中删除一个元素，就依次访问它的每一个未被访问过的邻接点，并令其进队，这样，当队列为空时，表明所有与初始点有路径相通的顶点都已访问完毕，算法到此结束。下面分别以邻接矩阵和邻接表作为图的存储结构给出相应的广度优先搜索遍历的算法，在算法中使用的队列可以采用第 4 章已经给出的顺序或链接队列类型，也可以直接定义队列和进行运算操作。

\n

[图片]

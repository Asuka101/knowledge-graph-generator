少为 2, 最多为$m=7$; 每个非树根结点的关键字个数最少为$\left\lceil m / 2\right\rceil-1=\lceil 7 / 2\rceil-1=3$, 最多为$m-1=6$, 子树个数最少为$\lceil m / 2\rceil=\lceil 7 / 2\rceil-4$, 最多为$m=7$。

B_树中的结点类型定义如下。

const int m=(B_树的阶数);

struct MBNode {

int keynum;

MBNode*parent;

KeyType key[m+1];

MBNode*ptr[m+1];

int recptr[m+1];

};

若所有记录被存储在外存上一个文件中, 其中的 recptr[i]保存 key[i]对应记录在文件中的记录位置序号, 所以被定义为整型。同样该数组的下标为 0 的位置未用。

\section*{9.5 .2 B_树查找}

根据 B_树的定义, 在 B_树上进行查找的过程与在二叉搜索树上类似, 都是经过一条从树根结点到待查关键字所在结点的查找路径, 不过对路径中每个结点的比较过程比在二叉搜索树的情况下要复杂一些, 通常需要经过同多个关键字比较后才能处理完一个结点,因此, 又称 B_树为多路查找树。在 B_树中查找一个关键字等于给定值 K的具体过程可叙述为: 若 B_树非空, 首先取出树根结点, 使给定值 K依次同该结点中的每一个关键字进行比较, 直到$K \leqslant K_{i}(1 \leqslant i<n+1)$, 假定用$K_{n+1}$作为终止标志, 保存比所有关键字都大的一个特定值, 该值不妨用 MaxKey常量表示) 时为止, 此时若$K=K_{i}$, 则表明查找成功, 返回具有该关键字$K_{i}$的记录的存储位置, 否则其值为 K 的关键字只可能落在该结点的由$P_{i-1}$所指向的子树上, 接着只要在该子树上继续进行查找即可; 这样, 每取出一个结点比较后就下移一层, 直到查找成功, 或被查找的子树为空 (即查找失败) 时止。

在图 9-6的 B_树上查找值为 73 的关键字时, 首先取出树根结点 a, 因 73大于 a 中的$K_{1}$, 即 73>62, 所以再同 a 结点中的$K_{2}$比较, 因 73 必然小于$K_{2}$的值 MaxKey, 接着取出由 a 结点的$P_{1}$指针所指向的结点 c, 因 73 小于 c 结点的关键字$K_{1}$, 即 73<80, 所以再取出由 c 结点的指针$P_{0}$所指向的结点 g, 因 73 等于 g 结点的关键字$K_{2}$（即 73）, 所以查找成功, 返回关键字为 73 的那个元素的存储位置。

若以图 9-6的 B_树上查找值为 56 的关键字时, 首先取出树根结点 a, 因 56<$K_{1}$（即 62）, 所以再取出由指针$P_{0}$所指向的结点 b, 因 56 大于 b 结点的所有关键字, 但必然小于终止标志$K_{3}$（即 MaxKey）, 所以再取出由 b 结点的指针$P_{2}$所指向的结点 f, 因 56 大于该结点的$K_{1}$, 小于终止标志$K_{2}$, 所以接着向$P_{1}$子树查找, 因$P_{1}$指针为空, 所以查找失败,返回特定值（用-1 表示）。

设指向 B_树根结点的指针用 MT 表示, 待查的关键字用 K 表示, 则在 B_树上进行查找的算法描述为:

int SearchMBTree(MBNode*MT, KeyType K)

(a) 插入 50
(b) 插入 30
(c) 插入 15

图 6-6 堆的插入

对于图 6-4 (a) 所示的堆, 若向它插入一个新元素$30$, 由于它小于双亲结点的值$35$,所以需要将$30$与$35$对调位置, 对调后因新元素$30$不小于其双亲元素$18$, 所以调整结束,得到的整个二叉树为一个堆, 插入结果如图 6-6 (b) 所示。

对于图 6-4 (a) 所示的堆, 若向它插入的一个新元素为$15$, 由于它小于双亲元素$35$,所以需要将$15$与$35$对调位置, 对调后因新元素$15$小于其双亲元素$18$, 所以又需要将$15$与$18$对调位置, 此时新元素被调整到了堆顶位置, 所以调整结束, 得到的插入后结果如图 6-6 (c) 所示。

向堆中插入一个元素的算法描述如下。

void InsertHeap(Heap& HBT, ElemType item) //向小根堆 HBT 中插入元素
{
//堆满时重分配大一倍的存储空间并进行相应操作
if(HBT.len==HBT.MaxSize) {
int k=sizeof(ElemType);
HBT.heap=(ElemType*) realloc(HBT.heap, 2*HBT.MaxSize*k); //计算每个元素存储空间的长度
//堆动态存储空间扩展为原来的 2 倍, 原内容自动保持不变
if(HBT.heap==NULL) {
cout<<"动态可分配的存储用完, 退出运行!"<<endl;
exit(1);
}
HBT.MaxSize=2*HBT.MaxSize; //把堆空间大小修改为新的长度
}
//用 i 指向待调整元素的位置, 初始指向新元素所在的堆尾位置
int i=HBT.len;
//寻找新元素的最终位置, 每次使双亲元素下移一层
while(i!=0) {
int j=(i-1)/2; //j 指向下标为 i 的元素的双亲元素
if(item>=HBT.heap[j]) break; //比较调整结束退出循环
HBT.heap[i]=HBT.heap[j]; //双亲元素下移
i=j; //改变调整元素的位置为其双亲位置
}
//把新元素调整到最终位置, 并使堆的长度增 1
HBT.heap[i]=item;
HBT.len++;
}

它插入到 S 集合来实现, 这样其时间复杂度为$O(n^2)$, 其中$n$表示集合 S1 的长度。因为每插入一个元素都要比较 S 集合中的当前所有元素后, 才能插入到表尾。每插入一个元素的时间复杂度为$O(n)$, 所以插入$n$个元素的时间复杂度为$O(n^2)$。在下面算法中, S1 复制到 S 采用元素直接赋值的方法, 其时间复杂度仅为$O(n)$。

在 Set 集合类型的对象中, 存在着动态分配的存储空间, 所以不能简单地采用赋值语句进行直接赋值式的复制, 若这样的话, 不同对象的 set 指针将指向同一个动态存储空间, 即不同的对象共同占用该空间, 这是系统所不允许的。道理很简单, 正常释放一个对象中 set 所指向的动态存储空间后, 共同使用该空间的其他对象中由 set 所指向的动态存储空间也被非法的释放而无法访问。因此, 对于含有动态存储空间的对象, 在复制时必须使之具有不同的动态存储空间, 并且必须把被复制对象中动态存储空间所保存的内容复制到复制对象的动态存储空间中。

下面算法共包含 4 步, 其中前 3 步完成把 S1 复制到 S 的任务, 第 4 步通过把 S2 中的每个元素插入到 S 集合中, 完成两集合的并运算。设 S1 和 S2 集合的长度分别为$n$和$m$, 则此算法的时间复杂度主要由第 4 步求出, 为$O(n \times m)$。

void UnionSet(Set& S1, Set& S2, Set& S)
{
    int i;
    if(S.MaxSize<S1.MaxSize) {   //为了把S1复制到S,重分配S动态数组
        delete []S.set;
        S.set=new ElemType[S1.MaxSize];
        S.MaxSize=S1.MaxSize;
    }
    for(i=0; i<S1.len; i++)       //S1集合中的全部元素依次复制到S中
        S.set[i]=S1.set[i];
    S.len=S1.len;                 //置集合S的长度为S1的长度
    for(i=0; i<S2.len; i++)       //向集合S依次插入集合S2中的每个元素
        InsertSet(S,S2.set[i]);
}

12. 求两个集合的交集

此算法首先把存放结果的集合 S 变为一个空集, 然后依次从 S2 集合中取出每一个元素, 利用它去查找 S1 集合, 看是否存在, 若存在则把它写入交集 S 中, 这样写入 S 中的元素既属于 S1 又属于 S2。在此算法中, 从 S1 中查找一个元素的时间复杂度为$O(n)$, 所以整个算法的时间复杂度为$O(n \times m)$。

void InterseSet(Set& S1, Set& S2, Set& S)
{
    int i;
    ElemType x;
    S.len=0;                      //置集合S为一个空集
    for(i=0; i<S2.len; i++) {     //用S2中的每个元素去查找S1集合
